using System.Collections.Generic;

namespace HopperRuntime.Core
{
    /// <summary>
    /// Hopper VM bytecode instruction opcodes.
    /// These map directly to the bytecode values generated by the Hopper compiler.
    /// </summary>
    public enum OpCode : byte
    {
        NOP = 0x00,
        DUP0 = 0x01,       // push [top]

        PUSHR0 = 0x02,       // R0 -> [top]
        POPR0 = 0x03,       // [top] -> R0

        BITSHL8 = 0x04,
        BITSHR8 = 0x05,
        BITANDFF = 0x06,

        LIBCALL = 0x08,
        LIBCALL0 = 0x09,
        LIBCALL1 = 0x0A,

        SYSCALL2 = 0x0B, // syscall <byte operand>, overload 2

        BITSHLB = 0x0C,
        BITSHRB = 0x0D,
        BITANDB = 0x0E,
        BITORB = 0x0F,

        PUSHIB = 0x1A,       // operand is byte
        POPLOCALB = 0x1B,    // operand is the location to pop to: BP + offset
        PUSHLOCALB = 0x1C,   // operand is the location to push from: BP + offset
        POPRELB = 0x1D,      // like POPLOCAL but the absolute address to pop is taken from BP + offset
        PUSHRELB = 0x1E,     // like PUSHLOCAL but the absolute address to push is taken from BP + offset
        POPGLOBALB = 0x1F,   // operand is the absolute address to pop to
        PUSHGLOBALB = 0x20,  // operand is the absolute address to push from
        PUSHSTACKADDRB = 0x21, // operand is the offset from BP of the variable - convert to absolute stack address and push that

        INCLOCALB = 0x22,
        DECLOCALB = 0x23,

        SYSCALL0 = 0x24,     // syscall <byte operand>, overload 0
        SYSCALL1 = 0x25,     // syscall <byte operand>, overload 1
        SYSCALL = 0x26,      // syscall <byte operand>,  overload [next]

        DUP = 0x27,          // operand is offset 0..255 into stack where 0=[top], 1=[next], etc
        DECSP = 0x28,

        DIE = 0x29,       // fail setting lastError to <byte operand>

        RETB = 0x2A,      // RET and pop <byte operand> bytes
        RETRESB = 0x2B,   // RET and pop <byte operand> bytes, but preserve [top] as the return value

        CALLB = 0x2C,     // <byte index operand>
        TESTBPB = 0x2D,   // verify that BP is what we expect it to be

        // jump offsets: -1 means address of J instruction - 1, 0 means address after J instruction
        JZB = 0x2E,       // <signed byte offset>
        JNZB = 0x2F,      // <signed byte offset>
        JB = 0x30,        // <signed byte offset>

        // instructions before here have a single byte operand

        // jump offsets: -1 means address of J instruction - 1, 0 means address after J instruction
        JZ = 0x31,        // <signed int offset>
        JNZ = 0x32,       // <signed int offset>
        J = 0x33,         // <signed int offset>

        CALL = 0x34,     // <integer index operand>

        RET = 0x35,      // RET and pop <uint operand> bytes
        RETRES = 0x36,   // RET and pop <uint operand> bytes, but preserve [top] as the return value

        PUSHI = 0x37,          // operand is uint
        POPLOCAL = 0x38,       // operand is the location to pop to: BP + offset
        PUSHLOCAL = 0x39,      // operand is the location to push from: BP + offset
        POPREL = 0x3A,         // like POPLOCAL but the absolute address to pop is taken from BP + offset
        PUSHREL = 0x3B,        // like PUSHLOCAL but the absolute address to push is taken from BP + offset
        POPGLOBAL = 0x3C,      // operand is the absolute address to pop to
        PUSHGLOBAL = 0x3D,     // operand is the absolute address to push from
        PUSHSTACKADDR = 0x3E,  // operand is the offset from BP of the variable - convert to absolute stack address and push that

        INCLOCALBB = 0x3F,
        PUSHILE = 0x40,

        // instructions before here have a word operand (or two bytes)

        BOOLNOT = 0x41,      // ![top] -> [top]
        BITNOT = 0x42,       // ~[top] -> [top]

        SWAP = 0x43,         // swap [top] and [next] (consider object manager stack slots?)

        PUSHI0 = 0x44,
        PUSHI1 = 0x45,
        PUSHIM1 = 0x46,
        PUSHGP = 0x47,        // GP, the global "floor" for child processes
        COPYNEXTPOP = 0x48,   // what follows is a pop of a reference into a variable - should it be made into a copy?

        ENTER = 0x49,
        RET0 = 0x4A,

        CALLREL = 0x4B,   // call delegate based on <index> in [top]

        POPLOCALB00 = 0x4C,
        POPLOCALB01 = 0x4D,
        PUSHLOCALB00 = 0x4E,
        PUSHLOCALB01 = 0x4F,

        CAST = 0x51, // operand is value type (byte) - change top of stack to this type

        PUSHGLOBALBB = 0x52,  // operand is the absolute address to push from, x2
        INCGLOBALB = 0x53,
        DECGLOBALB = 0x54,

        PUSHILT = 0x55,

        PUSHLOCALBB = 0x56,

        POPCOPYLOCALB = 0x57,
        POPCOPYRELB = 0x58,
        POPCOPYGLOBALB = 0x59,
        POPCOPYLOCAL = 0x5A,
        POPCOPYREL = 0x5B,
        POPCOPYGLOBAL = 0x5C,

        POPCOPYLOCALB00 = 0x5D,
        POPCOPYLOCALB01 = 0x5E,

        ENTERB = 0x5F,

        PUSHD = 0x60,

        RETFAST = 0x61,

        PUSHDB = 0x62,
        EXIT = 0x63,

        PUSHILEI = 0x65,
        INCGLOBALBB = 0x66,

        JREL = 0x67,
        JIXB = 0x68,
        JIX = 0x69,

        CALLI = 0x6A,

        PUSHIBLE = 0x6B,
        PUSHIBEQ = 0x6C,

        ADDB = 0x6D,
        SUBB = 0x6E,
        INC = 0x6F,
        DEC = 0x70,

        // pop 2 -> operation -> push 1: (bit 0 set means 'signed')
        ADD = 0x80,
        ADDI = 0x81,
        SUB = 0x82,
        SUBI = 0x83,
        DIV = 0x84,
        DIVI = 0x85,
        MUL = 0x86,
        MULI = 0x87,
        MOD = 0x88,
        MODI = 0x89,

        GT = 0x8A,
        GTI = 0x8B,
        LT = 0x8C,
        LTI = 0x8D,
        GE = 0x8E,
        GEI = 0x8F,
        LE = 0x90,
        LEI = 0x91,

        // pop 2 -> operation -> push 1: (bit 0 set means 'signed' so these are always unsigned)

        EQ = 0x92,
        NE = 0x94,
        BOOLOR = 0x96,
        BOOLAND = 0x98,
        BITAND = 0x9A,
        BITOR = 0x9C,
        BITXOR = 0x9E,
        BITSHR = 0xA0,
        BITSHL = 0xA2,

        INCLOCALIBB = 0xA3,
        INCLOCALIB = 0xA4,
        INCGLOBALIB = 0xA5,
        DECLOCALIB = 0xA6,
        DECGLOBALIB = 0xA7,

        SYSCALLB0 = 0xA8, // PUSHIB   SYSCALL0
        SYSCALL00 = 0xA9, // SYSCALL0 SYSCALL0
        PUSHIBB = 0xAA, // PUSHIB   PUSHIB
        SYSCALLB1 = 0xAB, // PUSHIB   SYSCALL1
        SYSCALL01 = 0xAC, // SYSCALL0 SYSCALL1
        SYSCALL10 = 0xAD, // SYSCALL1 SYSCALL0

        UNDEFINED = 0xAE,
    }

    /// <summary>
    /// Provides metadata and utility functions for Hopper opcodes
    /// </summary>
    public static class OpCodeInfo
    {
        /// <summary>
        /// Information about a specific opcode including its operands and behavior
        /// </summary>
        public class InstructionInfo
        {
            public OpCode OpCode { get; }
            public string Name { get; }
            public string Description { get; }
            public int OperandBytes { get; }
            public int StackPop { get; }      // Number of values popped from stack (-1 = variable)
            public int StackPush { get; }     // Number of values pushed to stack (-1 = variable)

            public InstructionInfo(OpCode opCode, string name, string description,
                                 int operandBytes, int stackPop = 0, int stackPush = 0)
            {
                OpCode = opCode;
                Name = name;
                Description = description;
                OperandBytes = operandBytes;
                StackPop = stackPop;
                StackPush = stackPush;
            }
        }

        /// <summary>
        /// Opcode information table for debugging and analysis
        /// </summary>
        private static readonly Dictionary<OpCode, InstructionInfo> instructionTable = new()
        {
            [OpCode.NOP] = new(OpCode.NOP, "NOP", "No operation", 0, 0, 0),
            [OpCode.DUP0] = new(OpCode.DUP0, "DUP0", "Push [top]", 0, 0, 1),

            [OpCode.PUSHR0] = new(OpCode.PUSHR0, "PUSHR0", "R0 -> [top]", 0, 0, 1),
            [OpCode.POPR0] = new(OpCode.POPR0, "POPR0", "[top] -> R0", 0, 1, 0),

            [OpCode.BITSHL8] = new(OpCode.BITSHL8, "BITSHL8", "Bit shift left 8", 0, 1, 1),
            [OpCode.BITSHR8] = new(OpCode.BITSHR8, "BITSHR8", "Bit shift right 8", 0, 1, 1),
            [OpCode.BITANDFF] = new(OpCode.BITANDFF, "BITANDFF", "Bit AND with 0xFF", 0, 1, 1),

            [OpCode.LIBCALL] = new(OpCode.LIBCALL, "LIBCALL", "Library call", 0, -1, -1),
            [OpCode.LIBCALL0] = new(OpCode.LIBCALL0, "LIBCALL0", "Library call 0", 0, -1, -1),
            [OpCode.LIBCALL1] = new(OpCode.LIBCALL1, "LIBCALL1", "Library call 1", 0, -1, -1),

            [OpCode.SYSCALL2] = new(OpCode.SYSCALL2, "SYSCALL2", "System call overload 2", 1, -1, -1),

            [OpCode.BITSHLB] = new(OpCode.BITSHLB, "BITSHLB", "Bit shift left by byte", 1, 1, 1),
            [OpCode.BITSHRB] = new(OpCode.BITSHRB, "BITSHRB", "Bit shift right by byte", 1, 1, 1),
            [OpCode.BITANDB] = new(OpCode.BITANDB, "BITANDB", "Bit AND with byte", 1, 1, 1),
            [OpCode.BITORB] = new(OpCode.BITORB, "BITORB", "Bit OR with byte", 1, 1, 1),

            [OpCode.PUSHIB] = new(OpCode.PUSHIB, "PUSHIB", "Push immediate byte", 1, 0, 1),
            [OpCode.POPLOCALB] = new(OpCode.POPLOCALB, "POPLOCALB", "Pop to local variable", 1, 1, 0),
            [OpCode.PUSHLOCALB] = new(OpCode.PUSHLOCALB, "PUSHLOCALB", "Push local variable", 1, 0, 1),
            [OpCode.POPRELB] = new(OpCode.POPRELB, "POPRELB", "Pop to relative address", 1, 1, 0),
            [OpCode.PUSHRELB] = new(OpCode.PUSHRELB, "PUSHRELB", "Push from relative address", 1, 0, 1),
            [OpCode.POPGLOBALB] = new(OpCode.POPGLOBALB, "POPGLOBALB", "Pop to global variable", 1, 1, 0),
            [OpCode.PUSHGLOBALB] = new(OpCode.PUSHGLOBALB, "PUSHGLOBALB", "Push global variable", 1, 0, 1),
            [OpCode.PUSHSTACKADDRB] = new(OpCode.PUSHSTACKADDRB, "PUSHSTACKADDRB", "Push stack address", 1, 0, 1),

            [OpCode.INCLOCALB] = new(OpCode.INCLOCALB, "INCLOCALB", "Increment local variable", 1, 0, 0),
            [OpCode.DECLOCALB] = new(OpCode.DECLOCALB, "DECLOCALB", "Decrement local variable", 1, 0, 0),

            [OpCode.SYSCALL0] = new(OpCode.SYSCALL0, "SYSCALL0", "System call overload 0", 1, -1, -1),
            [OpCode.SYSCALL1] = new(OpCode.SYSCALL1, "SYSCALL1", "System call overload 1", 1, -1, -1),
            [OpCode.SYSCALL] = new(OpCode.SYSCALL, "SYSCALL", "System call", 1, -1, -1),

            [OpCode.DUP] = new(OpCode.DUP, "DUP", "Duplicate stack item", 1, 0, 1),
            [OpCode.DECSP] = new(OpCode.DECSP, "DECSP", "Decrement stack pointer", 1, 1, 0),

            [OpCode.DIE] = new(OpCode.DIE, "DIE", "Terminate with error", 1, 0, 0),

            [OpCode.RETB] = new(OpCode.RETB, "RETB", "Return with cleanup", 1, -1, 0),
            [OpCode.RETRESB] = new(OpCode.RETRESB, "RETRESB", "Return with result and cleanup", 1, -1, 1),

            [OpCode.CALLB] = new(OpCode.CALLB, "CALLB", "Call with byte index", 1, 0, 0),
            [OpCode.TESTBPB] = new(OpCode.TESTBPB, "TESTBPB", "Test base pointer", 1, 0, 0),

            [OpCode.JZB] = new(OpCode.JZB, "JZB", "Jump if zero (byte offset)", 1, 1, 0),
            [OpCode.JNZB] = new(OpCode.JNZB, "JNZB", "Jump if not zero (byte offset)", 1, 1, 0),
            [OpCode.JB] = new(OpCode.JB, "JB", "Jump (byte offset)", 1, 0, 0),

            [OpCode.JZ] = new(OpCode.JZ, "JZ", "Jump if zero", 2, 1, 0),
            [OpCode.JNZ] = new(OpCode.JNZ, "JNZ", "Jump if not zero", 2, 1, 0),
            [OpCode.J] = new(OpCode.J, "J", "Jump", 2, 0, 0),

            [OpCode.CALL] = new(OpCode.CALL, "CALL", "Call via method table", 2, 0, 0),

            [OpCode.RET] = new(OpCode.RET, "RET", "Return", 2, -1, 0),
            [OpCode.RETRES] = new(OpCode.RETRES, "RETRES", "Return with result", 2, -1, 1),

            [OpCode.PUSHI] = new(OpCode.PUSHI, "PUSHI", "Push immediate uint", 2, 0, 1),
            [OpCode.POPLOCAL] = new(OpCode.POPLOCAL, "POPLOCAL", "Pop to local variable", 2, 1, 0),
            [OpCode.PUSHLOCAL] = new(OpCode.PUSHLOCAL, "PUSHLOCAL", "Push local variable", 2, 0, 1),
            [OpCode.POPREL] = new(OpCode.POPREL, "POPREL", "Pop to relative address", 2, 1, 0),
            [OpCode.PUSHREL] = new(OpCode.PUSHREL, "PUSHREL", "Push from relative address", 2, 0, 1),
            [OpCode.POPGLOBAL] = new(OpCode.POPGLOBAL, "POPGLOBAL", "Pop to global variable", 2, 1, 0),
            [OpCode.PUSHGLOBAL] = new(OpCode.PUSHGLOBAL, "PUSHGLOBAL", "Push global variable", 2, 0, 1),
            [OpCode.PUSHSTACKADDR] = new(OpCode.PUSHSTACKADDR, "PUSHSTACKADDR", "Push stack address", 2, 0, 1),

            [OpCode.INCLOCALBB] = new(OpCode.INCLOCALBB, "INCLOCALBB", "Increment local variable (BB)", 0, 0, 0),
            [OpCode.PUSHILE] = new(OpCode.PUSHILE, "PUSHILE", "Push immediate less equal", 2, 0, 1),

            [OpCode.BOOLNOT] = new(OpCode.BOOLNOT, "BOOLNOT", "Boolean NOT", 0, 1, 1),
            [OpCode.BITNOT] = new(OpCode.BITNOT, "BITNOT", "Bitwise NOT", 0, 1, 1),

            [OpCode.SWAP] = new(OpCode.SWAP, "SWAP", "Swap top two stack items", 0, 2, 2),

            [OpCode.PUSHI0] = new(OpCode.PUSHI0, "PUSHI0", "Push 0", 0, 0, 1),
            [OpCode.PUSHI1] = new(OpCode.PUSHI1, "PUSHI1", "Push 1", 0, 0, 1),
            [OpCode.PUSHIM1] = new(OpCode.PUSHIM1, "PUSHIM1", "Push -1", 0, 0, 1),
            [OpCode.PUSHGP] = new(OpCode.PUSHGP, "PUSHGP", "Push global pointer", 0, 0, 1),
            [OpCode.COPYNEXTPOP] = new(OpCode.COPYNEXTPOP, "COPYNEXTPOP", "Copy next pop", 0, 0, 0),

            [OpCode.ENTER] = new(OpCode.ENTER, "ENTER", "Function entry", 0, 0, 0),
            [OpCode.RET0] = new(OpCode.RET0, "RET0", "Return with no cleanup", 0, 0, 0),

            [OpCode.CALLREL] = new(OpCode.CALLREL, "CALLREL", "Call relative", 0, 1, 0),

            [OpCode.POPLOCALB00] = new(OpCode.POPLOCALB00, "POPLOCALB00", "Pop to local 0", 0, 1, 0),
            [OpCode.POPLOCALB01] = new(OpCode.POPLOCALB01, "POPLOCALB01", "Pop to local 1", 0, 1, 0),
            [OpCode.PUSHLOCALB00] = new(OpCode.PUSHLOCALB00, "PUSHLOCALB00", "Push local 0", 0, 0, 1),
            [OpCode.PUSHLOCALB01] = new(OpCode.PUSHLOCALB01, "PUSHLOCALB01", "Push local 1", 0, 0, 1),

            [OpCode.CAST] = new(OpCode.CAST, "CAST", "Cast to type", 1, 1, 1),

            [OpCode.PUSHGLOBALBB] = new(OpCode.PUSHGLOBALBB, "PUSHGLOBALBB", "Push global (BB)", 0, 0, 2),
            [OpCode.INCGLOBALB] = new(OpCode.INCGLOBALB, "INCGLOBALB", "Increment global", 1, 0, 0),
            [OpCode.DECGLOBALB] = new(OpCode.DECGLOBALB, "DECGLOBALB", "Decrement global", 1, 0, 0),

            [OpCode.PUSHILT] = new(OpCode.PUSHILT, "PUSHILT", "Push immediate less than", 2, 0, 1),

            [OpCode.PUSHLOCALBB] = new(OpCode.PUSHLOCALBB, "PUSHLOCALBB", "Push local (BB)", 0, 0, 2),

            [OpCode.POPCOPYLOCALB] = new(OpCode.POPCOPYLOCALB, "POPCOPYLOCALB", "Pop copy to local", 1, 1, 0),
            [OpCode.POPCOPYRELB] = new(OpCode.POPCOPYRELB, "POPCOPYRELB", "Pop copy to relative", 1, 1, 0),
            [OpCode.POPCOPYGLOBALB] = new(OpCode.POPCOPYGLOBALB, "POPCOPYGLOBALB", "Pop copy to global", 1, 1, 0),
            [OpCode.POPCOPYLOCAL] = new(OpCode.POPCOPYLOCAL, "POPCOPYLOCAL", "Pop copy to local", 2, 1, 0),
            [OpCode.POPCOPYREL] = new(OpCode.POPCOPYREL, "POPCOPYREL", "Pop copy to relative", 2, 1, 0),
            [OpCode.POPCOPYGLOBAL] = new(OpCode.POPCOPYGLOBAL, "POPCOPYGLOBAL", "Pop copy to global", 2, 1, 0),

            [OpCode.POPCOPYLOCALB00] = new(OpCode.POPCOPYLOCALB00, "POPCOPYLOCALB00", "Pop copy to local BP", 0, 1, 0),
            [OpCode.POPCOPYLOCALB01] = new(OpCode.POPCOPYLOCALB01, "POPCOPYLOCALB01", "Pop copy to local BP-1", 0, 1, 0),

            [OpCode.ENTERB] = new(OpCode.ENTERB, "ENTERB", "Function entry with locals", 1, 0, -1),

            [OpCode.PUSHD] = new(OpCode.PUSHD, "PUSHD", "Push Delegate Index", 2, 0, 1),

            [OpCode.RETFAST] = new(OpCode.RETFAST, "RETFAST", "Fast return", 0, 0, 0),

            [OpCode.PUSHDB] = new(OpCode.PUSHDB, "PUSHDB", "Push Delegate Index (byte)", 1, 0, 1),
            [OpCode.EXIT] = new(OpCode.EXIT, "EXIT", "Exit program", 0, 0, 0),

            [OpCode.PUSHILEI] = new(OpCode.PUSHILEI, "PUSHILEI", "Push immediate less equal (I)", 2, 0, 1),
            [OpCode.INCGLOBALBB] = new(OpCode.INCGLOBALBB, "INCGLOBALBB", "Increment global (BB)", 0, 0, 0),

            [OpCode.JREL] = new(OpCode.JREL, "JREL", "Jump relative", 0, 1, 0),
            [OpCode.JIXB] = new(OpCode.JIXB, "JIXB", "Jump index (byte)", 1, 1, 0),
            [OpCode.JIX] = new(OpCode.JIX, "JIX", "Jump index", 2, 1, 0),

            [OpCode.CALLI] = new(OpCode.CALLI, "CALLI", "Call immediate address", 2, 0, 0),

            [OpCode.PUSHIBLE] = new(OpCode.PUSHIBLE, "PUSHIBLE", "Push immediate (BLE)", 1, 0, 1),
            [OpCode.PUSHIBEQ] = new(OpCode.PUSHIBEQ, "PUSHIBEQ", "Push immediate (BEQ)", 1, 0, 1),

            [OpCode.ADDB] = new(OpCode.ADDB, "ADDB", "Add byte", 0, 2, 1),
            [OpCode.SUBB] = new(OpCode.SUBB, "SUBB", "Subtract byte", 0, 2, 1),
            [OpCode.INC] = new(OpCode.INC, "INC", "Increment", 0, 1, 1),
            [OpCode.DEC] = new(OpCode.DEC, "DEC", "Decrement", 0, 1, 1),

            [OpCode.ADD] = new(OpCode.ADD, "ADD", "Add (unsigned)", 0, 2, 1),
            [OpCode.ADDI] = new(OpCode.ADDI, "ADDI", "Add (signed)", 0, 2, 1),
            [OpCode.SUB] = new(OpCode.SUB, "SUB", "Subtract (unsigned)", 0, 2, 1),
            [OpCode.SUBI] = new(OpCode.SUBI, "SUBI", "Subtract (signed)", 0, 2, 1),
            [OpCode.DIV] = new(OpCode.DIV, "DIV", "Divide (unsigned)", 0, 2, 1),
            [OpCode.DIVI] = new(OpCode.DIVI, "DIVI", "Divide (signed)", 0, 2, 1),
            [OpCode.MUL] = new(OpCode.MUL, "MUL", "Multiply (unsigned)", 0, 2, 1),
            [OpCode.MULI] = new(OpCode.MULI, "MULI", "Multiply (signed)", 0, 2, 1),
            [OpCode.MOD] = new(OpCode.MOD, "MOD", "Modulo (unsigned)", 0, 2, 1),
            [OpCode.MODI] = new(OpCode.MODI, "MODI", "Modulo (signed)", 0, 2, 1),

            [OpCode.GT] = new(OpCode.GT, "GT", "Greater than (unsigned)", 0, 2, 1),
            [OpCode.GTI] = new(OpCode.GTI, "GTI", "Greater than (signed)", 0, 2, 1),
            [OpCode.LT] = new(OpCode.LT, "LT", "Less than (unsigned)", 0, 2, 1),
            [OpCode.LTI] = new(OpCode.LTI, "LTI", "Less than (signed)", 0, 2, 1),
            [OpCode.GE] = new(OpCode.GE, "GE", "Greater equal (unsigned)", 0, 2, 1),
            [OpCode.GEI] = new(OpCode.GEI, "GEI", "Greater equal (signed)", 0, 2, 1),
            [OpCode.LE] = new(OpCode.LE, "LE", "Less equal (unsigned)", 0, 2, 1),
            [OpCode.LEI] = new(OpCode.LEI, "LEI", "Less equal (signed)", 0, 2, 1),

            [OpCode.EQ] = new(OpCode.EQ, "EQ", "Equal", 0, 2, 1),
            [OpCode.NE] = new(OpCode.NE, "NE", "Not equal", 0, 2, 1),
            [OpCode.BOOLOR] = new(OpCode.BOOLOR, "BOOLOR", "Boolean OR", 0, 2, 1),
            [OpCode.BOOLAND] = new(OpCode.BOOLAND, "BOOLAND", "Boolean AND", 0, 2, 1),
            [OpCode.BITAND] = new(OpCode.BITAND, "BITAND", "Bitwise AND", 0, 2, 1),
            [OpCode.BITOR] = new(OpCode.BITOR, "BITOR", "Bitwise OR", 0, 2, 1),
            [OpCode.BITXOR] = new(OpCode.BITXOR, "BITXOR", "Bitwise XOR", 0, 2, 1),
            [OpCode.BITSHR] = new(OpCode.BITSHR, "BITSHR", "Bit shift right", 0, 2, 1),
            [OpCode.BITSHL] = new(OpCode.BITSHL, "BITSHL", "Bit shift left", 0, 2, 1),

            [OpCode.INCLOCALIBB] = new(OpCode.INCLOCALIBB, "INCLOCALIBB", "Increment local (IBB)", 0, 0, 0),
            [OpCode.INCLOCALIB] = new(OpCode.INCLOCALIB, "INCLOCALIB", "Increment local (IB)", 0, 0, 0),
            [OpCode.INCGLOBALIB] = new(OpCode.INCGLOBALIB, "INCGLOBALIB", "Increment global (IB)", 0, 0, 0),
            [OpCode.DECLOCALIB] = new(OpCode.DECLOCALIB, "DECLOCALIB", "Decrement local (IB)", 0, 0, 0),
            [OpCode.DECGLOBALIB] = new(OpCode.DECGLOBALIB, "DECGLOBALIB", "Decrement global (IB)", 0, 0, 0),

            [OpCode.SYSCALLB0] = new(OpCode.SYSCALLB0, "SYSCALLB0", "PUSHIB SYSCALL0", 2, -1, -1),
            [OpCode.SYSCALL00] = new(OpCode.SYSCALL00, "SYSCALL00", "SYSCALL0 SYSCALL0", 0, -1, -1),
            [OpCode.PUSHIBB] = new(OpCode.PUSHIBB, "PUSHIBB", "PUSHIB PUSHIB", 2, 0, 2),
            [OpCode.SYSCALLB1] = new(OpCode.SYSCALLB1, "SYSCALLB1", "PUSHIB SYSCALL1", 2, -1, -1),
            [OpCode.SYSCALL01] = new(OpCode.SYSCALL01, "SYSCALL01", "SYSCALL0 SYSCALL1", 0, -1, -1),
            [OpCode.SYSCALL10] = new(OpCode.SYSCALL10, "SYSCALL10", "SYSCALL1 SYSCALL0", 0, -1, -1),

            [OpCode.UNDEFINED] = new(OpCode.UNDEFINED, "UNDEFINED", "Undefined instruction", 0, 0, 0),
        };

        /// <summary>
        /// Get information about a specific opcode
        /// </summary>
        public static InstructionInfo? GetInfo(OpCode opCode)
        {
            instructionTable.TryGetValue(opCode, out InstructionInfo? info);
            return info;
        }

        /// <summary>
        /// Get the name of an opcode for debugging
        /// </summary>
        public static string GetName(OpCode opCode)
        {
            return GetInfo(opCode)?.Name ?? $"UNKNOWN_0x{(byte)opCode:X2}";
        }

        /// <summary>
        /// Get the number of operand bytes for an instruction
        /// </summary>
        public static int GetOperandBytes(OpCode opCode)
        {
            return GetInfo(opCode)?.OperandBytes ?? 0;
        }

        /// <summary>
        /// Check if an opcode is a function call instruction
        /// </summary>
        public static bool IsCall(OpCode opCode)
        {
            return opCode == OpCode.CALL || opCode == OpCode.CALLI;
        }

        /// <summary>
        /// Check if an opcode is a return instruction
        /// </summary>
        public static bool IsReturn(OpCode opCode)
        {
            return opCode == OpCode.RETB;
        }

        /// <summary>
        /// Check if an opcode is a system call
        /// </summary>
        public static bool IsSyscall(OpCode opCode)
        {
            return opCode == OpCode.SYSCALLB0 || opCode == OpCode.SYSCALL10;
        }

        /// <summary>
        /// Check if an opcode modifies the program counter (jumps, calls, returns)
        /// </summary>
        public static bool ModifiesPC(OpCode opCode)
        {
            return IsCall(opCode) || IsReturn(opCode);
            // TODO: Add jump instructions when implemented
        }

        /// <summary>
        /// Get all registered opcodes for debugging/tooling
        /// </summary>
        public static IEnumerable<OpCode> GetAllOpcodes()
        {
            return instructionTable.Keys;
        }

        /// <summary>
        /// Get a formatted instruction string for debugging
        /// </summary>
        public static string FormatInstruction(OpCode opCode, byte[]? operands = null)
        {
            var info = GetInfo(opCode);
            if (info == null)
                return $"UNKNOWN_0x{(byte)opCode:X2}";

            var result = info.Name;

            if (operands != null && operands.Length > 0)
            {
                result += " ";
                if (info.OperandBytes == 1)
                {
                    result += $"0x{operands[0]:X2}";
                }
                else if (info.OperandBytes == 2 && operands.Length >= 2)
                {
                    uint value = (uint)(operands[0] | (operands[1] << 8));
                    result += $"0x{value:X4}";
                }
                else
                {
                    result += string.Join(" ", operands.Take(info.OperandBytes).Select(b => $"0x{b:X2}"));
                }
            }

            return result;
        }
    }
}