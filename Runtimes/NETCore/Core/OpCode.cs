using System.Collections.Generic;

namespace HopperRuntime.Core
{
    /// <summary>
    /// Hopper VM bytecode instruction opcodes.
    /// These map directly to the bytecode values generated by the Hopper compiler.
    /// </summary>
    public enum OpCode : byte
    {
        // Stack manipulation
        PUSHI0 = 0x44,          // Push 0 onto stack
        PUSHI = 0x37,           // Push 16-bit immediate value

        // Global variable operations
        POPGLOBALB = 0x1F,      // Pop to global variable (byte index)
        PUSHGLOBALB = 0x20,     // Push global variable (byte index)

        // Local variable and function operations
        ENTERB = 0x5F,          // Function entry with local count
        ENTER = 0x49,           // Function entry without locals
        PUSHLOCALB = 0x1C,      // Push local variable (byte offset)

        // Function calls and returns
        CALL = 0x34,            // Call method via method table
        CALLI = 0x6A,           // Call immediate address (optimized)
        RETB = 0x2A,            // Return with stack cleanup

        // System calls
        SYSCALLB0 = 0xA8,       // System call with 1 parameter
        SYSCALL10 = 0xAD,       // Two consecutive system calls

        // TODO: Add more opcodes as discovered/implemented
        // These are placeholders for opcodes we'll encounter:
        // PUSH = 0x??,         // Push N-byte immediate
        // POP = 0x??,          // Pop and discard
        // DUP = 0x??,          // Duplicate top of stack
        // SWAP = 0x??,         // Swap top two stack items
        // JMP = 0x??,          // Unconditional jump
        // JZ = 0x??,           // Jump if zero
        // JNZ = 0x??,          // Jump if not zero
        // ADD = 0x??,          // Arithmetic operations
        // SUB = 0x??,
        // MUL = 0x??,
        // DIV = 0x??,
        // MOD = 0x??,
        // AND = 0x??,          // Bitwise operations
        // OR = 0x??,
        // XOR = 0x??,
        // NOT = 0x??,
        // SHL = 0x??,          // Bit shifting
        // SHR = 0x??,
        // EQ = 0x??,           // Comparison operations
        // NE = 0x??,
        // LT = 0x??,
        // LE = 0x??,
        // GT = 0x??,
        // GE = 0x??,
    }

    /// <summary>
    /// Provides metadata and utility functions for Hopper opcodes
    /// </summary>
    public static class OpCodeInfo
    {
        /// <summary>
        /// Information about a specific opcode including its operands and behavior
        /// </summary>
        public class InstructionInfo
        {
            public OpCode OpCode { get; }
            public string Name { get; }
            public string Description { get; }
            public int OperandBytes { get; }
            public int StackPop { get; }      // Number of values popped from stack (-1 = variable)
            public int StackPush { get; }     // Number of values pushed to stack (-1 = variable)

            public InstructionInfo(OpCode opCode, string name, string description,
                                 int operandBytes, int stackPop = 0, int stackPush = 0)
            {
                OpCode = opCode;
                Name = name;
                Description = description;
                OperandBytes = operandBytes;
                StackPop = stackPop;
                StackPush = stackPush;
            }
        }

        /// <summary>
        /// Opcode information table for debugging and analysis
        /// </summary>
        private static readonly Dictionary<OpCode, InstructionInfo> instructionTable = new()
        {
            [OpCode.PUSHI0] = new(OpCode.PUSHI0, "PUSHI0", "Push 0 onto stack", 0, 0, 1),
            [OpCode.PUSHI] = new(OpCode.PUSHI, "PUSHI", "Push 16-bit immediate value", 2, 0, 1),

            [OpCode.POPGLOBALB] = new(OpCode.POPGLOBALB, "POPGLOBALB", "Pop to global variable", 1, 1, 0),
            [OpCode.PUSHGLOBALB] = new(OpCode.PUSHGLOBALB, "PUSHGLOBALB", "Push global variable", 1, 0, 1),

            [OpCode.ENTERB] = new(OpCode.ENTERB, "ENTERB", "Function entry with locals", 1, 0, -1),
            [OpCode.ENTER] = new(OpCode.ENTER, "ENTER", "Function entry", 0, 0, 0),
            [OpCode.PUSHLOCALB] = new(OpCode.PUSHLOCALB, "PUSHLOCALB", "Push local variable", 1, 0, 1),

            [OpCode.CALL] = new(OpCode.CALL, "CALL", "Call via method table", 2, 0, 0),
            [OpCode.CALLI] = new(OpCode.CALLI, "CALLI", "Call immediate address", 2, 0, 0),
            [OpCode.RETB] = new(OpCode.RETB, "RETB", "Return with cleanup", 1, -1, 0),

            [OpCode.SYSCALLB0] = new(OpCode.SYSCALLB0, "SYSCALLB0", "System call with parameter", 2, -1, -1),
            [OpCode.SYSCALL10] = new(OpCode.SYSCALL10, "SYSCALL10", "Two system calls", 2, -1, -1),
        };

        /// <summary>
        /// Get information about a specific opcode
        /// </summary>
        public static InstructionInfo? GetInfo(OpCode opCode)
        {
            instructionTable.TryGetValue(opCode, out InstructionInfo? info);
            return info;
        }

        /// <summary>
        /// Get the name of an opcode for debugging
        /// </summary>
        public static string GetName(OpCode opCode)
        {
            return GetInfo(opCode)?.Name ?? $"UNKNOWN_0x{(byte)opCode:X2}";
        }

        /// <summary>
        /// Get the number of operand bytes for an instruction
        /// </summary>
        public static int GetOperandBytes(OpCode opCode)
        {
            return GetInfo(opCode)?.OperandBytes ?? 0;
        }

        /// <summary>
        /// Check if an opcode is a function call instruction
        /// </summary>
        public static bool IsCall(OpCode opCode)
        {
            return opCode == OpCode.CALL || opCode == OpCode.CALLI;
        }

        /// <summary>
        /// Check if an opcode is a return instruction
        /// </summary>
        public static bool IsReturn(OpCode opCode)
        {
            return opCode == OpCode.RETB;
        }

        /// <summary>
        /// Check if an opcode is a system call
        /// </summary>
        public static bool IsSyscall(OpCode opCode)
        {
            return opCode == OpCode.SYSCALLB0 || opCode == OpCode.SYSCALL10;
        }

        /// <summary>
        /// Check if an opcode modifies the program counter (jumps, calls, returns)
        /// </summary>
        public static bool ModifiesPC(OpCode opCode)
        {
            return IsCall(opCode) || IsReturn(opCode);
            // TODO: Add jump instructions when implemented
        }

        /// <summary>
        /// Get all registered opcodes for debugging/tooling
        /// </summary>
        public static IEnumerable<OpCode> GetAllOpcodes()
        {
            return instructionTable.Keys;
        }

        /// <summary>
        /// Get a formatted instruction string for debugging
        /// </summary>
        public static string FormatInstruction(OpCode opCode, byte[]? operands = null)
        {
            var info = GetInfo(opCode);
            if (info == null)
                return $"UNKNOWN_0x{(byte)opCode:X2}";

            var result = info.Name;

            if (operands != null && operands.Length > 0)
            {
                result += " ";
                if (info.OperandBytes == 1)
                {
                    result += $"0x{operands[0]:X2}";
                }
                else if (info.OperandBytes == 2 && operands.Length >= 2)
                {
                    uint value = (uint)(operands[0] | (operands[1] << 8));
                    result += $"0x{value:X4}";
                }
                else
                {
                    result += string.Join(" ", operands.Take(info.OperandBytes).Select(b => $"0x{b:X2}"));
                }
            }

            return result;
        }
    }
}