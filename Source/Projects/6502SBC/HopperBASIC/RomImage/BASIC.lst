// constant data

0x8000  0x0C 0x48 0x6F 0x70 0x70 0x65 0x72 0x20  0x42 0x41 0x53 0x49 0x43 0x20 0x76 0x33  // .Hopper.BASIC.v3
0x8010  0x2E 0x31 0x0A 0x00 0x41 0x55 0x54 0x4F  0x45 0x58 0x45 0x43 0x00 0x02 0x01 0x12  // .1..AUTOEXEC....
0x8020  0x00 0x02 0x03 0x10 0x11 0x02 0x05 0x02  0x03 0x02 0x06 0xA5 0x0B 0x02 0x07 0x9E  // ................
0x8030  0x0B 0x02 0x08 0x18 0x0B 0x03 0x09 0x04  0x05 0x06 0x03 0x0A 0x19 0x10 0x1A 0x03  // ................
0x8040  0x0B 0xAD 0x0A 0xAA 0x03 0x0C 0x07 0x08  0x09 0x02 0x0D 0x1B 0x1C 0x03 0x0E 0x9B  // ................
0x8050  0x1D 0x1E 0x02 0x0F 0x1F 0x20 0x02 0x10  0x0C 0x0D 0x02 0x11 0x0C 0xA5 0x02 0x15  // ................
0x8060  0x9E 0x21 0x03 0x16 0x9E 0x40 0x21 0x02  0x17 0xA2 0x21 0x02 0x18 0xA4 0x21 0x02  // .!...@!...!...!.
0x8070  0x19 0x0E 0x0D 0x03 0x13 0x0E 0x14 0xA5  0x03 0x14 0xA5 0x1D 0x54 0x02 0x1B 0x0E  // ............T...
0x8080  0x22 0x02 0x1C 0x0E 0x23 0x02 0x1D 0x0F  0x24 0x02 0x1E 0x25 0x1C 0x02 0x1F 0x26  // "...#...$..%...&
0x8090  0x21 0x02 0x20 0x27 0x21 0x02 0x21 0x28  0x21 0x06 0x22 0x29 0x2A 0x05 0x2B 0x14  // !..'!.!(!.")*.+.
0x80A0  0x2C 0x02 0x23 0x40 0x21 0x03 0x24 0x0F  0x98 0x2D 0x03 0x25 0x13 0x2F 0x30 0x02  // ,.#@!.$..-.%./0.
0x80B0  0x26 0x31 0x32 0x01 0x27 0x35 0x03 0x28  0x36 0x37 0x38 0x02 0x29 0x39 0xAD 0x02  // &12.'5.(678.)9..
0x80C0  0x2A 0xAD 0x03 0x05 0x2B 0xAA 0x3A 0x3B  0x3C 0x3D 0x04 0x2C 0x2D 0x04 0x05 0x3E  // *...+.:;<=.,-..>
0x80D0  0x04 0x2D 0x20 0x04 0x05 0x3E 0x02 0x2E  0x3F 0x21 0x02 0x2F 0x41 0x21 0x03 0x30  // .-...>..?!./A!.0
0x80E0  0x41 0x1D 0x9A 0x02 0x31 0x0E 0x41 0x02  0x12 0x0D 0x21 0x02 0x32 0x42 0x43 0x02  // A...1.A...!.2BC.
0x80F0  0x33 0x44 0x43 0x03 0x36 0x36 0x49 0x4A  0x02 0x34 0x19 0x0B 0x02 0x35 0x44 0x00  // 3DC.66IJ.4...5D.
0x8100  0x02 0x1A 0x0E 0x02 0x00 0x02 0x32 0x42  0x43 0x02 0x33 0x44 0x43 0x02 0x34 0x19  // ......2BC.3DC.4.
0x8110  0x0B 0x02 0x35 0x44 0x00 0x05 0x37 0x8B  0x4D 0x4E 0x4F 0x4C 0x01 0x38 0x50 0x01  // ..5D..7.MNOL.8P.
0x8120  0x39 0x53 0x01 0x3A 0x52 0x03 0x36 0x36  0x49 0x4A 0x01 0x3B 0x4C 0x01 0x3C 0x45  // 9S.:R.66IJ.;L.<E
0x8130  0x02 0x3D 0x45 0x51 0x02 0x3E 0x1F 0xAC  0x01 0x3F 0x47 0x01 0x40 0x48 0x01 0x41  // .=EQ.>...?G.@H.A
0x8140  0x06 0x02 0x42 0x45 0x46 0x01 0x43 0x44  0x02 0x04 0x0E 0x55 0x02 0x02 0x01 0x00  // ..BEF.CD...U....
0x8150  0x00 0x05 0x00 0x45 0x52 0x52 0x4F 0x52  0x06 0x01 0x53 0x59 0x4E 0x54 0x41 0x58  // ...ERROR..SYNTAX
0x8160  0x04 0x02 0x54 0x59 0x50 0x45 0x08 0x03  0x4D 0x49 0x53 0x4D 0x41 0x54 0x43 0x48  // ..TYPE..MISMATCH
0x8170  0x03 0x04 0x4F 0x55 0x54 0x02 0x05 0x4F  0x46 0x06 0x06 0x4D 0x45 0x4D 0x4F 0x52  // ..OUT..OF..MEMOR
0x8180  0x59 0x08 0x07 0x44 0x49 0x56 0x49 0x53  0x49 0x4F 0x4E 0x02 0x08 0x42 0x59 0x04  // Y..DIVISION..BY.
0x8190  0x09 0x5A 0x45 0x52 0x4F 0x07 0x0A 0x57  0x49 0x54 0x48 0x4F 0x55 0x54 0x06 0x0B  // .ZERO..WITHOUT..
0x81A0  0x45 0x58 0x49 0x53 0x54 0x53 0x09 0x0C  0x55 0x4E 0x44 0x45 0x46 0x49 0x4E 0x45  // EXISTS..UNDEFINE
0x81B0  0x44 0x0A 0x0D 0x49 0x44 0x45 0x4E 0x54  0x49 0x46 0x49 0x45 0x52 0x07 0x0E 0x49  // D..IDENTIFIER..I
0x81C0  0x4C 0x4C 0x45 0x47 0x41 0x4C 0x07 0x0F  0x49 0x4E 0x56 0x41 0x4C 0x49 0x44 0x03  // LLEGAL..INVALID.
0x81D0  0x10 0x4E 0x4F 0x54 0x0B 0x11 0x49 0x4D  0x50 0x4C 0x45 0x4D 0x45 0x4E 0x54 0x45  // .NOT..IMPLEMENTE
0x81E0  0x44 0x08 0x12 0x49 0x4E 0x54 0x45 0x52  0x4E 0x41 0x4C 0x04 0x13 0x4F 0x4E 0x4C  // D..INTERNAL..ONL
0x81F0  0x59 0x02 0x14 0x49 0x4E 0x08 0x18 0x56  0x41 0x52 0x49 0x41 0x42 0x4C 0x45 0x04  // Y..IN..VARIABLE.
0x8200  0x19 0x46 0x49 0x4C 0x45 0x05 0x1A 0x46  0x4F 0x55 0x4E 0x44 0x07 0x1B 0x4E 0x55  // .FILE..FOUND..NU
0x8210  0x4D 0x45 0x52 0x49 0x43 0x08 0x1C 0x4F  0x56 0x45 0x52 0x46 0x4C 0x4F 0x57 0x03  // MERIC..OVERFLOW.
0x8220  0x1D 0x54 0x4F 0x4F 0x04 0x1E 0x4C 0x4F  0x4E 0x47 0x03 0x1F 0x42 0x41 0x44 0x00  // .TOO..LONG..BAD.
0x8230  0x05 0x20 0x49 0x4E 0x44 0x45 0x58 0x08  0x21 0x45 0x58 0x50 0x45 0x43 0x54 0x45  // ..INDEX.!EXPECTE
0x8240  0x44 0x0A 0x22 0x41 0x53 0x53 0x49 0x47  0x4E 0x4D 0x45 0x4E 0x54 0x09 0x23 0x43  // D."ASSIGNMENT.#C
0x8250  0x48 0x41 0x52 0x41 0x43 0x54 0x45 0x52  0x08 0x24 0x4F 0x50 0x45 0x52 0x41 0x54  // HARACTER.$OPERAT
0x8260  0x4F 0x52 0x06 0x25 0x42 0x55 0x46 0x46  0x45 0x52 0x01 0x26 0x29 0x01 0x27 0x28  // OR.%BUFFER.&).'(
0x8270  0x01 0x28 0x3D 0x0A 0x29 0x55 0x4E 0x45  0x58 0x50 0x45 0x43 0x54 0x45 0x44 0x03  // .(=.)UNEXPECTED.
0x8280  0x2A 0x45 0x4E 0x44 0x04 0x2B 0x4C 0x49  0x4E 0x45 0x07 0x2C 0x4C 0x49 0x54 0x45  // *END.+LINE.,LITE
0x8290  0x52 0x41 0x4C 0x05 0x2D 0x56 0x41 0x4C  0x55 0x45 0x05 0x35 0x42 0x52 0x45 0x41  // RAL.-VALUE.5BREA
0x82A0  0x4B 0x02 0x2F 0x41 0x54 0x07 0x30 0x43  0x4F 0x4E 0x53 0x4F 0x4C 0x45 0x04 0x31  // K./AT.0CONSOLE.1
0x82B0  0x48 0x45 0x41 0x50 0x07 0x32 0x43 0x4F  0x52 0x52 0x55 0x50 0x54 0x02 0x36 0x4E  // HEAP.2CORRUPT.6N
0x82C0  0x4F 0x04 0x37 0x4D 0x4F 0x52 0x45 0x06  0x38 0x4C 0x4F 0x43 0x41 0x4C 0x53 0x07  // O.7MORE.8LOCALS.
0x82D0  0x39 0x4D 0x49 0x53 0x53 0x49 0x4E 0x47  0x08 0x3A 0x49 0x54 0x45 0x52 0x41 0x54  // 9MISSING.:ITERAT
0x82E0  0x4F 0x52 0x04 0x3B 0x4D 0x55 0x53 0x54  0x02 0x3C 0x42 0x45 0x05 0x3D 0x4C 0x4F  // OR.;MUST.<BE.=LO
0x82F0  0x43 0x41 0x4C 0x05 0x3E 0x52 0x41 0x4E  0x47 0x45 0x01 0x3F 0x5D 0x00 0x0A 0x40  // CAL.>RANGE.?]..@
0x8300  0x45 0x58 0x50 0x52 0x45 0x53 0x53 0x49  0x4F 0x4E 0x08 0x41 0x46 0x49 0x4C 0x45  // EXPRESSION.AFILE
0x8310  0x4E 0x41 0x4D 0x45 0x09 0x42 0x44 0x49  0x52 0x45 0x43 0x54 0x4F 0x52 0x59 0x04  // NAME.BDIRECTORY.
0x8320  0x43 0x46 0x55 0x4C 0x4C 0x06 0x44 0x45  0x45 0x50 0x52 0x4F 0x4D 0x05 0x45 0x42  // CFULL.DEEPROM.EB
0x8330  0x59 0x54 0x45 0x53 0x09 0x46 0x41 0x56  0x41 0x49 0x4C 0x41 0x42 0x4C 0x45 0x07  // YTES.FAVAILABLE.
0x8340  0x47 0x52 0x45 0x41 0x44 0x59 0x0A 0x3E  0x02 0x48 0x4F 0x4B 0x04 0x49 0x4D 0x41  // GREADY.>.HOK.IMA
0x8350  0x49 0x4E 0x07 0x4A 0x50 0x52 0x4F 0x47  0x52 0x41 0x4D 0x04 0x4B 0x56 0x4F 0x49  // IN.JPROGRAM.KVOI
0x8360  0x44 0x05 0x4C 0x46 0x49 0x4C 0x45 0x53  0x04 0x4D 0x57 0x49 0x4C 0x4C 0x05 0x4E  // D.LFILES.MWILL.N
0x8370  0x45 0x52 0x41 0x53 0x45 0x03 0x4F 0x41  0x4C 0x4C 0x09 0x50 0x4F 0x56 0x45 0x52  // ERASE.OALL.POVER
0x8380  0x57 0x52 0x49 0x54 0x45 0x04 0x51 0x55  0x53 0x45 0x44 0x08 0x53 0x43 0x4F 0x4E  // WRITE.QUSED.SCON
0x8390  0x54 0x49 0x4E 0x55 0x45 0x03 0x52 0x59  0x2F 0x4E 0x03 0x54 0x42 0x49 0x47 0x07  // TINUE.RY/N.TBIG.
0x83A0  0x55 0x43 0x4F 0x4D 0x4D 0x45 0x4E 0x54  0x00 0x00 0x19 0x33 0x4C 0x66 0x80 0x99  // UCOMMENT...3Lf..
0x83B0  0xB3 0xCC 0xE6 0x00 0x06 0x02 0x08 0x04  0x00 0x06 0x02 0x08 0x04 0x24 0x4D 0x41  // .............$MA
0x83C0  0x49 0x4E 0x00 0x00 0x03 0xAA 0x46 0x4F  0x52 0x02 0xA1 0x49 0x46 0x03 0x96 0x49  // IN....FOR..IF..I
0x83D0  0x4E 0x54 0x03 0xA9 0x45 0x4E 0x44 0x03  0xB8 0x41 0x4E 0x44 0x03 0xC0 0x41 0x42  // NT..END..AND..AB
0x83E0  0x53 0x04 0xA3 0x45 0x4C 0x53 0x45 0x02  0xB0 0x44 0x4F 0x03 0xC9 0x43 0x48 0x52  // S..ELSE..DO..CHR
0x83F0  0x03 0xC8 0x41 0x53 0x43 0x05 0xA4 0x45  0x4E 0x44 0x49 0x46 0x05 0x83 0x43 0x4C  // ..ASC..ENDIF..CL
0x8400  0x45 0x41 0x52 0x03 0xC7 0x43 0x4C 0x53  0x05 0xBD 0x46 0x41 0x4C 0x53 0x45 0x04  // EAR..CLS..FALSE.
0x8410  0x99 0x42 0x59 0x54 0x45 0x03 0x98 0x42  0x49 0x54 0x04 0x9C 0x43 0x48 0x41 0x52  // .BYTE..BIT..CHAR
0x8420  0x04 0xA5 0x46 0x55 0x4E 0x43 0x05 0x9E  0x43 0x4F 0x4E 0x53 0x54 0x05 0xC6 0x44  // ..FUNC..CONST..D
0x8430  0x45 0x4C 0x41 0x59 0x07 0xA6 0x45 0x4E  0x44 0x46 0x55 0x4E 0x43 0x05 0xA8 0x42  // ELAY..ENDFUNC..B
0x8440  0x45 0x47 0x49 0x4E 0x05 0xB7 0x41 0x52  0x52 0x41 0x59 0x03 0x91 0x42 0x59 0x45  // EGIN..ARRAY..BYE
0x8450  0x03 0x8A 0x44 0x45 0x4C 0x03 0x89 0x44  0x49 0x52 0x06 0x86 0x46 0x4F 0x52 0x47  // ..DEL..DIR..FORG
0x8460  0x45 0x54 0x06 0x8B 0x46 0x4F 0x52 0x4D  0x41 0x54 0x05 0x85 0x46 0x55 0x4E 0x43  // ET..FORMAT..FUNC
0x8470  0x53 0x06 0xD5 0x49 0x4D 0x50 0x4F 0x52  0x54 0x06 0xD6 0x45 0x58 0x50 0x4F 0x52  // S..IMPORT..EXPOR
0x8480  0x54 0x07 0xCF 0x49 0x32 0x43 0x46 0x49  0x4E 0x44 0x08 0xD0 0x49 0x32 0x43 0x42  // T..I2CFIND..I2CB
0x8490  0x45 0x47 0x49 0x4E 0x06 0xD1 0x49 0x32  0x43 0x50 0x55 0x54 0x06 0xD2 0x49 0x32  // EGIN..I2CPUT..I2
0x84A0  0x43 0x45 0x4E 0x44 0x06 0xD3 0x49 0x32  0x43 0x47 0x45 0x54 0x07 0xD4 0x49 0x32  // CEND..I2CGET..I2
0x84B0  0x43 0x4E 0x45 0x58 0x54 0x00 0x05 0x9F  0x50 0x52 0x49 0x4E 0x54 0x04 0xAD 0x4E  // CNEXT...PRINT..N
0x84C0  0x45 0x58 0x54 0x04 0xA2 0x54 0x48 0x45  0x4E 0x03 0xBB 0x4D 0x4F 0x44 0x03 0xCA  // EXT..THEN..MOD..
0x84D0  0x4C 0x45 0x4E 0x03 0x9D 0x56 0x41 0x52  0x04 0x9A 0x4C 0x4F 0x4E 0x47 0x05 0xAE  // LEN..VAR..LONG..
0x84E0  0x57 0x48 0x49 0x4C 0x45 0x04 0xAF 0x57  0x45 0x4E 0x44 0x04 0xAC 0x53 0x54 0x45  // WHILE..WEND..STE
0x84F0  0x50 0x04 0x81 0x4C 0x49 0x53 0x54 0x04  0x88 0x4C 0x4F 0x41 0x44 0x04 0x97 0x57  // P..LIST..LOAD..W
0x8500  0x4F 0x52 0x44 0x06 0x9B 0x53 0x54 0x52  0x49 0x4E 0x47 0x06 0xA7 0x52 0x45 0x54  // ORD..STRING..RET
0x8510  0x55 0x52 0x4E 0x03 0xBA 0x4E 0x4F 0x54  0x02 0xB9 0x4F 0x52 0x04 0xBC 0x54 0x52  // URN..NOT..OR..TR
0x8520  0x55 0x45 0x02 0xAB 0x54 0x4F 0x05 0xB1  0x55 0x4E 0x54 0x49 0x4C 0x03 0x80 0x4E  // UE..TO..UNTIL..N
0x8530  0x45 0x57 0x03 0x82 0x52 0x55 0x4E 0x03  0x8C 0x4D 0x45 0x4D 0x04 0x87 0x53 0x41  // EW..RUN..MEM..SA
0x8540  0x56 0x45 0x04 0x84 0x56 0x41 0x52 0x53  0x03 0x94 0x52 0x45 0x4D 0x06 0xC1 0x4D  // VE..VARS..REM..M
0x8550  0x49 0x4C 0x4C 0x49 0x53 0x04 0xC2 0x50  0x45 0x45 0x4B 0x04 0xC3 0x50 0x4F 0x4B  // ILLIS..PEEK..POK
0x8560  0x45 0x03 0xCE 0x52 0x4E 0x44 0x07 0xC5  0x53 0x45 0x43 0x4F 0x4E 0x44 0x53 0x07  // E..RND..SECONDS.
0x8570  0xCB 0x50 0x49 0x4E 0x4D 0x4F 0x44 0x45  0x04 0xCC 0x52 0x45 0x41 0x44 0x05 0xCD  // .PINMODE..READ..
0x8580  0x57 0x52 0x49 0x54 0x45 0x00 0x0A 0x3D  0x3D 0x20 0x43 0x52 0x41 0x53 0x48 0x20  // WRITE..==.CRASH.
0x8590  0x3D 0x3D 0x0A 0x00 0x53 0x50 0x3A 0x00  0x01 0x02 0x04 0x08 0x10 0x20 0x40 0x80  // ==..SP:.......@.
0x85A0  0x3C 0x2D 0x2D 0x2D 0x2D 0x2D 0x00 0x4C  0x01 0x16 0x4B 0x01 0x01 0x4D 0x44 0x01  // <-----.L..K..MD.
0x85B0  0x16 0x43 0x01 0x01 0x4E 0x44 0x01 0x43  0x43 0x01 0x03 0x8A 0x44 0x01 0x43 0x43  // .C..ND.CC...D.CC
0x85C0  0x02 0x04 0x8A 0x4C 0x01 0x4B 0x4B 0x01  0x03 0x8B 0x4C 0x01 0x4B 0x4B 0x02 0x04  // ...L.KK...L.KK..
0x85D0  0x8B 0x1C 0x4B 0x4B 0xFF 0x00 0x05 0x8C  0x1C 0x43 0x4B 0xFF 0x00 0x05 0x8D 0x1C  // ..KK.....CK.....
0x85E0  0x4B 0x43 0xFF 0x00 0x05 0x8E 0x1C 0x43  0x43 0xFF 0x00 0x05 0x8F 0x18 0x81 0xFF  // KC.....CC.......
0x85F0  0xFF 0x00 0x02 0x81 0x1B 0x50 0xFF 0xFF  0x00 0x06 0x50 0x43 0x43 0xFF 0xFF 0x04  // .....P....PCC...
0x8600  0x01 0x51 0x00 0x24 0x46 0x00                                                     // .Q.$F.

// /source/projects/6502sbc/hopperbasic/basic.asm:295
// ####  HopperBASIC.Hopper()  ####                                             0x0000

0x8606  0xD8            CLD                     // #else                             basic.asm:130
0x8607  0xA2 0xFF       LDX # 0xFF              //    Print startup banner with system information
0x8609  0x9A            TXS                     // printStartupBanner()              basic.asm:150
0x860A  0x78            SEI                     // SEI     Disable interrupts during initialization
0x860B  0x20 0x29 0xFF  JSR 0xFF29              // InitializeBASIC();                basic.asm:299
0x860E  0x58            CLI                     // CLI     Re-enable interrupts      basic.asm:301
0x860F  0x20 0x5D 0xFF  JSR 0xFF5D              // printStartupBanner();             basic.asm:305
0x8612  0x20 0x69 0xFF  JSR 0xFF69              // interpreterLoop();                basic.asm:309
0x8615  0xDB            STP                     // }                                 basic.asm:310

// /source/projects/6502sbc/hopperbasic/definitions/messages.asm:19
// ####  Messages.Main()  ####                                                  0x0001

0x8616  0xA9 0xBD       LDA # 0xBD              // LDA #(Messages.BeginFunctionName % 256)    TOPL
0x8618  0x85 0x11       STA 0x11                // STA ZP.TOPL                       messages.asm:21
0x861A  0xA9 0x83       LDA # 0x83              // LDA #(Messages.BeginFunctionName / 256)
0x861C  0x85 0x12       STA 0x12                // STA ZP.TOPH                       messages.asm:23
0x861E  0x60            RTS                     // }                                 messages.asm:24

// /source/projects/6502sbc/hopperbasic/definitions/basictypes.asm:43
// ####  BASICTypes.Promote()  ####                                             0x0002

0x861F  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       basictypes.asm:46
0x8621  0xC9 0x03       CMP # 0x03              // case BASICType.BYTE:              basictypes.asm:49
0x8623  0xD0 0x05       BNE 0x862A (+5)
0x8625  0x20 0x9A 0x97  JSR 0x979A              // Long.ZeroTop3();                  basictypes.asm:51
0x8628  0x80 0x29       BRA 0x8653 (+41)        // }                                 basictypes.asm:52
0x862A  0xC9 0x02       CMP # 0x02              // case BASICType.INT:               basictypes.asm:53
0x862C  0xD0 0x11       BNE 0x863F (+17)
0x862E  0x7F 0x12 0x08  BBR7 0x12, 0x8639 (+8)  // if (BBS7, ZP.TOP1)                basictypes.asm:55
0x8631  0xA9 0xFF       LDA # 0xFF              // LDA #0x0FF                        basictypes.asm:57
0x8633  0x85 0x13       STA 0x13                // STA ZP.TOP2                       basictypes.asm:58
0x8635  0x85 0x14       STA 0x14                // STA ZP.TOP3                       basictypes.asm:59
0x8637  0x80 0x1A       BRA 0x8653 (+26)        // }                                 basictypes.asm:60
0x8639  0x64 0x13       STZ 0x13                // STZ ZP.TOP2                       basictypes.asm:63
0x863B  0x64 0x14       STZ 0x14                // STZ ZP.TOP3    x2                 basictypes.asm:64
0x863D  0x80 0x14       BRA 0x8653 (+20)        // }                                 basictypes.asm:66
0x863F  0xC9 0x00       CMP # 0                 // case 0:                           basictypes.asm:67
0x8641  0xF0 0x04       BEQ 0x8647 (+4)
0x8643  0xC9 0x04       CMP # 0x04              // case BASICType.WORD:              basictypes.asm:68
0x8645  0xD0 0x06       BNE 0x864D (+6)
0x8647  0x64 0x13       STZ 0x13                // STZ ZP.TOP2                       basictypes.asm:70
0x8649  0x64 0x14       STZ 0x14                // STZ ZP.TOP3    x2                 basictypes.asm:71
0x864B  0x80 0x06       BRA 0x8653 (+6)         // }                                 basictypes.asm:72
0x864D  0xC9 0x08       CMP # 0x08              // case BASICType.LONG:              basictypes.asm:73
0x864F  0xF0 0x02       BEQ 0x8653 (+2)
0x8651  0x18            CLC                     // CLC                               basictypes.asm:78
0x8652  0x60            RTS                     // break;                            basictypes.asm:79
0x8653  0xA9 0x08       LDA # 0x08              // LDA # BASICType.LONG              basictypes.asm:82
0x8655  0x85 0x15       STA 0x15                // STA ZP.TOPT                       basictypes.asm:83
0x8657  0x38            SEC                     // SEC                               basictypes.asm:84
0x8658  0x60            RTS                     // break;                            basictypes.asm:85

// /source/projects/6502sbc/hopperbasic/definitions/basictypes.asm:92
// ####  BASICTypes.Coerce()  ####                                              0x0003

0x8659  0xA9 0x08       LDA # 0x08              // LDA #BASICType.LONG               basictypes.asm:95
0x865B  0xC5 0x15       CMP 0x15                // CMP ZP.TOPT                       basictypes.asm:96
0x865D  0xF0 0x06       BEQ 0x8665 (+6)         // if (NZ)                           basictypes.asm:97
0x865F  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0x8662  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:100
0x8665  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       basictypes.asm:102
0x8667  0xC9 0x03       CMP # 0x03              // case BASICType.BYTE:              basictypes.asm:105
0x8669  0xD0 0x0E       BNE 0x8679 (+14)
0x866B  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       basictypes.asm:107
0x866D  0x05 0x13       ORA 0x13                // ORA ZP.TOP2                       basictypes.asm:108
0x866F  0x05 0x14       ORA 0x14                // ORA ZP.TOP3    x3                 basictypes.asm:109
0x8671  0xF0 0x65       BEQ 0x86D8 (+101)       // if (NZ)                           basictypes.asm:110
0x8673  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x8676  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:113
0x8679  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              basictypes.asm:116
0x867B  0xD0 0x13       BNE 0x8690 (+19)
0x867D  0x85 0x15       STA 0x15                // STA ZP.TOPT                       basictypes.asm:118
0x867F  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       basictypes.asm:119
0x8681  0x05 0x13       ORA 0x13                // ORA ZP.TOP2                       basictypes.asm:120
0x8683  0x05 0x14       ORA 0x14                // ORA ZP.TOP3    x3                 basictypes.asm:121
0x8685  0xD0 0x03       BNE 0x868A (+3)         // if (NZ)                           basictypes.asm:122
0x8687  0x4C 0x59 0x8C  JMP 0x8C59
0x868A  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x868D  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:125
0x8690  0xC9 0x04       CMP # 0x04              // case BASICType.WORD:              basictypes.asm:128
0x8692  0xD0 0x0F       BNE 0x86A3 (+15)
0x8694  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       basictypes.asm:130
0x8696  0x05 0x14       ORA 0x14                // ORA ZP.TOP3    x2                 basictypes.asm:131
0x8698  0xD0 0x03       BNE 0x869D (+3)         // if (NZ)                           basictypes.asm:132
0x869A  0x4C 0x59 0x8C  JMP 0x8C59
0x869D  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x86A0  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:135
0x86A3  0xC9 0x02       CMP # 0x02              // case BASICType.INT:               basictypes.asm:138
0x86A5  0xD0 0x2B       BNE 0x86D2 (+43)
0x86A7  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       basictypes.asm:140
0x86A9  0x05 0x14       ORA 0x14                // ORA ZP.TOP3    x2                 basictypes.asm:141
0x86AB  0xD0 0x03       BNE 0x86B0 (+3)         // if (NZ)                           basictypes.asm:142
0x86AD  0x4C 0x59 0x8C  JMP 0x8C59
0x86B0  0xA9 0xFF       LDA # 0xFF              // LDA #0xFF                         basictypes.asm:144
0x86B2  0xC5 0x14       CMP 0x14                // CMP ZP.TOP3                       basictypes.asm:145
0x86B4  0xF0 0x06       BEQ 0x86BC (+6)         // if (NZ)                           basictypes.asm:146
0x86B6  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x86B9  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:149
0x86BC  0xC5 0x13       CMP 0x13                // CMP ZP.TOP2                       basictypes.asm:151
0x86BE  0xF0 0x06       BEQ 0x86C6 (+6)         // if (NZ)                           basictypes.asm:152
0x86C0  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x86C3  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:155
0x86C6  0x7F 0x12 0x03  BBR7 0x12, 0x86CC (+3)  // if (BBR7, ZP.TOP1)    not negative
0x86C9  0x4C 0x59 0x8C  JMP 0x8C59
0x86CC  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x86CF  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:160
0x86D2  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x86D5  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:167
0x86D8  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:170

// /source/projects/6502sbc/hopperbasic/definitions/basictypes.asm:178
// ####  BASICTypes.CoerceNext()  ####                                          0x0004

0x86DB  0xA9 0x08       LDA # 0x08              // LDA #BASICType.LONG               basictypes.asm:181
0x86DD  0xC5 0x1A       CMP 0x1A                // CMP ZP.NEXTT                      basictypes.asm:182
0x86DF  0xF0 0x06       BEQ 0x86E7 (+6)         // if (NZ)                           basictypes.asm:183
0x86E1  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0x86E4  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:186
0x86E7  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       basictypes.asm:188
0x86E9  0xC9 0x03       CMP # 0x03              // case BASICType.BYTE:              basictypes.asm:191
0x86EB  0xF0 0x04       BEQ 0x86F1 (+4)
0x86ED  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              basictypes.asm:192
0x86EF  0xD0 0x11       BNE 0x8702 (+17)
0x86F1  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      basictypes.asm:194
0x86F3  0x05 0x18       ORA 0x18                // ORA ZP.NEXT2                      basictypes.asm:195
0x86F5  0x05 0x19       ORA 0x19                // ORA ZP.NEXT3    x3                basictypes.asm:196
0x86F7  0xD0 0x03       BNE 0x86FC (+3)         // if (NZ)                           basictypes.asm:197
0x86F9  0x4C 0x59 0x8C  JMP 0x8C59
0x86FC  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x86FF  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:200
0x8702  0xC9 0x04       CMP # 0x04              // case BASICType.WORD:              basictypes.asm:203
0x8704  0xD0 0x0F       BNE 0x8715 (+15)
0x8706  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      basictypes.asm:205
0x8708  0x05 0x19       ORA 0x19                // ORA ZP.NEXT3    x2                basictypes.asm:206
0x870A  0xD0 0x03       BNE 0x870F (+3)         // if (NZ)                           basictypes.asm:207
0x870C  0x4C 0x59 0x8C  JMP 0x8C59
0x870F  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x8712  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:210
0x8715  0xC9 0x02       CMP # 0x02              // case BASICType.INT:               basictypes.asm:213
0x8717  0xD0 0x2B       BNE 0x8744 (+43)
0x8719  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      basictypes.asm:215
0x871B  0x05 0x19       ORA 0x19                // ORA ZP.NEXT3    x2                basictypes.asm:216
0x871D  0xD0 0x03       BNE 0x8722 (+3)         // if (NZ)                           basictypes.asm:217
0x871F  0x4C 0x59 0x8C  JMP 0x8C59
0x8722  0xA9 0xFF       LDA # 0xFF              // LDA #0xFF                         basictypes.asm:219
0x8724  0xC5 0x19       CMP 0x19                // CMP ZP.NEXT3                      basictypes.asm:220
0x8726  0xF0 0x06       BEQ 0x872E (+6)         // if (NZ)                           basictypes.asm:221
0x8728  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x872B  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:224
0x872E  0xC5 0x18       CMP 0x18                // CMP ZP.NEXT2                      basictypes.asm:226
0x8730  0xF0 0x06       BEQ 0x8738 (+6)         // if (NZ)                           basictypes.asm:227
0x8732  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x8735  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:230
0x8738  0x7F 0x17 0x03  BBR7 0x17, 0x873E (+3)  // if (BBR7, ZP.NEXT1)    not negative
0x873B  0x4C 0x59 0x8C  JMP 0x8C59
0x873E  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x8741  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:235
0x8744  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0x8747  0x4C 0x59 0x8C  JMP 0x8C59              // break;                            basictypes.asm:242

// /source/projects/6502sbc/hopperbasic/definitions/basictypes.asm:255
// ####  BASICTypes.PrintType()  ####                                           0x0005

0x874A  0x48            PHA                     // PHA                               basictypes.asm:256
0x874B  0xDA            PHX                     // PHX                               basictypes.asm:257
0x874C  0xAA            TAX                     // TAX                               basictypes.asm:258
0x874D  0x29 0xC0       AND # 0xC0              // AND # SymbolType.MASK             basictypes.asm:262
0x874F  0xF0 0x1E       BEQ 0x876F (+30)        // if (NZ)                           basictypes.asm:263
0x8751  0x8A            TXA                     // TXA                               basictypes.asm:265
0x8752  0x29 0x40       AND # 0x40              // AND # SymbolType.VARIABLE         basictypes.asm:266
0x8754  0xF0 0x0A       BEQ 0x8760 (+10)        // if (NZ)                           basictypes.asm:267
0x8756  0xA9 0x9D       LDA # 0x9D              // LDA # Token.VAR                   basictypes.asm:269
0x8758  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();    preserves X and Y
0x875B  0xA9 0x7C       LDA # 0x7C              // LDA #'|' Print.Char();            basictypes.asm:271
0x875D  0x20 0xB0 0x95  JSR 0x95B0
0x8760  0x8A            TXA                     // TXA                               basictypes.asm:273
0x8761  0x29 0x80       AND # 0x80              // AND # SymbolType.CONSTANT         basictypes.asm:274
0x8763  0xF0 0x0A       BEQ 0x876F (+10)        // if (NZ)                           basictypes.asm:275
0x8765  0xA9 0x9E       LDA # 0x9E              // LDA # Token.CONST                 basictypes.asm:277
0x8767  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();    preserves X and Y
0x876A  0xA9 0x7C       LDA # 0x7C              // LDA #'|' Print.Char();            basictypes.asm:279
0x876C  0x20 0xB0 0x95  JSR 0x95B0
0x876F  0x8A            TXA                     // TXA                               basictypes.asm:283
0x8770  0x29 0x10       AND # 0x10              // AND # BASICType.VAR               basictypes.asm:284
0x8772  0xF0 0x1C       BEQ 0x8790 (+28)        // if (NZ)                           basictypes.asm:285
0x8774  0xA9 0x9D       LDA # 0x9D              // LDA #Token.VAR                    basictypes.asm:287
0x8776  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();    preserves X and Y
0x8779  0x8A            TXA                     // TXA                               basictypes.asm:289
0x877A  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          basictypes.asm:290
0x877C  0xF0 0x10       BEQ 0x878E (+16)        // if (NZ)                           basictypes.asm:291
0x877E  0xA9 0x28       LDA # 0x28              // LDA #'(' Print.Char();            basictypes.asm:294
0x8780  0x20 0xB0 0x95  JSR 0x95B0
0x8783  0x8A            TXA                     // TXA                               basictypes.asm:295
0x8784  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          basictypes.asm:296
0x8786  0x20 0x4A 0x87  JSR 0x874A              // PrintType();                      basictypes.asm:297
0x8789  0xA9 0x29       LDA # 0x29              // LDA #')' Print.Char();            basictypes.asm:298
0x878B  0x20 0xB0 0x95  JSR 0x95B0
0x878E  0x80 0x6D       BRA 0x87FD (+109)       // }                                 basictypes.asm:300
0x8790  0x8A            TXA                     // TXA                               basictypes.asm:303
0x8791  0x29 0x20       AND # 0x20              // AND # BASICType.ARRAY             basictypes.asm:304
0x8793  0xF0 0x1C       BEQ 0x87B1 (+28)        // if (NZ)                           basictypes.asm:305
0x8795  0xA9 0xB7       LDA # 0xB7              // LDA #Token.ARRAY                  basictypes.asm:307
0x8797  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();    preserves X and Y
0x879A  0x8A            TXA                     // TXA                               basictypes.asm:309
0x879B  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          basictypes.asm:310
0x879D  0xF0 0x5E       BEQ 0x87FD (+94)        // if (NZ)                           basictypes.asm:311
0x879F  0xA9 0x28       LDA # 0x28              // LDA #'(' Print.Char();            basictypes.asm:314
0x87A1  0x20 0xB0 0x95  JSR 0x95B0
0x87A4  0x8A            TXA                     // TXA                               basictypes.asm:315
0x87A5  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          basictypes.asm:316
0x87A7  0x20 0x4A 0x87  JSR 0x874A              // PrintType();                      basictypes.asm:317
0x87AA  0xA9 0x29       LDA # 0x29              // LDA #')' Print.Char();            basictypes.asm:318
0x87AC  0x20 0xB0 0x95  JSR 0x95B0
0x87AF  0x80 0x4C       BRA 0x87FD (+76)        // }                                 basictypes.asm:320
0x87B1  0x8A            TXA                     // TXA                               basictypes.asm:324
0x87B2  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          basictypes.asm:325
0x87B4  0xD0 0x07       BNE 0x87BD (+7)         // if (Z)                            basictypes.asm:326
0x87B6  0xA9 0x4B       LDA # 0x4B              // LDA # ErrorWord.VOID              basictypes.asm:329
0x87B8  0x20 0x8C 0x8A  JSR 0x8A8C              // Error.PrintWord();                basictypes.asm:330
0x87BB  0x80 0x40       BRA 0x87FD (+64)        // }                                 basictypes.asm:331
0x87BD  0xC9 0x02       CMP # 0x02              // case BASICType.INT:               basictypes.asm:336
0x87BF  0xD0 0x04       BNE 0x87C5 (+4)
0x87C1  0xA9 0x96       LDA # 0x96              // LDA #Token.INT                    basictypes.asm:338
0x87C3  0x80 0x35       BRA 0x87FA (+53)        // }                                 basictypes.asm:339
0x87C5  0xC9 0x04       CMP # 0x04              // case BASICType.WORD:              basictypes.asm:340
0x87C7  0xD0 0x04       BNE 0x87CD (+4)
0x87C9  0xA9 0x97       LDA # 0x97              // LDA #Token.WORD                   basictypes.asm:342
0x87CB  0x80 0x2D       BRA 0x87FA (+45)        // }                                 basictypes.asm:343
0x87CD  0xC9 0x08       CMP # 0x08              // case BASICType.LONG:              basictypes.asm:344
0x87CF  0xD0 0x04       BNE 0x87D5 (+4)
0x87D1  0xA9 0x9A       LDA # 0x9A              // LDA #Token.LONG                   basictypes.asm:346
0x87D3  0x80 0x25       BRA 0x87FA (+37)        // }                                 basictypes.asm:347
0x87D5  0xC9 0x06       CMP # 0x06              // case BASICType.BIT:               basictypes.asm:348
0x87D7  0xD0 0x04       BNE 0x87DD (+4)
0x87D9  0xA9 0x98       LDA # 0x98              // LDA #Token.BIT                    basictypes.asm:350
0x87DB  0x80 0x1D       BRA 0x87FA (+29)        // }                                 basictypes.asm:351
0x87DD  0xC9 0x03       CMP # 0x03              // case BASICType.BYTE:              basictypes.asm:352
0x87DF  0xD0 0x04       BNE 0x87E5 (+4)
0x87E1  0xA9 0x99       LDA # 0x99              // LDA #Token.BYTE                   basictypes.asm:354
0x87E3  0x80 0x15       BRA 0x87FA (+21)        // }                                 basictypes.asm:355
0x87E5  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              basictypes.asm:356
0x87E7  0xD0 0x04       BNE 0x87ED (+4)
0x87E9  0xA9 0x9C       LDA # 0x9C              // LDA #Token.CHAR                   basictypes.asm:358
0x87EB  0x80 0x0D       BRA 0x87FA (+13)        // }                                 basictypes.asm:359
0x87ED  0xC9 0x05       CMP # 0x05              // case BASICType.STRING:            basictypes.asm:360
0x87EF  0xD0 0x04       BNE 0x87F5 (+4)
0x87F1  0xA9 0x9B       LDA # 0x9B              // LDA #Token.STRING                 basictypes.asm:362
0x87F3  0x80 0x05       BRA 0x87FA (+5)         // }                                 basictypes.asm:363
0x87F5  0x20 0xCA 0x8B  JSR 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0x87F8  0x80 0x03       BRA 0x87FD (+3)         // break;                            basictypes.asm:368
0x87FA  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();    preserves X and Y
0x87FD  0xFA            PLX                     // PLX                               basictypes.asm:377
0x87FE  0x68            PLA                     // PLA                               basictypes.asm:378
0x87FF  0x60            RTS                     // }                                 basictypes.asm:379

// /source/projects/6502sbc/hopperbasic/definitions/basictypes.asm:383
// ####  BASICTypes.FromToken()  ####                                           0x0006

0x8800  0xE0 0x96       CPX # 0x96              // case Token.INT:                   basictypes.asm:386
0x8802  0xD0 0x04       BNE 0x8808 (+4)
0x8804  0xA9 0x02       LDA # 0x02              // LDA # BASICType.INT               basictypes.asm:388
0x8806  0x38            SEC                     // SEC                               basictypes.asm:389
0x8807  0x60            RTS                     // }                                 basictypes.asm:390
0x8808  0xE0 0x97       CPX # 0x97              // case Token.WORD:                  basictypes.asm:391
0x880A  0xD0 0x04       BNE 0x8810 (+4)
0x880C  0xA9 0x04       LDA # 0x04              // LDA # BASICType.WORD              basictypes.asm:393
0x880E  0x38            SEC                     // SEC                               basictypes.asm:394
0x880F  0x60            RTS                     // }                                 basictypes.asm:395
0x8810  0xE0 0x99       CPX # 0x99              // case Token.BYTE:                  basictypes.asm:396
0x8812  0xD0 0x04       BNE 0x8818 (+4)
0x8814  0xA9 0x03       LDA # 0x03              // LDA # BASICType.BYTE              basictypes.asm:398
0x8816  0x38            SEC                     // SEC                               basictypes.asm:399
0x8817  0x60            RTS                     // }                                 basictypes.asm:400
0x8818  0xE0 0x9C       CPX # 0x9C              // case Token.CHAR:                  basictypes.asm:401
0x881A  0xD0 0x04       BNE 0x8820 (+4)
0x881C  0xA9 0x01       LDA # 1                 // LDA # BASICType.CHAR              basictypes.asm:403
0x881E  0x38            SEC                     // SEC                               basictypes.asm:404
0x881F  0x60            RTS                     // }                                 basictypes.asm:405
0x8820  0xE0 0x98       CPX # 0x98              // case Token.BIT:                   basictypes.asm:406
0x8822  0xD0 0x04       BNE 0x8828 (+4)
0x8824  0xA9 0x06       LDA # 0x06              // LDA # BASICType.BIT               basictypes.asm:408
0x8826  0x38            SEC                     // SEC                               basictypes.asm:409
0x8827  0x60            RTS                     // }                                 basictypes.asm:410
0x8828  0xE0 0x9B       CPX # 0x9B              // case Token.STRING:                basictypes.asm:411
0x882A  0xD0 0x04       BNE 0x8830 (+4)
0x882C  0xA9 0x05       LDA # 0x05              // LDA # BASICType.STRING            basictypes.asm:413
0x882E  0x38            SEC                     // SEC                               basictypes.asm:414
0x882F  0x60            RTS                     // }                                 basictypes.asm:415
0x8830  0xE0 0x9D       CPX # 0x9D              // case Token.VAR:                   basictypes.asm:416
0x8832  0xD0 0x04       BNE 0x8838 (+4)
0x8834  0xA9 0x10       LDA # 0x10              // LDA # BASICType.VAR               basictypes.asm:418
0x8836  0x38            SEC                     // SEC                               basictypes.asm:419
0x8837  0x60            RTS                     // }                                 basictypes.asm:420
0x8838  0xE0 0xB7       CPX # 0xB7              // case Token.ARRAY:                 basictypes.asm:421
0x883A  0xD0 0x04       BNE 0x8840 (+4)
0x883C  0xA9 0x20       LDA # 0x20              // LDA # BASICType.ARRAY             basictypes.asm:423
0x883E  0x38            SEC                     // SEC                               basictypes.asm:424
0x883F  0x60            RTS                     // }                                 basictypes.asm:425
0x8840  0xE0 0x9A       CPX # 0x9A              // case Token.LONG:                  basictypes.asm:426
0x8842  0xD0 0x04       BNE 0x8848 (+4)
0x8844  0xA9 0x08       LDA # 0x08              // LDA # BASICType.LONG              basictypes.asm:428
0x8846  0x38            SEC                     // SEC                               basictypes.asm:429
0x8847  0x60            RTS                     // }                                 basictypes.asm:430
0x8848  0x18            CLC                     // CLC                               basictypes.asm:433
0x8849  0x60            RTS                     // }                                 basictypes.asm:434

// /source/projects/6502sbc/hopperbasic/definitions/basictypes.asm:442
// ####  BASICTypes.ToToken()  ####                                             0x0007

0x884A  0xC9 0x02       CMP # 0x02              // case BASICType.INT:               basictypes.asm:445
0x884C  0xD0 0x04       BNE 0x8852 (+4)
0x884E  0xA9 0x96       LDA # 0x96              // LDA #Token.INT                    basictypes.asm:447
0x8850  0x38            SEC                     // SEC                               basictypes.asm:448
0x8851  0x60            RTS                     // }                                 basictypes.asm:449
0x8852  0xC9 0x04       CMP # 0x04              // case BASICType.WORD:              basictypes.asm:450
0x8854  0xD0 0x04       BNE 0x885A (+4)
0x8856  0xA9 0x97       LDA # 0x97              // LDA #Token.WORD                   basictypes.asm:452
0x8858  0x38            SEC                     // SEC                               basictypes.asm:453
0x8859  0x60            RTS                     // }                                 basictypes.asm:454
0x885A  0xC9 0x03       CMP # 0x03              // case BASICType.BYTE:              basictypes.asm:455
0x885C  0xD0 0x04       BNE 0x8862 (+4)
0x885E  0xA9 0x99       LDA # 0x99              // LDA #Token.BYTE                   basictypes.asm:457
0x8860  0x38            SEC                     // SEC                               basictypes.asm:458
0x8861  0x60            RTS                     // }                                 basictypes.asm:459
0x8862  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              basictypes.asm:460
0x8864  0xD0 0x04       BNE 0x886A (+4)
0x8866  0xA9 0x9C       LDA # 0x9C              // LDA #Token.CHAR                   basictypes.asm:462
0x8868  0x38            SEC                     // SEC                               basictypes.asm:463
0x8869  0x60            RTS                     // }                                 basictypes.asm:464
0x886A  0xC9 0x05       CMP # 0x05              // case BASICType.STRING:            basictypes.asm:465
0x886C  0xD0 0x04       BNE 0x8872 (+4)
0x886E  0xA9 0x9B       LDA # 0x9B              // LDA #Token.STRING                 basictypes.asm:467
0x8870  0x38            SEC                     // SEC                               basictypes.asm:468
0x8871  0x60            RTS                     // }                                 basictypes.asm:469
0x8872  0xC9 0x06       CMP # 0x06              // case BASICType.BIT:               basictypes.asm:470
0x8874  0xD0 0x04       BNE 0x887A (+4)
0x8876  0xA9 0x98       LDA # 0x98              // LDA #Token.BIT                    basictypes.asm:472
0x8878  0x38            SEC                     // SEC                               basictypes.asm:473
0x8879  0x60            RTS                     // }                                 basictypes.asm:474
0x887A  0xC9 0x10       CMP # 0x10              // case BASICType.VAR:               basictypes.asm:475
0x887C  0xD0 0x04       BNE 0x8882 (+4)
0x887E  0xA9 0x9D       LDA # 0x9D              // LDA #Token.VAR                    basictypes.asm:477
0x8880  0x38            SEC                     // SEC                               basictypes.asm:478
0x8881  0x60            RTS                     // }                                 basictypes.asm:479
0x8882  0xC9 0x20       CMP # 0x20              // case BASICType.ARRAY:             basictypes.asm:480
0x8884  0xD0 0x04       BNE 0x888A (+4)
0x8886  0xA9 0xB7       LDA # 0xB7              // LDA #Token.ARRAY                  basictypes.asm:482
0x8888  0x38            SEC                     // SEC                               basictypes.asm:483
0x8889  0x60            RTS                     // }                                 basictypes.asm:484
0x888A  0xC9 0x08       CMP # 0x08              // case BASICType.LONG:              basictypes.asm:485
0x888C  0xD0 0x04       BNE 0x8892 (+4)
0x888E  0xA9 0x9A       LDA # 0x9A              // LDA #Token.LONG                   basictypes.asm:487
0x8890  0x38            SEC                     // SEC                               basictypes.asm:488
0x8891  0x60            RTS                     // }                                 basictypes.asm:489
0x8892  0x18            CLC                     // CLC                               basictypes.asm:493
0x8893  0x60            RTS                     // }                                 basictypes.asm:494

// /source/projects/6502sbc/hopperbasic/definitions/basictypes.asm:500
// ####  BASICTypes.printEscapedChar()  ####                                    0x0008

0x8894  0x48            PHA                     // PHA                               basictypes.asm:501
0x8895  0xDA            PHX                     // PHX                               basictypes.asm:502
0x8896  0xA6 0x15       LDX 0x15                // LDX ZP.TOPT                       basictypes.asm:504
0x8898  0xC9 0x00       CMP # 0                 // case 0x00: { LDA #'0'  }          basictypes.asm:510
0x889A  0xD0 0x04       BNE 0x88A0 (+4)
0x889C  0xA9 0x30       LDA # 0x30
0x889E  0x80 0x55       BRA 0x88F5 (+85)
0x88A0  0xC9 0x07       CMP # 0x07              // case 0x07: { LDA #'a'  }          basictypes.asm:511
0x88A2  0xD0 0x04       BNE 0x88A8 (+4)
0x88A4  0xA9 0x61       LDA # 0x61
0x88A6  0x80 0x4D       BRA 0x88F5 (+77)
0x88A8  0xC9 0x08       CMP # 0x08              // case 0x08: { LDA #'b'  }          basictypes.asm:512
0x88AA  0xD0 0x04       BNE 0x88B0 (+4)
0x88AC  0xA9 0x62       LDA # 0x62
0x88AE  0x80 0x45       BRA 0x88F5 (+69)
0x88B0  0xC9 0x09       CMP # 0x09              // case 0x09: { LDA #'t'  }          basictypes.asm:513
0x88B2  0xD0 0x04       BNE 0x88B8 (+4)
0x88B4  0xA9 0x74       LDA # 0x74
0x88B6  0x80 0x3D       BRA 0x88F5 (+61)
0x88B8  0xC9 0x0A       CMP # 0x0A              // case 0x0A: { LDA #'n'  }          basictypes.asm:514
0x88BA  0xD0 0x04       BNE 0x88C0 (+4)
0x88BC  0xA9 0x6E       LDA # 0x6E
0x88BE  0x80 0x35       BRA 0x88F5 (+53)
0x88C0  0xC9 0x0C       CMP # 0x0C              // case 0x0C: { LDA #'f'  }          basictypes.asm:515
0x88C2  0xD0 0x04       BNE 0x88C8 (+4)
0x88C4  0xA9 0x66       LDA # 0x66
0x88C6  0x80 0x2D       BRA 0x88F5 (+45)
0x88C8  0xC9 0x0D       CMP # 0x0D              // case 0x0D: { LDA #'r'  }          basictypes.asm:516
0x88CA  0xD0 0x04       BNE 0x88D0 (+4)
0x88CC  0xA9 0x72       LDA # 0x72
0x88CE  0x80 0x25       BRA 0x88F5 (+37)
0x88D0  0xC9 0x1B       CMP # 0x1B              // case 0x1B: { LDA #'e'  }          basictypes.asm:517
0x88D2  0xD0 0x04       BNE 0x88D8 (+4)
0x88D4  0xA9 0x65       LDA # 0x65
0x88D6  0x80 0x1D       BRA 0x88F5 (+29)
0x88D8  0xC9 0x27       CMP # 0x27              // case '\'':                        basictypes.asm:518
0x88DA  0xD0 0x06       BNE 0x88E2 (+6)
0x88DC  0xE0 0x05       CPX # 0x05              // CPX # BASICType.STRING            basictypes.asm:520
0x88DE  0xF0 0x1C       BEQ 0x88FC (+28)        // if (Z) { break;    }    no \      basictypes.asm:521
0x88E0  0x80 0x13       BRA 0x88F5 (+19)
0x88E2  0xC9 0x22       CMP # 0x22              // case '"':                         basictypes.asm:523
0x88E4  0xD0 0x06       BNE 0x88EC (+6)
0x88E6  0xE0 0x01       CPX # 1                 // CPX # BASICType.CHAR              basictypes.asm:525
0x88E8  0xF0 0x12       BEQ 0x88FC (+18)        // if (Z) { break;    }     no \     basictypes.asm:526
0x88EA  0x80 0x09       BRA 0x88F5 (+9)
0x88EC  0xC9 0x5C       CMP # 0x5C              // case '\\': {           }          basictypes.asm:528
0x88EE  0xF0 0x05       BEQ 0x88F5 (+5)
0x88F0  0x20 0xE4 0x95  JSR 0x95E4              // Tools.IsPrintable();              basictypes.asm:531
0x88F3  0xB0 0x07       BCS 0x88FC (+7)         // if (C) { break; }     no \        basictypes.asm:532
0x88F5  0x48            PHA                     // PHA LDA #'\\' Serial.WriteChar(); PLA
0x88F6  0xA9 0x5C       LDA # 0x5C
0x88F8  0x20 0x2B 0x8D  JSR 0x8D2B
0x88FB  0x68            PLA
0x88FC  0x20 0xE4 0x95  JSR 0x95E4              // Tools.IsPrintable();              basictypes.asm:538
0x88FF  0x90 0x05       BCC 0x8906 (+5)         // if (C) { Serial.WriteChar(); }    basictypes.asm:539
0x8901  0x20 0x2B 0x8D  JSR 0x8D2B
0x8904  0x80 0x0A       BRA 0x8910 (+10)
0x8906  0x48            PHA                     // else   { PHA LDA #'x' Serial.WriteChar(); PLA Serial.HexOut(); }
0x8907  0xA9 0x78       LDA # 0x78
0x8909  0x20 0x2B 0x8D  JSR 0x8D2B
0x890C  0x68            PLA
0x890D  0x20 0xB5 0x8D  JSR 0x8DB5
0x8910  0x38            SEC                     // SEC                               basictypes.asm:541
0x8911  0xFA            PLX                     // PLX                               basictypes.asm:543
0x8912  0x68            PLA                     // PLA                               basictypes.asm:544
0x8913  0x60            RTS                     // }                                 basictypes.asm:545

// /source/projects/6502sbc/hopperbasic/definitions/basictypes.asm:552
// ####  BASICTypes.PrintValue()  ####                                          0x0009

0x8914  0x48            PHA                     // PHA                               basictypes.asm:553
0x8915  0xDA            PHX                     // PHX                               basictypes.asm:554
0x8916  0x08            PHP                     // PHP                               basictypes.asm:555
0x8917  0xA6 0x15       LDX 0x15                // LDX ZP.TOPT                       basictypes.asm:558
0x8919  0xE0 0x06       CPX # 0x06              // case BASICType.BIT:               basictypes.asm:561
0x891B  0xD0 0x12       BNE 0x892F (+18)
0x891D  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       basictypes.asm:563
0x891F  0xD0 0x07       BNE 0x8928 (+7)         // if (Z)                            basictypes.asm:565
0x8921  0xA9 0xBD       LDA # 0xBD              // LDA #Token.FALSE                  basictypes.asm:567
0x8923  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            basictypes.asm:568
0x8926  0x80 0x5D       BRA 0x8985 (+93)        // }                                 basictypes.asm:569
0x8928  0xA9 0xBC       LDA # 0xBC              // LDA #Token.TRUE                   basictypes.asm:572
0x892A  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            basictypes.asm:573
0x892D  0x80 0x56       BRA 0x8985 (+86)        // }                                 basictypes.asm:575
0x892F  0xE0 0x01       CPX # 1                 // case BASICType.CHAR:              basictypes.asm:576
0x8931  0xD0 0x1C       BNE 0x894F (+28)
0x8933  0x28            PLP                     // PLP                               basictypes.asm:579
0x8934  0x90 0x11       BCC 0x8947 (+17)        // if (C)                            basictypes.asm:580
0x8936  0xA9 0x27       LDA # 0x27              // LDA #'\'' Serial.WriteChar();     basictypes.asm:582
0x8938  0x20 0x2B 0x8D  JSR 0x8D2B
0x893B  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       basictypes.asm:583
0x893D  0x20 0x94 0x88  JSR 0x8894              // printEscapedChar();               basictypes.asm:584
0x8940  0xA9 0x27       LDA # 0x27              // LDA #'\'' Serial.WriteChar();     basictypes.asm:585
0x8942  0x20 0x2B 0x8D  JSR 0x8D2B
0x8945  0x80 0x05       BRA 0x894C (+5)         // }                                 basictypes.asm:586
0x8947  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       basictypes.asm:589
0x8949  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               basictypes.asm:590
0x894C  0x08            PHP                     // PHP                               basictypes.asm:592
0x894D  0x80 0x36       BRA 0x8985 (+54)        // }                                 basictypes.asm:594
0x894F  0xE0 0x05       CPX # 0x05              // case BASICType.STRING:            basictypes.asm:595
0x8951  0xD0 0x26       BNE 0x8979 (+38)
0x8953  0x28            PLP                     // PLP                               basictypes.asm:597
0x8954  0x20 0x5E 0xF6  JSR 0xF65E              // MoveTOPtoSTR();                   basictypes.asm:598
0x8957  0x90 0x1A       BCC 0x8973 (+26)        // if (C)                            basictypes.asm:600
0x8959  0xA9 0x22       LDA # 0x22              // LDA #'"' Serial.WriteChar();      basictypes.asm:602
0x895B  0x20 0x2B 0x8D  JSR 0x8D2B
0x895E  0x5A            PHY                     // PHY                               basictypes.asm:604
0x895F  0xA0 0x00       LDY # 0                 // LDY # 0                  Initialize string index
0x8961  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y      Load character from string
0x8963  0xF0 0x06       BEQ 0x896B (+6)         // if (Z) { break; }    Exit if null terminator found (\0 doesn't work within STRING)
0x8965  0x20 0x94 0x88  JSR 0x8894              // printEscapedChar();               basictypes.asm:610
0x8968  0xC8            INY                     // INY                  Move to next character
0x8969  0x80 0xF6       BRA 0x8961 (-10)        // }    loop                         basictypes.asm:612
0x896B  0x7A            PLY                     // PLY                               basictypes.asm:613
0x896C  0xA9 0x22       LDA # 0x22              // LDA #'"' Serial.WriteChar();      basictypes.asm:615
0x896E  0x20 0x2B 0x8D  JSR 0x8D2B
0x8971  0x80 0x03       BRA 0x8976 (+3)         // }                                 basictypes.asm:616
0x8973  0x20 0x9D 0x95  JSR 0x959D              // Print.String();     Print the actual string content
0x8976  0x08            PHP                     // PHP                               basictypes.asm:621
0x8977  0x80 0x0C       BRA 0x8985 (+12)        // }                                 basictypes.asm:622
0x8979  0xE0 0x08       CPX # 0x08              // case BASICType.LONG:              basictypes.asm:623
0x897B  0xD0 0x05       BNE 0x8982 (+5)
0x897D  0x20 0xCF 0x95  JSR 0x95CF              // Print.Decimal();    Numeric types basictypes.asm:625
0x8980  0x80 0x03       BRA 0x8985 (+3)         // }                                 basictypes.asm:626
0x8982  0x20 0xCA 0x8B  JSR 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0x8985  0xE7 0x02       SMB6 0x02               // SMB6 ZP.FLAGS    Bit 6 - output was produced
0x8987  0x28            PLP                     // PLP                               basictypes.asm:639
0x8988  0xFA            PLX                     // PLX                               basictypes.asm:640
0x8989  0x68            PLA                     // PLA                               basictypes.asm:641
0x898A  0x60            RTS                     // }                                 basictypes.asm:642

// /source/projects/6502sbc/hopperbasic/definitions/states.asm:43
// ####  States.IsFailure()  ####                                               0x000C

0x898B  0x48            PHA                     // PHA                               states.asm:44
0x898C  0xA5 0x4E       LDA 0x4E                // LDA ZP.SystemState                states.asm:45
0x898E  0xD0 0x03       BNE 0x8993 (+3)         // if (Z)                            states.asm:47
0x8990  0x38            SEC                     // SEC                               states.asm:49
0x8991  0x80 0x01       BRA 0x8994 (+1)         // }                                 states.asm:50
0x8993  0x18            CLC                     // CLC                               states.asm:53
0x8994  0x68            PLA                     // PLA                               states.asm:55
0x8995  0x60            RTS                     // }                                 states.asm:56

// /source/projects/6502sbc/hopperbasic/definitions/states.asm:62
// ####  States.CanContinue()  ####                                             0x000D

0x8996  0x48            PHA                     // PHA                               states.asm:63
0x8997  0xA5 0x4E       LDA 0x4E                // LDA ZP.SystemState                states.asm:64
0x8999  0xD0 0x03       BNE 0x899E (+3)         // if (Z)                            states.asm:66
0x899B  0x18            CLC                     // CLC     Failure                   states.asm:68
0x899C  0x80 0x01       BRA 0x899F (+1)         // }                                 states.asm:69
0x899E  0x38            SEC                     // SEC     Success, Exiting or Return -> can continue
0x899F  0x68            PLA                     // PLA                               states.asm:74
0x89A0  0x60            RTS                     // }                                 states.asm:75

// /source/projects/6502sbc/hopperbasic/definitions/states.asm:80
// ####  States.IsExiting()  ####                                               0x000E

0x89A1  0x48            PHA                     // PHA                               states.asm:81
0x89A2  0xA5 0x4E       LDA 0x4E                // LDA ZP.SystemState                states.asm:82
0x89A4  0xC9 0x02       CMP # 0x02              // CMP #State.Exiting                states.asm:83
0x89A6  0xD0 0x03       BNE 0x89AB (+3)         // if (Z)                            states.asm:84
0x89A8  0x38            SEC                     // SEC                               states.asm:86
0x89A9  0x80 0x01       BRA 0x89AC (+1)         // }                                 states.asm:87
0x89AB  0x18            CLC                     // CLC                               states.asm:90
0x89AC  0x68            PLA                     // PLA                               states.asm:92
0x89AD  0x60            RTS                     // }                                 states.asm:93

// /source/projects/6502sbc/hopperbasic/definitions/states.asm:98
// ####  States.IsSuccess()  ####                                               0x000F

0x89AE  0x48            PHA                     // PHA                               states.asm:99
0x89AF  0xA5 0x4E       LDA 0x4E                // LDA ZP.SystemState                states.asm:100
0x89B1  0xC9 0x01       CMP # 1                 // CMP #State.Success                states.asm:101
0x89B3  0xD0 0x03       BNE 0x89B8 (+3)         // if (Z)                            states.asm:102
0x89B5  0x38            SEC                     // SEC                               states.asm:104
0x89B6  0x80 0x01       BRA 0x89B9 (+1)         // }                                 states.asm:105
0x89B8  0x18            CLC                     // CLC                               states.asm:108
0x89B9  0x68            PLA                     // PLA                               states.asm:110
0x89BA  0x60            RTS                     // }                                 states.asm:111

// /source/projects/6502sbc/hopperbasic/definitions/states.asm:139
// ####  States.SetSuccess()  ####                                              0x0011

0x89BB  0x48            PHA                     // PHA                               states.asm:140
0x89BC  0xA9 0x01       LDA # 1                 // LDA #State.Success                states.asm:141
0x89BE  0x85 0x4E       STA 0x4E                // STA ZP.SystemState                states.asm:142
0x89C0  0x68            PLA                     // PLA                               states.asm:143
0x89C1  0x60            RTS                     // }                                 states.asm:144

// /source/projects/6502sbc/hopperbasic/definitions/states.asm:155
// ####  States.SetExiting()  ####                                              0x0013

0x89C2  0x48            PHA                     // PHA                               states.asm:156
0x89C3  0xA9 0x02       LDA # 0x02              // LDA #State.Exiting                states.asm:157
0x89C5  0x85 0x4E       STA 0x4E                // STA ZP.SystemState                states.asm:158
0x89C7  0x68            PLA                     // PLA                               states.asm:159
0x89C8  0x60            RTS                     // }                                 states.asm:160

// /source/projects/6502sbc/hopperbasic/definitions/tokens.asm:301
// ####  Tokens.searchKeywordTable()  ####                                      0x0016

0x89C9  0xA0 0x00       LDY # 0                 // LDY #0     Start at beginning of keyword table
0x89CB  0xB1 0x9C       LDA [0x9C],Y            // LDA [ZP.TableIndex], Y     Get length of this keyword
0x89CD  0xF0 0x2A       BEQ 0x89F9 (+42)        // if (Z) { break; }          End of table - not found
0x89CF  0x85 0x9E       STA 0x9E                // STA ZP.KeywordLength       Save keyword length
0x89D1  0xC8            INY                     // INY                               tokens.asm:309
0x89D2  0xB1 0x9C       LDA [0x9C],Y            // LDA [ZP.TableIndex], Y     Get token value
0x89D4  0x85 0x9F       STA 0x9F                // STA ZP.TokenValue          Save token value
0x89D6  0xC8            INY                     // INY                               tokens.asm:312
0x89D7  0xA2 0x00       LDX # 0                 // LDX #0     Character index in our identifier
0x89D9  0xBD 0xE0 0x0B  LDA 0x0BE0,X            // LDA Address.BasicProcessBuffer, X     Get char from our identifier
0x89DC  0xD0 0x07       BNE 0x89E5 (+7)         // if (Z)     Hit null terminator in our identifier
0x89DE  0xE4 0x9E       CPX 0x9E                // CPX ZP.KeywordLength              tokens.asm:322
0x89E0  0xD0 0x0F       BNE 0x89F1 (+15)        // if (Z)                            tokens.asm:323
0x89E2  0xA5 0x9F       LDA 0x9F                // LDA ZP.TokenValue     Return token value - exact match!
0x89E4  0x60            RTS                     // return;                           tokens.asm:326
0x89E5  0xE4 0x9E       CPX 0x9E                // CPX ZP.KeywordLength              tokens.asm:332
0x89E7  0xF0 0x08       BEQ 0x89F1 (+8)         // if (Z) { break; }          Our identifier is longer than keyword
0x89E9  0xD1 0x9C       CMP [0x9C],Y            // CMP [ZP.TableIndex], Y     Compare with expected character
0x89EB  0xD0 0x04       BNE 0x89F1 (+4)         // if (NZ) { break; }         Mismatch
0x89ED  0xE8            INX                     // INX                               tokens.asm:338
0x89EE  0xC8            INY                     // INY                               tokens.asm:339
0x89EF  0x80 0xE8       BRA 0x89D9 (-24)        // }    loop                         tokens.asm:340
0x89F1  0xE4 0x9E       CPX 0x9E                // CPX ZP.KeywordLength     Have we reached the end of keyword?
0x89F3  0xF0 0xD6       BEQ 0x89CB (-42)        // if (Z) { break; }        Yes, Y now points to start of next keyword
0x89F5  0xE8            INX                     // INX                      Move to next character position
0x89F6  0xC8            INY                     // INY                      Advance Y to next character
0x89F7  0x80 0xF8       BRA 0x89F1 (-8)         // }                                 tokens.asm:349
0x89F9  0xA9 0x00       LDA # 0                 // LDA #0     Not found              tokens.asm:351
0x89FB  0x60            RTS                     // }                                 tokens.asm:352

// /source/projects/6502sbc/hopperbasic/definitions/tokens.asm:359
// ####  Tokens.FindKeyword()  ####                                             0x0017

0x89FC  0xDA            PHX                     // PHX                               tokens.asm:360
0x89FD  0x5A            PHY                     // PHY                               tokens.asm:361
0x89FE  0xAD 0xE0 0x0B  LDA 0x0BE0              // LDA Address.BasicProcessBuffer    tokens.asm:364
0x8A01  0xC9 0x4A       CMP # 0x4A              // CMP #'J'     Split point changed to 'J'
0x8A03  0x90 0x0A       BCC 0x8A0F (+10)        // if (C)       >= 'J', use J-Z table
0x8A05  0xA9 0xB6       LDA # 0xB6              // LDA #(keywordsJZ % 256)           tokens.asm:368
0x8A07  0x85 0x9C       STA 0x9C                // STA ZP.TableIndexL                tokens.asm:369
0x8A09  0xA9 0x84       LDA # 0x84              // LDA #(keywordsJZ / 256)           tokens.asm:370
0x8A0B  0x85 0x9D       STA 0x9D                // STA ZP.TableIndexH                tokens.asm:371
0x8A0D  0x80 0x08       BRA 0x8A17 (+8)         // }                                 tokens.asm:372
0x8A0F  0xA9 0xC4       LDA # 0xC4              // LDA #(keywordsAI % 256)           tokens.asm:375
0x8A11  0x85 0x9C       STA 0x9C                // STA ZP.TableIndexL                tokens.asm:376
0x8A13  0xA9 0x83       LDA # 0x83              // LDA #(keywordsAI / 256)           tokens.asm:377
0x8A15  0x85 0x9D       STA 0x9D                // STA ZP.TableIndexH                tokens.asm:378
0x8A17  0x20 0xC9 0x89  JSR 0x89C9              // searchKeywordTable();             tokens.asm:381
0x8A1A  0x7A            PLY                     // PLY                               tokens.asm:396
0x8A1B  0xFA            PLX                     // PLX                               tokens.asm:397
0x8A1C  0x60            RTS                     // }                                 tokens.asm:399

// /source/projects/6502sbc/hopperbasic/definitions/tokens.asm:407
// ####  Tokens.PrintKeyword()  ####                                            0x0018

0x8A1D  0xDA            PHX                     // PHX                               tokens.asm:409
0x8A1E  0x5A            PHY                     // PHY                               tokens.asm:410
0x8A1F  0x85 0x9F       STA 0x9F                // STA ZP.TokenValue     Store target token value
0x8A21  0xA9 0xC4       LDA # 0xC4              // LDA #(keywordsAI % 256)           tokens.asm:415
0x8A23  0x85 0x9C       STA 0x9C                // STA ZP.TableIndexL                tokens.asm:416
0x8A25  0xA9 0x83       LDA # 0x83              // LDA #(keywordsAI / 256)           tokens.asm:417
0x8A27  0x85 0x9D       STA 0x9D                // STA ZP.TableIndexH                tokens.asm:418
0x8A29  0x20 0x3C 0x8A  JSR 0x8A3C              // PrintKeywordFromTable();          tokens.asm:420
0x8A2C  0xB0 0x0B       BCS 0x8A39 (+11)        // if (NC)                           tokens.asm:421
0x8A2E  0xA9 0xB6       LDA # 0xB6              // LDA #(keywordsJZ % 256)           tokens.asm:424
0x8A30  0x85 0x9C       STA 0x9C                // STA ZP.TableIndexL                tokens.asm:425
0x8A32  0xA9 0x84       LDA # 0x84              // LDA #(keywordsJZ / 256)           tokens.asm:426
0x8A34  0x85 0x9D       STA 0x9D                // STA ZP.TableIndexH                tokens.asm:427
0x8A36  0x20 0x3C 0x8A  JSR 0x8A3C              // PrintKeywordFromTable();          tokens.asm:428
0x8A39  0x7A            PLY                     // PLY                               tokens.asm:450
0x8A3A  0xFA            PLX                     // PLX                               tokens.asm:451
0x8A3B  0x60            RTS                     // }                                 tokens.asm:452

// /source/projects/6502sbc/hopperbasic/definitions/tokens.asm:459
// ####  Tokens.PrintKeywordFromTable()  ####                                   0x0019

0x8A3C  0xA0 0x00       LDY # 0                 // LDY #0     Index into keywords table
0x8A3E  0xB1 0x9C       LDA [0x9C],Y            // LDA [ZP.TableIndex], Y        Get length of this keyword
0x8A40  0xD0 0x02       BNE 0x8A44 (+2)         // if (Z)                            tokens.asm:464
0x8A42  0x18            CLC                     // CLC                               tokens.asm:466
0x8A43  0x60            RTS                     // break;                            tokens.asm:467
0x8A44  0x85 0x9E       STA 0x9E                // STA ZP.KeywordLength          Save keyword length
0x8A46  0xC8            INY                     // INY                               tokens.asm:471
0x8A47  0xB1 0x9C       LDA [0x9C],Y            // LDA [ZP.TableIndex], Y        Get token value
0x8A49  0xC5 0x9F       CMP 0x9F                // CMP ZP.TokenValue             Compare with target
0x8A4B  0xD0 0x12       BNE 0x8A5F (+18)        // if (Z)                            tokens.asm:474
0x8A4D  0xC8            INY                     // INY     Move to first character   tokens.asm:477
0x8A4E  0xA6 0x9E       LDX 0x9E                // LDX ZP.KeywordLength      X = character count
0x8A50  0xE0 0x00       CPX # 0                 // CPX #0                            tokens.asm:481
0x8A52  0xF0 0x09       BEQ 0x8A5D (+9)         // if (Z) { break; }                 tokens.asm:482
0x8A54  0xB1 0x9C       LDA [0x9C],Y            // LDA [ZP.TableIndex], Y     Access character
0x8A56  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokens.asm:485
0x8A59  0xC8            INY                     // INY                               tokens.asm:486
0x8A5A  0xCA            DEX                     // DEX                               tokens.asm:487
0x8A5B  0x80 0xF3       BRA 0x8A50 (-13)        // }    loop                         tokens.asm:488
0x8A5D  0x38            SEC                     // SEC                               tokens.asm:490
0x8A5E  0x60            RTS                     // break;     Done printing          tokens.asm:491
0x8A5F  0xC8            INY                     // INY                      Skip the token value byte first
0x8A60  0xA6 0x9E       LDX 0x9E                // LDX ZP.KeywordLength     Then skip the keyword characters
0x8A62  0xE0 0x00       CPX # 0                 // CPX #0                            tokens.asm:499
0x8A64  0xF0 0xD8       BEQ 0x8A3E (-40)        // if (Z) { break; }                 tokens.asm:500
0x8A66  0xC8            INY                     // INY                               tokens.asm:501
0x8A67  0xCA            DEX                     // DEX                               tokens.asm:502
0x8A68  0x80 0xF8       BRA 0x8A62 (-8)         // }                                 tokens.asm:503

// /source/projects/6502sbc/hopperbasic/definitions/tokens.asm:513
// ####  Tokens.IsKeyword()  ####                                               0x001A

0x8A6A  0xC9 0xDA       CMP # 0xDA              // CMP # Token.IDENTIFIER            tokens.asm:514
0x8A6C  0xD0 0x02       BNE 0x8A70 (+2)         // if (Z)                            tokens.asm:515
0x8A6E  0x18            CLC                     // CLC     Not a keyword             tokens.asm:517
0x8A6F  0x60            RTS                     // }                                 tokens.asm:518
0x8A70  0xC9 0xD7       CMP # 0xD7              // CMP #( Token.lastKeyword + 1)     tokens.asm:521
0x8A72  0x90 0x02       BCC 0x8A76 (+2)         // if (C)     A >= (lastKeyword + 1), meaning A > lastKeyword
0x8A74  0x18            CLC                     // CLC     Not a keyword (operators, literals, etc.)
0x8A75  0x60            RTS                     // }                                 tokens.asm:525
0x8A76  0x38            SEC                     // SEC     Is a keyword              tokens.asm:528
0x8A77  0x60            RTS                     // }                                 tokens.asm:531

// /source/projects/6502sbc/hopperbasic/definitions/tokens.asm:540
// ####  Tokens.IsEndOfPrintStatement()  ####                                   0x001B

0x8A78  0xC9 0xDE       CMP # 0xDE              // case Token.COLON:      another statement follows
0x8A7A  0xF0 0x0C       BEQ 0x8A88 (+12)
0x8A7C  0xC9 0xDB       CMP # 0xDB              // case Token.EOF:        end of stream
0x8A7E  0xF0 0x08       BEQ 0x8A88 (+8)
0x8A80  0xC9 0xDC       CMP # 0xDC              // case Token.EOL:        end of line
0x8A82  0xF0 0x04       BEQ 0x8A88 (+4)
0x8A84  0xC9 0x95       CMP # 0x95              // case Token.COMMENT:    end of line comment
0x8A86  0xD0 0x02       BNE 0x8A8A (+2)
0x8A88  0x38            SEC                     // SEC                               tokens.asm:548
0x8A89  0x60            RTS                     // }                                 tokens.asm:549
0x8A8A  0x18            CLC                     // CLC                               tokens.asm:552
0x8A8B  0x60            RTS                     // }                                 tokens.asm:553

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:380
// ####  Error.PrintWord()  ####                                                0x001C

0x8A8C  0x5A            PHY                     // PHY                               error.asm:381
0x8A8D  0xDA            PHX                     // PHX                               error.asm:382
0x8A8E  0xAA            TAX                     // TAX                               error.asm:384
0x8A8F  0x10 0x05       BPL 0x8A96 (+5)         // if (MI)                           error.asm:385
0x8A91  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            error.asm:388
0x8A94  0x80 0x2E       BRA 0x8AC4 (+46)        // }                                 error.asm:389
0x8A96  0x29 0x60       AND # 0x60              // AND #0x60      Extract bits 6-5 (table selector)
0x8A98  0xD0 0x08       BNE 0x8AA2 (+8)         // case 0x00:     Table 0 (0x00-0x1F)
0x8A9A  0xA9 0x51       LDA # 0x51              // LDA #(errorWordsTable0 % 256)     error.asm:399
0x8A9C  0x85 0x9C       STA 0x9C                // STA ZP.TableIndexL                error.asm:400
0x8A9E  0xA9 0x81       LDA # 0x81              // LDA #(errorWordsTable0 / 256)     error.asm:401
0x8AA0  0x80 0x1B       BRA 0x8ABD (+27)        // }                                 error.asm:402
0x8AA2  0xC9 0x20       CMP # 0x20              // case 0x20:     Table 1 (0x20-0x3F)
0x8AA4  0xD0 0x08       BNE 0x8AAE (+8)
0x8AA6  0xA9 0x30       LDA # 0x30              // LDA #(errorWordsTable1 % 256)     error.asm:405
0x8AA8  0x85 0x9C       STA 0x9C                // STA ZP.TableIndexL                error.asm:406
0x8AAA  0xA9 0x82       LDA # 0x82              // LDA #(errorWordsTable1 / 256)     error.asm:407
0x8AAC  0x80 0x0F       BRA 0x8ABD (+15)        // }                                 error.asm:408
0x8AAE  0xC9 0x40       CMP # 0x40              // case 0x40:     Table 2 (0x40-0x5F)
0x8AB0  0xD0 0x08       BNE 0x8ABA (+8)
0x8AB2  0xA9 0xFE       LDA # 0xFE              // LDA #(errorWordsTable2 % 256)     error.asm:411
0x8AB4  0x85 0x9C       STA 0x9C                // STA ZP.TableIndexL                error.asm:412
0x8AB6  0xA9 0x82       LDA # 0x82              // LDA #(errorWordsTable2 / 256)     error.asm:413
0x8AB8  0x80 0x03       BRA 0x8ABD (+3)         // }                                 error.asm:414
0x8ABA  0x18            CLC                     // CLC     Tables 2 & 3 not implemented yet
0x8ABB  0x80 0x07       BRA 0x8AC4 (+7)         // break;                            error.asm:418
0x8ABD  0x85 0x9D       STA 0x9D                // STA ZP.TableIndexH                error.asm:421
0x8ABF  0x86 0x9F       STX 0x9F                // STX ZP.TokenValue                 error.asm:422
0x8AC1  0x20 0x3C 0x8A  JSR 0x8A3C              // Tokens.PrintKeywordFromTable();   Input: ZP.TokenValue = target token value, ZP.TableIndex = table address
0x8AC4  0xFA            PLX                     // PLX                               error.asm:427
0x8AC5  0x7A            PLY                     // PLY                               error.asm:428
0x8AC6  0x60            RTS                     // }                                 error.asm:429

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:451
// ####  Error.findMessage()  ####                                              0x001D

0x8AC7  0xA0 0x00       LDY # 0                 // LDY #0     Start at beginning of table
0x8AC9  0xB1 0x1D       LDA [0x1D],Y            // LDA [ZP.IDY], Y       Get word count for this message
0x8ACB  0xD0 0x02       BNE 0x8ACF (+2)         // if (Z) { CLC break; }     End of table - not found
0x8ACD  0x18            CLC
0x8ACE  0x60            RTS
0x8ACF  0xAA            TAX                     // TAX                   X = word count (keep it in X, don't store in ZP!)
0x8AD0  0xC8            INY                     // INY                               error.asm:459
0x8AD1  0xB1 0x1D       LDA [0x1D],Y            // LDA [ZP.IDY], Y       Get error ID
0x8AD3  0xC5 0x0E       CMP 0x0E                // CMP ZP.ACCL           Compare with target
0x8AD5  0xD0 0x03       BNE 0x8ADA (+3)         // if (Z)                            error.asm:462
0x8AD7  0xC8            INY                     // INY     Move to first word ID     error.asm:465
0x8AD8  0x38            SEC                     // SEC                               error.asm:466
0x8AD9  0x60            RTS                     // break;     Done printing          error.asm:467
0x8ADA  0xC8            INY                     // INY     Skip the error ID byte first
0x8ADB  0xE0 0x00       CPX # 0                 // CPX #0                            error.asm:474
0x8ADD  0xF0 0xEA       BEQ 0x8AC9 (-22)        // if (Z) { break; }                 error.asm:475
0x8ADF  0xC8            INY                     // INY                               error.asm:476
0x8AE0  0xCA            DEX                     // DEX                               error.asm:477
0x8AE1  0x80 0xF8       BRA 0x8ADB (-8)         // }                                 error.asm:478

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:485
// ####  Error.MessageNL()  ####                                                0x001E

0x8AE3  0x20 0xE9 0x8A  JSR 0x8AE9              // Message();                        error.asm:486
0x8AE6  0x4C 0xB6 0x95  JMP 0x95B6              // Print.NewLine();                  error.asm:487

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:492
// ####  Error.Message()  ####                                                  0x001F

0x8AE9  0x85 0x0E       STA 0x0E                // STA ZP.ACCL     Store target error ID
0x8AEB  0x86 0x0F       STX 0x0F                // STX ZP.ACCH     Store MessageExtras
0x8AED  0x0F 0x0F 0x03  BBR0 0x0F, 0x8AF3 (+3)  // if (BBS0, ZP.ACCH)    PrefixSpace error.asm:496
0x8AF0  0x20 0xBB 0x95  JSR 0x95BB              // Space();                          error.asm:498
0x8AF3  0x6F 0x0F 0x05  BBR6 0x0F, 0x8AFB (+5)  // if (BBS6, ZP.ACCH)    PrefixQuest error.asm:500
0x8AF6  0xA9 0x3F       LDA # 0x3F              // LDA #'?' Print.Char();            error.asm:502
0x8AF8  0x20 0xB0 0x95  JSR 0x95B0
0x8AFB  0x7F 0x0F 0x05  BBR7 0x0F, 0x8B03 (+5)  // if (BBS7, ZP.ACCH)    InParens    error.asm:504
0x8AFE  0xA9 0x28       LDA # 0x28              // LDA #'(' Print.Char();            error.asm:506
0x8B00  0x20 0xB0 0x95  JSR 0x95B0
0x8B03  0xA9 0x1D       LDA # 0x1D              // LDA #(errorMessages0 % 256)       error.asm:509
0x8B05  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       error.asm:510
0x8B07  0xA9 0x80       LDA # 0x80              // LDA #(errorMessages0 / 256)       error.asm:511
0x8B09  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       error.asm:512
0x8B0B  0x20 0xC7 0x8A  JSR 0x8AC7              // findMessage();                    error.asm:513
0x8B0E  0xB0 0x0E       BCS 0x8B1E (+14)        // if (NC)                           error.asm:514
0x8B10  0xA9 0x05       LDA # 0x05              // LDA #(errorMessages1 % 256)       error.asm:517
0x8B12  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       error.asm:518
0x8B14  0xA9 0x81       LDA # 0x81              // LDA #(errorMessages1 / 256)       error.asm:519
0x8B16  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       error.asm:520
0x8B18  0x20 0xC7 0x8A  JSR 0x8AC7              // findMessage();                    error.asm:521
0x8B1B  0xB0 0x01       BCS 0x8B1E (+1)         // if (NC)                           error.asm:522
0x8B1D  0x00            BRK                     // BRK    internal error - message not found
0x8B1E  0xE0 0x00       CPX # 0                 // CPX #0                            error.asm:531
0x8B20  0xF0 0x0E       BEQ 0x8B30 (+14)        // if (Z) { break; }                 error.asm:532
0x8B22  0xB1 0x1D       LDA [0x1D],Y            // LDA [ZP.IDY], Y       Get word ID error.asm:534
0x8B24  0x20 0x8C 0x8A  JSR 0x8A8C              // PrintWord();    word in A         error.asm:535
0x8B27  0xC8            INY                     // INY                               error.asm:536
0x8B28  0xCA            DEX                     // DEX                               error.asm:537
0x8B29  0xF0 0x05       BEQ 0x8B30 (+5)         // if (Z) { break; }     Don't add space after last word
0x8B2B  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    error.asm:542
0x8B2E  0x80 0xEE       BRA 0x8B1E (-18)        // }                                 error.asm:543
0x8B30  0x7F 0x0F 0x05  BBR7 0x0F, 0x8B38 (+5)  // if (BBS7, ZP.ACCH)    InParens    error.asm:545
0x8B33  0xA9 0x29       LDA # 0x29              // LDA #')' Print.Char();            error.asm:547
0x8B35  0x20 0xB0 0x95  JSR 0x95B0
0x8B38  0x2F 0x0F 0x05  BBR2 0x0F, 0x8B40 (+5)  // if (BBS2, ZP.ACCH)    SuffixColon error.asm:549
0x8B3B  0xA9 0x3A       LDA # 0x3A              // LDA #':' Print.Char();            error.asm:551
0x8B3D  0x20 0xB0 0x95  JSR 0x95B0
0x8B40  0x3F 0x0F 0x05  BBR3 0x0F, 0x8B48 (+5)  // if (BBS3, ZP.ACCH)    SuffixQuest error.asm:553
0x8B43  0xA9 0x3F       LDA # 0x3F              // LDA #'?' Print.Char();            error.asm:555
0x8B45  0x20 0xB0 0x95  JSR 0x95B0
0x8B48  0x4F 0x0F 0x05  BBR4 0x0F, 0x8B50 (+5)  // if (BBS4, ZP.ACCH)    SuffixComma error.asm:557
0x8B4B  0xA9 0x2C       LDA # 0x2C              // LDA #',' Print.Char();            error.asm:559
0x8B4D  0x20 0xB0 0x95  JSR 0x95B0
0x8B50  0x5F 0x0F 0x05  BBR5 0x0F, 0x8B58 (+5)  // if (BBS5, ZP.ACCH)    SuffixPeriod
0x8B53  0xA9 0x2E       LDA # 0x2E              // LDA #'.' Print.Char();            error.asm:563
0x8B55  0x20 0xB0 0x95  JSR 0x95B0
0x8B58  0x9F 0x0F 0x01  BBS1 0x0F, 0x8B5C (+1)  // if (BBS1, ZP.ACCH)    SuffixSpace error.asm:565
0x8B5B  0x60            RTS
0x8B5C  0x4C 0xBB 0x95  JMP 0x95BB              // Space();                          error.asm:567

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:572
// ####  Error.commonError()  ####                                              0x0020

0x8B5F  0x85 0x2D       STA 0x2D                // STA ZP.LastError                  error.asm:573
0x8B61  0x18            CLC                     // CLC                               error.asm:574
0x8B62  0x60            RTS                     // }                                 error.asm:575

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:577
// ####  Error.commonErrorTOPtoERRSTR()  ####                                   0x0021

0x8B63  0x85 0x2D       STA 0x2D                // STA ZP.LastError                  error.asm:578
0x8B65  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       error.asm:580
0x8B67  0x85 0x7C       STA 0x7C                // STA ZP.ERRSTRH                    error.asm:581
0x8B69  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       error.asm:582
0x8B6B  0x85 0x7B       STA 0x7B                // STA ZP.ERRSTRL                    error.asm:583
0x8B6D  0x18            CLC                     // CLC                               error.asm:584
0x8B6E  0x60            RTS                     // }                                 error.asm:585

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:587
// ####  Error.commonErrorSTRtoERRSTR()  ####                                   0x0022

0x8B6F  0x85 0x2D       STA 0x2D                // STA ZP.LastError                  error.asm:588
0x8B71  0xA5 0x7A       LDA 0x7A                // LDA ZP.STRH                       error.asm:590
0x8B73  0x85 0x7C       STA 0x7C                // STA ZP.ERRSTRH                    error.asm:591
0x8B75  0xA5 0x79       LDA 0x79                // LDA ZP.STRL                       error.asm:592
0x8B77  0x85 0x7B       STA 0x7B                // STA ZP.ERRSTRL                    error.asm:593
0x8B79  0x18            CLC                     // CLC                               error.asm:594
0x8B7A  0x60            RTS                     // }                                 error.asm:595

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:601
// ####  Error.SyntaxError()  ####                                              0x0023

0x8B7B  0xA9 0x02       LDA # 0x02              // LDA # ErrorID.SyntaxError         error.asm:602
0x8B7D  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:603

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:607
// ####  Error.IdentifierExpected()  ####                                       0x0024

0x8B80  0xA9 0x12       LDA # 0x12              // LDA # ErrorID.IdentifierExpected  error.asm:608
0x8B82  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:609

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:612
// ####  Error.IllegalInFunction()  ####                                        0x0025

0x8B85  0xA9 0x13       LDA # 0x13              // LDA # ErrorID.IllegalInFunction   error.asm:613
0x8B87  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:614

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:617
// ####  Error.IllegalComment()  ####                                           0x0026

0x8B8A  0xA9 0x04       LDA # 0x04              // LDA #ErrorID.IllegalComment       error.asm:618
0x8B8C  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:619

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:623
// ####  Error.UndefinedIdentifierTOP()  ####                                   0x0027

0x8B8F  0xA9 0x10       LDA # 0x10              // LDA #ErrorID.UndefinedIdentifier  error.asm:624
0x8B91  0x4C 0x63 0x8B  JMP 0x8B63              // commonErrorTOPtoERRSTR();         error.asm:625

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:628
// ####  Error.UndefinedFunctionSTR()  ####                                     0x0028

0x8B94  0xA9 0x11       LDA # 0x11              // LDA #ErrorID.UndefinedFunction    error.asm:629
0x8B96  0x4C 0x6F 0x8B  JMP 0x8B6F              // commonErrorSTRtoERRSTR();         error.asm:630

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:634
// ####  Error.IllegalType()  ####                                              0x0029

0x8B99  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               error.asm:635
0x8B9B  0x85 0x7D       STA 0x7D                // STA ZP.ERRTOK                     error.asm:636
0x8B9D  0xA9 0x1A       LDA # 0x1A              // LDA #ErrorID.IllegalType          error.asm:637
0x8B9F  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:638

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:648
// ####  Error.FunctionTooBig()  ####                                           0x002B

0x8BA2  0xA9 0x14       LDA # 0x14              // LDA # ErrorID.FunctionTooBig      error.asm:664
0x8BA4  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:665

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:670
// ####  Error.FileNotFound()  ####                                             0x002C

0x8BA7  0xA9 0x0A       LDA # 0x0A              // LDA # ErrorID.FileNotFound        error.asm:671
0x8BA9  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:672

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:675
// ####  Error.FilenameExpected()  ####                                         0x002D

0x8BAC  0xA9 0x2F       LDA # 0x2F              // LDA # ErrorID.FilenameExpected    error.asm:676
0x8BAE  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:677

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:680
// ####  Error.FilenameTooLong()  ####                                          0x002E

0x8BB1  0xA9 0x30       LDA # 0x30              // LDA # ErrorID.FilenameTooLong     error.asm:681
0x8BB3  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:682

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:685
// ####  Error.IllegalFilename()  ####                                          0x002F

0x8BB6  0xA9 0x31       LDA # 0x31              // LDA #ErrorID.IllegalFilename      error.asm:686
0x8BB8  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:687

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:697
// ####  Error.EEPROMFull()  ####                                               0x0031

0x8BBB  0xA9 0x33       LDA # 0x33              // LDA #ErrorID.EEPROMFull           error.asm:698
0x8BBD  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:699

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:707
// ####  Error.EEPROMError()  ####                                              0x0033

0x8BC0  0xA9 0x35       LDA # 0x35              // LDA #ErrorID.EEPROMError          error.asm:708
0x8BC2  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:709

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:715
// ####  Error.IllegalIdentifier()  ####                                        0x0034

0x8BC5  0xA9 0x19       LDA # 0x19              // LDA #ErrorID.IllegalIdentifier    error.asm:716
0x8BC7  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:717

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:723
// ####  Error.InternalError()  ####                                            0x0035

0x8BCA  0xA9 0x01       LDA # 1                 // LDA #ErrorID.InternalError        error.asm:724
0x8BCC  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:725

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:735
// ####  Error.ExpectedRightBracket()  ####                                     0x0037

0x8BCF  0xA9 0x2E       LDA # 0x2E              // LDA #ErrorID.ExpectedRightBracket error.asm:736
0x8BD1  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:737

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:741
// ####  Error.RangeError()  ####                                               0x0038

0x8BD4  0xA9 0x2C       LDA # 0x2C              // LDA #ErrorID.RangeError           error.asm:742
0x8BD6  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:743

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:746
// ####  Error.IndexOutOfRange()  ####                                          0x0039

0x8BD9  0xA9 0x2D       LDA # 0x2D              // LDA #ErrorID.IndexOutOfRange      error.asm:747
0x8BDB  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:748

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:752
// ####  Error.Break()  ####                                                    0x003A

0x8BDE  0xA9 0x27       LDA # 0x27              // LDA #ErrorID.Break                error.asm:753
0x8BE0  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:754

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:758
// ####  Error.LateDeclaration()  ####                                          0x003B

0x8BE3  0xA9 0x28       LDA # 0x28              // LDA #ErrorID.LateDeclaration      error.asm:759
0x8BE5  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:760

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:789
// ####  Error.OnlyAtConsole()  ####                                            0x003E

0x8BE8  0xA9 0x25       LDA # 0x25              // LDA #ErrorID.OnlyAtConsole        error.asm:790
0x8BEA  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:791

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:795
// ####  Error.TypeMismatch()  ####                                             0x003F

0x8BED  0xA9 0x05       LDA # 0x05              // LDA #ErrorID.TypeMismatch         error.asm:796
0x8BEF  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:797

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:807
// ####  Error.FunctionExistsTOP()  ####                                        0x0041

0x8BF2  0xA9 0x06       LDA # 0x06              // LDA #ErrorID.FunctionExists    name is in ZP.TOP
0x8BF4  0x4C 0x63 0x8B  JMP 0x8B63              // commonErrorTOPtoERRSTR();         error.asm:809

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:813
// ####  Error.ConstantExistsTOP()  ####                                        0x0042

0x8BF7  0xA9 0x07       LDA # 0x07              // LDA #ErrorID.ConstantExists    name is in ZP.TOP
0x8BF9  0x4C 0x63 0x8B  JMP 0x8B63              // commonErrorTOPtoERRSTR();         error.asm:815

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:819
// ####  Error.VariableExistsTOP()  ####                                        0x0043

0x8BFC  0xA9 0x08       LDA # 0x08              // LDA #ErrorID.VariableExists    name is in ZP.TOP
0x8BFE  0x4C 0x63 0x8B  JMP 0x8B63              // commonErrorTOPtoERRSTR();         error.asm:821

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:837
// ####  Error.MissingNext()  ####                                              0x0046

0x8C01  0xA9 0x29       LDA # 0x29              // LDA #ErrorID.MissingNext          error.asm:838
0x8C03  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:839

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:843
// ####  Error.NextMismatch()  ####                                             0x0047

0x8C06  0xA9 0x2A       LDA # 0x2A              // LDA #ErrorID.NextMismatch         error.asm:844
0x8C08  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:845

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:849
// ####  Error.DivisionByZero()  ####                                           0x0048

0x8C0B  0xA9 0x0C       LDA # 0x0C              // LDA #ErrorID.DivisionByZero       error.asm:850
0x8C0D  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:851

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:855
// ####  Error.NumericOverflow()  ####                                          0x0049

0x8C10  0xA9 0x0D       LDA # 0x0D              // LDA #ErrorID.NumericOverflow      error.asm:856
0x8C12  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:857

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:867
// ####  Error.BadIndex()  ####                                                 0x004B

0x8C15  0xA9 0x0F       LDA # 0x0F              // LDA #ErrorID.BadIndex             error.asm:868
0x8C17  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:869

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:881
// ####  Error.ConstantExpressionExpected()  ####                               0x004D

0x8C1A  0xA9 0x16       LDA # 0x16              // LDA #ErrorID.ConstantExpressionExpected
0x8C1C  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:883

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:887
// ####  Error.IllegalCharacter()  ####                                         0x004E

0x8C1F  0xA9 0x1C       LDA # 0x1C              // LDA #ErrorID.IllegalCharacter     error.asm:888
0x8C21  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:889

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:895
// ####  Error.IllegalAssignment()  ####                                        0x004F

0x8C24  0xA9 0x1B       LDA # 0x1B              // LDA #ErrorID.IllegalAssignment    error.asm:896
0x8C26  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:897

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:901
// ####  Error.InvalidOperator()  ####                                          0x0050

0x8C29  0xA9 0x1D       LDA # 0x1D              // LDA #ErrorID.InvalidOperator      error.asm:902
0x8C2B  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:903

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:907
// ####  Error.BufferOverflow()  ####                                           0x0051

0x8C2E  0xA9 0x1E       LDA # 0x1E              // LDA #ErrorID.BufferOverflow       error.asm:908
0x8C30  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:909

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:913
// ####  Error.ExpectedEqual()  ####                                            0x0052

0x8C33  0xA9 0x21       LDA # 0x21              // LDA #ErrorID.ExpectedEqual        error.asm:914
0x8C35  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:915

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:919
// ####  Error.ExpectedRightParen()  ####                                       0x0053

0x8C38  0xA9 0x1F       LDA # 0x1F              // LDA #ErrorID.ExpectedRightParen   error.asm:920
0x8C3A  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:921

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:925
// ####  Error.ExpectedLeftParen()  ####                                        0x0054

0x8C3D  0xA9 0x20       LDA # 0x20              // LDA #ErrorID.ExpectedLeftParen    error.asm:926
0x8C3F  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:927

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:931
// ####  Error.UnexpectedEOL()  ####                                            0x0055

0x8C42  0xA9 0x22       LDA # 0x22              // LDA # ErrorID.UnexpectedEOL       error.asm:932
0x8C44  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:933

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:943
// ####  Error.InvalidBitValue()  ####                                          0x0057

0x8C47  0xA9 0x24       LDA # 0x24              // LDA #ErrorID.InvalidBitValue      error.asm:944
0x8C49  0x4C 0x5F 0x8B  JMP 0x8B5F              // commonError();                    error.asm:945

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:965
// ####  Error.ClearError()  ####                                               0x005A

0x8C4C  0x64 0x2D       STZ 0x2D                // STZ ZP.LastError                  error.asm:966
0x8C4E  0x64 0x7B       STZ 0x7B                // STZ ZP.ERRSTRL                    error.asm:967
0x8C50  0x64 0x7C       STZ 0x7C                // STZ ZP.ERRSTRH                    error.asm:968
0x8C52  0x64 0x7D       STZ 0x7D                // STZ ZP.ERRTOK                     error.asm:969
0x8C54  0x07 0x0C       RMB0 0x0C               // RMB0 ZP.SerialFlags       Clear the BREAK flag
0x8C56  0x4C 0xBB 0x89  JMP 0x89BB              // States.SetSuccess();              error.asm:971

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:979
// ####  Error.CheckError()  ####                                               0x005B

0x8C59  0x48            PHA                     // PHA                               error.asm:980
0x8C5A  0xA5 0x2D       LDA 0x2D                // LDA ZP.LastError                  error.asm:983
0x8C5C  0xD0 0x0B       BNE 0x8C69 (+11)        // if (Z)                            error.asm:984
0x8C5E  0x20 0x8B 0x89  JSR 0x898B              // States.IsFailure();               error.asm:986
0x8C61  0x90 0x03       BCC 0x8C66 (+3)         // if (C)                            error.asm:987
0x8C63  0x18            CLC                     // CLC     Failure                   error.asm:989
0x8C64  0x80 0x0B       BRA 0x8C71 (+11)        // }                                 error.asm:990
0x8C66  0x38            SEC                     // SEC     No error or Failure       error.asm:993
0x8C67  0x80 0x08       BRA 0x8C71 (+8)         // }                                 error.asm:995
0x8C69  0x20 0xAE 0x89  JSR 0x89AE              // States.IsSuccess();    don't alter Exiting or Return
0x8C6C  0x90 0x02       BCC 0x8C70 (+2)         // if (C)                            error.asm:1000
0x8C6E  0x64 0x4E       STZ 0x4E                // States.SetFailure();              error.asm:1002
0x8C70  0x18            CLC                     // CLC     Error occurred            error.asm:1004
0x8C71  0x68            PLA                     // PLA                               error.asm:1006
0x8C72  0x60            RTS                     // }                                 error.asm:1007

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:1010
// ####  Error.CheckErrorAndSetFailure()  ####                                  0x005C

0x8C73  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     error.asm:1011
0x8C76  0x90 0x01       BCC 0x8C79 (+1)         // if (NC)                           error.asm:1012
0x8C78  0x60            RTS
0x8C79  0x64 0x4E       STZ 0x4E                // States.SetFailure();              error.asm:1014
0x8C7B  0x60            RTS                     // }                                 error.asm:1016

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:1023
// ####  Error.CheckErrorAndStatus()  ####                                      0x005D

0x8C7C  0x48            PHA                     // PHA                               error.asm:1024
0x8C7D  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();    C if ok, NC if not ok (error)
0x8C80  0x90 0x03       BCC 0x8C85 (+3)         // if (C)                            error.asm:1026
0x8C82  0x20 0x96 0x89  JSR 0x8996              // States.CanContinue();    C if all good, NC if error or exit
0x8C85  0x68            PLA                     // PLA                               error.asm:1031
0x8C86  0x60            RTS                     // }                                 error.asm:1032

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:1038
// ####  Error.validateERRSTR()  ####                                           0x005E

0x8C87  0xA5 0x7C       LDA 0x7C                // LDA ZP.ERRSTRH                    error.asm:1041
0x8C89  0x05 0x7B       ORA 0x7B                // ORA ZP.ERRSTRL                    error.asm:1042
0x8C8B  0xF0 0x08       BEQ 0x8C95 (+8)         // if (NZ)                           error.asm:1043
0x8C8D  0xA5 0x7C       LDA 0x7C                // LDA ZP.ERRSTRH                    error.asm:1045
0x8C8F  0xC5 0x08       CMP 0x08                // CMP ZP.HEAPSTART                  error.asm:1046
0x8C91  0x90 0x02       BCC 0x8C95 (+2)         // if (C)    ERRSTR >= HEAPSTART     error.asm:1047
0x8C93  0x38            SEC                     // SEC                               error.asm:1049
0x8C94  0x60            RTS                     // break;                            error.asm:1050
0x8C95  0x18            CLC                     // CLC                               error.asm:1053
0x8C96  0x60            RTS                     // break;                            error.asm:1054

// /source/projects/6502sbc/hopperbasic/debugging/error.asm:1064
// ####  Error.CheckAndPrint()  ####                                            0x005F

0x8C97  0x48            PHA                     // PHA     Preserve A register       error.asm:1065
0x8C98  0xDA            PHX                     // PHX     Preserve X register       error.asm:1066
0x8C99  0x5A            PHY                     // PHY     Preserve Y register       error.asm:1067
0x8C9A  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     error.asm:1072
0x8C9D  0xB0 0x4A       BCS 0x8CE9 (+74)        // if (C)                            error.asm:1073
0x8C9F  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       error.asm:1078
0x8CA1  0x48            PHA                     // PHA                               error.asm:1079
0x8CA2  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       error.asm:1080
0x8CA4  0x48            PHA                     // PHA                               error.asm:1081
0x8CA5  0x20 0x87 0x8C  JSR 0x8C87              // validateERRSTR();                 error.asm:1084
0x8CA8  0x90 0x17       BCC 0x8CC1 (+23)        // if (C)                            error.asm:1085
0x8CAA  0xA5 0x2D       LDA 0x2D                // LDA ZP.LastError                  error.asm:1087
0x8CAC  0xA2 0x47       LDX # 0x47              // LDX # (MessageExtras.PrefixSpace|MessageExtras.PrefixQuest|MessageExtras.SuffixSpace|MessageExtras.SuffixColon)
0x8CAE  0x20 0xE9 0x8A  JSR 0x8AE9              // Error.Message();                  error.asm:1089
0x8CB1  0xA5 0x7B       LDA 0x7B                // LDA ZP.ERRSTRL                    error.asm:1090
0x8CB3  0x85 0x79       STA 0x79                // STA ZP.STRL                       error.asm:1091
0x8CB5  0xA5 0x7C       LDA 0x7C                // LDA ZP.ERRSTRH                    error.asm:1092
0x8CB7  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       error.asm:1093
0x8CB9  0x20 0x9D 0x95  JSR 0x959D              // Print.String();    STR            error.asm:1094
0x8CBC  0x20 0xB6 0x95  JSR 0x95B6              // Print.NewLine();                  error.asm:1095
0x8CBF  0x80 0x1C       BRA 0x8CDD (+28)        // }                                 error.asm:1096
0x8CC1  0xA5 0x7D       LDA 0x7D                // LDA ZP.ERRTOK                     error.asm:1099
0x8CC3  0xF0 0x11       BEQ 0x8CD6 (+17)        // if (NZ)                           error.asm:1100
0x8CC5  0xA5 0x2D       LDA 0x2D                // LDA ZP.LastError                  error.asm:1102
0x8CC7  0xA2 0x47       LDX # 0x47              // LDX # (MessageExtras.PrefixSpace|MessageExtras.PrefixQuest|MessageExtras.SuffixSpace|MessageExtras.SuffixColon)
0x8CC9  0x20 0xE9 0x8A  JSR 0x8AE9              // Error.Message();                  error.asm:1104
0x8CCC  0xA5 0x7D       LDA 0x7D                // LDA ZP.ERRTOK                     error.asm:1105
0x8CCE  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            error.asm:1106
0x8CD1  0x20 0xB6 0x95  JSR 0x95B6              // Print.NewLine();                  error.asm:1107
0x8CD4  0x80 0x07       BRA 0x8CDD (+7)         // }                                 error.asm:1108
0x8CD6  0xA5 0x2D       LDA 0x2D                // LDA ZP.LastError                  error.asm:1111
0x8CD8  0xA2 0x41       LDX # 0x41              // LDX # (MessageExtras.PrefixSpace|MessageExtras.PrefixQuest)
0x8CDA  0x20 0xE3 0x8A  JSR 0x8AE3              // Error.MessageNL();                error.asm:1113
0x8CDD  0x68            PLA                     // PLA                               error.asm:1137
0x8CDE  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       error.asm:1138
0x8CE0  0x68            PLA                     // PLA                               error.asm:1139
0x8CE1  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       error.asm:1140
0x8CE3  0x20 0x4C 0x8C  JSR 0x8C4C              // Error.ClearError();     Clear error state before next command
0x8CE6  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();     Reset state for clean start
0x8CE9  0x7A            PLY                     // PLY                               error.asm:1148
0x8CEA  0xFA            PLX                     // PLX                               error.asm:1149
0x8CEB  0x68            PLA                     // PLA                               error.asm:1150
0x8CEC  0x18            CLC                     // CLC     Error was found and printed
0x8CED  0x60            RTS                     // }                                 error.asm:1153

// /source/projects/6502sbc/hopperbasic/debugging/debug.asm:4092
// ####  Debug.Crash()  ####                                                    0x006D

0x8CEE  0x20 0xB5 0x8D  JSR 0x8DB5              // Serial.HexOut();                  debug.asm:4093
0x8CF1  0xBA            TSX                     // TSX PHX                           debug.asm:4095
0x8CF2  0xDA            PHX
0x8CF3  0x48            PHA                     // PHA                               debug.asm:4096
0x8CF4  0x20 0xB6 0x95  JSR 0x95B6              // Print.NewLine();                  debug.asm:4098
0x8CF7  0xA9 0x86       LDA # 0x86              // LDA #(debugCrashHeader % 256)     debug.asm:4100
0x8CF9  0x85 0x79       STA 0x79                // STA ZP.STR                        debug.asm:4101
0x8CFB  0xA9 0x85       LDA # 0x85              // LDA #(debugCrashHeader / 256)     debug.asm:4102
0x8CFD  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       debug.asm:4103
0x8CFF  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   debug.asm:4104
0x8D02  0x68            PLA                     // PLA                               debug.asm:4106
0x8D03  0x20 0xB5 0x8D  JSR 0x8DB5              // Serial.HexOut();                  debug.asm:4107
0x8D06  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    debug.asm:4108
0x8D09  0xA9 0x94       LDA # 0x94              // LDA #(regSP % 256)                debug.asm:4109
0x8D0B  0x85 0x79       STA 0x79                // STA ZP.STR                        debug.asm:4110
0x8D0D  0xA9 0x85       LDA # 0x85              // LDA #(regSP / 256)                debug.asm:4111
0x8D0F  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       debug.asm:4112
0x8D11  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   debug.asm:4113
0x8D14  0x68            PLA                     // PLA                               debug.asm:4114
0x8D15  0x20 0xB5 0x8D  JSR 0x8DB5              // Serial.HexOut();                  debug.asm:4115
0x8D18  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    debug.asm:4117
0x8D1B  0x20 0x97 0x8C  JSR 0x8C97              // CheckAndPrint();                  debug.asm:4118
0x8D1E  0x80 0xFE       BRA 0x8D1E (-2)         // loop {}                           debug.asm:4127

// /source/runtime/6502/devices/acia6850.asm:23
// ####  SerialDevice.initialize()  ####                                        0x0073

0x8D20  0xA9 0x03       LDA # 0x03              // LDA #0b00000011           reset the 6850
0x8D22  0x85 0xEC       STA 0xEC                // STA ControlRegister               acia6850.asm:25
0x8D24  0xA9 0x16       LDA # 0x16              // LDA #0b00010110           8-N-1,  28800 baud (/64 for  1.8432 mHz), no rx interrupt
0x8D26  0x09 0x80       ORA # 0x80              // ORA #0b10000000           has rx interrupt
0x8D28  0x85 0xEC       STA 0xEC                // STA ControlRegister               acia6850.asm:37
0x8D2A  0x60            RTS                     // }                                 acia6850.asm:38

// /source/runtime/6502/devices/acia6850.asm:41
// ####  SerialDevice.writeChar()  ####                                         0x0074

0x8D2B  0x1F 0xEC 0xFD  BBR1 0xEC, 0x8D2B (-3)  // if (BBS1, StatusRegister) { break; }    loop if not ready (bit set means TDRE is empty and ready)
0x8D2E  0x85 0xED       STA 0xED                // STA DataRegister              output character to TDRE
0x8D30  0x60            RTS                     // }                                 acia6850.asm:59

// /source/runtime/6502/devices/acia6850.asm:63
// ####  SerialDevice.isr()  ####                                               0x0075

0x8D31  0x7F 0xEC 0x1B  BBR7 0xEC, 0x8D4F (+27) // if (BBS7, StatusRegister)    interrupt request by 6850
0x8D34  0x0F 0xEC 0x18  BBR0 0xEC, 0x8D4F (+24) // if (BBS0, StatusRegister)    RDRF : receive data register full
0x8D37  0x48            PHA                     // PHA                               acia6850.asm:73
0x8D38  0xA5 0xED       LDA 0xED                // LDA DataRegister           read serial byte
0x8D3A  0xC9 0x03       CMP # 0x03              // CMP #0x03                  is it break? (<ctrl><C>)
0x8D3C  0xD0 0x05       BNE 0x8D43 (+5)         // if (Z)                            acia6850.asm:76
0x8D3E  0x87 0x0C       SMB0 0x0C               // SMB0 ZP.SerialFlags               acia6850.asm:78
0x8D40  0x68            PLA                     // PLA                               acia6850.asm:79
0x8D41  0x80 0x0C       BRA 0x8D4F (+12)        // }                                 acia6850.asm:80
0x8D43  0xDA            PHX                     // PHX                               acia6850.asm:83
0x8D44  0xA6 0x0A       LDX 0x0A                // LDX Serial.InWritePointer       push it into serial input buffer
0x8D46  0x9D 0x00 0x02  STA 0x0200,X            // STA Serial.InBuffer, X            acia6850.asm:85
0x8D49  0xE6 0x0A       INC 0x0A                // INC Serial.InWritePointer         acia6850.asm:86
0x8D4B  0xFA            PLX                     // PLX                               acia6850.asm:87
0x8D4C  0x68            PLA                     // PLA                               acia6850.asm:88
0x8D4D  0x38            SEC                     // SEC    Byte added to buffer       acia6850.asm:89
0x8D4E  0x60            RTS                     // break;                            acia6850.asm:90
0x8D4F  0x18            CLC                     // CLC                No byte added  acia6850.asm:94
0x8D50  0x60            RTS                     // break;                            acia6850.asm:95

// /source/runtime/6502/serial.asm:32
// ####  Serial.Initialize()  ####                                              0x0076

0x8D51  0x78            SEI                     // SEI                       disable interrupts
0x8D52  0x64 0x0A       STZ 0x0A                // STZ Serial.InWritePointer         serial.asm:36
0x8D54  0x64 0x0B       STZ 0x0B                // STZ Serial.InReadPointer          serial.asm:37
0x8D56  0x64 0x0C       STZ 0x0C                // STZ ZP.SerialFlags                serial.asm:39
0x8D58  0x58            CLI                     // CLI                       enable interrupts
0x8D59  0x4C 0x20 0x8D  JMP 0x8D20              // SerialDevice.initialize();    device-specific initialization

// /source/runtime/6502/serial.asm:69
// ####  Serial.ISR()  ####                                                     0x0078

0x8D5C  0x20 0x31 0x8D  JSR 0x8D31              // SerialDevice.isr();               serial.asm:70
0x8D5F  0xB0 0x01       BCS 0x8D62 (+1)         // if (C)                          Byte was added to buffer?
0x8D61  0x60            RTS
0x8D62  0x48            PHA                     // PHA                               serial.asm:74
0x8D63  0xA5 0x0A       LDA 0x0A                // LDA InWritePointer                serial.asm:75
0x8D65  0x38            SEC                     // SEC                               serial.asm:76
0x8D66  0xE5 0x0B       SBC 0x0B                // SBC InReadPointer                 serial.asm:77
0x8D68  0xC9 0xF0       CMP # 0xF0              // CMP #240                 Nearly full? (240/256 bytes used)
0x8D6A  0x90 0x0C       BCC 0x8D78 (+12)        // if (C)                   Carry set if >= 240
0x8D6C  0x9F 0x0C 0x09  BBS1 0x0C, 0x8D78 (+9)  // if (BBR1, SerialFlags)     Bit 1 clear? (not stopped yet)
0x8D6F  0xDA            PHX                     // PHX                               serial.asm:83
0x8D70  0xA9 0x13       LDA # 0x13              // LDA #0x13        XOFF             serial.asm:84
0x8D72  0x20 0x2B 0x8D  JSR 0x8D2B              // SerialDevice.writeChar();     Send XOFF
0x8D75  0xFA            PLX                     // PLX                               serial.asm:86
0x8D76  0x97 0x0C       SMB1 0x0C               // SMB1 SerialFlags        Set bit 1 (XOFF sent)
0x8D78  0x68            PLA                     // PLA                               serial.asm:91
0x8D79  0x60            RTS                     // }                                 serial.asm:93

// /source/runtime/6502/serial.asm:97
// ####  Serial.IsAvailable()  ####                                             0x0079

0x8D7A  0x78            SEI                     // SEI                               serial.asm:98
0x8D7B  0x0F 0x0C 0x04  BBR0 0x0C, 0x8D82 (+4)  // if (BBS0, ZP.SerialFlags)      Bit 0 set? (break detected)
0x8D7E  0xA9 0x01       LDA # 1                 // LDA #1    <ctrl><C> is avaiable   serial.asm:101
0x8D80  0x80 0x04       BRA 0x8D86 (+4)         // }                                 serial.asm:102
0x8D82  0xA5 0x0B       LDA 0x0B                // LDA InReadPointer                 serial.asm:105
0x8D84  0xC5 0x0A       CMP 0x0A                // CMP InWritePointer                serial.asm:106
0x8D86  0x58            CLI                     // CLI                               serial.asm:109
0x8D87  0x60            RTS                     // }                                 serial.asm:110

// /source/runtime/6502/serial.asm:115
// ####  Serial.WaitForChar()  ####                                             0x007A

0x8D88  0x20 0x7A 0x8D  JSR 0x8D7A              // IsAvailable();                    serial.asm:118
0x8D8B  0xF0 0xFB       BEQ 0x8D88 (-5)         // if (NZ) { break; }                serial.asm:119
0x8D8D  0x0F 0x0C 0x05  BBR0 0x0C, 0x8D95 (+5)  // if (BBS0, ZP.SerialFlags)    break?
0x8D90  0x07 0x0C       RMB0 0x0C               // RMB0 ZP.SerialFlags               serial.asm:123
0x8D92  0xA9 0x03       LDA # 0x03              // LDA #0x03    <ctrl><C>            serial.asm:124
0x8D94  0x60            RTS                     // }                                 serial.asm:125
0x8D95  0xDA            PHX                     // PHX                               serial.asm:128
0x8D96  0xA6 0x0B       LDX 0x0B                // LDX Serial.InReadPointer          serial.asm:129
0x8D98  0xBD 0x00 0x02  LDA 0x0200,X            // LDA Serial.InBuffer, X            serial.asm:130
0x8D9B  0xE6 0x0B       INC 0x0B                // INC Serial.InReadPointer          serial.asm:131
0x8D9D  0xFA            PLX                     // PLX                               serial.asm:132
0x8D9E  0x9F 0x0C 0x01  BBS1 0x0C, 0x8DA2 (+1)  // if (BBS1, ZP.SerialFlags)         Bit 1 set? (currently stopped)
0x8DA1  0x60            RTS
0x8DA2  0x48            PHA                     // PHA                               serial.asm:137
0x8DA3  0xA5 0x0A       LDA 0x0A                // LDA Serial.InWritePointer         serial.asm:138
0x8DA5  0x38            SEC                     // SEC                               serial.asm:139
0x8DA6  0xE5 0x0B       SBC 0x0B                // SBC Serial.InReadPointer          serial.asm:140
0x8DA8  0xC9 0x10       CMP # 0x10              // CMP #16                     Mostly empty? (only 16/256 bytes used)
0x8DAA  0xB0 0x07       BCS 0x8DB3 (+7)         // if (NC)                     Carry clear if < 16
0x8DAC  0xA9 0x11       LDA # 0x11              // LDA #XON                          serial.asm:144
0x8DAE  0x20 0x2B 0x8D  JSR 0x8D2B              // SerialDevice.writeChar();     Send XON
0x8DB1  0x17 0x0C       RMB1 0x0C               // RMB1 SerialFlags        Clear bit 1 (resume flow)
0x8DB3  0x68            PLA                     // PLA                               serial.asm:149
0x8DB4  0x60            RTS                     // }                                 serial.asm:152

// /source/runtime/6502/serial.asm:227
// ####  Serial.HexOut()  ####                                                  0x007C

0x8DB5  0x48            PHA                     // PHA                               serial.asm:231
0x8DB6  0x48            PHA                     // PHA                               serial.asm:232
0x8DB7  0x4A            LSR A                   // LSR A LSR A LSR A LSR A           serial.asm:235
0x8DB8  0x4A            LSR A
0x8DB9  0x4A            LSR A
0x8DBA  0x4A            LSR A
0x8DBB  0xC9 0x0A       CMP # 0x0A              // CMP #0x0A                         serial.asm:236
0x8DBD  0x90 0x02       BCC 0x8DC1 (+2)         // if (C)                            serial.asm:237
0x8DBF  0x69 0x06       ADC # 0x06              // ADC #6    add 7 (6+C=1)           serial.asm:239
0x8DC1  0x69 0x30       ADC # 0x30              // ADC #'0'                          serial.asm:241
0x8DC3  0x20 0x2B 0x8D  JSR 0x8D2B              // WriteChar();                      serial.asm:242
0x8DC6  0x68            PLA                     // PLA                               serial.asm:245
0x8DC7  0x29 0x0F       AND # 0x0F              // AND #0x0F                         serial.asm:246
0x8DC9  0xC9 0x0A       CMP # 0x0A              // CMP #0x0A                         serial.asm:247
0x8DCB  0x90 0x02       BCC 0x8DCF (+2)         // if (C)                            serial.asm:248
0x8DCD  0x69 0x06       ADC # 0x06              // ADC #6    add 7 (6+C=1)           serial.asm:250
0x8DCF  0x69 0x30       ADC # 0x30              // ADC #'0'                          serial.asm:252
0x8DD1  0x20 0x2B 0x8D  JSR 0x8D2B              // WriteChar();                      serial.asm:253
0x8DD4  0x68            PLA                     // PLA                               serial.asm:255
0x8DD5  0x60            RTS                     // }                                 serial.asm:256

// /source/runtime/6502/allocate.asm:44
// ####  Allocate.Allocate()  ####                                              0x007E

0x8DD6  0xA5 0x06       LDA 0x06                // LDA ZP.FREELISTL                  allocate.asm:47
0x8DD8  0x85 0x5D       STA 0x5D                // STA maIndexL                      allocate.asm:48
0x8DDA  0xA5 0x07       LDA 0x07                // LDA ZP.FREELISTH                  allocate.asm:49
0x8DDC  0x85 0x5E       STA 0x5E                // STA maIndexH                      allocate.asm:50
0x8DDE  0x20 0x61 0x93  JSR 0x9361              // Utilities.IncACC();               allocate.asm:53
0x8DE1  0x20 0x61 0x93  JSR 0x9361              // Utilities.IncACC();               allocate.asm:54
0x8DE4  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL       Load the low byte
0x8DE6  0x18            CLC                     // CLC               Clear carry     allocate.asm:58
0x8DE7  0x69 0x07       ADC # 0x07              // ADC # 0x07        Add 7           allocate.asm:59
0x8DE9  0x85 0x0E       STA 0x0E                // STA ZP.ACCL       Store back the low byte
0x8DEB  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH       Load the high byte
0x8DED  0x69 0x00       ADC # 0                 // ADC # 0           Add the carry to the high byte
0x8DEF  0x85 0x0F       STA 0x0F                // STA ZP.ACCH       Store back the high byte
0x8DF1  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL       Load the adjusted low byte
0x8DF3  0x29 0xF8       AND # 0xF8              // AND # 0xF8        Mask out the lower 3 bits
0x8DF5  0x85 0x0E       STA 0x0E                // STA ZP.ACCL       Store the masked low byte back
0x8DF7  0x64 0x4F       STZ 0x4F                // STZ maBESTL                       allocate.asm:72
0x8DF9  0x64 0x50       STZ 0x50                // STZ maBESTH                       allocate.asm:73
0x8DFB  0x64 0x51       STZ 0x51                // STZ maBESTSIZEL                   allocate.asm:74
0x8DFD  0x64 0x52       STZ 0x52                // STZ maBESTSIZEH                   allocate.asm:75
0x8DFF  0x64 0x53       STZ 0x53                // STZ maBESTNEXTL                   allocate.asm:76
0x8E01  0x64 0x54       STZ 0x54                // STZ maBESTNEXTH                   allocate.asm:77
0x8E03  0x64 0x55       STZ 0x55                // STZ maBESTPREVL                   allocate.asm:78
0x8E05  0x64 0x56       STZ 0x56                // STZ maBESTPREVH                   allocate.asm:79
0x8E07  0xA5 0x0F       LDA 0x0F                // LDA ACCH                          allocate.asm:91
0x8E09  0xD0 0x08       BNE 0x8E13 (+8)         // if (Z)    < 256                   allocate.asm:92
0x8E0B  0xA9 0x06       LDA # 0x06              // LDA #6                            allocate.asm:94
0x8E0D  0xC5 0x0E       CMP 0x0E                // CMP ZP.ACCL                       allocate.asm:95
0x8E0F  0x90 0x02       BCC 0x8E13 (+2)         // if (C)    size < 6?               allocate.asm:96
0x8E11  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       allocate.asm:99
0x8E13  0xA5 0x5D       LDA 0x5D                // LDA maIndexL                      allocate.asm:106
0x8E15  0x05 0x5E       ORA 0x5E                // ORA maIndexH                      allocate.asm:107
0x8E17  0xF0 0x65       BEQ 0x8E7E (+101)       // if (Z)                            allocate.asm:108
0x8E19  0xA0 0x01       LDY # 1                 // LDY #1                            allocate.asm:116
0x8E1B  0xB1 0x5D       LDA [0x5D],Y            // LDA [maIndex], Y                  allocate.asm:117
0x8E1D  0xC5 0x0F       CMP 0x0F                // CMP ZP.ACCH                       allocate.asm:118
0x8E1F  0xD0 0x05       BNE 0x8E26 (+5)         // if (Z)                            allocate.asm:119
0x8E21  0x88            DEY                     // DEY                               allocate.asm:121
0x8E22  0xB1 0x5D       LDA [0x5D],Y            // LDA [maIndex], Y                  allocate.asm:122
0x8E24  0xC5 0x0E       CMP 0x0E                // CMP ZP.ACCL                       allocate.asm:123
0x8E26  0x90 0x3B       BCC 0x8E63 (+59)        // if (NC) { break; }    [maIndex] < ACC
0x8E28  0xA5 0x51       LDA 0x51                // LDA maBESTSIZEL                   allocate.asm:131
0x8E2A  0x05 0x52       ORA 0x52                // ORA maBESTSIZEH                   allocate.asm:132
0x8E2C  0xF0 0x0F       BEQ 0x8E3D (+15)        // if (NZ)                           allocate.asm:133
0x8E2E  0xA0 0x01       LDY # 1                 // LDY #1                            allocate.asm:136
0x8E30  0xB1 0x5D       LDA [0x5D],Y            // LDA [maIndex], Y                  allocate.asm:137
0x8E32  0xC5 0x52       CMP 0x52                // CMP maBESTSIZEH                   allocate.asm:138
0x8E34  0xD0 0x05       BNE 0x8E3B (+5)         // if (Z)                            allocate.asm:139
0x8E36  0x88            DEY                     // DEY                               allocate.asm:141
0x8E37  0xB1 0x5D       LDA [0x5D],Y            // LDA [maIndex], Y                  allocate.asm:142
0x8E39  0xC5 0x51       CMP 0x51                // CMP maBESTSIZEL                   allocate.asm:143
0x8E3B  0xB0 0x26       BCS 0x8E63 (+38)        // if (C)                            allocate.asm:145
0x8E3D  0xA5 0x5D       LDA 0x5D                // LDA maIndexL                      allocate.asm:154
0x8E3F  0x85 0x4F       STA 0x4F                // STA maBESTL                       allocate.asm:155
0x8E41  0xA5 0x5E       LDA 0x5E                // LDA maIndexH                      allocate.asm:156
0x8E43  0x85 0x50       STA 0x50                // STA maBESTH                       allocate.asm:157
0x8E45  0xB2 0x4F       LDA [0x4F]              // LDA [maBEST]                      allocate.asm:161
0x8E47  0x85 0x51       STA 0x51                // STA maBESTSIZEL                   allocate.asm:162
0x8E49  0xA0 0x01       LDY # 1                 // LDY # 1                           allocate.asm:163
0x8E4B  0xB1 0x4F       LDA [0x4F],Y            // LDA [maBEST], Y                   allocate.asm:170
0x8E4D  0x85 0x52       STA 0x52                // STA maBESTSIZEH                   allocate.asm:171
0x8E4F  0xC8            INY                     // INY                               allocate.asm:173
0x8E50  0xB1 0x4F       LDA [0x4F],Y            // LDA [maBEST], Y                   allocate.asm:174
0x8E52  0x85 0x53       STA 0x53                // STA maBESTNEXTL                   allocate.asm:175
0x8E54  0xC8            INY                     // INY                               allocate.asm:176
0x8E55  0xB1 0x4F       LDA [0x4F],Y            // LDA [maBEST], Y                   allocate.asm:177
0x8E57  0x85 0x54       STA 0x54                // STA maBESTNEXTH                   allocate.asm:178
0x8E59  0xC8            INY                     // INY                               allocate.asm:180
0x8E5A  0xB1 0x4F       LDA [0x4F],Y            // LDA [maBEST], Y                   allocate.asm:181
0x8E5C  0x85 0x55       STA 0x55                // STA maBESTPREVL                   allocate.asm:182
0x8E5E  0xC8            INY                     // INY                               allocate.asm:183
0x8E5F  0xB1 0x4F       LDA [0x4F],Y            // LDA [maBEST], Y                   allocate.asm:184
0x8E61  0x85 0x56       STA 0x56                // STA maBESTPREVH                   allocate.asm:185
0x8E63  0xA5 0x51       LDA 0x51                // LDA maBESTSIZEL                   allocate.asm:189
0x8E65  0xC5 0x0E       CMP 0x0E                // CMP ZP.ACCL                       allocate.asm:190
0x8E67  0xD0 0x06       BNE 0x8E6F (+6)         // if (Z)                            allocate.asm:191
0x8E69  0xA5 0x52       LDA 0x52                // LDA maBESTSIZEH                   allocate.asm:193
0x8E6B  0xC5 0x0F       CMP 0x0F                // CMP ZP.ACCH                       allocate.asm:194
0x8E6D  0xF0 0x0F       BEQ 0x8E7E (+15)        // if (Z)                            allocate.asm:195
0x8E6F  0xA0 0x02       LDY # 0x02              // LDY #2                            allocate.asm:204
0x8E71  0xB1 0x5D       LDA [0x5D],Y            // LDA [maIndex], Y                  allocate.asm:205
0x8E73  0x48            PHA                     // PHA                               allocate.asm:206
0x8E74  0xC8            INY                     // INY                               allocate.asm:207
0x8E75  0xB1 0x5D       LDA [0x5D],Y            // LDA [maIndex], Y                  allocate.asm:208
0x8E77  0x85 0x5E       STA 0x5E                // STA maIndexH                      allocate.asm:209
0x8E79  0x68            PLA                     // PLA                               allocate.asm:210
0x8E7A  0x85 0x5D       STA 0x5D                // STA maIndexL                      allocate.asm:211
0x8E7C  0x80 0x95       BRA 0x8E13 (-107)       // }    loop : available block search
0x8E7E  0xA5 0x4F       LDA 0x4F                // LDA maBESTL                       allocate.asm:215
0x8E80  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       allocate.asm:216
0x8E82  0xA5 0x50       LDA 0x50                // LDA maBESTH                       allocate.asm:217
0x8E84  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       allocate.asm:218
0x8E86  0x20 0x48 0x93  JSR 0x9348              // IncIDX();                         allocate.asm:220
0x8E89  0x20 0x48 0x93  JSR 0x9348              // IncIDX();                         allocate.asm:221
0x8E8C  0x18            CLC                     // CLC                               allocate.asm:224
0x8E8D  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       allocate.asm:225
0x8E8F  0x69 0x06       ADC # 0x06              // ADC #6                            allocate.asm:226
0x8E91  0x85 0x57       STA 0x57                // STA maSCRATCHL                    allocate.asm:227
0x8E93  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       allocate.asm:228
0x8E95  0x69 0x00       ADC # 0                 // ADC #0                            allocate.asm:229
0x8E97  0x85 0x58       STA 0x58                // STA maSCRATCHH                    allocate.asm:230
0x8E99  0xA5 0x52       LDA 0x52                // LDA maBESTSIZEH                   allocate.asm:233
0x8E9B  0xC5 0x58       CMP 0x58                // CMP maSCRATCHH                    allocate.asm:234
0x8E9D  0xD0 0x04       BNE 0x8EA3 (+4)         // if (Z)                            allocate.asm:235
0x8E9F  0xA5 0x52       LDA 0x52                // LDA maBESTSIZEH                   allocate.asm:237
0x8EA1  0xC5 0x57       CMP 0x57                // CMP maSCRATCHL                    allocate.asm:238
0x8EA3  0xB0 0x03       BCS 0x8EA8 (+3)         // if (C)     maBESTSIZE >= maSCRATCH
0x8EA5  0x4C 0x40 0x8F  JMP 0x8F40
0x8EA8  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       allocate.asm:249
0x8EAA  0x92 0x4F       STA [0x4F]              // STA [maBEST]                      allocate.asm:251
0x8EAC  0xA0 0x01       LDY # 1                 // LDY # 1                           allocate.asm:252
0x8EAE  0xA5 0x0F       LDA 0x0F                // LDA ACCH                          allocate.asm:258
0x8EB0  0x91 0x4F       STA [0x4F],Y            // STA [maBEST], Y                   allocate.asm:259
0x8EB2  0x18            CLC                     // CLC                               allocate.asm:262
0x8EB3  0xA5 0x4F       LDA 0x4F                // LDA maBESTL                       allocate.asm:263
0x8EB5  0x65 0x0E       ADC 0x0E                // ADC ACCL                          allocate.asm:264
0x8EB7  0x85 0x59       STA 0x59                // STA maNEWHOLEL                    allocate.asm:265
0x8EB9  0xA5 0x50       LDA 0x50                // LDA maBESTH                       allocate.asm:266
0x8EBB  0x65 0x0F       ADC 0x0F                // ADC ACCH                          allocate.asm:267
0x8EBD  0x85 0x5A       STA 0x5A                // STA maNEWHOLEH                    allocate.asm:268
0x8EBF  0x38            SEC                     // SEC                               allocate.asm:270
0x8EC0  0xA5 0x51       LDA 0x51                // LDA maBESTSIZEL                   allocate.asm:271
0x8EC2  0xE5 0x0E       SBC 0x0E                // SBC ZP.ACCL                       allocate.asm:272
0x8EC4  0x85 0x5B       STA 0x5B                // STA maNEWHOLESIZEL                allocate.asm:273
0x8EC6  0xA5 0x52       LDA 0x52                // LDA maBESTSIZEH                   allocate.asm:274
0x8EC8  0xE5 0x0F       SBC 0x0F                // SBC ZP.ACCH                       allocate.asm:275
0x8ECA  0x85 0x5C       STA 0x5C                // STA maNEWHOLESIZEH                allocate.asm:276
0x8ECC  0xA5 0x5B       LDA 0x5B                // LDA maNEWHOLESIZEL                allocate.asm:278
0x8ECE  0x92 0x59       STA [0x59]              // STA [maNEWHOLE]                   allocate.asm:280
0x8ED0  0xA0 0x01       LDY # 1                 // LDY # 1                           allocate.asm:281
0x8ED2  0xA5 0x5C       LDA 0x5C                // LDA maNEWHOLESIZEH                allocate.asm:287
0x8ED4  0x91 0x59       STA [0x59],Y            // STA [maNEWHOLE], Y                allocate.asm:288
0x8ED6  0xA5 0x55       LDA 0x55                // LDA maBESTPREVL                   allocate.asm:290
0x8ED8  0x05 0x56       ORA 0x56                // ORA maBESTPREVH                   allocate.asm:291
0x8EDA  0xD0 0x31       BNE 0x8F0D (+49)        // if (Z)                            allocate.asm:292
0x8EDC  0xA5 0x59       LDA 0x59                // LDA maNEWHOLEL                    allocate.asm:295
0x8EDE  0x85 0x06       STA 0x06                // STA FREELISTL                     allocate.asm:296
0x8EE0  0xA5 0x5A       LDA 0x5A                // LDA maNEWHOLEH                    allocate.asm:297
0x8EE2  0x85 0x07       STA 0x07                // STA FREELISTH                     allocate.asm:298
0x8EE4  0xC8            INY                     // INY                               allocate.asm:299
0x8EE5  0xA5 0x53       LDA 0x53                // LDA maBESTNEXTL                   allocate.asm:300
0x8EE7  0x91 0x59       STA [0x59],Y            // STA [maNEWHOLE], Y                allocate.asm:301
0x8EE9  0xC8            INY                     // INY                               allocate.asm:302
0x8EEA  0xA5 0x54       LDA 0x54                // LDA maBESTNEXTH                   allocate.asm:303
0x8EEC  0x91 0x59       STA [0x59],Y            // STA [maNEWHOLE], Y                allocate.asm:304
0x8EEE  0xC8            INY                     // INY                               allocate.asm:305
0x8EEF  0xA9 0x00       LDA # 0                 // LDA #0                            allocate.asm:306
0x8EF1  0x91 0x59       STA [0x59],Y            // STA [maNEWHOLE], Y                allocate.asm:307
0x8EF3  0xC8            INY                     // INY                               allocate.asm:308
0x8EF4  0x91 0x59       STA [0x59],Y            // STA [maNEWHOLE], Y                allocate.asm:309
0x8EF6  0xA5 0x53       LDA 0x53                // LDA maBESTNEXTL                   allocate.asm:311
0x8EF8  0x05 0x54       ORA 0x54                // ORA maBESTNEXTH                   allocate.asm:312
0x8EFA  0xD0 0x03       BNE 0x8EFF (+3)         // if (Z)                            allocate.asm:313
0x8EFC  0x4C 0x94 0x8F  JMP 0x8F94              // break;    memoryAllocateExit      allocate.asm:315
0x8EFF  0xA0 0x04       LDY # 0x04              // LDY #4                            allocate.asm:318
0x8F01  0xA5 0x59       LDA 0x59                // LDA maNEWHOLEL                    allocate.asm:319
0x8F03  0x91 0x53       STA [0x53],Y            // STA [maBESTNEXT], Y               allocate.asm:320
0x8F05  0xC8            INY                     // INY                               allocate.asm:321
0x8F06  0xA5 0x5A       LDA 0x5A                // LDA maNEWHOLEH                    allocate.asm:322
0x8F08  0x91 0x53       STA [0x53],Y            // STA [maBESTNEXT], Y               allocate.asm:323
0x8F0A  0x4C 0x94 0x8F  JMP 0x8F94              // break;    memoryAllocateExit      allocate.asm:324
0x8F0D  0xA0 0x02       LDY # 0x02              // LDY #2                            allocate.asm:327
0x8F0F  0xA5 0x53       LDA 0x53                // LDA maBESTNEXTL                   allocate.asm:328
0x8F11  0x91 0x59       STA [0x59],Y            // STA [maNEWHOLE], Y                allocate.asm:329
0x8F13  0xC8            INY                     // INY                               allocate.asm:330
0x8F14  0xA5 0x54       LDA 0x54                // LDA maBESTNEXTH                   allocate.asm:331
0x8F16  0x91 0x59       STA [0x59],Y            // STA [maNEWHOLE], Y                allocate.asm:332
0x8F18  0xC8            INY                     // INY                               allocate.asm:333
0x8F19  0xA5 0x55       LDA 0x55                // LDA maBESTPREVL                   allocate.asm:334
0x8F1B  0x91 0x59       STA [0x59],Y            // STA [maNEWHOLE], Y                allocate.asm:335
0x8F1D  0xC8            INY                     // INY                               allocate.asm:336
0x8F1E  0xA5 0x56       LDA 0x56                // LDA maBESTPREVH                   allocate.asm:337
0x8F20  0x91 0x59       STA [0x59],Y            // STA [maNEWHOLE], Y                allocate.asm:338
0x8F22  0xA0 0x02       LDY # 0x02              // LDY #2                            allocate.asm:339
0x8F24  0xA5 0x59       LDA 0x59                // LDA maNEWHOLEL                    allocate.asm:340
0x8F26  0x91 0x55       STA [0x55],Y            // STA [maBESTPREV], Y               allocate.asm:341
0x8F28  0xC8            INY                     // INY                               allocate.asm:342
0x8F29  0xA5 0x5A       LDA 0x5A                // LDA maNEWHOLEH                    allocate.asm:343
0x8F2B  0x91 0x55       STA [0x55],Y            // STA [maBESTPREV], Y               allocate.asm:344
0x8F2D  0xA5 0x53       LDA 0x53                // LDA maBESTNEXTL                   allocate.asm:346
0x8F2F  0x05 0x54       ORA 0x54                // ORA maBESTNEXTH                   allocate.asm:347
0x8F31  0xF0 0x61       BEQ 0x8F94 (+97)        // if (Z)                            allocate.asm:348
0x8F33  0xA0 0x04       LDY # 0x04              // LDY #4                            allocate.asm:353
0x8F35  0xA5 0x59       LDA 0x59                // LDA maNEWHOLEL                    allocate.asm:354
0x8F37  0x91 0x53       STA [0x53],Y            // STA [maBESTNEXT], Y               allocate.asm:355
0x8F39  0xC8            INY                     // INY                               allocate.asm:356
0x8F3A  0xA5 0x5A       LDA 0x5A                // LDA maNEWHOLEH                    allocate.asm:357
0x8F3C  0x91 0x53       STA [0x53],Y            // STA [maBESTNEXT], Y               allocate.asm:358
0x8F3E  0x80 0x54       BRA 0x8F94 (+84)        // break;    memoryAllocateExit      allocate.asm:359
0x8F40  0xA5 0x52       LDA 0x52                // LDA maBESTSIZEH                   allocate.asm:364
0x8F42  0xC5 0x0F       CMP 0x0F                // CMP ZP.ACCH                       allocate.asm:365
0x8F44  0xD0 0x04       BNE 0x8F4A (+4)         // if (Z)                            allocate.asm:366
0x8F46  0xA5 0x51       LDA 0x51                // LDA maBESTSIZEL                   allocate.asm:368
0x8F48  0xC5 0x0E       CMP 0x0E                // CMP ZP.ACCL                       allocate.asm:369
0x8F4A  0xB0 0x05       BCS 0x8F51 (+5)         // if (NC)                           allocate.asm:372
0x8F4C  0xA9 0x03       LDA # 0x03              // LDA #0x03 Debug.Crash();    Memory allocation failure
0x8F4E  0x20 0xEE 0x8C  JSR 0x8CEE
0x8F51  0xA5 0x51       LDA 0x51                // LDA maBESTSIZEL                   allocate.asm:398
0x8F53  0x92 0x4F       STA [0x4F]              // STA [maBEST]                      allocate.asm:400
0x8F55  0xA0 0x01       LDY # 1                 // LDY # 1                           allocate.asm:401
0x8F57  0xA5 0x52       LDA 0x52                // LDA maBESTSIZEH                   allocate.asm:407
0x8F59  0x91 0x4F       STA [0x4F],Y            // STA [maBEST], Y                   allocate.asm:408
0x8F5B  0xA5 0x55       LDA 0x55                // LDA maBESTPREVL                   allocate.asm:410
0x8F5D  0x05 0x56       ORA 0x56                // ORA maBESTPREVH                   allocate.asm:411
0x8F5F  0xD0 0x19       BNE 0x8F7A (+25)        // if (Z)                            allocate.asm:412
0x8F61  0xA5 0x53       LDA 0x53                // LDA maBESTNEXTL                   allocate.asm:417
0x8F63  0x85 0x06       STA 0x06                // STA FREELISTL                     allocate.asm:418
0x8F65  0xA5 0x54       LDA 0x54                // LDA maBESTNEXTH                   allocate.asm:419
0x8F67  0x85 0x07       STA 0x07                // STA FREELISTH                     allocate.asm:420
0x8F69  0xA5 0x53       LDA 0x53                // LDA maBESTNEXTL                   allocate.asm:422
0x8F6B  0x05 0x54       ORA 0x54                // ORA maBESTNEXTH                   allocate.asm:423
0x8F6D  0xF0 0x25       BEQ 0x8F94 (+37)        // if (Z)                            allocate.asm:424
0x8F6F  0xA9 0x00       LDA # 0                 // LDA # 0                           allocate.asm:430
0x8F71  0xA0 0x04       LDY # 0x04              // LDY # 4                           allocate.asm:431
0x8F73  0x91 0x06       STA [0x06],Y            // STA [ZP.FREELIST], Y              allocate.asm:432
0x8F75  0xC8            INY                     // INY                               allocate.asm:433
0x8F76  0x91 0x06       STA [0x06],Y            // STA [ZP.FREELIST], Y              allocate.asm:434
0x8F78  0x80 0x1A       BRA 0x8F94 (+26)        // break;    memoryAllocateExit      allocate.asm:435
0x8F7A  0xA0 0x02       LDY # 0x02              // LDY # 2                           allocate.asm:441
0x8F7C  0xA5 0x53       LDA 0x53                // LDA maBESTNEXTL                   allocate.asm:442
0x8F7E  0x91 0x55       STA [0x55],Y            // STA [maBESTPREV], Y               allocate.asm:443
0x8F80  0xC8            INY                     // INY                               allocate.asm:444
0x8F81  0xA5 0x54       LDA 0x54                // LDA maBESTNEXTH                   allocate.asm:445
0x8F83  0x91 0x55       STA [0x55],Y            // STA [maBESTPREV], Y               allocate.asm:446
0x8F85  0x05 0x53       ORA 0x53                // ORA maBESTNEXTL                   allocate.asm:448
0x8F87  0xF0 0x0B       BEQ 0x8F94 (+11)        // if (Z)                            allocate.asm:449
0x8F89  0xA0 0x04       LDY # 0x04              // LDY #4                            allocate.asm:455
0x8F8B  0xA5 0x55       LDA 0x55                // LDA maBESTPREVL                   allocate.asm:456
0x8F8D  0x91 0x53       STA [0x53],Y            // STA [maBESTNEXT], Y               allocate.asm:457
0x8F8F  0xC8            INY                     // INY                               allocate.asm:458
0x8F90  0xA5 0x56       LDA 0x56                // LDA maBESTPREVH                   allocate.asm:459
0x8F92  0x91 0x53       STA [0x53],Y            // STA [maBESTNEXT], Y               allocate.asm:460
0x8F94  0x20 0x71 0x93  JSR 0x9371              // DecACCx2();                       allocate.asm:470
0x8F97  0x18            CLC                     // CLC                               allocate.asm:472
0x8F98  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       allocate.asm:473
0x8F9A  0x65 0x0E       ADC 0x0E                // ADC ZP.ACCL                       allocate.asm:474
0x8F9C  0x85 0x57       STA 0x57                // STA maSCRATCHL                    allocate.asm:475
0x8F9E  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       allocate.asm:476
0x8FA0  0x65 0x0F       ADC 0x0F                // ADC ZP.ACCH                       allocate.asm:477
0x8FA2  0x85 0x58       STA 0x58                // STA maSCRATCHH                    allocate.asm:478
0x8FA4  0xA5 0x58       LDA 0x58                // LDA maSCRATCHH                    allocate.asm:482
0x8FA6  0xC5 0x1C       CMP 0x1C                // CMP ZP.IDXH                       allocate.asm:483
0x8FA8  0xD0 0x06       BNE 0x8FB0 (+6)         // if (Z)                            allocate.asm:484
0x8FAA  0xA5 0x57       LDA 0x57                // LDA maSCRATCHL                    allocate.asm:486
0x8FAC  0xC5 0x1B       CMP 0x1B                // CMP ZP.IDXL                       allocate.asm:487
0x8FAE  0xF0 0x0E       BEQ 0x8FBE (+14)        // if (Z)                            allocate.asm:488
0x8FB0  0xA5 0x57       LDA 0x57                // LDA maSCRATCHL                    allocate.asm:495
0x8FB2  0xD0 0x02       BNE 0x8FB6 (+2)         // if (Z)                            allocate.asm:496
0x8FB4  0xC6 0x58       DEC 0x58                // DEC maSCRATCHH                    allocate.asm:498
0x8FB6  0xC6 0x57       DEC 0x57                // DEC maSCRATCHL                    allocate.asm:500
0x8FB8  0xA9 0x00       LDA # 0                 // LDA # 0                           allocate.asm:503
0x8FBA  0x92 0x57       STA [0x57]              // STA [maSCRATCH]                   allocate.asm:505
0x8FBC  0x80 0xE6       BRA 0x8FA4 (-26)        // }                                 allocate.asm:510
0x8FBE  0x60            RTS                     // }                                 allocate.asm:511

// /source/runtime/6502/free.asm:74
// ####  Free.Free()  ####                                                      0x007F

0x8FBF  0x38            SEC                     // SEC                               free.asm:91
0x8FC0  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       free.asm:92
0x8FC2  0xE9 0x02       SBC # 0x02              // SBC # 2                           free.asm:93
0x8FC4  0x85 0x5F       STA 0x5F                // STA mfCURRENTL                    free.asm:94
0x8FC6  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       free.asm:95
0x8FC8  0xE9 0x00       SBC # 0                 // SBC # 0                           free.asm:96
0x8FCA  0x85 0x60       STA 0x60                // STA mfCURRENTH                    free.asm:97
0x8FCC  0xB2 0x5F       LDA [0x5F]              // LDA [mfCURRENT]                   free.asm:99
0x8FCE  0xA0 0x01       LDY # 1                 // LDY # 1                           free.asm:100
0x8FD0  0x85 0x5D       STA 0x5D                // STA mfSIZEL                       free.asm:106
0x8FD2  0xB1 0x5F       LDA [0x5F],Y            // LDA [mfCURRENT], Y                free.asm:107
0x8FD4  0x85 0x5E       STA 0x5E                // STA mfSIZEH                       free.asm:108
0x8FD6  0xA5 0x06       LDA 0x06                // LDA FREELISTL                     free.asm:111
0x8FD8  0x85 0x5F       STA 0x5F                // STA mfCURRENTL                    free.asm:112
0x8FDA  0xA5 0x07       LDA 0x07                // LDA FREELISTH                     free.asm:113
0x8FDC  0x85 0x60       STA 0x60                // STA mfCURRENTH                    free.asm:114
0x8FDE  0x64 0x4F       STZ 0x4F                // STZ mfPREVIOUSL                   free.asm:117
0x8FE0  0x64 0x50       STZ 0x50                // STZ mfPREVIOUSH                   free.asm:118
0x8FE2  0xA5 0x5F       LDA 0x5F                // LDA mfCURRENTL                    free.asm:127
0x8FE4  0x05 0x60       ORA 0x60                // ORA mfCURRENTH                    free.asm:128
0x8FE6  0xF0 0x29       BEQ 0x9011 (+41)        // if (Z)                            free.asm:129
0x8FE8  0xA5 0x60       LDA 0x60                // LDA mfCURRENTH                    free.asm:136
0x8FEA  0xC5 0x1C       CMP 0x1C                // CMP ZP.IDXH                       free.asm:137
0x8FEC  0xD0 0x04       BNE 0x8FF2 (+4)         // if (Z)                            free.asm:138
0x8FEE  0xA5 0x5F       LDA 0x5F                // LDA mfCURRENTL                    free.asm:140
0x8FF0  0xC5 0x1B       CMP 0x1B                // CMP ZP.IDXL                       free.asm:141
0x8FF2  0xF0 0x02       BEQ 0x8FF6 (+2)         // if (NZ)    mfCURRENT != ZP.IDX (not >)
0x8FF4  0xB0 0x1B       BCS 0x9011 (+27)        // if (C)                            free.asm:147
0x8FF6  0xA5 0x5F       LDA 0x5F                // LDA mfCURRENTL                    free.asm:153
0x8FF8  0x85 0x4F       STA 0x4F                // STA mfPREVIOUSL                   free.asm:154
0x8FFA  0xA5 0x60       LDA 0x60                // LDA mfCURRENTH                    free.asm:155
0x8FFC  0x85 0x50       STA 0x50                // STA mfPREVIOUSH                   free.asm:156
0x8FFE  0xA0 0x02       LDY # 0x02              // LDY # 2                           free.asm:159
0x9000  0xB1 0x5F       LDA [0x5F],Y            // LDA [mfCURRENT], Y                free.asm:160
0x9002  0x85 0x53       STA 0x53                // STA mfCURRENTNEXTL                free.asm:161
0x9004  0xC8            INY                     // INY                               free.asm:162
0x9005  0xB1 0x5F       LDA [0x5F],Y            // LDA [mfCURRENT], Y                free.asm:163
0x9007  0x85 0x54       STA 0x54                // STA mfCURRENTNEXTH                free.asm:164
0x9009  0x85 0x60       STA 0x60                // STA mfCURRENTH                    free.asm:166
0x900B  0xA5 0x53       LDA 0x53                // LDA mfCURRENTNEXTL                free.asm:167
0x900D  0x85 0x5F       STA 0x5F                // STA mfCURRENTL                    free.asm:168
0x900F  0x80 0xD1       BRA 0x8FE2 (-47)        // }    loop findBeyondAddress       free.asm:170
0x9011  0xA5 0x4F       LDA 0x4F                // LDA mfPREVIOUSL                   free.asm:173
0x9013  0x85 0x55       STA 0x55                // STA mfCURRENTPREVL                free.asm:174
0x9015  0xA5 0x50       LDA 0x50                // LDA mfPREVIOUSH                   free.asm:175
0x9017  0x85 0x56       STA 0x56                // STA mfCURRENTPREVH                free.asm:176
0x9019  0x64 0x51       STZ 0x51                // STZ mfCURRENTSIZEL                free.asm:178
0x901B  0x64 0x52       STZ 0x52                // STZ mfCURRENTSIZEH                free.asm:179
0x901D  0x64 0x53       STZ 0x53                // STZ mfCURRENTNEXTL                free.asm:180
0x901F  0x64 0x54       STZ 0x54                // STZ mfCURRENTNEXTH                free.asm:181
0x9021  0xA5 0x5F       LDA 0x5F                // LDA mfCURRENTL                    free.asm:191
0x9023  0x05 0x60       ORA 0x60                // ORA mfCURRENTH                    free.asm:192
0x9025  0xF0 0x14       BEQ 0x903B (+20)        // if (Z)                            free.asm:193
0x9027  0xB2 0x5F       LDA [0x5F]              // LDA [mfCURRENT]                   free.asm:200
0x9029  0xA0 0x01       LDY # 1                 // LDY # 1                           free.asm:201
0x902B  0x85 0x51       STA 0x51                // STA mfCURRENTSIZEL                free.asm:207
0x902D  0xB1 0x5F       LDA [0x5F],Y            // LDA [mfCURRENT], Y                free.asm:209
0x902F  0x85 0x52       STA 0x52                // STA mfCURRENTSIZEH                free.asm:210
0x9031  0xC8            INY                     // INY                               free.asm:212
0x9032  0xB1 0x5F       LDA [0x5F],Y            // LDA [mfCURRENT], Y                free.asm:213
0x9034  0x85 0x53       STA 0x53                // STA mfCURRENTNEXTL                free.asm:214
0x9036  0xC8            INY                     // INY                               free.asm:215
0x9037  0xB1 0x5F       LDA [0x5F],Y            // LDA [mfCURRENT], Y                free.asm:216
0x9039  0x85 0x54       STA 0x54                // STA mfCURRENTNEXTH                free.asm:217
0x903B  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       free.asm:223
0x903D  0x85 0x57       STA 0x57                // STA mfFREESLOTL                   free.asm:224
0x903F  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       free.asm:225
0x9041  0x85 0x58       STA 0x58                // STA mfFREESLOTH                   free.asm:226
0x9043  0x38            SEC                     // SEC                               free.asm:228
0x9044  0xA5 0x57       LDA 0x57                // LDA mfFREESLOTL                   free.asm:229
0x9046  0xE9 0x02       SBC # 0x02              // SBC # 2                           free.asm:230
0x9048  0x85 0x57       STA 0x57                // STA mfFREESLOTL                   free.asm:231
0x904A  0xA5 0x58       LDA 0x58                // LDA mfFREESLOTH                   free.asm:232
0x904C  0xE9 0x00       SBC # 0                 // SBC # 0                           free.asm:233
0x904E  0x85 0x58       STA 0x58                // STA mfFREESLOTH                   free.asm:234
0x9050  0xA5 0x55       LDA 0x55                // LDA mfCURRENTPREVL                free.asm:236
0x9052  0x05 0x56       ORA 0x56                // ORA mfCURRENTPREVH                free.asm:237
0x9054  0xF0 0x03       BEQ 0x9059 (+3)         // if (Z)                            free.asm:238
0x9056  0x4C 0xE4 0x90  JMP 0x90E4
0x9059  0xA0 0x02       LDY # 0x02              // LDY #2                            free.asm:246
0x905B  0xA5 0x5F       LDA 0x5F                // LDA mfCURRENTL                    free.asm:247
0x905D  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:248
0x905F  0xC8            INY                     // INY                               free.asm:249
0x9060  0xA5 0x60       LDA 0x60                // LDA mfCURRENTH                    free.asm:250
0x9062  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:251
0x9064  0xC8            INY                     // INY                               free.asm:253
0x9065  0xA9 0x00       LDA # 0                 // LDA #0                            free.asm:254
0x9067  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:255
0x9069  0xC8            INY                     // INY                               free.asm:256
0x906A  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:257
0x906C  0xA0 0x04       LDY # 0x04              // LDY #4                            free.asm:259
0x906E  0xA5 0x57       LDA 0x57                // LDA mfFREESLOTL                   free.asm:260
0x9070  0x91 0x5F       STA [0x5F],Y            // STA [mfCURRENT], Y                free.asm:261
0x9072  0xC8            INY                     // INY                               free.asm:262
0x9073  0xA5 0x58       LDA 0x58                // LDA mfFREESLOTH                   free.asm:263
0x9075  0x91 0x5F       STA [0x5F],Y            // STA [mfCURRENT], Y                free.asm:264
0x9077  0x18            CLC                     // CLC                               free.asm:267
0x9078  0xA5 0x57       LDA 0x57                // LDA mfFREESLOTL                   free.asm:268
0x907A  0x65 0x5D       ADC 0x5D                // ADC mfSIZEL                       free.asm:269
0x907C  0x85 0x59       STA 0x59                // STA mfGAPFRONTL                   free.asm:270
0x907E  0xA5 0x58       LDA 0x58                // LDA mfFREESLOTH                   free.asm:271
0x9080  0x65 0x5E       ADC 0x5E                // ADC mfSIZEH                       free.asm:272
0x9082  0x85 0x5A       STA 0x5A                // STA mfGAPFRONTH                   free.asm:273
0x9084  0x38            SEC                     // SEC                               free.asm:274
0x9085  0xA5 0x06       LDA 0x06                // LDA FREELISTL                     free.asm:275
0x9087  0xE5 0x59       SBC 0x59                // SBC mfGAPFRONTL                   free.asm:276
0x9089  0x85 0x59       STA 0x59                // STA mfGAPFRONTL                   free.asm:277
0x908B  0xA5 0x07       LDA 0x07                // LDA FREELISTH                     free.asm:278
0x908D  0xE5 0x5A       SBC 0x5A                // SBC mfGAPFRONTH                   free.asm:279
0x908F  0x85 0x5A       STA 0x5A                // STA mfGAPFRONTH                   free.asm:280
0x9091  0x05 0x59       ORA 0x59                // ORA mfGAPFRONTL                   free.asm:281
0x9093  0xD0 0x46       BNE 0x90DB (+70)        // if (Z)                            free.asm:282
0x9095  0xB2 0x06       LDA [0x06]              // LDA [ZP.FREELIST]                 free.asm:288
0x9097  0xA0 0x01       LDY # 1                 // LDY # 1                           free.asm:289
0x9099  0x85 0x5B       STA 0x5B                // STA mfNEXTSIZEL                   free.asm:295
0x909B  0xB1 0x06       LDA [0x06],Y            // LDA [ZP.FREELIST], Y              free.asm:297
0x909D  0x85 0x5C       STA 0x5C                // STA mfNEXTSIZEH                   free.asm:298
0x909F  0xC8            INY                     // INY                               free.asm:300
0x90A0  0xB1 0x06       LDA [0x06],Y            // LDA [ZP.FREELIST], Y              free.asm:301
0x90A2  0x85 0x5F       STA 0x5F                // STA mfNEXTNEXTL                   free.asm:302
0x90A4  0xC8            INY                     // INY                               free.asm:303
0x90A5  0xB1 0x06       LDA [0x06],Y            // LDA [ZP.FREELIST], Y              free.asm:304
0x90A7  0x85 0x60       STA 0x60                // STA mfNEXTNEXTH                   free.asm:305
0x90A9  0x18            CLC                     // CLC                               free.asm:308
0x90AA  0xA5 0x5B       LDA 0x5B                // LDA mfNEXTSIZEL                   free.asm:309
0x90AC  0x65 0x5D       ADC 0x5D                // ADC mfSIZEL                       free.asm:310
0x90AE  0x85 0x5D       STA 0x5D                // STA mfSIZEL                       free.asm:311
0x90B0  0xA5 0x5C       LDA 0x5C                // LDA mfNEXTSIZEH                   free.asm:312
0x90B2  0x65 0x5E       ADC 0x5E                // ADC mfSIZEH                       free.asm:313
0x90B4  0x85 0x5E       STA 0x5E                // STA mfSIZEH                       free.asm:314
0x90B6  0xA5 0x5D       LDA 0x5D                // LDA mfSIZEL                       free.asm:317
0x90B8  0x92 0x57       STA [0x57]              // STA [mfFREESLOT]                  free.asm:319
0x90BA  0xA0 0x01       LDY # 1                 // LDY # 1                           free.asm:320
0x90BC  0xA5 0x5E       LDA 0x5E                // LDA mfSIZEH                       free.asm:326
0x90BE  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:327
0x90C0  0xC8            INY                     // INY                               free.asm:330
0x90C1  0xA5 0x5F       LDA 0x5F                // LDA mfNEXTNEXTL                   free.asm:331
0x90C3  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:332
0x90C5  0xC8            INY                     // INY                               free.asm:333
0x90C6  0xA5 0x60       LDA 0x60                // LDA mfNEXTNEXTH                   free.asm:334
0x90C8  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:335
0x90CA  0xA5 0x5F       LDA 0x5F                // LDA mfNEXTNEXTL                   free.asm:339
0x90CC  0x05 0x60       ORA 0x60                // ORA mfNEXTNEXTH                   free.asm:340
0x90CE  0xF0 0x0B       BEQ 0x90DB (+11)        // if (Z)                            free.asm:341
0x90D0  0xA0 0x04       LDY # 0x04              // LDY #4                            free.asm:349
0x90D2  0xA5 0x57       LDA 0x57                // LDA mfFREESLOTL                   free.asm:350
0x90D4  0x91 0x5F       STA [0x5F],Y            // STA [mfNEXTNEXT], Y               free.asm:351
0x90D6  0xC8            INY                     // INY                               free.asm:352
0x90D7  0xA5 0x58       LDA 0x58                // LDA mfFREESLOTH                   free.asm:353
0x90D9  0x91 0x5F       STA [0x5F],Y            // STA [mfNEXTNEXT], Y               free.asm:354
0x90DB  0xA5 0x57       LDA 0x57                // LDA mfFREESLOTL                   free.asm:359
0x90DD  0x85 0x06       STA 0x06                // STA FREELISTL                     free.asm:360
0x90DF  0xA5 0x58       LDA 0x58                // LDA mfFREESLOTH                   free.asm:361
0x90E1  0x85 0x07       STA 0x07                // STA FREELISTH                     free.asm:362
0x90E3  0x60            RTS                     // break;    memoryFreeExit          free.asm:364
0x90E4  0xA5 0x5F       LDA 0x5F                // LDA mfCURRENTL                    free.asm:367
0x90E6  0x05 0x60       ORA 0x60                // ORA mfCURRENTH                    free.asm:368
0x90E8  0xD0 0x44       BNE 0x912E (+68)        // if (Z)                            free.asm:369
0x90EA  0xA0 0x02       LDY # 0x02              // LDY #2                            free.asm:379
0x90EC  0xA5 0x57       LDA 0x57                // LDA mfFREESLOTL                   free.asm:380
0x90EE  0x91 0x55       STA [0x55],Y            // STA [mfCURRENTPREV], Y            free.asm:381
0x90F0  0xC8            INY                     // INY                               free.asm:382
0x90F1  0xA5 0x58       LDA 0x58                // LDA mfFREESLOTH                   free.asm:383
0x90F3  0x91 0x55       STA [0x55],Y            // STA [mfCURRENTPREV], Y            free.asm:384
0x90F5  0xC8            INY                     // INY                               free.asm:387
0x90F6  0xA5 0x55       LDA 0x55                // LDA mfCURRENTPREVL                free.asm:388
0x90F8  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:389
0x90FA  0xC8            INY                     // INY                               free.asm:390
0x90FB  0xA5 0x56       LDA 0x56                // LDA mfCURRENTPREVH                free.asm:391
0x90FD  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:392
0x90FF  0xA0 0x02       LDY # 0x02              // LDY #2                            free.asm:395
0x9101  0xA9 0x00       LDA # 0                 // LDA #0                            free.asm:396
0x9103  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:397
0x9105  0xC8            INY                     // INY                               free.asm:398
0x9106  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:399
0x9108  0x20 0xE1 0x91  JSR 0x91E1              // freeHelper1();                    free.asm:403
0x910B  0xF0 0x01       BEQ 0x910E (+1)         // if (NZ)                           free.asm:404
0x910D  0x60            RTS                     // break;    memoryFreeExit          free.asm:406
0x910E  0x18            CLC                     // CLC                               free.asm:413
0x910F  0xA5 0x5D       LDA 0x5D                // LDA mfSIZEL                       free.asm:414
0x9111  0x65 0x5B       ADC 0x5B                // ADC mfPREVSIZEL                   free.asm:415
0x9113  0x85 0x5D       STA 0x5D                // STA mfSIZEL                       free.asm:416
0x9115  0xA5 0x5E       LDA 0x5E                // LDA mfSIZEH                       free.asm:417
0x9117  0x65 0x5C       ADC 0x5C                // ADC mfPREVSIZEH                   free.asm:418
0x9119  0x85 0x5E       STA 0x5E                // STA mfSIZEH                       free.asm:419
0x911B  0xA5 0x5D       LDA 0x5D                // LDA mfSIZEL                       free.asm:421
0x911D  0x92 0x55       STA [0x55]              // STA [mfCURRENTPREV]               free.asm:423
0x911F  0xA0 0x01       LDY # 1                 // LDY # 1                           free.asm:424
0x9121  0xA5 0x5E       LDA 0x5E                // LDA mfSIZEH                       free.asm:430
0x9123  0x91 0x55       STA [0x55],Y            // STA [mfCURRENTPREV], Y            free.asm:431
0x9125  0xA9 0x00       LDA # 0                 // LDA #0                            free.asm:434
0x9127  0xC8            INY                     // INY                               free.asm:435
0x9128  0x91 0x55       STA [0x55],Y            // STA [mfCURRENTPREV], Y            free.asm:436
0x912A  0xC8            INY                     // INY                               free.asm:437
0x912B  0x91 0x55       STA [0x55],Y            // STA [mfCURRENTPREV], Y            free.asm:438
0x912D  0x60            RTS                     // break;    memoryFreeExit          free.asm:439
0x912E  0xA0 0x02       LDY # 0x02              // LDY #2                            free.asm:448
0x9130  0xA5 0x57       LDA 0x57                // LDA mfFREESLOTL                   free.asm:449
0x9132  0x91 0x55       STA [0x55],Y            // STA [mfCURRENTPREV], Y            free.asm:450
0x9134  0xC8            INY                     // INY                               free.asm:451
0x9135  0xA5 0x58       LDA 0x58                // LDA mfFREESLOTH                   free.asm:452
0x9137  0x91 0x55       STA [0x55],Y            // STA [mfCURRENTPREV], Y            free.asm:453
0x9139  0xC8            INY                     // INY                               free.asm:456
0x913A  0xA5 0x55       LDA 0x55                // LDA mfCURRENTPREVL                free.asm:457
0x913C  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:458
0x913E  0xC8            INY                     // INY                               free.asm:459
0x913F  0xA5 0x56       LDA 0x56                // LDA mfCURRENTPREVH                free.asm:460
0x9141  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:461
0x9143  0xA0 0x02       LDY # 0x02              // LDY #2                            free.asm:464
0x9145  0xA5 0x5F       LDA 0x5F                // LDA mfCURRENTL                    free.asm:465
0x9147  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:466
0x9149  0xC8            INY                     // INY                               free.asm:467
0x914A  0xA5 0x60       LDA 0x60                // LDA mfCURRENTH                    free.asm:468
0x914C  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:469
0x914E  0xC8            INY                     // INY                               free.asm:472
0x914F  0xA5 0x57       LDA 0x57                // LDA mfFREESLOTL                   free.asm:473
0x9151  0x91 0x5F       STA [0x5F],Y            // STA [mfCURRENT], Y                free.asm:474
0x9153  0xC8            INY                     // INY                               free.asm:475
0x9154  0xA5 0x58       LDA 0x58                // LDA mfFREESLOTH                   free.asm:476
0x9156  0x91 0x5F       STA [0x5F],Y            // STA [mfCURRENT], Y                free.asm:477
0x9158  0x20 0xE1 0x91  JSR 0x91E1              // freeHelper1();                    free.asm:481
0x915B  0xD0 0x33       BNE 0x9190 (+51)        // if (Z)                            free.asm:482
0x915D  0x18            CLC                     // CLC                               free.asm:488
0x915E  0xA5 0x5D       LDA 0x5D                // LDA mfSIZEL                       free.asm:489
0x9160  0x65 0x5B       ADC 0x5B                // ADC mfPREVSIZEL                   free.asm:490
0x9162  0x85 0x5D       STA 0x5D                // STA mfSIZEL                       free.asm:491
0x9164  0xA5 0x5E       LDA 0x5E                // LDA mfSIZEH                       free.asm:492
0x9166  0x65 0x5C       ADC 0x5C                // ADC mfPREVSIZEH                   free.asm:493
0x9168  0x85 0x5E       STA 0x5E                // STA mfSIZEH                       free.asm:494
0x916A  0xA5 0x5D       LDA 0x5D                // LDA mfSIZEL                       free.asm:496
0x916C  0x92 0x55       STA [0x55]              // STA [mfCURRENTPREV]               free.asm:498
0x916E  0xA0 0x01       LDY # 1                 // LDY # 1                           free.asm:499
0x9170  0xA5 0x5E       LDA 0x5E                // LDA mfSIZEH                       free.asm:505
0x9172  0x91 0x55       STA [0x55],Y            // STA [mfCURRENTPREV], Y            free.asm:506
0x9174  0xC8            INY                     // INY                               free.asm:509
0x9175  0xA5 0x5F       LDA 0x5F                // LDA mfCURRENTL                    free.asm:510
0x9177  0x91 0x55       STA [0x55],Y            // STA [mfCURRENTPREV], Y            free.asm:511
0x9179  0xC8            INY                     // INY                               free.asm:512
0x917A  0xA5 0x60       LDA 0x60                // LDA mfCURRENTH                    free.asm:513
0x917C  0x91 0x55       STA [0x55],Y            // STA [mfCURRENTPREV], Y            free.asm:514
0x917E  0xC8            INY                     // INY                               free.asm:517
0x917F  0xA5 0x55       LDA 0x55                // LDA mfCURRENTPREVL                free.asm:518
0x9181  0x91 0x5F       STA [0x5F],Y            // STA [mfCURRENT], Y                free.asm:519
0x9183  0xC8            INY                     // INY                               free.asm:520
0x9184  0xA5 0x56       LDA 0x56                // LDA mfCURRENTPREVH                free.asm:521
0x9186  0x91 0x5F       STA [0x5F],Y            // STA [mfCURRENT], Y                free.asm:522
0x9188  0xA5 0x55       LDA 0x55                // LDA mfCURRENTPREVL                free.asm:524
0x918A  0x85 0x57       STA 0x57                // STA mfFREESLOTL                   free.asm:525
0x918C  0xA5 0x56       LDA 0x56                // LDA mfCURRENTPREVH                free.asm:526
0x918E  0x85 0x58       STA 0x58                // STA mfFREESLOTH                   free.asm:527
0x9190  0x18            CLC                     // CLC                               free.asm:531
0x9191  0xA5 0x57       LDA 0x57                // LDA mfFREESLOTL                   free.asm:532
0x9193  0x65 0x5D       ADC 0x5D                // ADC mfSIZEL                       free.asm:533
0x9195  0x85 0x59       STA 0x59                // STA mfGAPNEXTL                    free.asm:534
0x9197  0xA5 0x58       LDA 0x58                // LDA mfFREESLOTH                   free.asm:535
0x9199  0x65 0x5E       ADC 0x5E                // ADC mfSIZEH                       free.asm:536
0x919B  0x85 0x5A       STA 0x5A                // STA mfGAPNEXTH                    free.asm:537
0x919D  0x38            SEC                     // SEC                               free.asm:538
0x919E  0xA5 0x5F       LDA 0x5F                // LDA mfCURRENTL                    free.asm:539
0x91A0  0xE5 0x59       SBC 0x59                // SBC mfGAPNEXTL                    free.asm:540
0x91A2  0x85 0x59       STA 0x59                // STA mfGAPNEXTL                    free.asm:541
0x91A4  0xA5 0x60       LDA 0x60                // LDA mfCURRENTH                    free.asm:542
0x91A6  0xE5 0x5A       SBC 0x5A                // SBC mfGAPNEXTH                    free.asm:543
0x91A8  0x85 0x5A       STA 0x5A                // STA mfGAPNEXTH                    free.asm:544
0x91AA  0x05 0x59       ORA 0x59                // ORA mfGAPNEXTL                    free.asm:545
0x91AC  0xD0 0x32       BNE 0x91E0 (+50)        // if (NZ) { break; }                free.asm:546
0x91AE  0x18            CLC                     // CLC                               free.asm:553
0x91AF  0xA5 0x5D       LDA 0x5D                // LDA mfSIZEL                       free.asm:554
0x91B1  0x65 0x51       ADC 0x51                // ADC mfCURRENTSIZEL                free.asm:555
0x91B3  0x85 0x5D       STA 0x5D                // STA mfSIZEL                       free.asm:556
0x91B5  0xA5 0x5E       LDA 0x5E                // LDA mfSIZEH                       free.asm:557
0x91B7  0x65 0x52       ADC 0x52                // ADC mfCURRENTSIZEH                free.asm:558
0x91B9  0x85 0x5E       STA 0x5E                // STA mfSIZEH                       free.asm:559
0x91BB  0xA5 0x5D       LDA 0x5D                // LDA mfSIZEL                       free.asm:561
0x91BD  0x92 0x57       STA [0x57]              // STA [mfFREESLOT]                  free.asm:563
0x91BF  0xA0 0x01       LDY # 1                 // LDY # 1                           free.asm:564
0x91C1  0xA5 0x5E       LDA 0x5E                // LDA mfSIZEH                       free.asm:570
0x91C3  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:571
0x91C5  0xC8            INY                     // INY                               free.asm:574
0x91C6  0xA5 0x53       LDA 0x53                // LDA mfCURRENTNEXTL                free.asm:575
0x91C8  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:576
0x91CA  0xC8            INY                     // INY                               free.asm:577
0x91CB  0xA5 0x54       LDA 0x54                // LDA mfCURRENTNEXTH                free.asm:578
0x91CD  0x91 0x57       STA [0x57],Y            // STA [mfFREESLOT], Y               free.asm:579
0x91CF  0xA5 0x53       LDA 0x53                // LDA mfCURRENTNEXTL                free.asm:581
0x91D1  0x05 0x54       ORA 0x54                // ORA mfCURRENTNEXTH                free.asm:582
0x91D3  0xF0 0x0B       BEQ 0x91E0 (+11)        // if (Z)                            free.asm:583
0x91D5  0xA0 0x04       LDY # 0x04              // LDY #4                            free.asm:591
0x91D7  0xA5 0x57       LDA 0x57                // LDA mfFREESLOTL                   free.asm:592
0x91D9  0x91 0x53       STA [0x53],Y            // STA [mfCURRENTNEXT], Y            free.asm:593
0x91DB  0xC8            INY                     // INY                               free.asm:594
0x91DC  0xA5 0x58       LDA 0x58                // LDA mfFREESLOTH                   free.asm:595
0x91DE  0x91 0x53       STA [0x53],Y            // STA [mfCURRENTNEXT], Y            free.asm:596
0x91E0  0x60            RTS                     // }                                 free.asm:600

// /source/runtime/6502/free.asm:603
// ####  Free.freeHelper1()  ####                                               0x0080

0x91E1  0xB2 0x55       LDA [0x55]              // LDA [mfCURRENTPREV]               free.asm:606
0x91E3  0xA0 0x01       LDY # 1                 // LDY # 1                           free.asm:607
0x91E5  0x85 0x5B       STA 0x5B                // STA mfPREVSIZEL                   free.asm:613
0x91E7  0xB1 0x55       LDA [0x55],Y            // LDA [mfCURRENTPREV], Y            free.asm:614
0x91E9  0x85 0x5C       STA 0x5C                // STA mfPREVSIZEH                   free.asm:615
0x91EB  0x18            CLC                     // CLC                               free.asm:617
0x91EC  0xA5 0x55       LDA 0x55                // LDA mfCURRENTPREVL                free.asm:618
0x91EE  0x65 0x5B       ADC 0x5B                // ADC mfPREVSIZEL                   free.asm:619
0x91F0  0x85 0x59       STA 0x59                // STA mfGAPBACKL                    free.asm:620
0x91F2  0xA5 0x56       LDA 0x56                // LDA mfCURRENTPREVH                free.asm:621
0x91F4  0x65 0x5C       ADC 0x5C                // ADC mfPREVSIZEH                   free.asm:622
0x91F6  0x85 0x5A       STA 0x5A                // STA mfGAPBACKH                    free.asm:623
0x91F8  0x38            SEC                     // SEC                               free.asm:624
0x91F9  0xA5 0x57       LDA 0x57                // LDA mfFREESLOTL                   free.asm:625
0x91FB  0xE5 0x59       SBC 0x59                // SBC mfGAPBACKL                    free.asm:626
0x91FD  0x85 0x59       STA 0x59                // STA mfGAPBACKL                    free.asm:627
0x91FF  0xA5 0x58       LDA 0x58                // LDA mfFREESLOTH                   free.asm:628
0x9201  0xE5 0x5A       SBC 0x5A                // SBC mfGAPBACKH                    free.asm:629
0x9203  0x85 0x5A       STA 0x5A                // STA mfGAPBACKH                    free.asm:630
0x9205  0x05 0x59       ORA 0x59                // ORA mfGAPBACKL                    free.asm:631
0x9207  0x60            RTS                     // }                                 free.asm:632

// /source/runtime/6502/memory.asm:7
// ####  Memory.probeTest()  ####                                               0x0081

0x9208  0xA9 0xAA       LDA # 0xAA              // LDA #0xAA                         memory.asm:11
0x920A  0x92 0x1B       STA [0x1B]              // STA [IDX]                         memory.asm:13
0x920C  0xB2 0x1B       LDA [0x1B]              // LDA [IDX]                         memory.asm:14
0x920E  0xC9 0xAA       CMP # 0xAA              // CMP #0xAA                         memory.asm:20
0x9210  0xD0 0x0C       BNE 0x921E (+12)        // if (Z)                            memory.asm:21
0x9212  0xA9 0x55       LDA # 0x55              // LDA #0x55                         memory.asm:23
0x9214  0x92 0x1B       STA [0x1B]              // STA [IDX]                         memory.asm:25
0x9216  0xB2 0x1B       LDA [0x1B]              // LDA [IDX]                         memory.asm:26
0x9218  0xC9 0x55       CMP # 0x55              // CMP #0x55                         memory.asm:31
0x921A  0xD0 0x02       BNE 0x921E (+2)         // if (Z)                            memory.asm:32
0x921C  0x38            SEC                     // SEC    RAM found                  memory.asm:34
0x921D  0x60            RTS                     // break;                            memory.asm:35
0x921E  0x18            CLC                     // CLC    not RAM                    memory.asm:38
0x921F  0x60            RTS                     // break;                            memory.asm:39

// /source/runtime/6502/memory.asm:44
// ####  Memory.probeRAM()  ####                                                0x0082

0x9220  0xA9 0xFF       LDA # 0xFF              // LDA # 0xFF                        memory.asm:48
0x9222  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       memory.asm:49
0x9224  0xA9 0xDF       LDA # 0xDF              // LDA # 0xDF                        memory.asm:50
0x9226  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       memory.asm:51
0x9228  0x20 0x08 0x92  JSR 0x9208              // probeTest();                      memory.asm:52
0x922B  0x90 0x03       BCC 0x9230 (+3)         // if (C)                            memory.asm:53
0x922D  0xA9 0xE0       LDA # 0xE0              // LDA # 0xE0                        memory.asm:56
0x922F  0x60            RTS                     // break;                            memory.asm:57
0x9230  0xA9 0xBF       LDA # 0xBF              // LDA # 0xBF                        memory.asm:59
0x9232  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       memory.asm:60
0x9234  0x20 0x08 0x92  JSR 0x9208              // probeTest();                      memory.asm:61
0x9237  0x90 0x03       BCC 0x923C (+3)         // if (C)                            memory.asm:62
0x9239  0xA9 0xC0       LDA # 0xC0              // LDA # 0xC0                        memory.asm:65
0x923B  0x60            RTS                     // break;                            memory.asm:66
0x923C  0xA9 0x7F       LDA # 0x7F              // LDA # 0x7F                        memory.asm:68
0x923E  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       memory.asm:69
0x9240  0x20 0x08 0x92  JSR 0x9208              // probeTest();                      memory.asm:70
0x9243  0x90 0x03       BCC 0x9248 (+3)         // if (C)                            memory.asm:71
0x9245  0xA9 0x80       LDA # 0x80              // LDA # 0x80                        memory.asm:74
0x9247  0x60            RTS                     // break;                            memory.asm:75
0x9248  0xA9 0x3F       LDA # 0x3F              // LDA # 0x3F                        memory.asm:77
0x924A  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       memory.asm:78
0x924C  0x20 0x08 0x92  JSR 0x9208              // probeTest();                      memory.asm:79
0x924F  0x90 0x03       BCC 0x9254 (+3)         // if (C)                            memory.asm:80
0x9251  0xA9 0x40       LDA # 0x40              // LDA # 0x40                        memory.asm:83
0x9253  0x60            RTS                     // break;                            memory.asm:84
0x9254  0xA9 0x02       LDA # 0x02              // LDA # 0x02 Debug.Crash();    failed to find at least 16K of RAM
0x9256  0x4C 0xEE 0x8C  JMP 0x8CEE

// /source/runtime/6502/memory.asm:99
// ####  Memory.InitializeHeapSize()  ####                                      0x0083

0x9259  0xA9 0x1B       LDA # 0x1B              // LDA # (Address.HopperData >> 8)   memory.asm:105
0x925B  0x85 0x08       STA 0x08                // STA ZP.HEAPSTART                  memory.asm:111
0x925D  0xA9 0x80       LDA # 0x80              // LDA # (Address.RamSize >> 8)      memory.asm:114
0x925F  0xC9 0x80       CMP # 0x80              // CMP # 0x80                        memory.asm:115
0x9261  0xD0 0x03       BNE 0x9266 (+3)         // if (Z)                            memory.asm:116
0x9263  0x20 0x20 0x92  JSR 0x9220              // probeRAM();    munts Y, sets A    memory.asm:123
0x9266  0x38            SEC                     // SEC                               memory.asm:125
0x9267  0xE5 0x08       SBC 0x08                // SBC ZP.HEAPSTART                  memory.asm:126
0x9269  0x85 0x09       STA 0x09                // STA ZP.HEAPSIZE                   memory.asm:127
0x926B  0xA9 0x00       LDA # 0                 // LDA #0                            memory.asm:130
0x926D  0x48            PHA                     // PHA PHA                           memory.asm:131
0x926E  0x48            PHA
0x926F  0x85 0x1B       STA 0x1B                // STA IDXL                          memory.asm:132
0x9271  0xA5 0x08       LDA 0x08                // LDA ZP.HEAPSTART                  memory.asm:133
0x9273  0x85 0x1C       STA 0x1C                // STA IDXH                          memory.asm:134
0x9275  0xA6 0x09       LDX 0x09                // LDX ZP.HEAPSIZE    number of 256 byte pages is same as MSB of size
0x9277  0x20 0x3A 0x93  JSR 0x933A              // Utilities.ClearPages();    munts A, X, Y
0x927A  0xA5 0x08       LDA 0x08                // LDA ZP.HEAPSTART                  memory.asm:139
0x927C  0x85 0x07       STA 0x07                // STA ZP.FREELISTH                  memory.asm:140
0x927E  0x68            PLA                     // PLA    0 -> A                     memory.asm:141
0x927F  0xA8            TAY                     // TAY    0 -> Y                     memory.asm:142
0x9280  0x85 0x06       STA 0x06                // STA ZP.FREELISTL                  memory.asm:143
0x9282  0x91 0x06       STA [0x06],Y            // STA [ZP.FREELIST], Y              memory.asm:146
0x9284  0xA5 0x09       LDA 0x09                // LDA ZP.HEAPSIZE                   memory.asm:147
0x9286  0xC8            INY                     // INY                               memory.asm:148
0x9287  0x91 0x06       STA [0x06],Y            // STA [ZP.FREELIST], Y              memory.asm:149
0x9289  0x68            PLA                     // PLA    0 -> A                     memory.asm:152
0x928A  0xC8            INY                     // INY                               memory.asm:153
0x928B  0x91 0x06       STA [0x06],Y            // STA [ZP.FREELIST], Y              memory.asm:154
0x928D  0xC8            INY                     // INY                               memory.asm:155
0x928E  0x91 0x06       STA [0x06],Y            // STA [ZP.FREELIST], Y              memory.asm:156
0x9290  0xC8            INY                     // INY                               memory.asm:159
0x9291  0x91 0x06       STA [0x06],Y            // STA [ZP.FREELIST], Y              memory.asm:160
0x9293  0xC8            INY                     // INY                               memory.asm:161
0x9294  0x91 0x06       STA [0x06],Y            // STA [ZP.FREELIST], Y              memory.asm:162
0x9296  0x60            RTS                     // }                                 memory.asm:163

// /source/runtime/6502/memory.asm:178
// ####  Memory.Allocate()  ####                                                0x0084

0x9297  0x48            PHA                     // PHA                               memory.asm:179
0x9298  0x5A            PHY                     // PHY                               memory.asm:180
0x9299  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       memory.asm:186
0x929B  0x48            PHA                     // PHA                               memory.asm:187
0x929C  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       memory.asm:188
0x929E  0x48            PHA                     // PHA                               memory.asm:189
0x929F  0x20 0xD6 0x8D  JSR 0x8DD6              // Allocate.Allocate();    Munts: A, Y, ZP.FREELIST, ZP.ACCL(size), -> ZP.IDX
0x92A2  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       memory.asm:192
0x92A4  0x05 0x1C       ORA 0x1C                // ORA ZP.IDXH                       memory.asm:193
0x92A6  0xD0 0x06       BNE 0x92AE (+6)         // if (Z)                            memory.asm:194
0x92A8  0xA9 0x09       LDA # 0x09              // Error.OutOfMemory(); BIT ZP.EmulatorPCL
0x92AA  0x20 0x5F 0x8B  JSR 0x8B5F
0x92AD  0x18            CLC                     // CLC                               memory.asm:198
0x92AE  0x68            PLA                     // PLA                               memory.asm:201
0x92AF  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       memory.asm:202
0x92B1  0x68            PLA                     // PLA                               memory.asm:203
0x92B2  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       memory.asm:204
0x92B4  0x38            SEC                     // SEC                               memory.asm:209
0x92B5  0x7A            PLY                     // PLY                               memory.asm:210
0x92B6  0x68            PLA                     // PLA                               memory.asm:211
0x92B7  0x60            RTS                     // }                                 memory.asm:212

// /source/runtime/6502/memory.asm:219
// ####  Memory.Free()  ####                                                    0x0085

0x92B8  0x5A            PHY                     // PHY                               memory.asm:220
0x92B9  0x20 0xBF 0x8F  JSR 0x8FBF              // Free.Free();    Munts: ZP.IDX, ZP.FREELIST
0x92BC  0x38            SEC                     // SEC    success                    memory.asm:234
0x92BD  0x7A            PLY                     // PLY                               memory.asm:236
0x92BE  0x60            RTS                     // }                                 memory.asm:237

// /source/runtime/6502/memory.asm:239
// ####  Memory.FreeIDY()  ####                                                 0x0086

0x92BF  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       memory.asm:240
0x92C1  0x48            PHA                     // PHA                               memory.asm:241
0x92C2  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       memory.asm:242
0x92C4  0x48            PHA                     // PHA                               memory.asm:243
0x92C5  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       memory.asm:245
0x92C7  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       memory.asm:246
0x92C9  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       memory.asm:247
0x92CB  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       memory.asm:248
0x92CD  0x20 0xB8 0x92  JSR 0x92B8              // Memory.Free();     Input: ZP.IDX, Munts: ZP.IDX, ZP.M* -> C on success
0x92D0  0x68            PLA                     // PLA                               memory.asm:251
0x92D1  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       memory.asm:252
0x92D3  0x68            PLA                     // PLA                               memory.asm:253
0x92D4  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       memory.asm:254
0x92D6  0x60            RTS                     // }                                 memory.asm:255

// /source/runtime/6502/memory.asm:313
// ####  Memory.AvailableACC()  ####                                            0x0087

0x92D7  0x64 0x0E       STZ 0x0E                // STZ ZP.ACCL                       memory.asm:317
0x92D9  0x64 0x0F       STZ 0x0F                // STZ ZP.ACCH                       memory.asm:318
0x92DB  0xA5 0x06       LDA 0x06                // LDA ZP.FREELISTL                  memory.asm:324
0x92DD  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       memory.asm:325
0x92DF  0xA5 0x07       LDA 0x07                // LDA ZP.FREELISTH                  memory.asm:326
0x92E1  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       memory.asm:327
0x92E3  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       memory.asm:331
0x92E5  0x05 0x1C       ORA 0x1C                // ORA ZP.IDXH                       memory.asm:332
0x92E7  0xF0 0x21       BEQ 0x930A (+33)        // if (Z)                            memory.asm:333
0x92E9  0xA0 0x00       LDY # 0                 // LDY # 0                           memory.asm:338
0x92EB  0x18            CLC                     // CLC                               memory.asm:339
0x92EC  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   memory.asm:340
0x92EE  0x65 0x0E       ADC 0x0E                // ADC ZP.ACCL                       memory.asm:341
0x92F0  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       memory.asm:342
0x92F2  0xC8            INY                     // INY                               memory.asm:343
0x92F3  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   memory.asm:344
0x92F5  0x65 0x0F       ADC 0x0F                // ADC ZP.ACCH                       memory.asm:345
0x92F7  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       memory.asm:346
0x92F9  0x20 0x71 0x93  JSR 0x9371              // DecACCx2();                       memory.asm:349
0x92FC  0xC8            INY                     // INY                               memory.asm:351
0x92FD  0xB1 0x1B       LDA [0x1B],Y            // LDA [IDX], Y                      memory.asm:352
0x92FF  0x48            PHA                     // PHA                               memory.asm:353
0x9300  0xC8            INY                     // INY                               memory.asm:354
0x9301  0xB1 0x1B       LDA [0x1B],Y            // LDA [IDX], Y                      memory.asm:355
0x9303  0x85 0x1C       STA 0x1C                // STA IDXH                          memory.asm:356
0x9305  0x68            PLA                     // PLA                               memory.asm:357
0x9306  0x85 0x1B       STA 0x1B                // STA IDXL                          memory.asm:358
0x9308  0x80 0xD9       BRA 0x92E3 (-39)        // }    loop                         memory.asm:359
0x930A  0x60            RTS                     // }                                 memory.asm:360

// /source/runtime/6502/memory.asm:470
// ####  Memory.Copy()  ####                                                    0x008B

0x930B  0xA5 0x65       LDA 0x65                // LDA ZP.FLENGTHL                   memory.asm:474
0x930D  0x05 0x66       ORA 0x66                // ORA ZP.FLENGTHH                   memory.asm:475
0x930F  0xF0 0x1A       BEQ 0x932B (+26)        // if (Z) { break; }     Nothing left to copy
0x9311  0xB2 0x61       LDA [0x61]              // LDA [ZP.FSOURCEADDRESS]           memory.asm:479
0x9313  0x92 0x63       STA [0x63]              // STA [ZP.FDESTINATIONADDRESS]      memory.asm:480
0x9315  0xE6 0x61       INC 0x61                // INC ZP.FSOURCEADDRESSL            memory.asm:483
0x9317  0xD0 0x02       BNE 0x931B (+2)         // if (Z)                            memory.asm:484
0x9319  0xE6 0x62       INC 0x62                // INC ZP.FSOURCEADDRESSH            memory.asm:486
0x931B  0xE6 0x63       INC 0x63                // INC ZP.FDESTINATIONADDRESSL       memory.asm:490
0x931D  0xD0 0x02       BNE 0x9321 (+2)         // if (Z)                            memory.asm:491
0x931F  0xE6 0x64       INC 0x64                // INC ZP.FDESTINATIONADDRESSH       memory.asm:493
0x9321  0xA5 0x65       LDA 0x65                // LDA ZP.FLENGTHL                   memory.asm:497
0x9323  0xD0 0x02       BNE 0x9327 (+2)         // if (Z)                            memory.asm:498
0x9325  0xC6 0x66       DEC 0x66                // DEC ZP.FLENGTHH                   memory.asm:500
0x9327  0xC6 0x65       DEC 0x65                // DEC ZP.FLENGTHL                   memory.asm:502
0x9329  0x80 0xE0       BRA 0x930B (-32)        // }                                 memory.asm:503
0x932B  0x60            RTS                     // }                                 memory.asm:504

// /source/runtime/6502/memory.asm:545
// ####  Memory.ClearPage()  ####                                               0x008D

0x932C  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       memory.asm:546
0x932E  0x64 0x1B       STZ 0x1B                // STZ ZP.IDXL                       memory.asm:547
0x9330  0xA0 0x00       LDY # 0                 // LDY #0                            memory.asm:549
0x9332  0xA9 0x00       LDA # 0                 // LDA #0                            memory.asm:550
0x9334  0x91 0x1B       STA [0x1B],Y            // STA [IDX], Y                      memory.asm:553
0x9336  0x88            DEY                     // DEY                               memory.asm:554
0x9337  0xD0 0xFB       BNE 0x9334 (-5)         // if (Z) { break; }                 memory.asm:555
0x9339  0x60            RTS                     // }                                 memory.asm:557

// /source/runtime/6502/utilities.asm:41
// ####  Utilities.ClearPages()  ####                                           0x0091

0x933A  0xA9 0x00       LDA # 0                 // LDA #0                            utilities.asm:42
0x933C  0xA8            TAY                     // TAY    0 -> Y                     utilities.asm:45
0x933D  0x91 0x1B       STA [0x1B],Y            // STA [IDX], Y                      utilities.asm:48
0x933F  0x88            DEY                     // DEY                               utilities.asm:49
0x9340  0xD0 0xFB       BNE 0x933D (-5)         // if (Z) { break; }                 utilities.asm:50
0x9342  0xE6 0x1C       INC 0x1C                // INC IDXH                          utilities.asm:53
0x9344  0xCA            DEX                     // DEX                               utilities.asm:54
0x9345  0xD0 0xF5       BNE 0x933C (-11)        // if (Z) { break; }                 utilities.asm:55
0x9347  0x60            RTS                     // }                                 utilities.asm:57

// /source/runtime/6502/utilities.asm:59
// ####  Utilities.IncIDX()  ####                                               0x0092

0x9348  0xE6 0x1B       INC 0x1B                // INC ZP.IDXL                       utilities.asm:60
0x934A  0xF0 0x01       BEQ 0x934D (+1)         // if (Z)                            utilities.asm:61
0x934C  0x60            RTS
0x934D  0xE6 0x1C       INC 0x1C                // INC ZP.IDXH                       utilities.asm:63
0x934F  0x60            RTS                     // }                                 utilities.asm:65

// /source/runtime/6502/utilities.asm:67
// ####  Utilities.IncIDY()  ####                                               0x0093

0x9350  0xE6 0x1D       INC 0x1D                // INC ZP.IDYL                       utilities.asm:68
0x9352  0xF0 0x01       BEQ 0x9355 (+1)         // if (Z)                            utilities.asm:69
0x9354  0x60            RTS
0x9355  0xE6 0x1E       INC 0x1E                // INC ZP.IDYH                       utilities.asm:71
0x9357  0x60            RTS                     // }                                 utilities.asm:73

// /source/runtime/6502/utilities.asm:75
// ####  Utilities.DecIDY()  ####                                               0x0094

0x9358  0xA5 0x1D       LDA 0x1D                // LDA IDYL                          utilities.asm:76
0x935A  0xD0 0x02       BNE 0x935E (+2)         // if (Z)                            utilities.asm:77
0x935C  0xC6 0x1E       DEC 0x1E                // DEC IDYH                          utilities.asm:79
0x935E  0xC6 0x1D       DEC 0x1D                // DEC IDYL                          utilities.asm:81
0x9360  0x60            RTS                     // }                                 utilities.asm:82

// /source/runtime/6502/utilities.asm:101
// ####  Utilities.IncACC()  ####                                               0x0097

0x9361  0xE6 0x0E       INC 0x0E                // INC ZP.ACCL                       utilities.asm:102
0x9363  0xF0 0x01       BEQ 0x9366 (+1)         // if (Z)                            utilities.asm:103
0x9365  0x60            RTS
0x9366  0xE6 0x0F       INC 0x0F                // INC ZP.ACCH                       utilities.asm:105
0x9368  0x60            RTS                     // }                                 utilities.asm:107

// /source/runtime/6502/utilities.asm:119
// ####  Utilities.IncNEXT()  ####                                              0x0099

0x9369  0xE6 0x16       INC 0x16                // INC ZP.NEXTL                      utilities.asm:120
0x936B  0xF0 0x01       BEQ 0x936E (+1)         // if (Z)                            utilities.asm:121
0x936D  0x60            RTS
0x936E  0xE6 0x17       INC 0x17                // INC ZP.NEXTH                      utilities.asm:123
0x9370  0x60            RTS                     // }                                 utilities.asm:125

// /source/runtime/6502/utilities.asm:127
// ####  Utilities.DecACCx2()  ####                                             0x009A

0x9371  0x48            PHA                     // PHA                               utilities.asm:128
0x9372  0x38            SEC                     // SEC                               utilities.asm:129
0x9373  0xA5 0x0E       LDA 0x0E                // LDA ACCL                          utilities.asm:130
0x9375  0xE9 0x02       SBC # 0x02              // SBC # 2                           utilities.asm:131
0x9377  0x85 0x0E       STA 0x0E                // STA ACCL                          utilities.asm:132
0x9379  0xA5 0x0F       LDA 0x0F                // LDA ACCH                          utilities.asm:133
0x937B  0xE9 0x00       SBC # 0                 // SBC # 0                           utilities.asm:134
0x937D  0x85 0x0F       STA 0x0F                // STA ACCH                          utilities.asm:135
0x937F  0x68            PLA                     // PLA                               utilities.asm:136
0x9380  0x60            RTS                     // }                                 utilities.asm:137

// /source/runtime/6502/utilities.asm:147
// ####  Utilities.IncDESTINATIONADDRESS()  ####                                0x009C

0x9381  0xE6 0x63       INC 0x63                // INC ZP.FDESTINATIONADDRESSL       utilities.asm:148
0x9383  0xF0 0x01       BEQ 0x9386 (+1)         // if (Z)                            utilities.asm:149
0x9385  0x60            RTS
0x9386  0xE6 0x64       INC 0x64                // INC ZP.FDESTINATIONADDRESSH       utilities.asm:151
0x9388  0x60            RTS                     // }                                 utilities.asm:153

// /source/runtime/6502/utilities.asm:155
// ####  Utilities.IncLENGTH()  ####                                            0x009D

0x9389  0xE6 0x65       INC 0x65                // INC ZP.FLENGTHL                   utilities.asm:156
0x938B  0xF0 0x01       BEQ 0x938E (+1)         // if (Z)                            utilities.asm:157
0x938D  0x60            RTS
0x938E  0xE6 0x66       INC 0x66                // INC ZP.FLENGTHH                   utilities.asm:159
0x9390  0x60            RTS                     // }                                 utilities.asm:161

// /source/runtime/6502/utilities.asm:171
// ####  Utilities.DecSOURCEADDRESS()  ####                                     0x009F

0x9391  0xA5 0x61       LDA 0x61                // LDA FSOURCEADDRESSL               utilities.asm:172
0x9393  0xD0 0x02       BNE 0x9397 (+2)         // if (Z)                            utilities.asm:173
0x9395  0xC6 0x62       DEC 0x62                // DEC FSOURCEADDRESSH               utilities.asm:175
0x9397  0xC6 0x61       DEC 0x61                // DEC FSOURCEADDRESSL               utilities.asm:177
0x9399  0x60            RTS                     // }                                 utilities.asm:178

// /source/runtime/6502/stacks.asm:8
// ####  Stacks.Initialize()  ####                                              0x00A2

0x939A  0x64 0x03       STZ 0x03                // STZ ZP.SP                         stacks.asm:10
0x939C  0x64 0x04       STZ 0x04                // STZ ZP.BP                         stacks.asm:11
0x939E  0x64 0x05       STZ 0x05                // STZ ZP.CSP                        stacks.asm:12
0x93A0  0x64 0x1B       STZ 0x1B                // STZ IDXL     setting this to 0 once is enough (ClearPages does not modify IDXL)
0x93A2  0xA9 0x03       LDA # 0x03              // LDA # (Address.CallStackLSB >> 8) stacks.asm:26
0x93A4  0x85 0x1C       STA 0x1C                // STA IDXH                          stacks.asm:27
0x93A6  0xA2 0x05       LDX # 0x05              // LDX # 5                    5 contiguous pages for CallStack, TypeStack and ValueStack
0x93A8  0x4C 0x3A 0x93  JMP 0x933A              // Utilities.ClearPages();    with IDX (memory location) and X (number of pages) initialized (does not modify IDXL)

// /source/runtime/6502/stacks.asm:33
// ####  Stacks.PopBP()  ####                                                   0x00A3

0x93AB  0xC6 0x05       DEC 0x05                // DEC ZP.CSP                        stacks.asm:34
0x93AD  0xA4 0x05       LDY 0x05                // LDY ZP.CSP                        stacks.asm:35
0x93AF  0xB9 0x00 0x03  LDA 0x0300,Y            // LDA Address.CallStackLSB, Y       stacks.asm:36
0x93B2  0x85 0x04       STA 0x04                // STA ZP.BP                         stacks.asm:37
0x93B4  0x60            RTS                     // }                                 stacks.asm:38

// /source/runtime/6502/stacks.asm:40
// ####  Stacks.PushBP()  ####                                                  0x00A4

0x93B5  0xA4 0x05       LDY 0x05                // LDY ZP.CSP                        stacks.asm:42
0x93B7  0xA5 0x04       LDA 0x04                // LDA ZP.BP                         stacks.asm:43
0x93B9  0x99 0x00 0x03  STA 0x0300,Y            // STA Address.CallStackLSB, Y       stacks.asm:44
0x93BC  0xE6 0x05       INC 0x05                // INC ZP.CSP                        stacks.asm:45
0x93BE  0x60            RTS                     // }                                 stacks.asm:52

// /source/runtime/6502/stacks.asm:54
// ####  Stacks.PopPC()  ####                                                   0x00A5

0x93BF  0xC6 0x05       DEC 0x05                // DEC ZP.CSP                        stacks.asm:55
0x93C1  0xA4 0x05       LDY 0x05                // LDY ZP.CSP                        stacks.asm:56
0x93C3  0xB9 0x00 0x03  LDA 0x0300,Y            // LDA Address.CallStackLSB, Y       stacks.asm:57
0x93C6  0x85 0x00       STA 0x00                // STA ZP.PCL                        stacks.asm:58
0x93C8  0xB9 0x00 0x04  LDA 0x0400,Y            // LDA Address.CallStackMSB, Y       stacks.asm:59
0x93CB  0x85 0x01       STA 0x01                // STA ZP.PCH                        stacks.asm:60
0x93CD  0x60            RTS                     // }                                 stacks.asm:61

// /source/runtime/6502/stacks.asm:63
// ####  Stacks.PushPC()  ####                                                  0x00A6

0x93CE  0xA4 0x05       LDY 0x05                // LDY ZP.CSP                        stacks.asm:64
0x93D0  0xA5 0x00       LDA 0x00                // LDA ZP.PCL                        stacks.asm:65
0x93D2  0x99 0x00 0x03  STA 0x0300,Y            // STA Address.CallStackLSB, Y       stacks.asm:66
0x93D5  0xA5 0x01       LDA 0x01                // LDA ZP.PCH                        stacks.asm:67
0x93D7  0x99 0x00 0x04  STA 0x0400,Y            // STA Address.CallStackMSB, Y       stacks.asm:68
0x93DA  0xE6 0x05       INC 0x05                // INC ZP.CSP                        stacks.asm:69
0x93DC  0x60            RTS                     // }                                 stacks.asm:70

// /source/runtime/6502/stacks.asm:74
// ####  Stacks.PopXID()  ####                                                  0x00A7

0x93DD  0xC6 0x05       DEC 0x05                // DEC ZP.CSP                        stacks.asm:75
0x93DF  0xA4 0x05       LDY 0x05                // LDY ZP.CSP                        stacks.asm:76
0x93E1  0xB9 0x00 0x03  LDA 0x0300,Y            // LDA Address.CallStackLSB, Y       stacks.asm:77
0x93E4  0x85 0x80       STA 0x80                // STA ZP.XIDL                       stacks.asm:78
0x93E6  0xB9 0x00 0x04  LDA 0x0400,Y            // LDA Address.CallStackMSB, Y       stacks.asm:79
0x93E9  0x85 0x81       STA 0x81                // STA ZP.XIDH                       stacks.asm:80
0x93EB  0x60            RTS                     // }                                 stacks.asm:81

// /source/runtime/6502/stacks.asm:83
// ####  Stacks.PushXID()  ####                                                 0x00A8

0x93EC  0xA4 0x05       LDY 0x05                // LDY ZP.CSP                        stacks.asm:84
0x93EE  0xA5 0x80       LDA 0x80                // LDA ZP.XIDL                       stacks.asm:85
0x93F0  0x99 0x00 0x03  STA 0x0300,Y            // STA Address.CallStackLSB, Y       stacks.asm:86
0x93F3  0xA5 0x81       LDA 0x81                // LDA ZP.XIDH                       stacks.asm:87
0x93F5  0x99 0x00 0x04  STA 0x0400,Y            // STA Address.CallStackMSB, Y       stacks.asm:88
0x93F8  0xE6 0x05       INC 0x05                // INC ZP.CSP                        stacks.asm:89
0x93FA  0x60            RTS                     // }                                 stacks.asm:90

// /source/runtime/6502/stacks.asm:96
// ####  Stacks.GetStackTopBP()  ####                                           0x00A9

0x93FB  0x18            CLC                     // CLC                               stacks.asm:97
0x93FC  0x65 0x04       ADC 0x04                // ADC ZP.BP                         stacks.asm:98
0x93FE  0xA8            TAY                     // TAY                               stacks.asm:99
0x93FF  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackB0, Y       stacks.asm:100
0x9402  0x85 0x11       STA 0x11                // STA ZP.TOP0                       stacks.asm:101
0x9404  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackB1, Y       stacks.asm:102
0x9407  0x85 0x12       STA 0x12                // STA ZP.TOP1                       stacks.asm:103
0x9409  0xB9 0x00 0x08  LDA 0x0800,Y            // LDA Address.ValueStackB2, Y       stacks.asm:104
0x940C  0x85 0x13       STA 0x13                // STA ZP.TOP2                       stacks.asm:105
0x940E  0xB9 0x00 0x09  LDA 0x0900,Y            // LDA Address.ValueStackB3, Y       stacks.asm:106
0x9411  0x85 0x14       STA 0x14                // STA ZP.TOP3                       stacks.asm:107
0x9413  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStackLSB, Y       stacks.asm:108
0x9416  0x29 0x0F       AND # 0x0F              // AND #BASICType.TYPEMASK     Strip VAR bit
0x9418  0x85 0x15       STA 0x15                // STA ZP.TOPT                       stacks.asm:110
0x941A  0x60            RTS                     // }                                 stacks.asm:111

// /source/runtime/6502/stacks.asm:138
// ####  Stacks.GetStackTopSP()  ####                                           0x00AA

0x941B  0x18            CLC                     // CLC                               stacks.asm:139
0x941C  0x65 0x03       ADC 0x03                // ADC ZP.SP                         stacks.asm:140
0x941E  0xA8            TAY                     // TAY                               stacks.asm:141
0x941F  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackB0, Y       stacks.asm:142
0x9422  0x85 0x11       STA 0x11                // STA ZP.TOP0                       stacks.asm:143
0x9424  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackB1, Y       stacks.asm:144
0x9427  0x85 0x12       STA 0x12                // STA ZP.TOP1                       stacks.asm:145
0x9429  0xB9 0x00 0x08  LDA 0x0800,Y            // LDA Address.ValueStackB2, Y       stacks.asm:146
0x942C  0x85 0x13       STA 0x13                // STA ZP.TOP2                       stacks.asm:147
0x942E  0xB9 0x00 0x09  LDA 0x0900,Y            // LDA Address.ValueStackB3, Y       stacks.asm:148
0x9431  0x85 0x14       STA 0x14                // STA ZP.TOP3                       stacks.asm:149
0x9433  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStackLSB, Y       stacks.asm:150
0x9436  0x29 0x0F       AND # 0x0F              // AND #BASICType.TYPEMASK     Strip VAR bit
0x9438  0x85 0x15       STA 0x15                // STA ZP.TOPT                       stacks.asm:152
0x943A  0x60            RTS                     // }                                 stacks.asm:153

// /source/runtime/6502/stacks.asm:159
// ####  Stacks.GetStackNextSP()  ####                                          0x00AB

0x943B  0x18            CLC                     // CLC                               stacks.asm:160
0x943C  0x65 0x03       ADC 0x03                // ADC ZP.SP                         stacks.asm:161
0x943E  0xA8            TAY                     // TAY                               stacks.asm:162
0x943F  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackB0, Y       stacks.asm:163
0x9442  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      stacks.asm:164
0x9444  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackB1, Y       stacks.asm:165
0x9447  0x85 0x17       STA 0x17                // STA ZP.NEXT1                      stacks.asm:166
0x9449  0xB9 0x00 0x08  LDA 0x0800,Y            // LDA Address.ValueStackB2, Y       stacks.asm:167
0x944C  0x85 0x18       STA 0x18                // STA ZP.NEXT2                      stacks.asm:168
0x944E  0xB9 0x00 0x09  LDA 0x0900,Y            // LDA Address.ValueStackB3, Y       stacks.asm:169
0x9451  0x85 0x19       STA 0x19                // STA ZP.NEXT3                      stacks.asm:170
0x9453  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStackLSB, Y       stacks.asm:171
0x9456  0x29 0x0F       AND # 0x0F              // AND #BASICType.TYPEMASK     Strip VAR bit
0x9458  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT                      stacks.asm:173
0x945A  0x60            RTS                     // }                                 stacks.asm:174

// /source/runtime/6502/stacks.asm:179
// ####  Stacks.SetStackTopBP()  ####                                           0x00AC

0x945B  0x18            CLC                     // CLC                               stacks.asm:180
0x945C  0x65 0x04       ADC 0x04                // ADC ZP.BP                         stacks.asm:181
0x945E  0xA8            TAY                     // TAY                               stacks.asm:182
0x945F  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       stacks.asm:183
0x9461  0x99 0x00 0x06  STA 0x0600,Y            // STA Address.ValueStackB0, Y       stacks.asm:184
0x9464  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       stacks.asm:185
0x9466  0x99 0x00 0x07  STA 0x0700,Y            // STA Address.ValueStackB1, Y       stacks.asm:186
0x9469  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       stacks.asm:187
0x946B  0x99 0x00 0x08  STA 0x0800,Y            // STA Address.ValueStackB2, Y       stacks.asm:188
0x946E  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       stacks.asm:189
0x9470  0x99 0x00 0x09  STA 0x0900,Y            // STA Address.ValueStackB3, Y       stacks.asm:190
0x9473  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       stacks.asm:191
0x9475  0x99 0x00 0x05  STA 0x0500,Y            // STA Address.TypeStackLSB, Y       stacks.asm:192
0x9478  0x60            RTS                     // }                                 stacks.asm:193

// /source/runtime/6502/stacks.asm:197
// ####  Stacks.PopTop()  ####                                                  0x00AD

0x9479  0xC6 0x03       DEC 0x03                // DEC ZP.SP                         stacks.asm:198
0x947B  0xA6 0x03       LDX 0x03                // LDX ZP.SP                         stacks.asm:199
0x947D  0xBD 0x00 0x06  LDA 0x0600,X            // LDA Address.ValueStackLSB, X      stacks.asm:200
0x9480  0x85 0x11       STA 0x11                // STA ZP.TOPL                       stacks.asm:201
0x9482  0xBD 0x00 0x07  LDA 0x0700,X            // LDA Address.ValueStackMSB, X      stacks.asm:202
0x9485  0x85 0x12       STA 0x12                // STA ZP.TOPH                       stacks.asm:203
0x9487  0xBD 0x00 0x05  LDA 0x0500,X            // LDA Address.TypeStackLSB, X       stacks.asm:204
0x948A  0x85 0x15       STA 0x15                // STA ZP.TOPT                       stacks.asm:205
0x948C  0x60            RTS                     // }                                 stacks.asm:206

// /source/runtime/6502/stacks.asm:208
// ####  Stacks.PopNext()  ####                                                 0x00AE

0x948D  0xC6 0x03       DEC 0x03                // DEC ZP.SP                         stacks.asm:209
0x948F  0xA6 0x03       LDX 0x03                // LDX ZP.SP                         stacks.asm:210
0x9491  0xBD 0x00 0x06  LDA 0x0600,X            // LDA Address.ValueStackLSB, X      stacks.asm:211
0x9494  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      stacks.asm:212
0x9496  0xBD 0x00 0x07  LDA 0x0700,X            // LDA Address.ValueStackMSB, X      stacks.asm:213
0x9499  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      stacks.asm:214
0x949B  0xBD 0x00 0x05  LDA 0x0500,X            // LDA Address.TypeStackLSB, X       stacks.asm:215
0x949E  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT                      stacks.asm:216
0x94A0  0x60            RTS                     // }                                 stacks.asm:217

// /source/runtime/6502/stacks.asm:220
// ####  Stacks.PushTop()  ####                                                 0x00AF

0x94A1  0xA4 0x03       LDY 0x03                // LDY ZP.SP                         stacks.asm:221
0x94A3  0x99 0x00 0x05  STA 0x0500,Y            // STA Address.TypeStackLSB, Y       stacks.asm:222
0x94A6  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       stacks.asm:223
0x94A8  0x99 0x00 0x06  STA 0x0600,Y            // STA Address.ValueStackLSB, Y      stacks.asm:224
0x94AB  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       stacks.asm:225
0x94AD  0x99 0x00 0x07  STA 0x0700,Y            // STA Address.ValueStackMSB, Y      stacks.asm:226
0x94B0  0xE6 0x03       INC 0x03                // INC ZP.SP                         stacks.asm:227
0x94B2  0x60            RTS                     // }                                 stacks.asm:228

// /source/runtime/6502/stacks.asm:240
// ####  Stacks.PopTopNext()  ####                                              0x00B1

0x94B3  0xA6 0x03       LDX 0x03                // LDX ZP.SP                         stacks.asm:242
0x94B5  0xCA            DEX                     // DEX                               stacks.asm:243
0x94B6  0xBD 0x00 0x06  LDA 0x0600,X            // LDA Address.ValueStackLSB, X      stacks.asm:244
0x94B9  0x85 0x11       STA 0x11                // STA ZP.TOPL                       stacks.asm:245
0x94BB  0xBD 0x00 0x07  LDA 0x0700,X            // LDA Address.ValueStackMSB, X      stacks.asm:246
0x94BE  0x85 0x12       STA 0x12                // STA ZP.TOPH                       stacks.asm:247
0x94C0  0xBD 0x00 0x05  LDA 0x0500,X            // LDA Address.TypeStackLSB, X       stacks.asm:248
0x94C3  0x85 0x15       STA 0x15                // STA ZP.TOPT                       stacks.asm:249
0x94C5  0xCA            DEX                     // DEX                               stacks.asm:251
0x94C6  0x86 0x03       STX 0x03                // STX ZP.SP                         stacks.asm:252
0x94C8  0xBD 0x00 0x06  LDA 0x0600,X            // LDA Address.ValueStackLSB, X      stacks.asm:253
0x94CB  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      stacks.asm:254
0x94CD  0xBD 0x00 0x07  LDA 0x0700,X            // LDA Address.ValueStackMSB, X      stacks.asm:255
0x94D0  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      stacks.asm:256
0x94D2  0xBD 0x00 0x05  LDA 0x0500,X            // LDA Address.TypeStackLSB, X       stacks.asm:257
0x94D5  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT                      stacks.asm:258
0x94D7  0x60            RTS                     // }                                 stacks.asm:263

// /source/runtime/6502/stacks.asm:265
// ####  Stacks.PushNext()  ####                                                0x00B2

0x94D8  0xA4 0x03       LDY 0x03                // LDY ZP.SP                         stacks.asm:266
0x94DA  0x99 0x00 0x05  STA 0x0500,Y            // STA Address.TypeStackLSB, Y       stacks.asm:267
0x94DD  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      stacks.asm:268
0x94DF  0x99 0x00 0x06  STA 0x0600,Y            // STA Address.ValueStackLSB, Y      stacks.asm:269
0x94E2  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      stacks.asm:270
0x94E4  0x99 0x00 0x07  STA 0x0700,Y            // STA Address.ValueStackMSB, Y      stacks.asm:271
0x94E7  0xE6 0x03       INC 0x03                // INC ZP.SP                         stacks.asm:272
0x94E9  0x60            RTS                     // }                                 stacks.asm:273

// /source/runtime/6502/stacks.asm:286
// ####  Stacks.PushX()  ####                                                   0x00B4

0x94EA  0x86 0x16       STX 0x16                // STX ZP.NEXTL                      stacks.asm:288
0x94EC  0x64 0x17       STZ 0x17                // STZ ZP.NEXTH                      stacks.asm:290
0x94EE  0xA9 0x06       LDA # 0x06              // LDA #Types.Bool                   stacks.asm:295
0x94F0  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT                      stacks.asm:296
0x94F2  0x4C 0xD8 0x94  JMP 0x94D8              // PushNext();                       stacks.asm:297

// /source/runtime/6502/stacks.asm:313
// ####  Stacks.PopIDX()  ####                                                  0x00B6

0x94F5  0xC6 0x03       DEC 0x03                // DEC ZP.SP                         stacks.asm:314
0x94F7  0xA4 0x03       LDY 0x03                // LDY ZP.SP                         stacks.asm:315
0x94F9  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackLSB, Y      stacks.asm:316
0x94FC  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       stacks.asm:317
0x94FE  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackMSB, Y      stacks.asm:318
0x9501  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       stacks.asm:319
0x9503  0x60            RTS                     // }                                 stacks.asm:320

// /source/runtime/6502/stacks.asm:332
// ####  Stacks.PopA()  ####                                                    0x00B8

0x9504  0xC6 0x03       DEC 0x03                // DEC ZP.SP                         stacks.asm:333
0x9506  0xA4 0x03       LDY 0x03                // LDY ZP.SP                         stacks.asm:334
0x9508  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackLSB, Y      stacks.asm:335
0x950B  0x60            RTS                     // }                                 stacks.asm:336

// /source/runtime/6502/time.asm:22
// ####  Time.DelayTOP()  ####                                                  0x00BA

0x950C  0x48            PHA                     // PHA                               time.asm:23
0x950D  0xDA            PHX                     // PHX                               time.asm:24
0x950E  0xA6 0x25       LDX 0x25                // LDX ZP.TICK3        reading TICK3 makes a snapshot of all 4 registers on the emulator
0x9510  0x18            CLC                     // CLC                               time.asm:29
0x9511  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       time.asm:30
0x9513  0x65 0x22       ADC 0x22                // ADC ZP.TICK0                      time.asm:31
0x9515  0x85 0x4F       STA 0x4F                // STA ZP.TARGET0                    time.asm:32
0x9517  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       time.asm:33
0x9519  0x65 0x23       ADC 0x23                // ADC ZP.TICK1                      time.asm:34
0x951B  0x85 0x50       STA 0x50                // STA ZP.TARGET1                    time.asm:35
0x951D  0xA5 0x24       LDA 0x24                // LDA ZP.TICK2                      time.asm:36
0x951F  0x69 0x00       ADC # 0                 // ADC #0    to collect the carry    time.asm:37
0x9521  0x85 0x51       STA 0x51                // STA ZP.TARGET2                    time.asm:38
0x9523  0x8A            TXA                     // TXA    restore ZP.TICK3           time.asm:39
0x9524  0x69 0x00       ADC # 0                 // ADC #0    to collect the carry    time.asm:40
0x9526  0x85 0x52       STA 0x52                // STA ZP.TARGET3                    time.asm:41
0x9528  0xA5 0x25       LDA 0x25                // LDA ZP.TICK3      reading TICK3 makes a snapshot of all 4 registers on the emulator
0x952A  0xC5 0x52       CMP 0x52                // CMP ZP.TARGET3                    time.asm:48
0x952C  0x90 0xFA       BCC 0x9528 (-6)         // if (NC) { continue; }             time.asm:49
0x952E  0xA5 0x24       LDA 0x24                // LDA ZP.TICK2                      time.asm:50
0x9530  0xC5 0x51       CMP 0x51                // CMP ZP.TARGET2                    time.asm:51
0x9532  0x90 0xF4       BCC 0x9528 (-12)        // if (NC) { continue; }             time.asm:52
0x9534  0xA5 0x23       LDA 0x23                // LDA ZP.TICK1                      time.asm:53
0x9536  0xC5 0x50       CMP 0x50                // CMP ZP.TARGET1                    time.asm:54
0x9538  0x90 0xEE       BCC 0x9528 (-18)        // if (NC) { continue; }             time.asm:55
0x953A  0xA5 0x22       LDA 0x22                // LDA ZP.TICK0                      time.asm:57
0x953C  0xC5 0x4F       CMP 0x4F                // CMP ZP.TARGET0                    time.asm:58
0x953E  0x90 0xE8       BCC 0x9528 (-24)        // if (NC) { continue; }             time.asm:59
0x9540  0xFA            PLX                     // PLX                               time.asm:64
0x9541  0x68            PLA                     // PLA                               time.asm:65
0x9542  0x60            RTS                     // }                                 time.asm:66

// /source/runtime/6502/devices/w65c22.asm:10
// ####  W65C22.initialize()  ####                                              0x00BF

0x9543  0x64 0xF3       STZ 0xF3                // STZ ZP.DDRA    set all pins on port A to input (good default in case we don't use it)
0x9545  0x64 0xF2       STZ 0xF2                // STZ ZP.DDRB    set all pins on port B to input (good default in case we don't use it)
0x9547  0xA9 0x40       LDA # 0x40              // LDA # 0b01000000    put the timer into free run mode
0x9549  0x85 0xFB       STA 0xFB                // STA ZP.ACR                        w65c22.asm:26
0x954B  0xA9 0xE8       LDA # 0xE8              // LDA # 0xE8                        w65c22.asm:29
0x954D  0x85 0x11       STA 0x11                // STA ZP.TOPL                       w65c22.asm:30
0x954F  0xA9 0x03       LDA # 0x03              // LDA # 0x03                        w65c22.asm:31
0x9551  0x85 0x12       STA 0x12                // STA ZP.TOPH                       w65c22.asm:32
0x9553  0x4C 0x72 0x95  JMP 0x9572              // sharedSamplesMicroSet();          w65c22.asm:34

// /source/runtime/6502/devices/w65c22.asm:38
// ####  W65C22.isr()  ####                                                     0x00C0

0x9556  0xFF 0xFD 0x01  BBS7 0xFD, 0x955A (+1)  // if (BBS7, ZP.IFR)    IRQ by VIA   w65c22.asm:40
0x9559  0x60            RTS
0x955A  0xEF 0xFD 0x01  BBS6 0xFD, 0x955E (+1)  // if (BBS6, ZP.IFR)    Timer 1 IRQ  w65c22.asm:42
0x955D  0x60            RTS
0x955E  0x24 0xF4       BIT 0xF4                // BIT  ZP.T1CL      clear the interrupt by reading T1 Counter L
0x9560  0xE6 0x22       INC 0x22                // INC  ZP.TICK0                     w65c22.asm:46
0x9562  0xF0 0x01       BEQ 0x9565 (+1)         // if (Z)                            w65c22.asm:47
0x9564  0x60            RTS
0x9565  0xE6 0x23       INC 0x23                // INC  ZP.TICK1                     w65c22.asm:49
0x9567  0xF0 0x01       BEQ 0x956A (+1)         // if (Z)                            w65c22.asm:50
0x9569  0x60            RTS
0x956A  0xE6 0x24       INC 0x24                // INC  ZP.TICK2                     w65c22.asm:52
0x956C  0xF0 0x01       BEQ 0x956F (+1)         // if (Z)                            w65c22.asm:53
0x956E  0x60            RTS
0x956F  0xE6 0x25       INC 0x25                // INC  ZP.TICK3                     w65c22.asm:55
0x9571  0x60            RTS                     // }                                 w65c22.asm:84

// /source/runtime/6502/devices/w65c22.asm:87
// ####  W65C22.sharedSamplesMicroSet()  ####                                   0x00C1

0x9572  0x64 0xFE       STZ 0xFE                // STA ZP.IER                        w65c22.asm:89
0x9574  0x06 0x11       ASL 0x11                // ASL ZP.TOPL                       w65c22.asm:94
0x9576  0x26 0x12       ROL 0x12                // ROL ZP.TOPH                       w65c22.asm:95
0x9578  0x06 0x11       ASL 0x11                // ASL ZP.TOPL                       w65c22.asm:99
0x957A  0x26 0x12       ROL 0x12                // ROL ZP.TOPH                       w65c22.asm:100
0x957C  0x06 0x11       ASL 0x11                // ASL ZP.TOPL                       w65c22.asm:104
0x957E  0x26 0x12       ROL 0x12                // ROL ZP.TOPH                       w65c22.asm:105
0x9580  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       w65c22.asm:109
0x9582  0xD0 0x02       BNE 0x9586 (+2)         // if (Z)                            w65c22.asm:110
0x9584  0xC6 0x12       DEC 0x12                // DEC ZP.TOPH                       w65c22.asm:112
0x9586  0xC6 0x11       DEC 0x11                // DEC ZP.TOPL                       w65c22.asm:114
0x9588  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       w65c22.asm:116
0x958A  0x85 0xF4       STA 0xF4                // STA ZP.T1CL                       w65c22.asm:117
0x958C  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       w65c22.asm:118
0x958E  0x85 0xF5       STA 0xF5                // STA ZP.T1CH                       w65c22.asm:119
0x9590  0x64 0x22       STZ 0x22                // STZ ZP.TICK0                      w65c22.asm:122
0x9592  0x64 0x23       STZ 0x23                // STZ ZP.TICK1                      w65c22.asm:123
0x9594  0x64 0x24       STZ 0x24                // STZ ZP.TICK2                      w65c22.asm:124
0x9596  0x64 0x25       STZ 0x25                // STZ ZP.TICK3                      w65c22.asm:125
0x9598  0xA9 0xC0       LDA # 0xC0              // LDA # 0b11000000    Set Timer1 bit in IER to put Timer1 into free run mode
0x959A  0x85 0xFE       STA 0xFE                // STA ZP.IER                        w65c22.asm:135
0x959C  0x60            RTS                     // }                                 w65c22.asm:136

// /source/projects/6502sbc/hopperbasic/utilities/print.asm:7
// ####  Print.String()  ####                                                   0x00C5

0x959D  0x48            PHA                     // PHA                               print.asm:8
0x959E  0x5A            PHY                     // PHY                               print.asm:9
0x959F  0xA0 0x00       LDY # 0                 // LDY #0                 Initialize string index
0x95A1  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y    Load character from string
0x95A3  0xF0 0x06       BEQ 0x95AB (+6)         // if (Z) { break; }    Exit if null terminator found
0x95A5  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();    Print the character
0x95A8  0xC8            INY                     // INY                Move to next character
0x95A9  0x80 0xF6       BRA 0x95A1 (-10)        // }                                 print.asm:19
0x95AB  0xE7 0x02       SMB6 0x02               // SMB6 ZP.FLAGS    Bit 6 - output was produced
0x95AD  0x7A            PLY                     // PLY                               print.asm:23
0x95AE  0x68            PLA                     // PLA                               print.asm:24
0x95AF  0x60            RTS                     // }                                 print.asm:25

// /source/projects/6502sbc/hopperbasic/utilities/print.asm:33
// ####  Print.Char()  ####                                                     0x00C6

0x95B0  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               print.asm:34
0x95B3  0xE7 0x02       SMB6 0x02               // SMB6 ZP.FLAGS    Bit 6 - output was produced
0x95B5  0x60            RTS                     // }                                 print.asm:37

// /source/projects/6502sbc/hopperbasic/utilities/print.asm:56
// ####  Print.NewLine()  ####                                                  0x00C8

0x95B6  0xA9 0x0A       LDA # 0x0A              // LDA #'\n'                         print.asm:57
0x95B8  0x4C 0x2B 0x8D  JMP 0x8D2B              // Serial.WriteChar();               print.asm:58

// /source/projects/6502sbc/hopperbasic/utilities/print.asm:66
// ####  Print.Space()  ####                                                    0x00C9

0x95BB  0xA9 0x20       LDA # 0x20              // LDA #' '                          print.asm:67
0x95BD  0x4C 0x2B 0x8D  JMP 0x8D2B              // Serial.WriteChar();               print.asm:68

// /source/projects/6502sbc/hopperbasic/utilities/print.asm:76
// ####  Print.Spaces()  ####                                                   0x00CA

0x95C0  0xDA            PHX                     // PHX                               print.asm:77
0x95C1  0xE0 0x00       CPX # 0                 // CPX #0                            print.asm:78
0x95C3  0xF0 0x08       BEQ 0x95CD (+8)         // if (NZ)                           print.asm:79
0x95C5  0xA9 0x20       LDA # 0x20              // LDA #' '                          print.asm:83
0x95C7  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               print.asm:84
0x95CA  0xCA            DEX                     // DEX                               print.asm:85
0x95CB  0xD0 0xF8       BNE 0x95C5 (-8)         // if (Z)    Set Z - counter reached 0
0x95CD  0xFA            PLX                     // PLX                               print.asm:92
0x95CE  0x60            RTS                     // }                                 print.asm:93

// /source/projects/6502sbc/hopperbasic/utilities/print.asm:103
// ####  Print.Decimal()  ####                                                  0x00CB

0x95CF  0x48            PHA                     // PHA                               print.asm:105
0x95D0  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       print.asm:106
0x95D2  0x48            PHA                     // PHA                               print.asm:107
0x95D3  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          print.asm:109
0x95D5  0x85 0x15       STA 0x15                // STA ZP.TOPT                       print.asm:110
0x95D7  0x20 0x1F 0x86  JSR 0x861F              // BASICTypes.Promote();    -> LONG  print.asm:111
0x95DA  0x20 0x70 0x9D  JSR 0x9D70              // Long.Print();                     print.asm:112
0x95DD  0x68            PLA                     // PLA                               print.asm:114
0x95DE  0x85 0x15       STA 0x15                // STA ZP.TOPT                       print.asm:115
0x95E0  0x68            PLA                     // PLA                               print.asm:116
0x95E1  0xE7 0x02       SMB6 0x02               // SMB6 ZP.FLAGS    Bit 6 - output was produced
0x95E3  0x60            RTS                     // }                                 print.asm:119

// /source/projects/6502sbc/hopperbasic/utilities/tools.asm:11
// ####  Tools.IsPrintable()  ####                                              0x00CC

0x95E4  0xC9 0x20       CMP # 0x20              // CMP #32                           tools.asm:14
0x95E6  0x90 0x06       BCC 0x95EE (+6)         // if (C)     >= 32                  tools.asm:15
0x95E8  0xC9 0x7F       CMP # 0x7F              // CMP #127                          tools.asm:17
0x95EA  0xB0 0x02       BCS 0x95EE (+2)         // if (NC)     <= 126                tools.asm:18
0x95EC  0x38            SEC                     // SEC                               tools.asm:20
0x95ED  0x60            RTS                     // break;                            tools.asm:21
0x95EE  0x18            CLC                     // CLC                               tools.asm:24
0x95EF  0x60            RTS                     // break;                            tools.asm:25

// /source/projects/6502sbc/hopperbasic/utilities/tools.asm:34
// ####  Tools.StringLength()  ####                                             0x00CD

0x95F0  0xDA            PHX                     // PHX                               tools.asm:35
0x95F1  0x5A            PHY                     // PHY                               tools.asm:36
0x95F2  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       tools.asm:39
0x95F4  0x48            PHA                     // PHA                               tools.asm:40
0x95F5  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       tools.asm:41
0x95F7  0x48            PHA                     // PHA                               tools.asm:42
0x95F8  0x86 0x11       STX 0x11                // STX ZP.TOPL                       tools.asm:44
0x95FA  0x84 0x12       STY 0x12                // STY ZP.TOPH                       tools.asm:45
0x95FC  0xA0 0x00       LDY # 0                 // LDY #0                            tools.asm:47
0x95FE  0xB1 0x11       LDA [0x11],Y            // LDA [ZP.TOP], Y                   tools.asm:50
0x9600  0xF0 0x03       BEQ 0x9605 (+3)         // if (Z) { break; }                 tools.asm:51
0x9602  0xC8            INY                     // INY                               tools.asm:52
0x9603  0x80 0xF9       BRA 0x95FE (-7)         // }                                 tools.asm:59
0x9605  0x68            PLA                     // PLA                               tools.asm:62
0x9606  0x85 0x12       STA 0x12                // STA ZP.TOPH                       tools.asm:63
0x9608  0x68            PLA                     // PLA                               tools.asm:64
0x9609  0x85 0x11       STA 0x11                // STA ZP.TOPL                       tools.asm:65
0x960B  0x98            TYA                     // TYA     Length in A               tools.asm:67
0x960C  0x7A            PLY                     // PLY                               tools.asm:69
0x960D  0xFA            PLX                     // PLX                               tools.asm:70
0x960E  0x60            RTS                     // }                                 tools.asm:71

// /source/projects/6502sbc/hopperbasic/utilities/tools.asm:78
// ####  Tools.StringCompare()  ####                                            0x00CE

0x960F  0x48            PHA                     // PHA                               tools.asm:79
0x9610  0x5A            PHY                     // PHY                               tools.asm:80
0x9611  0xA0 0x00       LDY # 0                 // LDY #0                            tools.asm:82
0x9613  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       tools.asm:86
0x9615  0xC5 0x16       CMP 0x16                // CMP ZP.NEXTL                      tools.asm:87
0x9617  0xD0 0x09       BNE 0x9622 (+9)         // if (Z)                            tools.asm:88
0x9619  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       tools.asm:90
0x961B  0xC5 0x17       CMP 0x17                // CMP ZP.NEXTH                      tools.asm:91
0x961D  0xD0 0x03       BNE 0x9622 (+3)         // if (Z)                            tools.asm:92
0x961F  0x38            SEC                     // SEC    Set C for match            tools.asm:95
0x9620  0x80 0x13       BRA 0x9635 (+19)        // break;                            tools.asm:96
0x9622  0xB1 0x11       LDA [0x11],Y            // LDA [ZP.TOP], Y                   tools.asm:99
0x9624  0xD1 0x16       CMP [0x16],Y            // CMP [ZP.NEXT], Y                  tools.asm:100
0x9626  0xF0 0x03       BEQ 0x962B (+3)         // if (NZ)                           tools.asm:101
0x9628  0x18            CLC                     // CLC     Set NC for mismatch       tools.asm:104
0x9629  0x80 0x0A       BRA 0x9635 (+10)        // break;                            tools.asm:105
0x962B  0xB1 0x11       LDA [0x11],Y            // LDA [ZP.TOP], Y                   tools.asm:109
0x962D  0xD0 0x03       BNE 0x9632 (+3)         // if (Z)                            tools.asm:110
0x962F  0x38            SEC                     // SEC     Set C for match           tools.asm:114
0x9630  0x80 0x03       BRA 0x9635 (+3)         // break;                            tools.asm:115
0x9632  0xC8            INY                     // INY                               tools.asm:118
0x9633  0x80 0xDE       BRA 0x9613 (-34)        // }                                 tools.asm:119
0x9635  0x7A            PLY                     // PLY                               tools.asm:121
0x9636  0x68            PLA                     // PLA                               tools.asm:122
0x9637  0x60            RTS                     // }                                 tools.asm:123

// /source/projects/6502sbc/hopperbasic/utilities/tools.asm:168
// ####  Tools.CreateTokenStream()  ####                                        0x00D0

0x9638  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       tools.asm:169
0x963A  0x48            PHA                     // PHA                               tools.asm:170
0x963B  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       tools.asm:171
0x963D  0x48            PHA                     // PHA                               tools.asm:172
0x963E  0xA5 0x65       LDA 0x65                // LDA ZP.FLENGTHL                   tools.asm:182
0x9640  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       tools.asm:183
0x9642  0xA5 0x66       LDA 0x66                // LDA ZP.FLENGTHH                   tools.asm:184
0x9644  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       tools.asm:185
0x9646  0x20 0x61 0x93  JSR 0x9361              // IncACC();    for the EOF          tools.asm:186
0x9649  0x20 0x97 0x92  JSR 0x9297              // Memory.Allocate();     Tools.CreateTokenStream(): Input: ZP.ACC = size, Munts: ZP.M*, ZP.FREELIST, ZP.ACCL, -> ZP.IDX
0x964C  0x90 0x21       BCC 0x966F (+33)        // if (NC) { BIT ZP.EmulatorPCL break; }
0x964E  0x18            CLC                     // CLC                               tools.asm:192
0x964F  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               tools.asm:193
0x9651  0x65 0x61       ADC 0x61                // ADC ZP.FSOURCEADDRESSL            tools.asm:194
0x9653  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            tools.asm:195
0x9655  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               tools.asm:196
0x9657  0x65 0x62       ADC 0x62                // ADC ZP.FSOURCEADDRESSH            tools.asm:197
0x9659  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            tools.asm:198
0x965B  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       tools.asm:203
0x965D  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       tools.asm:204
0x965F  0x85 0x63       STA 0x63                // STA ZP.FDESTINATIONADDRESSL       tools.asm:205
0x9661  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       tools.asm:206
0x9663  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       tools.asm:207
0x9665  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       tools.asm:208
0x9667  0x20 0x0B 0x93  JSR 0x930B              // Memory.Copy();    Munts: ZP.FSOURCEADDRESS, ZP.FDESTINATIONADDRESS, ZP.FLENGTH
0x966A  0xA9 0xDB       LDA # 0xDB              // LDA #Token.EOF                    tools.asm:214
0x966C  0x92 0x63       STA [0x63]              // STA [ZP.FDESTINATIONADDRESS]    Write EOF token
0x966E  0x38            SEC                     // SEC                               tools.asm:217
0x966F  0x68            PLA                     // PLA                               tools.asm:226
0x9670  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       tools.asm:227
0x9672  0x68            PLA                     // PLA                               tools.asm:228
0x9673  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       tools.asm:229
0x9675  0x60            RTS                     // }                                 tools.asm:230

// /source/projects/6502sbc/hopperbasic/utilities/tools.asm:237
// ####  Tools.ToUpperSTR()  ####                                               0x00D1

0x9676  0xA0 0x00       LDY # 0                 // LDY #0                            tools.asm:238
0x9678  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   tools.asm:241
0x967A  0xF0 0x0C       BEQ 0x9688 (+12)        // if (Z) { break; }     Null terminator
0x967C  0x20 0x4E 0x97  JSR 0x974E              // Char.IsLower();       preserves A tools.asm:243
0x967F  0x90 0x04       BCC 0x9685 (+4)         // if (C)                            tools.asm:244
0x9681  0x29 0xDF       AND # 0xDF              // AND #0xDF         Convert to uppercase by stripping bit 5
0x9683  0x91 0x79       STA [0x79],Y            // STA [ZP.STR], Y                   tools.asm:247
0x9685  0xC8            INY                     // INY                               tools.asm:249
0x9686  0xD0 0xF0       BNE 0x9678 (-16)        // if (Z) { break; }     Prevent overflow
0x9688  0x60            RTS                     // }                                 tools.asm:252

// /source/projects/6502sbc/hopperbasic/utilities/buffermanager.asm:4
// ####  BufferManager.InitializeForTokenGeneration()  ####                     0x00D2

0x9689  0x64 0x38       STZ 0x38                // STA ZP.TokenBufferL               buffermanager.asm:7
0x968B  0xA9 0x0C       LDA # 0x0C              // LDA #(Address.TokenizerBuffer / 256)
0x968D  0x85 0x39       STA 0x39                // STA ZP.TokenBufferH               buffermanager.asm:9
0x968F  0x20 0xA3 0xB9  JSR 0xB9A3              // Tokenizer.Initialize();           buffermanager.asm:10
0x9692  0x4C 0xE5 0x96  JMP 0x96E5              // BufferManager.ResetInputBuffer(); buffermanager.asm:11

// /source/projects/6502sbc/hopperbasic/utilities/buffermanager.asm:15
// ####  BufferManager.UseREPLOpCodeBuffer()  ####                              0x00D3

0x9695  0xB7 0x02       SMB3 0x02               // SMB3 ZP.FLAGS    Set REPL mode: we're using REPL buffers for compilation
0x9697  0x64 0x3A       STZ 0x3A                // STA ZP.OpCodeBufferL              buffermanager.asm:20
0x9699  0xA9 0x16       LDA # 0x16              // LDA #(Address.REPLOpCodeBuffer / 256)
0x969B  0x85 0x3B       STA 0x3B                // STA ZP.OpCodeBufferH              buffermanager.asm:22
0x969D  0x60            RTS                     // }                                 buffermanager.asm:36

// /source/projects/6502sbc/hopperbasic/utilities/buffermanager.asm:40
// ####  BufferManager.UseFunctionBuffers()  ####                               0x00D4

0x969E  0x37 0x02       RMB3 0x02               // RMB3 ZP.FLAGS    Clear REPL mode flag : using function buffers for compilation
0x96A0  0x64 0x3A       STZ 0x3A                // STA ZP.OpCodeBufferL              buffermanager.asm:45
0x96A2  0xA9 0x14       LDA # 0x14              // LDA #(Address.FunctionOpCodeBuffer / 256)
0x96A4  0x85 0x3B       STA 0x3B                // STA ZP.OpCodeBufferH              buffermanager.asm:47
0x96A6  0x20 0xC6 0xA7  JSR 0xA7C6              // Functions.GetBody();    Input: ZP.IDX = function node, Output: ZP.IDY = tokens pointer
0x96A9  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       buffermanager.asm:67
0x96AB  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       buffermanager.asm:68
0x96AD  0xD0 0x03       BNE 0x96B2 (+3)         // if (Z)                            buffermanager.asm:69
0x96AF  0x4C 0xCA 0x8B  JMP 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0x96B2  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       buffermanager.asm:76
0x96B4  0x85 0x38       STA 0x38                // STA ZP.TokenBufferL               buffermanager.asm:77
0x96B6  0x85 0x63       STA 0x63                // STA ZP.FDESTINATIONADDRESSL       buffermanager.asm:78
0x96B8  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       buffermanager.asm:79
0x96BA  0x85 0x39       STA 0x39                // STA ZP.TokenBufferH               buffermanager.asm:80
0x96BC  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       buffermanager.asm:81
0x96BE  0x64 0x65       STZ 0x65                // STZ ZP.FLENGTHL                   buffermanager.asm:84
0x96C0  0x64 0x66       STZ 0x66                // STZ ZP.FLENGTHH                   buffermanager.asm:85
0x96C2  0x20 0x89 0x93  JSR 0x9389              // IncLENGTH();                      buffermanager.asm:90
0x96C5  0xB2 0x1D       LDA [0x1D]              // LDA [ZP.IDY]                      buffermanager.asm:91
0x96C7  0xC9 0xDB       CMP # 0xDB              // CMP #Token.EOF                    buffermanager.asm:92
0x96C9  0xF0 0x08       BEQ 0x96D3 (+8)         // if (Z) { break; }                 buffermanager.asm:93
0x96CB  0x20 0x50 0x93  JSR 0x9350              // IncIDY();                         buffermanager.asm:94
0x96CE  0x20 0x81 0x93  JSR 0x9381              // IncDESTINATIONADDRESS();          buffermanager.asm:95
0x96D1  0x80 0xEF       BRA 0x96C2 (-17)        // }                                 buffermanager.asm:96
0x96D3  0xA5 0x65       LDA 0x65                // LDA ZP.FLENGTHL                      Length of function tokens
0x96D5  0x85 0x29       STA 0x29                // STA ZP.TokenBufferContentLengthL  buffermanager.asm:100
0x96D7  0xA5 0x66       LDA 0x66                // LDA ZP.FLENGTHH                   buffermanager.asm:101
0x96D9  0x85 0x2A       STA 0x2A                // STA ZP.TokenBufferContentLengthH  buffermanager.asm:102
0x96DB  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL             Start at beginning of function tokens
0x96DD  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              buffermanager.asm:105
0x96DF  0x60            RTS                     // break;                            buffermanager.asm:107

// /source/projects/6502sbc/hopperbasic/utilities/buffermanager.asm:112
// ####  BufferManager.ResetTokenizerBuffer()  ####                             0x00D5

0x96E0  0x64 0x29       STZ 0x29                // STZ ZP.TokenBufferContentLengthL  buffermanager.asm:113
0x96E2  0x64 0x2A       STZ 0x2A                // STZ ZP.TokenBufferContentLengthH  buffermanager.asm:114
0x96E4  0x60            RTS                     // }                                 buffermanager.asm:127

// /source/projects/6502sbc/hopperbasic/utilities/buffermanager.asm:129
// ####  BufferManager.ResetInputBuffer()  ####                                 0x00D6

0x96E5  0x08            PHP                     // PHP                               buffermanager.asm:130
0x96E6  0x64 0x28       STZ 0x28                // STZ ZP.BasicInputLength           buffermanager.asm:132
0x96E8  0x28            PLP                     // PLP                               buffermanager.asm:144
0x96E9  0x60            RTS                     // }                                 buffermanager.asm:145

// /source/projects/6502sbc/hopperbasic/objects/char.asm:18
// ####  Char.getCharClass()  ####                                              0x00D8

0x96EA  0xC9 0x30       CMP # 0x30              // CMP #'0'                          char.asm:21
0x96EC  0x90 0x07       BCC 0x96F5 (+7)         // if (C)                            char.asm:22
0x96EE  0xC9 0x3A       CMP # 0x3A              // CMP #('9'+1)                      char.asm:24
0x96F0  0xB0 0x03       BCS 0x96F5 (+3)         // if (NC) { LDA # (CharClass.Digit | CharClass.Hex) break; }
0x96F2  0xA9 0x05       LDA # 0x05
0x96F4  0x60            RTS
0x96F5  0xC9 0x41       CMP # 0x41              // CMP #'A'                          char.asm:27
0x96F7  0x90 0x07       BCC 0x9700 (+7)         // if (C)                            char.asm:28
0x96F9  0xC9 0x47       CMP # 0x47              // CMP #('F'+1)                      char.asm:30
0x96FB  0xB0 0x03       BCS 0x9700 (+3)         // if (NC) { LDA # (CharClass.Alpha | CharClass.Upper | CharClass.Hex) break; }
0x96FD  0xA9 0x16       LDA # 0x16
0x96FF  0x60            RTS
0x9700  0xC9 0x47       CMP # 0x47              // CMP #'G'                          char.asm:33
0x9702  0x90 0x07       BCC 0x970B (+7)         // if (C)                            char.asm:34
0x9704  0xC9 0x5B       CMP # 0x5B              // CMP #('Z'+1)                      char.asm:36
0x9706  0xB0 0x03       BCS 0x970B (+3)         // if (NC) { LDA # (CharClass.Alpha | CharClass.Upper) break; }
0x9708  0xA9 0x12       LDA # 0x12
0x970A  0x60            RTS
0x970B  0xC9 0x61       CMP # 0x61              // CMP #'a'                          char.asm:39
0x970D  0x90 0x07       BCC 0x9716 (+7)         // if (C)                            char.asm:40
0x970F  0xC9 0x67       CMP # 0x67              // CMP #('f'+1)                      char.asm:42
0x9711  0xB0 0x03       BCS 0x9716 (+3)         // if (NC) { LDA # (CharClass.Alpha | CharClass.Lower | CharClass.Hex) break; }
0x9713  0xA9 0x0E       LDA # 0x0E
0x9715  0x60            RTS
0x9716  0xC9 0x67       CMP # 0x67              // CMP #'g'                          char.asm:45
0x9718  0x90 0x07       BCC 0x9721 (+7)         // if (C)                            char.asm:46
0x971A  0xC9 0x7B       CMP # 0x7B              // CMP #('z'+1)                      char.asm:48
0x971C  0xB0 0x03       BCS 0x9721 (+3)         // if (NC) { LDA # (CharClass.Alpha | CharClass.Lower) break; }
0x971E  0xA9 0x0A       LDA # 0x0A
0x9720  0x60            RTS
0x9721  0xA9 0x00       LDA # 0                 // LDA # CharClass.Other             char.asm:51
0x9723  0x60            RTS                     // break;                            char.asm:52

// /source/projects/6502sbc/hopperbasic/objects/char.asm:59
// ####  Char.IsDigit()  ####                                                   0x00D9

0x9724  0x48            PHA                     // PHA                               char.asm:60
0x9725  0x20 0xEA 0x96  JSR 0x96EA              // getCharClass();                   char.asm:61
0x9728  0x29 0x01       AND # 1                 // AND # CharClass.Digit             char.asm:62
0x972A  0xF0 0x03       BEQ 0x972F (+3)         // if (NZ)                           char.asm:63
0x972C  0x38            SEC                     // SEC    '0'..'9'                   char.asm:65
0x972D  0x80 0x01       BRA 0x9730 (+1)         // }                                 char.asm:66
0x972F  0x18            CLC                     // CLC                               char.asm:69
0x9730  0x68            PLA                     // PLA                               char.asm:71
0x9731  0x60            RTS                     // }                                 char.asm:72

// /source/projects/6502sbc/hopperbasic/objects/char.asm:77
// ####  Char.IsAlpha()  ####                                                   0x00DA

0x9732  0x48            PHA                     // PHA                               char.asm:78
0x9733  0x20 0xEA 0x96  JSR 0x96EA              // getCharClass();                   char.asm:79
0x9736  0x29 0x02       AND # 0x02              // AND # CharClass.Alpha             char.asm:80
0x9738  0xF0 0x03       BEQ 0x973D (+3)         // if (NZ)                           char.asm:81
0x973A  0x38            SEC                     // SEC    'a'..'z' | 'A'..'Z'        char.asm:83
0x973B  0x80 0x01       BRA 0x973E (+1)         // }                                 char.asm:84
0x973D  0x18            CLC                     // CLC                               char.asm:87
0x973E  0x68            PLA                     // PLA                               char.asm:89
0x973F  0x60            RTS                     // }                                 char.asm:90

// /source/projects/6502sbc/hopperbasic/objects/char.asm:95
// ####  Char.IsAlphaNumeric()  ####                                            0x00DB

0x9740  0x48            PHA                     // PHA                               char.asm:96
0x9741  0x20 0xEA 0x96  JSR 0x96EA              // getCharClass();                   char.asm:97
0x9744  0x29 0x03       AND # 0x03              // AND # (CharClass.Alpha|CharClass.Digit)
0x9746  0xF0 0x03       BEQ 0x974B (+3)         // if (NZ)                           char.asm:99
0x9748  0x38            SEC                     // SEC    'a'..'z' | 'A'..'Z'        char.asm:101
0x9749  0x80 0x01       BRA 0x974C (+1)         // }                                 char.asm:102
0x974B  0x18            CLC                     // CLC                               char.asm:105
0x974C  0x68            PLA                     // PLA                               char.asm:107
0x974D  0x60            RTS                     // }                                 char.asm:108

// /source/projects/6502sbc/hopperbasic/objects/char.asm:113
// ####  Char.IsLower()  ####                                                   0x00DC

0x974E  0x48            PHA                     // PHA                               char.asm:114
0x974F  0x20 0xEA 0x96  JSR 0x96EA              // getCharClass();                   char.asm:115
0x9752  0x29 0x08       AND # 0x08              // AND # CharClass.Lower             char.asm:116
0x9754  0xF0 0x03       BEQ 0x9759 (+3)         // if (NZ)                           char.asm:117
0x9756  0x38            SEC                     // SEC    'a'..'z'                   char.asm:119
0x9757  0x80 0x01       BRA 0x975A (+1)         // }                                 char.asm:120
0x9759  0x18            CLC                     // CLC                               char.asm:123
0x975A  0x68            PLA                     // PLA                               char.asm:125
0x975B  0x60            RTS                     // }                                 char.asm:126

// /source/projects/6502sbc/hopperbasic/objects/char.asm:131
// ####  Char.IsHex()  ####                                                     0x00DD

0x975C  0x48            PHA                     // PHA                               char.asm:132
0x975D  0x20 0xEA 0x96  JSR 0x96EA              // getCharClass();                   char.asm:133
0x9760  0x29 0x04       AND # 0x04              // AND # CharClass.Hex               char.asm:134
0x9762  0xF0 0x03       BEQ 0x9767 (+3)         // if (NZ)                           char.asm:135
0x9764  0x38            SEC                     // SEC                               char.asm:137
0x9765  0x80 0x01       BRA 0x9768 (+1)         // }                                 char.asm:138
0x9767  0x18            CLC                     // CLC                               char.asm:141
0x9768  0x68            PLA                     // PLA                               char.asm:143
0x9769  0x60            RTS                     // }                                 char.asm:144

// /source/projects/6502sbc/hopperbasic/objects/long.asm:7
// ####  Long.PushTop()  ####                                                   0x00DE

0x976A  0xA4 0x03       LDY 0x03                // LDY ZP.SP                       Current stack pointer
0x976C  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       long.asm:11
0x976E  0x99 0x00 0x05  STA 0x0500,Y            // STA TypeStack, Y               Store type
0x9771  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       long.asm:14
0x9773  0x99 0x00 0x06  STA 0x0600,Y            // STA ValueStackB0,Y             Store byte 0 (LSB)
0x9776  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       long.asm:16
0x9778  0x99 0x00 0x07  STA 0x0700,Y            // STA ValueStackB1,Y             Store byte 1
0x977B  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       long.asm:19
0x977D  0x99 0x00 0x08  STA 0x0800,Y            // STA ValueStackB2,Y             Store byte 2
0x9780  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       long.asm:21
0x9782  0x99 0x00 0x09  STA 0x0900,Y            // STA ValueStackB3,Y             Store byte 3 (MSB)
0x9785  0xE6 0x03       INC 0x03                // INC ZP.SP                      Advance stack pointer
0x9787  0x38            SEC                     // SEC                               long.asm:26
0x9788  0x60            RTS                     // break;                            long.asm:27

// /source/projects/6502sbc/hopperbasic/objects/long.asm:32
// ####  Long.PushTopStrictLONG()  ####                                         0x00DF

0x9789  0xA9 0x08       LDA # 0x08              // LDA # BASICType.LONG              long.asm:33
0x978B  0x85 0x15       STA 0x15                // STA ZP.TOPT                       long.asm:34
0x978D  0x4C 0x6A 0x97  JMP 0x976A              // Long.PushTopStrict();             long.asm:35

// /source/projects/6502sbc/hopperbasic/objects/long.asm:38
// ####  Long.LoadTopByte()  ####                                               0x00E0

0x9790  0x85 0x11       STA 0x11                // STA ZP.TOP0                       long.asm:39
0x9792  0x4C 0x9A 0x97  JMP 0x979A              // Long.ZeroTop3();                  long.asm:40

// /source/projects/6502sbc/hopperbasic/objects/long.asm:43
// ####  Long.ZeroTop()  ####                                                   0x00E1

0x9795  0x64 0x11       STZ 0x11                // STZ ZP.TOP0                       long.asm:44
0x9797  0x4C 0x9A 0x97  JMP 0x979A              // ZeroTop3();                       long.asm:45

// /source/projects/6502sbc/hopperbasic/objects/long.asm:48
// ####  Long.ZeroTop3()  ####                                                  0x00E2

0x979A  0x64 0x12       STZ 0x12                // STZ ZP.TOP1                       long.asm:49
0x979C  0x64 0x13       STZ 0x13                // STZ ZP.TOP2                       long.asm:50
0x979E  0x64 0x14       STZ 0x14                // STZ ZP.TOP3                       long.asm:51
0x97A0  0x60            RTS                     // }                                 long.asm:52

// /source/projects/6502sbc/hopperbasic/objects/long.asm:54
// ####  Long.ZeroNext()  ####                                                  0x00E3

0x97A1  0x64 0x16       STZ 0x16                // STZ ZP.NEXT0                      long.asm:55
0x97A3  0x4C 0xA6 0x97  JMP 0x97A6              // ZeroNext3();                      long.asm:56

// /source/projects/6502sbc/hopperbasic/objects/long.asm:59
// ####  Long.ZeroNext3()  ####                                                 0x00E4

0x97A6  0x64 0x17       STZ 0x17                // STZ ZP.NEXT1                      long.asm:60
0x97A8  0x64 0x18       STZ 0x18                // STZ ZP.NEXT2                      long.asm:61
0x97AA  0x64 0x19       STZ 0x19                // STZ ZP.NEXT3                      long.asm:62
0x97AC  0x60            RTS                     // }                                 long.asm:63

// /source/projects/6502sbc/hopperbasic/objects/long.asm:65
// ####  Long.ZeroCheckTop()  ####                                              0x00E5

0x97AD  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       long.asm:66
0x97AF  0x05 0x12       ORA 0x12                // ORA ZP.TOP1                       long.asm:67
0x97B1  0x05 0x13       ORA 0x13                // ORA ZP.TOP2                       long.asm:68
0x97B3  0x05 0x14       ORA 0x14                // ORA ZP.TOP3                       long.asm:69
0x97B5  0x60            RTS                     // }                                 long.asm:70

// /source/projects/6502sbc/hopperbasic/objects/long.asm:72
// ####  Long.ZeroCheckNext()  ####                                             0x00E6

0x97B6  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      long.asm:73
0x97B8  0x05 0x17       ORA 0x17                // ORA ZP.NEXT1                      long.asm:74
0x97BA  0x05 0x18       ORA 0x18                // ORA ZP.NEXT2                      long.asm:75
0x97BC  0x05 0x19       ORA 0x19                // ORA ZP.NEXT3                      long.asm:76
0x97BE  0x60            RTS                     // }                                 long.asm:77

// /source/projects/6502sbc/hopperbasic/objects/long.asm:80
// ####  Long.zeroResult()  ####                                                0x00E7

0x97BF  0x64 0x4F       STZ 0x4F                // STZ ZP.RESULT0                    long.asm:81
0x97C1  0x64 0x50       STZ 0x50                // STZ ZP.RESULT1                    long.asm:82
0x97C3  0x64 0x51       STZ 0x51                // STZ ZP.RESULT2                    long.asm:83
0x97C5  0x64 0x52       STZ 0x52                // STZ ZP.RESULT3                    long.asm:84
0x97C7  0x60            RTS                     // }                                 long.asm:85

// /source/projects/6502sbc/hopperbasic/objects/long.asm:87
// ####  Long.zeroResult8()  ####                                               0x00E8

0x97C8  0x20 0xBF 0x97  JSR 0x97BF              // zeroResult();                     long.asm:88
0x97CB  0x64 0x53       STZ 0x53                // STZ ZP.RESULT4                    long.asm:89
0x97CD  0x64 0x54       STZ 0x54                // STZ ZP.RESULT5                    long.asm:90
0x97CF  0x64 0x55       STZ 0x55                // STZ ZP.RESULT6                    long.asm:91
0x97D1  0x64 0x56       STZ 0x56                // STZ ZP.RESULT7                    long.asm:92
0x97D3  0x60            RTS                     // }                                 long.asm:93

// /source/projects/6502sbc/hopperbasic/objects/long.asm:96
// ####  Long.moveNextToResult()  ####                                          0x00E9

0x97D4  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      long.asm:97
0x97D6  0x85 0x4F       STA 0x4F                // STA ZP.RESULT0                    long.asm:98
0x97D8  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      long.asm:99
0x97DA  0x85 0x50       STA 0x50                // STA ZP.RESULT1                    long.asm:100
0x97DC  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      long.asm:101
0x97DE  0x85 0x51       STA 0x51                // STA ZP.RESULT2                    long.asm:102
0x97E0  0xA5 0x19       LDA 0x19                // LDA ZP.NEXT3                      long.asm:103
0x97E2  0x85 0x52       STA 0x52                // STA ZP.RESULT3                    long.asm:104
0x97E4  0x60            RTS                     // }                                 long.asm:105

// /source/projects/6502sbc/hopperbasic/objects/long.asm:118
// ####  Long.moveTopToNext()  ####                                             0x00EB

0x97E5  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       long.asm:119
0x97E7  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      long.asm:120
0x97E9  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       long.asm:121
0x97EB  0x85 0x17       STA 0x17                // STA ZP.NEXT1                      long.asm:122
0x97ED  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       long.asm:123
0x97EF  0x85 0x18       STA 0x18                // STA ZP.NEXT2                      long.asm:124
0x97F1  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       long.asm:125
0x97F3  0x85 0x19       STA 0x19                // STA ZP.NEXT3                      long.asm:126
0x97F5  0x60            RTS                     // }                                 long.asm:127

// /source/projects/6502sbc/hopperbasic/objects/long.asm:129
// ####  Long.moveResultToTop()  ####                                           0x00EC

0x97F6  0xA5 0x4F       LDA 0x4F                // LDA ZP.RESULT0                    long.asm:130
0x97F8  0x85 0x11       STA 0x11                // STA ZP.TOP0                       long.asm:131
0x97FA  0xA5 0x50       LDA 0x50                // LDA ZP.RESULT1                    long.asm:132
0x97FC  0x85 0x12       STA 0x12                // STA ZP.TOP1                       long.asm:133
0x97FE  0xA5 0x51       LDA 0x51                // LDA ZP.RESULT2                    long.asm:134
0x9800  0x85 0x13       STA 0x13                // STA ZP.TOP2                       long.asm:135
0x9802  0xA5 0x52       LDA 0x52                // LDA ZP.RESULT3                    long.asm:136
0x9804  0x85 0x14       STA 0x14                // STA ZP.TOP3                       long.asm:137
0x9806  0x60            RTS                     // }                                 long.asm:138

// /source/projects/6502sbc/hopperbasic/objects/long.asm:140
// ####  Long.moveResultToNext()  ####                                          0x00ED

0x9807  0xA5 0x4F       LDA 0x4F                // LDA ZP.RESULT0                    long.asm:141
0x9809  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      long.asm:142
0x980B  0xA5 0x50       LDA 0x50                // LDA ZP.RESULT1                    long.asm:143
0x980D  0x85 0x17       STA 0x17                // STA ZP.NEXT1                      long.asm:144
0x980F  0xA5 0x51       LDA 0x51                // LDA ZP.RESULT2                    long.asm:145
0x9811  0x85 0x18       STA 0x18                // STA ZP.NEXT2                      long.asm:146
0x9813  0xA5 0x52       LDA 0x52                // LDA ZP.RESULT3                    long.asm:147
0x9815  0x85 0x19       STA 0x19                // STA ZP.NEXT3                      long.asm:148
0x9817  0x60            RTS                     // }                                 long.asm:149

// /source/projects/6502sbc/hopperbasic/objects/long.asm:151
// ####  Long.commonSwapNEXTTOP()  ####                                         0x00EE

0x9818  0xA4 0x11       LDY 0x11                // LDY ZP.TOP0                       long.asm:152
0x981A  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      long.asm:153
0x981C  0x85 0x11       STA 0x11                // STA ZP.TOP0                       long.asm:154
0x981E  0x84 0x16       STY 0x16                // STY ZP.NEXT0                      long.asm:155
0x9820  0xA4 0x12       LDY 0x12                // LDY ZP.TOP1                       long.asm:157
0x9822  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      long.asm:158
0x9824  0x85 0x12       STA 0x12                // STA ZP.TOP1                       long.asm:159
0x9826  0x84 0x17       STY 0x17                // STY ZP.NEXT1                      long.asm:160
0x9828  0xA4 0x13       LDY 0x13                // LDY ZP.TOP2                       long.asm:162
0x982A  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      long.asm:163
0x982C  0x85 0x13       STA 0x13                // STA ZP.TOP2                       long.asm:164
0x982E  0x84 0x18       STY 0x18                // STY ZP.NEXT2                      long.asm:165
0x9830  0xA4 0x14       LDY 0x14                // LDY ZP.TOP3                       long.asm:167
0x9832  0xA5 0x19       LDA 0x19                // LDA ZP.NEXT3                      long.asm:168
0x9834  0x85 0x14       STA 0x14                // STA ZP.TOP3                       long.asm:169
0x9836  0x84 0x19       STY 0x19                // STY ZP.NEXT3                      long.asm:170
0x9838  0x60            RTS                     // }                                 long.asm:171

// /source/projects/6502sbc/hopperbasic/objects/long.asm:174
// ####  Long.shiftNEXTleft()  ####                                             0x00EF

0x9839  0x06 0x16       ASL 0x16                // ASL ZP.NEXT0                      long.asm:175
0x983B  0x26 0x17       ROL 0x17                // ROL ZP.NEXT1                      long.asm:176
0x983D  0x26 0x18       ROL 0x18                // ROL ZP.NEXT2                      long.asm:177
0x983F  0x26 0x19       ROL 0x19                // ROL ZP.NEXT3                      long.asm:178
0x9841  0x26 0x53       ROL 0x53                // ROL ZP.RESULT4                    long.asm:179
0x9843  0x26 0x54       ROL 0x54                // ROL ZP.RESULT5                    long.asm:180
0x9845  0x26 0x55       ROL 0x55                // ROL ZP.RESULT6                    long.asm:181
0x9847  0x26 0x56       ROL 0x56                // ROL ZP.RESULT7                    long.asm:182
0x9849  0xB0 0x01       BCS 0x984C (+1)         // if (C)                            long.asm:184
0x984B  0x60            RTS
0x984C  0x4C 0x10 0x8C  JMP 0x8C10              // Error.NumericOverflow();          long.asm:186

// /source/projects/6502sbc/hopperbasic/objects/long.asm:191
// ####  Long.shiftNEXTright()  ####                                            0x00F0

0x984F  0x46 0x19       LSR 0x19                // LSR ZP.NEXT3                      long.asm:192
0x9851  0x66 0x18       ROR 0x18                // ROR ZP.NEXT2                      long.asm:193
0x9853  0x66 0x17       ROR 0x17                // ROR ZP.NEXT1                      long.asm:194
0x9855  0x66 0x16       ROR 0x16                // ROR ZP.NEXT0                      long.asm:195
0x9857  0x60            RTS                     // }                                 long.asm:196

// /source/projects/6502sbc/hopperbasic/objects/long.asm:243
// ####  Long.PushNext()  ####                                                  0x00F2

0x9858  0xA4 0x03       LDY 0x03                // LDY ZP.SP                       Current stack pointer
0x985A  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      long.asm:247
0x985C  0xBF 0x1A 0x03  BBS3 0x1A, 0x9862 (+3)  // if (BBR3, ZP.NEXTT)               long.asm:249
0x985F  0x4C 0xED 0x8B  JMP 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0x9862  0x99 0x00 0x05  STA 0x0500,Y            // STA TypeStack, Y              Store type
0x9865  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      long.asm:256
0x9867  0x99 0x00 0x06  STA 0x0600,Y            // STA ValueStackB0,Y             Store byte 0 (LSB)
0x986A  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      long.asm:258
0x986C  0x99 0x00 0x07  STA 0x0700,Y            // STA ValueStackB1,Y             Store byte 1
0x986F  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      long.asm:260
0x9871  0x99 0x00 0x08  STA 0x0800,Y            // STA ValueStackB2,Y            Store byte 2
0x9874  0xA5 0x19       LDA 0x19                // LDA ZP.NEXT3                      long.asm:262
0x9876  0x99 0x00 0x09  STA 0x0900,Y            // STA ValueStackB3,Y            Store byte 3 (MSB)
0x9879  0xE6 0x03       INC 0x03                // INC ZP.SP                       Advance stack pointer
0x987B  0x38            SEC                     // SEC                               long.asm:267
0x987C  0x60            RTS                     // break;                            long.asm:268

// /source/projects/6502sbc/hopperbasic/objects/long.asm:330
// ####  Long.PopTopNext()  ####                                                0x00F4

0x987D  0xC6 0x03       DEC 0x03                // DEC ZP.SP                         long.asm:333
0x987F  0xA4 0x03       LDY 0x03                // LDY ZP.SP                       Y point to TOP
0x9881  0xC6 0x03       DEC 0x03                // DEC ZP.SP                       X point to NEXT
0x9883  0xA6 0x03       LDX 0x03                // LDX ZP.SP                         long.asm:336
0x9885  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA TypeStack, Y                  long.asm:338
0x9888  0x85 0x15       STA 0x15                // STA ZP.TOPT                       long.asm:339
0x988A  0xBD 0x00 0x05  LDA 0x0500,X            // LDA TypeStack, X                  long.asm:341
0x988D  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT                      long.asm:342
0x988F  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA ValueStackB0,Y             Load byte 0
0x9892  0x85 0x11       STA 0x11                // STA ZP.TOP0                       long.asm:345
0x9894  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA ValueStackB1,Y             Load byte 1
0x9897  0x85 0x12       STA 0x12                // STA ZP.TOP1                       long.asm:347
0x9899  0x3F 0x15 0x10  BBR3 0x15, 0x98AC (+16) // if (BBS3, ZP.TOPT)                long.asm:348
0x989C  0xBF 0x1A 0x03  BBS3 0x1A, 0x98A2 (+3)  // if (BBR3, ZP.NEXTT)               long.asm:350
0x989F  0x4C 0xED 0x8B  JMP 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL    if one is LONG, both must be LONG
0x98A2  0xB9 0x00 0x08  LDA 0x0800,Y            // LDA ValueStackB2,Y             Load byte 2
0x98A5  0x85 0x13       STA 0x13                // STA ZP.TOP2                       long.asm:356
0x98A7  0xB9 0x00 0x09  LDA 0x0900,Y            // LDA ValueStackB3,Y             Load byte 3
0x98AA  0x85 0x14       STA 0x14                // STA ZP.TOP3                       long.asm:358
0x98AC  0xBD 0x00 0x06  LDA 0x0600,X            // LDA ValueStackB0,X             Load byte 0
0x98AF  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      long.asm:361
0x98B1  0xBD 0x00 0x07  LDA 0x0700,X            // LDA ValueStackB1,X             Load byte 1
0x98B4  0x85 0x17       STA 0x17                // STA ZP.NEXT1                      long.asm:363
0x98B6  0x3F 0x1A 0x10  BBR3 0x1A, 0x98C9 (+16) // if (BBS3, ZP.NEXTT)               long.asm:364
0x98B9  0xBF 0x15 0x03  BBS3 0x15, 0x98BF (+3)  // if (BBR3, ZP.TOPT)                long.asm:366
0x98BC  0x4C 0xED 0x8B  JMP 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL    if one is LONG, both must be LONG
0x98BF  0xBD 0x00 0x08  LDA 0x0800,X            // LDA ValueStackB2,X             Load byte 2
0x98C2  0x85 0x18       STA 0x18                // STA ZP.NEXT2                      long.asm:372
0x98C4  0xBD 0x00 0x09  LDA 0x0900,X            // LDA ValueStackB3,X             Load byte 3
0x98C7  0x85 0x19       STA 0x19                // STA ZP.NEXT3                      long.asm:374
0x98C9  0x38            SEC                     // SEC                               long.asm:376
0x98CA  0x60            RTS                     // break;                            long.asm:377

// /source/projects/6502sbc/hopperbasic/objects/long.asm:384
// ####  Long.GetStackTopSP()  ####                                             0x00F5

0x98CB  0x18            CLC                     // CLC                               long.asm:385
0x98CC  0x65 0x03       ADC 0x03                // ADC ZP.SP                         long.asm:386
0x98CE  0xA8            TAY                     // TAY                               long.asm:387
0x98CF  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackB0, Y       long.asm:388
0x98D2  0x85 0x11       STA 0x11                // STA ZP.TOP0                       long.asm:389
0x98D4  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackB1, Y       long.asm:390
0x98D7  0x85 0x12       STA 0x12                // STA ZP.TOP1                       long.asm:391
0x98D9  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackB0, Y       long.asm:392
0x98DC  0x85 0x13       STA 0x13                // STA ZP.TOP2                       long.asm:393
0x98DE  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackB1, Y       long.asm:394
0x98E1  0x85 0x14       STA 0x14                // STA ZP.TOP3                       long.asm:395
0x98E3  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStackLSB, Y       long.asm:396
0x98E6  0x29 0x0F       AND # 0x0F              // AND #BASICType.TYPEMASK     Strip VAR bit
0x98E8  0x85 0x15       STA 0x15                // STA ZP.TOPT                       long.asm:398
0x98EA  0x60            RTS                     // }                                 long.asm:399

// /source/projects/6502sbc/hopperbasic/objects/long.asm:403
// ####  Long.PopTop()  ####                                                    0x00F6

0x98EB  0xC6 0x03       DEC 0x03                // DEC ZP.SP                         long.asm:404
0x98ED  0xA6 0x03       LDX 0x03                // LDX ZP.SP                       Y points to TOP
0x98EF  0xBD 0x00 0x05  LDA 0x0500,X            // LDA TypeStack, X                  long.asm:407
0x98F2  0x85 0x15       STA 0x15                // STA ZP.TOPT                       long.asm:408
0x98F4  0xBD 0x00 0x06  LDA 0x0600,X            // LDA ValueStackB0, X            Load byte 0
0x98F7  0x85 0x11       STA 0x11                // STA ZP.TOP0                       long.asm:411
0x98F9  0xBD 0x00 0x07  LDA 0x0700,X            // LDA ValueStackB1, X            Load byte 1
0x98FC  0x85 0x12       STA 0x12                // STA ZP.TOP1                       long.asm:413
0x98FE  0xBF 0x15 0x01  BBS3 0x15, 0x9902 (+1)  // if (BBS3, ZP.TOPT)                long.asm:414
0x9901  0x60            RTS
0x9902  0xBD 0x00 0x08  LDA 0x0800,X            // LDA ValueStackB2,X             Load byte 2
0x9905  0x85 0x13       STA 0x13                // STA ZP.TOP2                       long.asm:417
0x9907  0xBD 0x00 0x09  LDA 0x0900,X            // LDA ValueStackB3,X             Load byte 3
0x990A  0x85 0x14       STA 0x14                // STA ZP.TOP3                       long.asm:419
0x990C  0x60            RTS                     // }                                 long.asm:421

// /source/projects/6502sbc/hopperbasic/objects/long.asm:425
// ####  Long.PopNext()  ####                                                   0x00F7

0x990D  0xC6 0x03       DEC 0x03                // DEC ZP.SP                         long.asm:426
0x990F  0xA6 0x03       LDX 0x03                // LDX ZP.SP                       Y points to TOP
0x9911  0xBD 0x00 0x05  LDA 0x0500,X            // LDA TypeStack, X                  long.asm:429
0x9914  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT                      long.asm:430
0x9916  0xBD 0x00 0x06  LDA 0x0600,X            // LDA ValueStackB0, X            Load byte 0
0x9919  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      long.asm:433
0x991B  0xBD 0x00 0x07  LDA 0x0700,X            // LDA ValueStackB1, X            Load byte 1
0x991E  0x85 0x17       STA 0x17                // STA ZP.NEXT1                      long.asm:435
0x9920  0xBF 0x15 0x01  BBS3 0x15, 0x9924 (+1)  // if (BBS3, ZP.TOPT)                long.asm:436
0x9923  0x60            RTS
0x9924  0xBD 0x00 0x08  LDA 0x0800,X            // LDA ValueStackB2,X             Load byte 2
0x9927  0x85 0x18       STA 0x18                // STA ZP.NEXT2                      long.asm:439
0x9929  0xBD 0x00 0x09  LDA 0x0900,X            // LDA ValueStackB3,X             Load byte 3
0x992C  0x85 0x19       STA 0x19                // STA ZP.NEXT3                      long.asm:441
0x992E  0x60            RTS                     // }                                 long.asm:443

// /source/projects/6502sbc/hopperbasic/objects/long.asm:446
// ####  Long.Mod()  ####                                                       0x00F8

0x992F  0xA5 0x19       LDA 0x19                // LDA ZP.NEXT3                      long.asm:447
0x9931  0x48            PHA                     // PHA                               long.asm:448
0x9932  0x20 0x92 0x99  JSR 0x9992              // utilityDoLongSigns();             long.asm:450
0x9935  0xA2 0x01       LDX # 1                 // LDX #1    Mod                     long.asm:451
0x9937  0x20 0x84 0x9A  JSR 0x9A84              // DivMod();    RESULT = NEXT % TOP  long.asm:452
0x993A  0x20 0x07 0x98  JSR 0x9807              // moveResultToNext();               long.asm:454
0x993D  0x68            PLA                     // PLA    take the sign from the divisor (NEXT)
0x993E  0x30 0x03       BMI 0x9943 (+3)         // if (MI)                           long.asm:457
0x9940  0x4C 0x58 0x98  JMP 0x9858
0x9943  0x20 0x78 0x99  JSR 0x9978              // negateLongNEXT();    NEXT  = -NEXT
0x9946  0x4C 0x58 0x98  JMP 0x9858              // Long.PushNext();                  long.asm:461

// /source/projects/6502sbc/hopperbasic/objects/long.asm:464
// ####  Long.Div()  ####                                                       0x00F9

0x9949  0x20 0x92 0x99  JSR 0x9992              // utilityDoLongSigns();             long.asm:465
0x994C  0xA2 0x00       LDX # 0                 // LDX #0    Div                     long.asm:466
0x994E  0x20 0x84 0x9A  JSR 0x9A84              // DivMod();    NEXT = NEXT / TOP    long.asm:467
0x9951  0xA5 0x6F       LDA 0x6F                // LDA ZP.FSIGN    load the sign count
0x9953  0xC9 0x01       CMP # 1                 // CMP # 1                           long.asm:469
0x9955  0xF0 0x03       BEQ 0x995A (+3)         // if (Z)                            long.asm:470
0x9957  0x4C 0x58 0x98  JMP 0x9858
0x995A  0x20 0x78 0x99  JSR 0x9978              // negateLongNEXT();    NEXT  = -NEXT
0x995D  0x4C 0x58 0x98  JMP 0x9858              // Long.PushNext();                  long.asm:474

// /source/projects/6502sbc/hopperbasic/objects/long.asm:477
// ####  Long.Mul()  ####                                                       0x00FA

0x9960  0x20 0x92 0x99  JSR 0x9992              // utilityDoLongSigns();             long.asm:479
0x9963  0x20 0x77 0x9B  JSR 0x9B77              // utilityLongMUL();                 long.asm:483
0x9966  0x20 0x07 0x98  JSR 0x9807              // moveResultToNext();    RESULT0-3 -> NEXT0-3
0x9969  0xA5 0x6F       LDA 0x6F                // LDA ZP.FSIGN    load the sign count
0x996B  0xC9 0x01       CMP # 1                 // CMP # 1                           long.asm:487
0x996D  0xF0 0x03       BEQ 0x9972 (+3)         // if (Z)                            long.asm:488
0x996F  0x4C 0x58 0x98  JMP 0x9858
0x9972  0x20 0x78 0x99  JSR 0x9978              // negateLongNEXT();    NEXT  = -NEXT
0x9975  0x4C 0x58 0x98  JMP 0x9858              // Long.PushNext();                  long.asm:492

// /source/projects/6502sbc/hopperbasic/objects/long.asm:497
// ####  Long.negateLongNEXT()  ####                                            0x00FB

0x9978  0x38            SEC                     // SEC                               long.asm:498
0x9979  0xA9 0x00       LDA # 0                 // LDA # 0                           long.asm:499
0x997B  0xE5 0x16       SBC 0x16                // SBC ZP.NEXT0                      long.asm:500
0x997D  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      long.asm:501
0x997F  0xA9 0x00       LDA # 0                 // LDA # 0                           long.asm:502
0x9981  0xE5 0x17       SBC 0x17                // SBC ZP.NEXT1                      long.asm:503
0x9983  0x85 0x17       STA 0x17                // STA ZP.NEXT1                      long.asm:504
0x9985  0xA9 0x00       LDA # 0                 // LDA # 0                           long.asm:505
0x9987  0xE5 0x18       SBC 0x18                // SBC ZP.NEXT2                      long.asm:506
0x9989  0x85 0x18       STA 0x18                // STA ZP.NEXT2                      long.asm:507
0x998B  0xA9 0x00       LDA # 0                 // LDA # 0                           long.asm:508
0x998D  0xE5 0x19       SBC 0x19                // SBC ZP.NEXT3                      long.asm:509
0x998F  0x85 0x19       STA 0x19                // STA ZP.NEXT3                      long.asm:510
0x9991  0x60            RTS                     // }                                 long.asm:511

// /source/projects/6502sbc/hopperbasic/objects/long.asm:514
// ####  Long.utilityDoLongSigns()  ####                                        0x00FC

0x9992  0xDA            PHX                     // PHX                               long.asm:515
0x9993  0xA2 0x00       LDX # 0                 // LDX #0                            long.asm:516
0x9995  0xA5 0x19       LDA 0x19                // LDA ZP.NEXT3                      long.asm:517
0x9997  0x0A            ASL A                   // ASL    sign bit into carry        long.asm:518
0x9998  0x90 0x04       BCC 0x999E (+4)         // if (C)                            long.asm:519
0x999A  0xE8            INX                     // INX    count the -ve              long.asm:521
0x999B  0x20 0x78 0x99  JSR 0x9978              // negateLongNEXT();    NEXT = -NEXT long.asm:522
0x999E  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       long.asm:524
0x99A0  0x0A            ASL A                   // ASL    sign bit into carry        long.asm:525
0x99A1  0x90 0x04       BCC 0x99A7 (+4)         // if (C)                            long.asm:526
0x99A3  0xE8            INX                     // INX    count the -ve              long.asm:528
0x99A4  0x20 0x5D 0x9B  JSR 0x9B5D              // NegateLongTOP();    TOP = -TOP    long.asm:529
0x99A7  0x86 0x6F       STX 0x6F                // STX ZP.FSIGN    store the sign count
0x99A9  0xFA            PLX                     // PLX                               long.asm:533
0x99AA  0x60            RTS                     // }                                 long.asm:534

// /source/projects/6502sbc/hopperbasic/objects/long.asm:537
// ####  Long.commonEQ()  ####                                                  0x00FD

0x99AB  0xA2 0x00       LDX # 0                 // LDX # 0                           long.asm:539
0x99AD  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      long.asm:540
0x99AF  0xC5 0x11       CMP 0x11                // CMP ZP.TOP0                       long.asm:541
0x99B1  0xF0 0x01       BEQ 0x99B4 (+1)         // if (Z)                            long.asm:542
0x99B3  0x60            RTS
0x99B4  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      long.asm:544
0x99B6  0xC5 0x12       CMP 0x12                // CMP ZP.TOP1                       long.asm:545
0x99B8  0xF0 0x01       BEQ 0x99BB (+1)         // if (Z)                            long.asm:546
0x99BA  0x60            RTS
0x99BB  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      long.asm:548
0x99BD  0xC5 0x13       CMP 0x13                // CMP ZP.TOP2                       long.asm:549
0x99BF  0xF0 0x01       BEQ 0x99C2 (+1)         // if (Z)                            long.asm:550
0x99C1  0x60            RTS
0x99C2  0xA5 0x19       LDA 0x19                // LDA ZP.NEXT3                      long.asm:552
0x99C4  0xC5 0x14       CMP 0x14                // CMP ZP.TOP3                       long.asm:553
0x99C6  0xF0 0x01       BEQ 0x99C9 (+1)         // if (Z)                            long.asm:554
0x99C8  0x60            RTS
0x99C9  0xE8            INX                     // INX                               long.asm:556
0x99CA  0x60            RTS                     // }                                 long.asm:561

// /source/projects/6502sbc/hopperbasic/objects/long.asm:563
// ####  Long.commonLT()  ####                                                  0x00FE

0x99CB  0xA2 0x00       LDX # 0                 // LDX # 0                           long.asm:564
0x99CD  0x38            SEC                     // SEC                               long.asm:567
0x99CE  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      long.asm:568
0x99D0  0xE5 0x11       SBC 0x11                // SBC ZP.TOP0                       long.asm:569
0x99D2  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      long.asm:570
0x99D4  0xE5 0x12       SBC 0x12                // SBC ZP.TOP1                       long.asm:571
0x99D6  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      long.asm:572
0x99D8  0xE5 0x13       SBC 0x13                // SBC ZP.TOP2                       long.asm:573
0x99DA  0xA5 0x19       LDA 0x19                // LDA ZP.NEXT3                      long.asm:574
0x99DC  0xE5 0x14       SBC 0x14                // SBC ZP.TOP3                       long.asm:575
0x99DE  0x30 0x01       BMI 0x99E1 (+1)         // if (MI)                           long.asm:576
0x99E0  0x60            RTS
0x99E1  0xE8            INX                     // INX                               long.asm:578
0x99E2  0x60            RTS                     // }                                 long.asm:580

// /source/projects/6502sbc/hopperbasic/objects/long.asm:582
// ####  Long.LT()  ####                                                        0x00FF

0x99E3  0x20 0xCB 0x99  JSR 0x99CB              // commonLT();                       long.asm:583
0x99E6  0x4C 0xEA 0x94  JMP 0x94EA              // Stacks.PushX();    as Type.Bool   long.asm:584

// /source/projects/6502sbc/hopperbasic/objects/long.asm:587
// ####  Long.GT()  ####                                                        0x0100

0x99E9  0x20 0x18 0x98  JSR 0x9818              // commonSwapNEXTTOP();              long.asm:588
0x99EC  0x20 0xCB 0x99  JSR 0x99CB              // commonLT();                       long.asm:589
0x99EF  0x4C 0xEA 0x94  JMP 0x94EA              // Stacks.PushX();    as Type.Bool   long.asm:590

// /source/projects/6502sbc/hopperbasic/objects/long.asm:593
// ####  Long.EQ()  ####                                                        0x0101

0x99F2  0x20 0xAB 0x99  JSR 0x99AB              // commonEQ();                       long.asm:594
0x99F5  0x4C 0xEA 0x94  JMP 0x94EA              // Stacks.PushX();    as Type.Bool   long.asm:595

// /source/projects/6502sbc/hopperbasic/objects/long.asm:598
// ####  Long.NE()  ####                                                        0x0102

0x99F8  0x20 0xAB 0x99  JSR 0x99AB              // commonEQ();                       long.asm:599
0x99FB  0xE0 0x00       CPX # 0                 // CPX # 0                           long.asm:600
0x99FD  0xD0 0x05       BNE 0x9A04 (+5)         // if (Z)                            long.asm:601
0x99FF  0xA2 0x01       LDX # 1                 // LDX #1                            long.asm:603
0x9A01  0x4C 0xEA 0x94  JMP 0x94EA              // }                                 long.asm:604
0x9A04  0xA2 0x00       LDX # 0                 // LDX #0                            long.asm:607
0x9A06  0x4C 0xEA 0x94  JMP 0x94EA              // Stacks.PushX();    as Type.Bool   long.asm:609

// /source/projects/6502sbc/hopperbasic/objects/long.asm:612
// ####  Long.LE()  ####                                                        0x0103

0x9A09  0x20 0xAB 0x99  JSR 0x99AB              // commonEQ();                       long.asm:613
0x9A0C  0xE0 0x00       CPX # 0                 // CPX # 0                           long.asm:614
0x9A0E  0xF0 0x03       BEQ 0x9A13 (+3)         // if (Z)                            long.asm:615
0x9A10  0x4C 0xEA 0x94  JMP 0x94EA
0x9A13  0x20 0xCB 0x99  JSR 0x99CB              // commonLT();                       long.asm:617
0x9A16  0x4C 0xEA 0x94  JMP 0x94EA              // Stacks.PushX();    as Type.Bool   long.asm:619

// /source/projects/6502sbc/hopperbasic/objects/long.asm:623
// ####  Long.GE()  ####                                                        0x0104

0x9A19  0x20 0xAB 0x99  JSR 0x99AB              // commonEQ();                       long.asm:624
0x9A1C  0xE0 0x00       CPX # 0                 // CPX # 0                           long.asm:625
0x9A1E  0xF0 0x03       BEQ 0x9A23 (+3)         // if (Z)                            long.asm:626
0x9A20  0x4C 0xEA 0x94  JMP 0x94EA
0x9A23  0x20 0x18 0x98  JSR 0x9818              // commonSwapNEXTTOP();              long.asm:628
0x9A26  0x20 0xCB 0x99  JSR 0x99CB              // commonLT();                       long.asm:629
0x9A29  0x4C 0xEA 0x94  JMP 0x94EA              // Stacks.PushX();    as Type.Bool   long.asm:631

// /source/projects/6502sbc/hopperbasic/objects/long.asm:640
// ####  Long.utility16BitDiv10()  ####                                         0x0105

0x9A2C  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      long.asm:642
0x9A2E  0x85 0x11       STA 0x11                // STA ZP.TOP0                       long.asm:643
0x9A30  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      long.asm:644
0x9A32  0x85 0x12       STA 0x12                // STA ZP.TOP1                       long.asm:645
0x9A34  0xA5 0x12       LDA 0x12                // LDA    ZP.TOP1                    long.asm:652
0x9A36  0x85 0x0E       STA 0x0E                // STA    ZP.ACCL                    long.asm:653
0x9A38  0x4A            LSR A                   // LSR                               long.asm:654
0x9A39  0x69 0x0D       ADC # 0x0D              // ADC    #13                        long.asm:655
0x9A3B  0x65 0x0E       ADC 0x0E                // ADC    ZP.ACCL                    long.asm:656
0x9A3D  0x6A            ROR A                   // ROR                               long.asm:657
0x9A3E  0x4A            LSR A                   // LSR                               long.asm:658
0x9A3F  0x4A            LSR A                   // LSR                               long.asm:659
0x9A40  0x65 0x0E       ADC 0x0E                // ADC    ZP.ACCL                    long.asm:660
0x9A42  0x6A            ROR A                   // ROR                               long.asm:661
0x9A43  0x65 0x0E       ADC 0x0E                // ADC    ZP.ACCL                    long.asm:662
0x9A45  0x6A            ROR A                   // ROR                               long.asm:663
0x9A46  0x4A            LSR A                   // LSR                               long.asm:664
0x9A47  0x29 0x7C       AND # 0x7C              // AND    # 0x7C                   AND'ing here...
0x9A49  0x85 0x0E       STA 0x0E                // STA    ZP.ACCL                     and saving result as highTen (times 4)
0x9A4B  0x4A            LSR A                   // LSR                               long.asm:667
0x9A4C  0x4A            LSR A                   // LSR                               long.asm:668
0x9A4D  0x85 0x17       STA 0x17                // STA    ZP.NEXT1                   long.asm:669
0x9A4F  0x65 0x0E       ADC 0x0E                // ADC    ZP.ACCL                     highTen (times 5)
0x9A51  0x0A            ASL A                   // ASL                             highTen (times 10)
0x9A52  0xE5 0x12       SBC 0x12                // SBC    ZP.TOP1                    long.asm:672
0x9A54  0x49 0xFF       EOR # 0xFF              // EOR    # 0xFF                     long.asm:673
0x9A56  0xA8            TAY                     // TAY                             mod 10 result!
0x9A57  0xB9 0xA9 0x83  LDA 0x83A9,Y            // LDA    tensRemaining, Y         Fill the low byte with the tens it should
0x9A5A  0x85 0x16       STA 0x16                // STA    ZP.NEXT0                    have at this point from the high byte divide.
0x9A5C  0xA5 0x11       LDA 0x11                // LDA    ZP.TOP0                    long.asm:678
0x9A5E  0x79 0xB3 0x83  ADC 0x83B3,Y            // ADC    modRemaining, Y          4  @69
0x9A61  0xB0 0x16       BCS 0x9A79 (+22)        // if (NC)                           long.asm:681
0x9A63  0x85 0x0E       STA 0x0E                // STA    ZP.ACCL                    long.asm:683
0x9A65  0x4A            LSR A                   // LSR                               long.asm:684
0x9A66  0x69 0x0D       ADC # 0x0D              // ADC    # 13                       long.asm:685
0x9A68  0x65 0x0E       ADC 0x0E                // ADC    ZP.ACCL                    long.asm:686
0x9A6A  0x6A            ROR A                   // ROR                               long.asm:687
0x9A6B  0x4A            LSR A                   // LSR                               long.asm:688
0x9A6C  0x4A            LSR A                   // LSR                               long.asm:689
0x9A6D  0x65 0x0E       ADC 0x0E                // ADC    ZP.ACCL                    long.asm:690
0x9A6F  0x6A            ROR A                   // ROR                               long.asm:691
0x9A70  0x65 0x0E       ADC 0x0E                // ADC    ZP.ACCL                    long.asm:692
0x9A72  0x6A            ROR A                   // ROR                               long.asm:693
0x9A73  0x4A            LSR A                   // LSR                               long.asm:694
0x9A74  0x4A            LSR A                   // LSR                               long.asm:695
0x9A75  0x4A            LSR A                   // LSR                               long.asm:696
0x9A76  0x18            CLC                     // CLC                               long.asm:697
0x9A77  0x80 0x06       BRA 0x9A7F (+6)         // break;                            long.asm:698
0x9A79  0xC9 0x04       CMP # 0x04              // CMP    #4                        We have overflowed, but we can apply a shortcut.
0x9A7B  0xA9 0x19       LDA # 0x19              // LDA    #25                       Divide by 10 will be at least 25, and the
0x9A7D  0xF0 0xB5       BEQ 0x9A34 (-75)        // if (NZ)                          carry is set when higher for the next addition.
0x9A7F  0x65 0x16       ADC 0x16                // ADC    ZP.NEXT0                   long.asm:708
0x9A81  0x85 0x16       STA 0x16                // STA    ZP.NEXT0                   long.asm:709
0x9A83  0x60            RTS                     // }                                 long.asm:710

// /source/projects/6502sbc/hopperbasic/objects/long.asm:715
// ####  Long.DivMod()  ####                                                    0x0106

0x9A84  0x20 0xBF 0x97  JSR 0x97BF              // zeroResult();                     long.asm:722
0x9A87  0x20 0xAD 0x97  JSR 0x97AD              // Long.ZeroCheckTop();              long.asm:742
0x9A8A  0xD0 0x06       BNE 0x9A92 (+6)         // if (Z)     Divisor is zero        long.asm:743
0x9A8C  0x20 0x0B 0x8C  JSR 0x8C0B              // Error.DivisionByZero(); BIT ZP.EmulatorPCL
0x9A8F  0x4C 0x59 0x8C  JMP 0x8C59              // CheckError();                     long.asm:749
0x9A92  0xE0 0x00       CPX # 0                 // CPX #0                            long.asm:754
0x9A94  0xF0 0x03       BEQ 0x9A99 (+3)         // if (Z)                            long.asm:755
0x9A96  0x4C 0x1E 0x9B  JMP 0x9B1E
0x9A99  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       long.asm:757
0x9A9B  0x05 0x14       ORA 0x14                // ORA ZP.TOP3                       long.asm:758
0x9A9D  0xF0 0x03       BEQ 0x9AA2 (+3)         // if (Z)    16 bit divisor          long.asm:759
0x9A9F  0x4C 0x1E 0x9B  JMP 0x9B1E
0x9AA2  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       long.asm:761
0x9AA4  0xD0 0x29       BNE 0x9ACF (+41)        // if (Z)                            long.asm:762
0x9AA6  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       long.asm:765
0x9AA8  0xC9 0x01       CMP # 1                 // CMP #1                            long.asm:766
0x9AAA  0xD0 0x01       BNE 0x9AAD (+1)         // if (Z)                            long.asm:767
0x9AAC  0x60            RTS                     // break;    exit                    long.asm:773
0x9AAD  0xC9 0x10       CMP # 0x10              // CMP #16                           long.asm:775
0x9AAF  0xD0 0x05       BNE 0x9AB6 (+5)         // if (Z)                            long.asm:776
0x9AB1  0x20 0x4F 0x98  JSR 0x984F              // shiftNEXTright();    NEXT >> 1    long.asm:778
0x9AB4  0xA9 0x08       LDA # 0x08              // LDA #8               Set up for next CMP
0x9AB6  0xC9 0x08       CMP # 0x08              // CMP #8                            long.asm:781
0x9AB8  0xD0 0x05       BNE 0x9ABF (+5)         // if (Z)                            long.asm:782
0x9ABA  0x20 0x4F 0x98  JSR 0x984F              // shiftNEXTright();    NEXT >> 1    long.asm:784
0x9ABD  0xA9 0x04       LDA # 0x04              // LDA #4               Set up for next CMP
0x9ABF  0xC9 0x04       CMP # 0x04              // CMP #4                            long.asm:787
0x9AC1  0xD0 0x05       BNE 0x9AC8 (+5)         // if (Z)                            long.asm:788
0x9AC3  0x20 0x4F 0x98  JSR 0x984F              // shiftNEXTright();    NEXT >> 1    long.asm:790
0x9AC6  0xA9 0x02       LDA # 0x02              // LDA #2               Set up for next CMP
0x9AC8  0xC9 0x02       CMP # 0x02              // CMP #2                            long.asm:793
0x9ACA  0xD0 0x03       BNE 0x9ACF (+3)         // if (Z)                            long.asm:794
0x9ACC  0x4C 0x4F 0x98  JMP 0x984F              // shiftNEXTright();    NEXT >> 1 (final shift)
0x9ACF  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      long.asm:806
0x9AD1  0x05 0x19       ORA 0x19                // ORA ZP.NEXT3                      long.asm:807
0x9AD3  0xD0 0x49       BNE 0x9B1E (+73)        // if (Z)     All high bytes are zero - use 16-bit division
0x9AD5  0x64 0x18       STZ 0x18                // STZ ZP.NEXT2                      long.asm:811
0x9AD7  0x64 0x19       STZ 0x19                // STZ ZP.NEXT3                      long.asm:812
0x9AD9  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       long.asm:814
0x9ADB  0xD0 0x21       BNE 0x9AFE (+33)        // if (Z)                            long.asm:815
0x9ADD  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       long.asm:817
0x9ADF  0xC9 0x0A       CMP # 0x0A              // CMP # 10                          long.asm:818
0x9AE1  0xD0 0x03       BNE 0x9AE6 (+3)         // if (Z)                            long.asm:819
0x9AE3  0x4C 0x2C 0x9A  JMP 0x9A2C              // utility16BitDiv10();     / 10     long.asm:821
0x9AE6  0xC9 0x32       CMP # 0x32              // CMP # 50                          long.asm:827
0x9AE8  0xD0 0x0A       BNE 0x9AF4 (+10)        // if (Z)                            long.asm:828
0x9AEA  0x20 0x2C 0x9A  JSR 0x9A2C              // utility16BitDiv10();     / 10     long.asm:830
0x9AED  0x06 0x16       ASL 0x16                // ASL ZP.NEXT0             * 2      long.asm:831
0x9AEF  0x26 0x17       ROL 0x17                // ROL ZP.NEXT1                      long.asm:832
0x9AF1  0x4C 0x2C 0x9A  JMP 0x9A2C              // utility16BitDiv10();     / 10     long.asm:833
0x9AF4  0xC9 0x64       CMP # 0x64              // CMP # 100                         long.asm:839
0x9AF6  0xD0 0x06       BNE 0x9AFE (+6)         // if (Z)                            long.asm:840
0x9AF8  0x20 0x2C 0x9A  JSR 0x9A2C              // utility16BitDiv10();     / 10     long.asm:842
0x9AFB  0x4C 0x2C 0x9A  JMP 0x9A2C              // utility16BitDiv10();     / 10     long.asm:843
0x9AFE  0xA2 0x10       LDX # 0x10              // LDX #16          16 iterations instead of 32
0x9B00  0x06 0x16       ASL 0x16                // ASL NEXT0       shift hi bit of dividend into remainder
0x9B02  0x26 0x17       ROL 0x17                // ROL NEXT1                         long.asm:856
0x9B04  0x26 0x4F       ROL 0x4F                // ROL RESULT0                       long.asm:857
0x9B06  0x26 0x50       ROL 0x50                // ROL RESULT1                       long.asm:858
0x9B08  0x38            SEC                     // SEC              trial subtraction
0x9B09  0xA5 0x4F       LDA 0x4F                // LDA RESULT0                       long.asm:861
0x9B0B  0xE5 0x11       SBC 0x11                // SBC TOP0                          long.asm:862
0x9B0D  0xA8            TAY                     // TAY             temp storage      long.asm:863
0x9B0E  0xA5 0x50       LDA 0x50                // LDA RESULT1                       long.asm:864
0x9B10  0xE5 0x12       SBC 0x12                // SBC TOP1                          long.asm:865
0x9B12  0x90 0x06       BCC 0x9B1A (+6)         // if (C)           did subtraction succeed?
0x9B14  0x85 0x50       STA 0x50                // STA RESULT1     if yes, save it   long.asm:868
0x9B16  0x84 0x4F       STY 0x4F                // STY RESULT0                       long.asm:869
0x9B18  0xE6 0x16       INC 0x16                // INC NEXT0       and record a 1 in the quotient
0x9B1A  0xCA            DEX                     // DEX                               long.asm:872
0x9B1B  0xD0 0xE3       BNE 0x9B00 (-29)        // if (Z) { break; }                 long.asm:873
0x9B1D  0x60            RTS                     // break;    16 bit exit             long.asm:878
0x9B1E  0xA2 0x20       LDX # 0x20              // LDX #32          there are 16 bits in N
0x9B20  0x06 0x16       ASL 0x16                // ASL NEXT0       shift hi bit of N into R
0x9B22  0x26 0x17       ROL 0x17                // ROL NEXT1       (vacating the lo bit, which will be used for the quotient)
0x9B24  0x26 0x18       ROL 0x18                // ROL NEXT2                         long.asm:890
0x9B26  0x26 0x19       ROL 0x19                // ROL NEXT3                         long.asm:891
0x9B28  0x26 0x4F       ROL 0x4F                // ROL RESULT0                       long.asm:892
0x9B2A  0x26 0x50       ROL 0x50                // ROL RESULT1                       long.asm:893
0x9B2C  0x26 0x51       ROL 0x51                // ROL RESULT2                       long.asm:894
0x9B2E  0x26 0x52       ROL 0x52                // ROL RESULT3                       long.asm:895
0x9B30  0x38            SEC                     // SEC              trial subtraction
0x9B31  0xA5 0x4F       LDA 0x4F                // LDA RESULT0                       long.asm:898
0x9B33  0xE5 0x11       SBC 0x11                // SBC TOP0                          long.asm:899
0x9B35  0x85 0x53       STA 0x53                // STA RESULT4                       long.asm:900
0x9B37  0xA5 0x50       LDA 0x50                // LDA RESULT1                       long.asm:901
0x9B39  0xE5 0x12       SBC 0x12                // SBC TOP1                          long.asm:902
0x9B3B  0x85 0x54       STA 0x54                // STA RESULT5                       long.asm:903
0x9B3D  0xA5 0x51       LDA 0x51                // LDA RESULT2                       long.asm:904
0x9B3F  0xE5 0x13       SBC 0x13                // SBC TOP2                          long.asm:905
0x9B41  0x85 0x55       STA 0x55                // STA RESULT6                       long.asm:906
0x9B43  0xA5 0x52       LDA 0x52                // LDA RESULT3                       long.asm:907
0x9B45  0xE5 0x14       SBC 0x14                // SBC TOP3                          long.asm:908
0x9B47  0x90 0x10       BCC 0x9B59 (+16)        // if (C)           did subtraction succeed?
0x9B49  0x85 0x52       STA 0x52                // STA RESULT3     if yes, save it   long.asm:913
0x9B4B  0xA5 0x55       LDA 0x55                // LDA RESULT6                       long.asm:914
0x9B4D  0x85 0x51       STA 0x51                // STA RESULT2                       long.asm:915
0x9B4F  0xA5 0x54       LDA 0x54                // LDA RESULT5                       long.asm:916
0x9B51  0x85 0x50       STA 0x50                // STA RESULT1                       long.asm:917
0x9B53  0xA5 0x53       LDA 0x53                // LDA RESULT4                       long.asm:918
0x9B55  0x85 0x4F       STA 0x4F                // STA RESULT0                       long.asm:919
0x9B57  0xE6 0x16       INC 0x16                // INC NEXT0       and record a 1 in the quotient
0x9B59  0xCA            DEX                     // DEX                               long.asm:922
0x9B5A  0xD0 0xC4       BNE 0x9B20 (-60)        // if (Z) { break; }                 long.asm:923
0x9B5C  0x60            RTS                     // break;    32 bit exit             long.asm:928

// /source/projects/6502sbc/hopperbasic/objects/long.asm:935
// ####  Long.NegateLongTOP()  ####                                             0x0107

0x9B5D  0x38            SEC                     // SEC                               long.asm:936
0x9B5E  0xA9 0x00       LDA # 0                 // LDA # 0                           long.asm:937
0x9B60  0xE5 0x11       SBC 0x11                // SBC TOP0                          long.asm:938
0x9B62  0x85 0x11       STA 0x11                // STA TOP0                          long.asm:939
0x9B64  0xA9 0x00       LDA # 0                 // LDA # 0                           long.asm:940
0x9B66  0xE5 0x12       SBC 0x12                // SBC TOP1                          long.asm:941
0x9B68  0x85 0x12       STA 0x12                // STA TOP1                          long.asm:942
0x9B6A  0xA9 0x00       LDA # 0                 // LDA # 0                           long.asm:943
0x9B6C  0xE5 0x13       SBC 0x13                // SBC TOP2                          long.asm:944
0x9B6E  0x85 0x13       STA 0x13                // STA TOP2                          long.asm:945
0x9B70  0xA9 0x00       LDA # 0                 // LDA # 0                           long.asm:946
0x9B72  0xE5 0x14       SBC 0x14                // SBC TOP3                          long.asm:947
0x9B74  0x85 0x14       STA 0x14                // STA TOP3                          long.asm:948
0x9B76  0x60            RTS                     // }                                 long.asm:949

// /source/projects/6502sbc/hopperbasic/objects/long.asm:953
// ####  Long.utilityLongMUL()  ####                                            0x0108

0x9B77  0x20 0xC8 0x97  JSR 0x97C8              // zeroResult8();                    long.asm:959
0x9B7A  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      long.asm:967
0x9B7C  0x05 0x18       ORA 0x18                // ORA ZP.NEXT2                      long.asm:968
0x9B7E  0x05 0x19       ORA 0x19                // ORA ZP.NEXT3                      long.asm:969
0x9B80  0xD0 0x49       BNE 0x9BCB (+73)        // if (Z)     NEXT is 8-bit          long.asm:970
0x9B82  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      long.asm:973
0x9B84  0xF0 0x14       BEQ 0x9B9A (+20)        // case 0:                           long.asm:976
0x9B86  0xC9 0x01       CMP # 1                 // case 1:                           long.asm:977
0x9B88  0xF0 0x10       BEQ 0x9B9A (+16)
0x9B8A  0xC9 0x02       CMP # 0x02              // case 2:                           long.asm:978
0x9B8C  0xF0 0x0C       BEQ 0x9B9A (+12)
0x9B8E  0xC9 0x04       CMP # 0x04              // case 4:                           long.asm:979
0x9B90  0xF0 0x08       BEQ 0x9B9A (+8)
0x9B92  0xC9 0x08       CMP # 0x08              // case 8:                           long.asm:980
0x9B94  0xF0 0x04       BEQ 0x9B9A (+4)
0x9B96  0xC9 0x10       CMP # 0x10              // case 16:                          long.asm:981
0x9B98  0xD0 0x05       BNE 0x9B9F (+5)
0x9B9A  0x20 0x18 0x98  JSR 0x9818              // commonSwapNEXTTOP();              long.asm:983
0x9B9D  0x80 0x2C       BRA 0x9BCB (+44)        // }                                 long.asm:987
0x9B9F  0xC9 0x0A       CMP # 0x0A              // case 10:                          long.asm:988
0x9BA1  0xD0 0x28       BNE 0x9BCB (+40)
0x9BA3  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       long.asm:991
0x9BA5  0x05 0x13       ORA 0x13                // ORA ZP.TOP2                       long.asm:992
0x9BA7  0x05 0x14       ORA 0x14                // ORA ZP.TOP3                       long.asm:993
0x9BA9  0xD0 0x1D       BNE 0x9BC8 (+29)        // if (Z)     TOP is 8-bit           long.asm:994
0x9BAB  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       long.asm:996
0x9BAD  0xF0 0x1C       BEQ 0x9BCB (+28)        // case  0:                          long.asm:999
0x9BAF  0xC9 0x01       CMP # 1                 // case  1:                          long.asm:1000
0x9BB1  0xF0 0x18       BEQ 0x9BCB (+24)
0x9BB3  0xC9 0x02       CMP # 0x02              // case  2:                          long.asm:1001
0x9BB5  0xF0 0x14       BEQ 0x9BCB (+20)
0x9BB7  0xC9 0x04       CMP # 0x04              // case  4:                          long.asm:1002
0x9BB9  0xF0 0x10       BEQ 0x9BCB (+16)
0x9BBB  0xC9 0x08       CMP # 0x08              // case  8:                          long.asm:1003
0x9BBD  0xF0 0x0C       BEQ 0x9BCB (+12)
0x9BBF  0xC9 0x10       CMP # 0x10              // case 16:                          long.asm:1004
0x9BC1  0xF0 0x08       BEQ 0x9BCB (+8)
0x9BC3  0x20 0x18 0x98  JSR 0x9818              // commonSwapNEXTTOP();              long.asm:1008
0x9BC6  0x80 0x03       BRA 0x9BCB (+3)         // }                                 long.asm:1012
0x9BC8  0x20 0x18 0x98  JSR 0x9818              // commonSwapNEXTTOP();              long.asm:1017
0x9BCB  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       long.asm:1030
0x9BCD  0x05 0x14       ORA 0x14                // ORA ZP.TOP3                       long.asm:1031
0x9BCF  0xF0 0x03       BEQ 0x9BD4 (+3)         // if (Z)                            long.asm:1032
0x9BD1  0x4C 0x53 0x9C  JMP 0x9C53
0x9BD4  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       long.asm:1035
0x9BD6  0xD0 0x36       BNE 0x9C0E (+54)        // if (Z)                            long.asm:1036
0x9BD8  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       long.asm:1039
0x9BDA  0xD0 0x01       BNE 0x9BDD (+1)         // if (Z)                            long.asm:1041
0x9BDC  0x60            RTS                     // break;    exit                    long.asm:1047
0x9BDD  0xC9 0x01       CMP # 1                 // CMP #1                            long.asm:1049
0x9BDF  0xD0 0x03       BNE 0x9BE4 (+3)         // if (Z)                            long.asm:1050
0x9BE1  0x4C 0xD4 0x97  JMP 0x97D4              // moveNextToResult();               long.asm:1056
0x9BE4  0xC9 0x10       CMP # 0x10              // CMP #16                           long.asm:1059
0x9BE6  0xD0 0x05       BNE 0x9BED (+5)         // if (Z)                            long.asm:1060
0x9BE8  0x20 0x39 0x98  JSR 0x9839              // shiftNEXTleft();    NEXT << 1, can set overflow error
0x9BEB  0xA9 0x08       LDA # 0x08              // LDA #8                            long.asm:1063
0x9BED  0xC9 0x08       CMP # 0x08              // CMP #8                            long.asm:1065
0x9BEF  0xD0 0x05       BNE 0x9BF6 (+5)         // if (Z)                            long.asm:1066
0x9BF1  0x20 0x39 0x98  JSR 0x9839              // shiftNEXTleft();    NEXT << 1, can set overflow error
0x9BF4  0xA9 0x04       LDA # 0x04              // LDA #4                            long.asm:1069
0x9BF6  0xC9 0x04       CMP # 0x04              // CMP #4                            long.asm:1071
0x9BF8  0xD0 0x05       BNE 0x9BFF (+5)         // if (Z)                            long.asm:1072
0x9BFA  0x20 0x39 0x98  JSR 0x9839              // shiftNEXTleft();    NEXT << 1, can set overflow error
0x9BFD  0xA9 0x02       LDA # 0x02              // LDA #2                            long.asm:1075
0x9BFF  0xC9 0x02       CMP # 0x02              // CMP #2                            long.asm:1077
0x9C01  0xD0 0x09       BNE 0x9C0C (+9)         // if (Z)                            long.asm:1078
0x9C03  0x20 0x39 0x98  JSR 0x9839              // shiftNEXTleft();    NEXT << 1, can set overflow error
0x9C06  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     long.asm:1081
0x9C09  0x4C 0xD4 0x97  JMP 0x97D4              // moveNextToResult();               long.asm:1082
0x9C0C  0xC9 0x0A       CMP # 0x0A              // CMP #10                           long.asm:1088
0x9C0E  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      long.asm:1096
0x9C10  0x05 0x19       ORA 0x19                // ORA ZP.NEXT3                      long.asm:1097
0x9C12  0xD0 0x3F       BNE 0x9C53 (+63)        // if (Z)     All high bytes are zero - use 16-bit multiply
0x9C14  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      long.asm:1100
0x9C16  0x05 0x12       ORA 0x12                // ORA ZP.TOP1                       long.asm:1101
0x9C18  0xD0 0x17       BNE 0x9C31 (+23)        // if (Z)                            long.asm:1102
0x9C1A  0xA9 0x00       LDA # 0                 // LDA #0                            long.asm:1104
0x9C1C  0xA2 0x08       LDX # 0x08              // LDX #8           Only 8 iterations!
0x9C1E  0x46 0x16       LSR 0x16                // LSR ZP.NEXT0                      long.asm:1108
0x9C20  0x90 0x07       BCC 0x9C29 (+7)         // if (C)                            long.asm:1109
0x9C22  0xA5 0x50       LDA 0x50                // LDA ZP.RESULT1      get upper half of product
0x9C24  0x18            CLC                     // CLC                               long.asm:1112
0x9C25  0x65 0x11       ADC 0x11                // ADC ZP.TOP0         add multiplicand to it
0x9C27  0x85 0x50       STA 0x50                // STA ZP.RESULT1      (carry may be set from this add)
0x9C29  0x66 0x50       ROR 0x50                // ROR ZP.RESULT1          rotate partial product right
0x9C2B  0x66 0x4F       ROR 0x4F                // ROR ZP.RESULT0          through both bytes
0x9C2D  0xCA            DEX                     // DEX                     decrement bit count
0x9C2E  0xD0 0xEE       BNE 0x9C1E (-18)        // if (Z) { break; }       exit loop when 8 bits are done
0x9C30  0x60            RTS                     // break;    8 bit exit              long.asm:1124
0x9C31  0xA9 0x00       LDA # 0                 // LDA #0                            long.asm:1127
0x9C33  0xA2 0x10       LDX # 0x10              // LDX #16                   16 bits instead of 32
0x9C35  0x46 0x17       LSR 0x17                // LSR ZP.NEXT1          shift 16-bit multiplier right
0x9C37  0x66 0x16       ROR 0x16                // ROR ZP.NEXT0                      long.asm:1132
0x9C39  0x90 0x0B       BCC 0x9C46 (+11)        // if (C)                Go rotate right if c = 0
0x9C3B  0xA5 0x51       LDA 0x51                // LDA ZP.RESULT2      get upper half of product and add multiplicand to it
0x9C3D  0x18            CLC                     // CLC                               long.asm:1136
0x9C3E  0x65 0x11       ADC 0x11                // ADC ZP.TOP0                       long.asm:1137
0x9C40  0x85 0x51       STA 0x51                // STA ZP.RESULT2                    long.asm:1138
0x9C42  0xA5 0x52       LDA 0x52                // LDA ZP.RESULT3                    long.asm:1139
0x9C44  0x65 0x12       ADC 0x12                // ADC ZP.TOP1                       long.asm:1140
0x9C46  0x6A            ROR A                   // ROR A                 rotate partial product
0x9C47  0x85 0x52       STA 0x52                // STA ZP.RESULT3        right       long.asm:1143
0x9C49  0x66 0x51       ROR 0x51                // ROR ZP.RESULT2                    long.asm:1144
0x9C4B  0x66 0x50       ROR 0x50                // ROR ZP.RESULT1                    long.asm:1145
0x9C4D  0x66 0x4F       ROR 0x4F                // ROR ZP.RESULT0                    long.asm:1146
0x9C4F  0xCA            DEX                     // DEX                   decrement bit count and
0x9C50  0xD0 0xE3       BNE 0x9C35 (-29)        // if (Z) { break; }     exit loop when 16 bits are done
0x9C52  0x60            RTS                     // break;    16 bit exit             long.asm:1153
0x9C53  0xA9 0x00       LDA # 0                 // LDA # 0                           long.asm:1160
0x9C55  0xA2 0x20       LDX # 0x20              // LDX # 32                          long.asm:1161
0x9C57  0x46 0x19       LSR 0x19                // LSR ZP.NEXT3      shift multiplyer right
0x9C59  0x66 0x18       ROR 0x18                // ROR ZP.NEXT2                      long.asm:1165
0x9C5B  0x66 0x17       ROR 0x17                // ROR ZP.NEXT1                      long.asm:1166
0x9C5D  0x66 0x16       ROR 0x16                // ROR ZP.NEXT0                      long.asm:1167
0x9C5F  0x90 0x17       BCC 0x9C78 (+23)        // if (C)    Go rotate right if c = 0
0x9C61  0xA5 0x53       LDA 0x53                // LDA ZP.RESULT4      get upper half of product and add multiplicand to it
0x9C63  0x18            CLC                     // CLC                               long.asm:1171
0x9C64  0x65 0x11       ADC 0x11                // ADC ZP.TOP0                       long.asm:1172
0x9C66  0x85 0x53       STA 0x53                // STA ZP.RESULT4                    long.asm:1173
0x9C68  0xA5 0x54       LDA 0x54                // LDA ZP.RESULT5                    long.asm:1174
0x9C6A  0x65 0x12       ADC 0x12                // ADC ZP.TOP1                       long.asm:1175
0x9C6C  0x85 0x54       STA 0x54                // STA ZP.RESULT5                    long.asm:1176
0x9C6E  0xA5 0x55       LDA 0x55                // LDA ZP.RESULT6                    long.asm:1177
0x9C70  0x65 0x13       ADC 0x13                // ADC ZP.TOP2                       long.asm:1178
0x9C72  0x85 0x55       STA 0x55                // STA ZP.RESULT6                    long.asm:1179
0x9C74  0xA5 0x56       LDA 0x56                // LDA ZP.RESULT7                    long.asm:1180
0x9C76  0x65 0x14       ADC 0x14                // ADC ZP.TOP3                       long.asm:1181
0x9C78  0x6A            ROR A                   // ROR A       rotate partial product
0x9C79  0x85 0x56       STA 0x56                // STA ZP.RESULT7      right         long.asm:1184
0x9C7B  0x66 0x55       ROR 0x55                // ROR ZP.RESULT6                    long.asm:1185
0x9C7D  0x66 0x54       ROR 0x54                // ROR ZP.RESULT5                    long.asm:1186
0x9C7F  0x66 0x53       ROR 0x53                // ROR ZP.RESULT4                    long.asm:1187
0x9C81  0x66 0x52       ROR 0x52                // ROR ZP.RESULT3                    long.asm:1188
0x9C83  0x66 0x51       ROR 0x51                // ROR ZP.RESULT2                    long.asm:1189
0x9C85  0x66 0x50       ROR 0x50                // ROR ZP.RESULT1                    long.asm:1190
0x9C87  0x66 0x4F       ROR 0x4F                // ROR ZP.RESULT0                    long.asm:1191
0x9C89  0xCA            DEX                     // DEX                   decrement bit count and
0x9C8A  0xD0 0xCB       BNE 0x9C57 (-53)        // if (Z) { break; }     exit loop when 32 bits are done
0x9C8C  0x60            RTS                     // break;    32 bit exit             long.asm:1195

// /source/projects/6502sbc/hopperbasic/objects/long.asm:1208
// ####  Long.AddDigit()  ####                                                  0x0109

0x9C8D  0xC9 0x0A       CMP # 0x0A              // CMP #10                           long.asm:1209
0x9C8F  0x90 0x02       BCC 0x9C93 (+2)         // if (C)     A >= 10, invalid digit long.asm:1210
0x9C91  0x18            CLC                     // CLC     Return NC for error       long.asm:1212
0x9C92  0x60            RTS                     // return;                           long.asm:1213
0x9C93  0x18            CLC                     // CLC                               long.asm:1215
0x9C94  0x65 0x11       ADC 0x11                // ADC ZP.TOP0                       long.asm:1216
0x9C96  0x85 0x11       STA 0x11                // STA ZP.TOP0                       long.asm:1217
0x9C98  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       long.asm:1218
0x9C9A  0x69 0x00       ADC # 0                 // ADC #0                            long.asm:1219
0x9C9C  0x85 0x12       STA 0x12                // STA ZP.TOP1                       long.asm:1220
0x9C9E  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       long.asm:1221
0x9CA0  0x69 0x00       ADC # 0                 // ADC #0                            long.asm:1222
0x9CA2  0x85 0x13       STA 0x13                // STA ZP.TOP2                       long.asm:1223
0x9CA4  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       long.asm:1224
0x9CA6  0x69 0x00       ADC # 0                 // ADC #0                            long.asm:1225
0x9CA8  0x85 0x14       STA 0x14                // STA ZP.TOP3                       long.asm:1226
0x9CAA  0x90 0x02       BCC 0x9CAE (+2)         // if (C)                            long.asm:1227
0x9CAC  0x18            CLC                     // CLC    Return NC for overflow     long.asm:1229
0x9CAD  0x60            RTS                     // }                                 long.asm:1230
0x9CAE  0x38            SEC                     // SEC    Return C for success       long.asm:1233
0x9CAF  0x60            RTS                     // }                                 long.asm:1235

// /source/projects/6502sbc/hopperbasic/objects/long.asm:1243
// ####  Long.FromDecimal()  ####                                               0x010A

0x9CB0  0x20 0x95 0x97  JSR 0x9795              // Long.ZeroTop();                   long.asm:1244
0x9CB3  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   long.asm:1253
0x9CB5  0xF0 0x32       BEQ 0x9CE9 (+50)        // if (Z) { break; }     Null terminator
0x9CB7  0x20 0x24 0x97  JSR 0x9724              // Char.IsDigit();                   long.asm:1259
0x9CBA  0x90 0x2D       BCC 0x9CE9 (+45)        // if (NC) { break; }     Not a digit
0x9CBC  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   long.asm:1263
0x9CBE  0x38            SEC                     // SEC                               long.asm:1264
0x9CBF  0xE9 0x30       SBC # 0x30              // SBC #'0'                          long.asm:1265
0x9CC1  0x48            PHA                     // PHA     Save digit                long.asm:1266
0x9CC2  0xA9 0x0A       LDA # 0x0A              // LDA #10                           long.asm:1269
0x9CC4  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      long.asm:1270
0x9CC6  0x20 0xA6 0x97  JSR 0x97A6              // ZeroNext3();                      long.asm:1271
0x9CC9  0x5A            PHY                     // PHY                               long.asm:1273
0x9CCA  0x20 0x77 0x9B  JSR 0x9B77              // utilityLongMUL();     RESULT = NEXT * TOP, munts Y
0x9CCD  0x7A            PLY                     // PLY                               long.asm:1275
0x9CCE  0xA5 0x53       LDA 0x53                // LDA ZP.RESULT4                    long.asm:1278
0x9CD0  0x05 0x54       ORA 0x54                // ORA ZP.RESULT5                    long.asm:1279
0x9CD2  0x05 0x55       ORA 0x55                // ORA ZP.RESULT6                    long.asm:1280
0x9CD4  0x05 0x56       ORA 0x56                // ORA ZP.RESULT7                    long.asm:1281
0x9CD6  0xF0 0x03       BEQ 0x9CDB (+3)         // if (NZ)     Overflow              long.asm:1282
0x9CD8  0x68            PLA                     // PLA     Clean up stack            long.asm:1284
0x9CD9  0x18            CLC                     // CLC                               long.asm:1285
0x9CDA  0x60            RTS                     // return;                           long.asm:1286
0x9CDB  0x20 0xF6 0x97  JSR 0x97F6              // moveResultToTop();    preserves Y long.asm:1290
0x9CDE  0x68            PLA                     // PLA                               long.asm:1293
0x9CDF  0x20 0x8D 0x9C  JSR 0x9C8D              // Long.AddDigit();    preserves Y   long.asm:1294
0x9CE2  0xB0 0x02       BCS 0x9CE6 (+2)         // if (NC)     Overflow              long.asm:1295
0x9CE4  0x18            CLC                     // CLC                               long.asm:1297
0x9CE5  0x60            RTS                     // return;                           long.asm:1298
0x9CE6  0xC8            INY                     // INY                               long.asm:1300
0x9CE7  0x80 0xCA       BRA 0x9CB3 (-54)        // }    loop                         long.asm:1301
0x9CE9  0x38            SEC                     // SEC     Success                   long.asm:1302
0x9CEA  0x60            RTS                     // }                                 long.asm:1303

// /source/projects/6502sbc/hopperbasic/objects/long.asm:1311
// ####  Long.FromHex()  ####                                                   0x010B

0x9CEB  0x20 0x95 0x97  JSR 0x9795              // Long.ZeroTop();                   long.asm:1312
0x9CEE  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   long.asm:1316
0x9CF0  0xF0 0x36       BEQ 0x9D28 (+54)        // if (Z) { break; }     Null terminator
0x9CF2  0x20 0x5C 0x97  JSR 0x975C              // Char.IsHex();                     long.asm:1319
0x9CF5  0x90 0x31       BCC 0x9D28 (+49)        // if (NC) { break; }     Not hex digit
0x9CF7  0xA2 0x04       LDX # 0x04              // LDX #4                            long.asm:1323
0x9CF9  0x06 0x11       ASL 0x11                // ASL ZP.TOP0                       long.asm:1326
0x9CFB  0x26 0x12       ROL 0x12                // ROL ZP.TOP1                       long.asm:1327
0x9CFD  0x26 0x13       ROL 0x13                // ROL ZP.TOP2                       long.asm:1328
0x9CFF  0x26 0x14       ROL 0x14                // ROL ZP.TOP3                       long.asm:1329
0x9D01  0x90 0x02       BCC 0x9D05 (+2)         // if (C)     Overflow               long.asm:1330
0x9D03  0x18            CLC                     // CLC                               long.asm:1332
0x9D04  0x60            RTS                     // return;                           long.asm:1333
0x9D05  0xCA            DEX                     // DEX                               long.asm:1335
0x9D06  0xD0 0xF1       BNE 0x9CF9 (-15)        // if (Z) { break; }                 long.asm:1336
0x9D08  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   long.asm:1340
0x9D0A  0x20 0x24 0x97  JSR 0x9724              // Char.IsDigit();                   long.asm:1341
0x9D0D  0x90 0x05       BCC 0x9D14 (+5)         // if (C)                            long.asm:1342
0x9D0F  0x38            SEC                     // SEC                               long.asm:1344
0x9D10  0xE9 0x30       SBC # 0x30              // SBC #'0'                          long.asm:1345
0x9D12  0x80 0x0D       BRA 0x9D21 (+13)        // }                                 long.asm:1346
0x9D14  0x20 0x4E 0x97  JSR 0x974E              // Char.IsLower();                   long.asm:1349
0x9D17  0x90 0x05       BCC 0x9D1E (+5)         // if (C)                            long.asm:1350
0x9D19  0x38            SEC                     // SEC                               long.asm:1352
0x9D1A  0xE9 0x57       SBC # 0x57              // SBC #('a' - 10)                   long.asm:1353
0x9D1C  0x80 0x03       BRA 0x9D21 (+3)         // }                                 long.asm:1354
0x9D1E  0x38            SEC                     // SEC                               long.asm:1357
0x9D1F  0xE9 0x37       SBC # 0x37              // SBC #('A' - 10)                   long.asm:1358
0x9D21  0x05 0x11       ORA 0x11                // ORA ZP.TOP0                       long.asm:1363
0x9D23  0x85 0x11       STA 0x11                // STA ZP.TOP0                       long.asm:1364
0x9D25  0xC8            INY                     // INY                               long.asm:1366
0x9D26  0x80 0xC6       BRA 0x9CEE (-58)        // }                                 long.asm:1367
0x9D28  0x38            SEC                     // SEC     Success                   long.asm:1368
0x9D29  0x60            RTS                     // }                                 long.asm:1369

// /source/projects/6502sbc/hopperbasic/objects/long.asm:1376
// ####  Long.DetermineType()  ####                                             0x010C

0x9D2A  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       long.asm:1377
0x9D2C  0x05 0x13       ORA 0x13                // ORA ZP.TOP2                       long.asm:1378
0x9D2E  0xF0 0x05       BEQ 0x9D35 (+5)         // if (NZ)                           long.asm:1379
0x9D30  0xA9 0x08       LDA # 0x08              // LDA #BASICType.LONG               long.asm:1381
0x9D32  0x85 0x15       STA 0x15                // STA ZP.TOPT                       long.asm:1382
0x9D34  0x60            RTS                     // return;                           long.asm:1383
0x9D35  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       long.asm:1386
0x9D37  0xF0 0x0D       BEQ 0x9D46 (+13)        // if (NZ)                           long.asm:1387
0x9D39  0x24 0x12       BIT 0x12                // BIT ZP.TOP1                       long.asm:1389
0x9D3B  0x10 0x04       BPL 0x9D41 (+4)         // if (MI)                           long.asm:1390
0x9D3D  0xA9 0x04       LDA # 0x04              // LDA #BASICType.WORD     32768-65535
0x9D3F  0x80 0x02       BRA 0x9D43 (+2)         // }                                 long.asm:1393
0x9D41  0xA9 0x02       LDA # 0x02              // LDA #BASICType.INT      256-32767 long.asm:1396
0x9D43  0x85 0x15       STA 0x15                // STA ZP.TOPT                       long.asm:1398
0x9D45  0x60            RTS                     // return;                           long.asm:1399
0x9D46  0xA9 0x03       LDA # 0x03              // LDA #BASICType.BYTE     0-255     long.asm:1402
0x9D48  0x85 0x15       STA 0x15                // STA ZP.TOPT                       long.asm:1403
0x9D4A  0x60            RTS                     // }                                 long.asm:1404

// /source/projects/6502sbc/hopperbasic/objects/long.asm:1412
// ####  Long.utility8BitDivMod10()  ####                                       0x010D

0x9D4B  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      long.asm:1413
0x9D4D  0xA0 0x00       LDY # 0                 // LDY #0                 Initialize quotient
0x9D4F  0xC9 0x64       CMP # 0x64              // CMP #100                          long.asm:1417
0x9D51  0x90 0x0E       BCC 0x9D61 (+14)        // if (C)                 >= 100     long.asm:1418
0x9D53  0x38            SEC                     // SEC                               long.asm:1420
0x9D54  0xE9 0x64       SBC # 0x64              // SBC #100                          long.asm:1421
0x9D56  0xA0 0x0A       LDY # 0x0A              // LDY #10            Add 10 to quotient
0x9D58  0xC9 0x64       CMP # 0x64              // CMP #100           Check for >= 200
0x9D5A  0x90 0x05       BCC 0x9D61 (+5)         // if (C)                            long.asm:1425
0x9D5C  0x38            SEC                     // SEC                               long.asm:1427
0x9D5D  0xE9 0x64       SBC # 0x64              // SBC #100                          long.asm:1428
0x9D5F  0xA0 0x14       LDY # 0x14              // LDY #20        Set quotient to 20 long.asm:1429
0x9D61  0xC9 0x0A       CMP # 0x0A              // CMP #10                           long.asm:1436
0x9D63  0x90 0x06       BCC 0x9D6B (+6)         // if (NC) { break; }     < 10, we're done
0x9D65  0x38            SEC                     // SEC                               long.asm:1439
0x9D66  0xE9 0x0A       SBC # 0x0A              // SBC #10                           long.asm:1440
0x9D68  0xC8            INY                     // INY                               long.asm:1441
0x9D69  0x80 0xF6       BRA 0x9D61 (-10)        // }                                 long.asm:1442
0x9D6B  0x85 0x4F       STA 0x4F                // STA ZP.RESULT0         Store remainder (0-9)
0x9D6D  0x84 0x16       STY 0x16                // STY ZP.NEXT0           Store quotient
0x9D6F  0x60            RTS                     // }                                 long.asm:1446

// /source/projects/6502sbc/hopperbasic/objects/long.asm:1454
// ####  Long.Print()  ####                                                     0x010E

0x9D70  0xDA            PHX                     // PHX                               long.asm:1455
0x9D71  0x5A            PHY                     // PHY                               long.asm:1456
0x9D72  0xBF 0x15 0x08  BBS3 0x15, 0x9D7D (+8)  // if (BBR3, ZP.TOPT)    Bit 3 - LONG
0x9D75  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL    only allow LONG
0x9D78  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     long.asm:1462
0x9D7B  0x80 0x48       BRA 0x9DC5 (+72)        // break;                            long.asm:1463
0x9D7D  0x20 0xE5 0x97  JSR 0x97E5              // moveTopToNext();                  long.asm:1466
0x9D80  0x7F 0x19 0x08  BBR7 0x19, 0x9D8B (+8)  // if (BBS7, ZP.NEXT3)               long.asm:1467
0x9D83  0xA9 0x2D       LDA # 0x2D              // LDA #'-'                          long.asm:1469
0x9D85  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               long.asm:1470
0x9D88  0x20 0x78 0x99  JSR 0x9978              // negateLongNEXT();                 long.asm:1471
0x9D8B  0x20 0xB6 0x97  JSR 0x97B6              // Long.ZeroCheckNext();             long.asm:1475
0x9D8E  0xD0 0x07       BNE 0x9D97 (+7)         // if (Z)                            long.asm:1476
0x9D90  0xA9 0x30       LDA # 0x30              // LDA #'0'                          long.asm:1478
0x9D92  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               long.asm:1479
0x9D95  0x80 0x2E       BRA 0x9DC5 (+46)        // break;                            long.asm:1480
0x9D97  0xA0 0x00       LDY # 0                 // LDY #0     Digit counter (also stack depth)
0x9D99  0x5A            PHY                     // PHY                               long.asm:1488
0x9D9A  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      long.asm:1489
0x9D9C  0x05 0x18       ORA 0x18                // ORA ZP.NEXT2                      long.asm:1490
0x9D9E  0x05 0x19       ORA 0x19                // ORA ZP.NEXT3                      long.asm:1491
0x9DA0  0xD0 0x05       BNE 0x9DA7 (+5)         // if (Z)                            long.asm:1492
0x9DA2  0x20 0x4B 0x9D  JSR 0x9D4B              // utility8BitDivMod10();            long.asm:1496
0x9DA5  0x80 0x0A       BRA 0x9DB1 (+10)        // }                                 long.asm:1497
0x9DA7  0xA9 0x0A       LDA # 0x0A              // LDA #10                           long.asm:1501
0x9DA9  0x20 0x90 0x97  JSR 0x9790              // LoadTopByte();                    long.asm:1502
0x9DAC  0xA2 0x01       LDX # 1                 // LDX #1             X=1 for mod (ensures we get remainder)
0x9DAE  0x20 0x84 0x9A  JSR 0x9A84              // DivMod();                         long.asm:1507
0x9DB1  0x7A            PLY                     // PLY                               long.asm:1510
0x9DB2  0xA5 0x4F       LDA 0x4F                // LDA ZP.RESULT0     Remainder is 0-9
0x9DB4  0x09 0x30       ORA # 0x30              // ORA #'0'           Convert to ASCII
0x9DB6  0x48            PHA                     // PHA                               long.asm:1515
0x9DB7  0xC8            INY                     // INY                Count digits   long.asm:1516
0x9DB8  0x20 0xB6 0x97  JSR 0x97B6              // Long.ZeroCheckNext();             long.asm:1519
0x9DBB  0xD0 0xDC       BNE 0x9D99 (-36)        // if (Z) { break; }     Done extracting digits
0x9DBD  0x68            PLA                     // PLA                               long.asm:1526
0x9DBE  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               long.asm:1527
0x9DC1  0x88            DEY                     // DEY                               long.asm:1528
0x9DC2  0xD0 0xF9       BNE 0x9DBD (-7)         // if (Z) { break; }                 long.asm:1529
0x9DC4  0x38            SEC                     // SEC                               long.asm:1531
0x9DC5  0x7A            PLY                     // PLY                               long.asm:1534
0x9DC6  0xFA            PLX                     // PLX                               long.asm:1535
0x9DC7  0x60            RTS                     // }                                 long.asm:1536

// /source/projects/6502sbc/hopperbasic/objects/table.asm:21
// ####  Table.GetFirst()  ####                                                 0x010F

0x9DC8  0xB5 0x00       LDA 0x00,X              // LDA 0x00, X                       table.asm:23
0x9DCA  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       table.asm:24
0x9DCC  0xB5 0x01       LDA 0x01,X              // LDA 0x01, X                       table.asm:25
0x9DCE  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       table.asm:26
0x9DD0  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       table.asm:29
0x9DD2  0x05 0x1C       ORA 0x1C                // ORA ZP.IDXH                       table.asm:30
0x9DD4  0xD0 0x02       BNE 0x9DD8 (+2)         // if (Z)                            table.asm:31
0x9DD6  0x18            CLC                     // CLC     Empty list                table.asm:33
0x9DD7  0x60            RTS                     // }                                 table.asm:34
0x9DD8  0x38            SEC                     // SEC     Found node                table.asm:37
0x9DD9  0x60            RTS                     // }                                 table.asm:39

// /source/projects/6502sbc/hopperbasic/objects/table.asm:45
// ####  Table.GetNext()  ####                                                  0x0110

0x9DDA  0x5A            PHY                     // PHY                               table.asm:46
0x9DDB  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       table.asm:51
0x9DDD  0x05 0x1C       ORA 0x1C                // ORA ZP.IDXH                       table.asm:52
0x9DDF  0xD0 0x03       BNE 0x9DE4 (+3)         // if (Z)                            table.asm:53
0x9DE1  0x18            CLC                     // CLC     Already at end            table.asm:55
0x9DE2  0x80 0x16       BRA 0x9DFA (+22)        // break;                            table.asm:56
0x9DE4  0xB2 0x1B       LDA [0x1B]              // LDA [ZP.IDX]                      table.asm:60
0x9DE6  0x48            PHA                     // PHA                               table.asm:61
0x9DE7  0xA0 0x01       LDY # 1                 // LDY #1                            table.asm:62
0x9DE9  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   table.asm:63
0x9DEB  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       table.asm:64
0x9DED  0x68            PLA                     // PLA                               table.asm:65
0x9DEE  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       table.asm:66
0x9DF0  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       table.asm:69
0x9DF2  0x05 0x1C       ORA 0x1C                // ORA ZP.IDXH                       table.asm:70
0x9DF4  0xD0 0x03       BNE 0x9DF9 (+3)         // if (Z)                            table.asm:71
0x9DF6  0x18            CLC                     // CLC     End of list               table.asm:73
0x9DF7  0x80 0x01       BRA 0x9DFA (+1)         // }                                 table.asm:74
0x9DF9  0x38            SEC                     // SEC     Found next node           table.asm:77
0x9DFA  0x7A            PLY                     // PLY                               table.asm:82
0x9DFB  0x60            RTS                     // }                                 table.asm:83

// /source/projects/6502sbc/hopperbasic/objects/table.asm:90
// ####  Table.Add()  ####                                                      0x0111

0x9DFC  0x48            PHA                     // PHA                               table.asm:91
0x9DFD  0xDA            PHX                     // PHX                               table.asm:92
0x9DFE  0x5A            PHY                     // PHY                               table.asm:93
0x9DFF  0x20 0x97 0x92  JSR 0x9297              // Memory.Allocate();          Table.Add(): Input: ZP.ACC = size, Munts: ZP.M*, ZP.FREELIST, ZP.ACCL, -> ZP.IDX
0x9E02  0x90 0x44       BCC 0x9E48 (+68)        // if (NC) { BIT ZP.EmulatorPCL break; }
0x9E04  0xA9 0x00       LDA # 0                 // LDA #0                            table.asm:101
0x9E06  0x92 0x1B       STA [0x1B]              // STA [IDX]                         table.asm:102
0x9E08  0xA0 0x01       LDY # 1                 // LDY #1                            table.asm:103
0x9E0A  0x91 0x1B       STA [0x1B],Y            // STA [IDX], Y                      table.asm:104
0x9E0C  0xB5 0x00       LDA 0x00,X              // LDA 0x00, X                Get low byte of pointer to first node
0x9E0E  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL                  table.asm:108
0x9E10  0xB5 0x01       LDA 0x01,X              // LDA 0x01, X                Get high byte of pointer to first node
0x9E12  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  table.asm:110
0x9E14  0x05 0x67       ORA 0x67                // ORA ZP.LCURRENTL                  table.asm:112
0x9E16  0xD0 0x0B       BNE 0x9E23 (+11)        // if (Z)                            table.asm:113
0x9E18  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       table.asm:116
0x9E1A  0x95 0x00       STA 0x00,X              // STA 0x00, X                       table.asm:117
0x9E1C  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       table.asm:118
0x9E1E  0x95 0x01       STA 0x01,X              // STA 0x01, X                       table.asm:119
0x9E20  0x38            SEC                     // SEC     Success                   table.asm:120
0x9E21  0x80 0x25       BRA 0x9E48 (+37)        // break;                            table.asm:121
0x9E23  0xB2 0x67       LDA [0x67]              // LDA [ZP.LCURRENT]                 table.asm:128
0x9E25  0x85 0x6D       STA 0x6D                // STA ZP.LNEXTL                     table.asm:129
0x9E27  0xA0 0x01       LDY # 1                 // LDY #1                            table.asm:130
0x9E29  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              table.asm:131
0x9E2B  0x85 0x6E       STA 0x6E                // STA ZP.LNEXTH                     table.asm:132
0x9E2D  0x05 0x6D       ORA 0x6D                // ORA ZP.LNEXTL                     table.asm:134
0x9E2F  0xD0 0x0C       BNE 0x9E3D (+12)        // if (Z)                            table.asm:135
0x9E31  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       table.asm:138
0x9E33  0x92 0x67       STA [0x67]              // STA [ZP.LCURRENT]                 table.asm:139
0x9E35  0xA0 0x01       LDY # 1                 // LDY #1                            table.asm:140
0x9E37  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       table.asm:141
0x9E39  0x91 0x67       STA [0x67],Y            // STA [ZP.LCURRENT], Y              table.asm:142
0x9E3B  0x80 0x0A       BRA 0x9E47 (+10)        // break;                            table.asm:143
0x9E3D  0xA5 0x6D       LDA 0x6D                // LDA ZP.LNEXTL                     table.asm:146
0x9E3F  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL                  table.asm:147
0x9E41  0xA5 0x6E       LDA 0x6E                // LDA ZP.LNEXTH                     table.asm:148
0x9E43  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  table.asm:149
0x9E45  0x80 0xDC       BRA 0x9E23 (-36)        // }    loop                         table.asm:150
0x9E47  0x38            SEC                     // SEC     Success                   table.asm:152
0x9E48  0x7A            PLY                     // PLY                               table.asm:156
0x9E49  0xFA            PLX                     // PLX                               table.asm:157
0x9E4A  0x68            PLA                     // PLA                               table.asm:158
0x9E4B  0x60            RTS                     // }                                 table.asm:159

// /source/projects/6502sbc/hopperbasic/objects/table.asm:166
// ####  Table.Delete()  ####                                                   0x0112

0x9E4C  0x48            PHA                     // PHA                               table.asm:167
0x9E4D  0xDA            PHX                     // PHX                               table.asm:168
0x9E4E  0x5A            PHY                     // PHY                               table.asm:169
0x9E4F  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       table.asm:171
0x9E51  0x48            PHA                     // PHA                               table.asm:172
0x9E52  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       table.asm:173
0x9E54  0x48            PHA                     // PHA                               table.asm:174
0x9E55  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       table.asm:176
0x9E57  0x48            PHA                     // PHA                               table.asm:177
0x9E58  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       table.asm:178
0x9E5A  0x48            PHA                     // PHA                               table.asm:179
0x9E5B  0x86 0x70       STX 0x70                // STX ZP.LHEADX                     table.asm:183
0x9E5D  0xB5 0x00       LDA 0x00,X              // LDA 0x00, X                       table.asm:186
0x9E5F  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL                  table.asm:187
0x9E61  0xB5 0x01       LDA 0x01,X              // LDA 0x01, X                       table.asm:188
0x9E63  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  table.asm:189
0x9E65  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  table.asm:192
0x9E67  0x05 0x68       ORA 0x68                // ORA ZP.LCURRENTH                  table.asm:193
0x9E69  0xD0 0x04       BNE 0x9E6F (+4)         // if (Z)                            table.asm:194
0x9E6B  0x18            CLC                     // CLC     Node not found            table.asm:196
0x9E6C  0x4C 0xF0 0x9E  JMP 0x9EF0              // break;                            table.asm:197
0x9E6F  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  table.asm:201
0x9E71  0xC5 0x1B       CMP 0x1B                // CMP ZP.IDXL                       table.asm:202
0x9E73  0xD0 0x27       BNE 0x9E9C (+39)        // if (Z)                            table.asm:203
0x9E75  0xA5 0x68       LDA 0x68                // LDA ZP.LCURRENTH                  table.asm:205
0x9E77  0xC5 0x1C       CMP 0x1C                // CMP ZP.IDXH                       table.asm:206
0x9E79  0xD0 0x21       BNE 0x9E9C (+33)        // if (Z)                            table.asm:207
0x9E7B  0xA6 0x70       LDX 0x70                // LDX ZP.LHEADX                     table.asm:211
0x9E7D  0xB2 0x67       LDA [0x67]              // LDA [ZP.LCURRENT]                 table.asm:212
0x9E7F  0x95 0x00       STA 0x00,X              // STA 0x00, X                       table.asm:213
0x9E81  0xA0 0x01       LDY # 1                 // LDY #1                            table.asm:214
0x9E83  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              table.asm:215
0x9E85  0x95 0x01       STA 0x01,X              // STA 0x01, X                       table.asm:216
0x9E87  0x68            PLA                     // PLA                               table.asm:219
0x9E88  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       table.asm:220
0x9E8A  0x68            PLA                     // PLA                               table.asm:221
0x9E8B  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       table.asm:222
0x9E8D  0x68            PLA                     // PLA                               table.asm:223
0x9E8E  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       table.asm:224
0x9E90  0x68            PLA                     // PLA                               table.asm:225
0x9E91  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       table.asm:226
0x9E93  0x20 0xB8 0x92  JSR 0x92B8              // Memory.Free();    Input: ZP.IDX, Munts: A, ZP.IDX, ZP.M* -> C on success
0x9E96  0x48            PHA                     // PHA                               table.asm:231
0x9E97  0x48            PHA                     // PHA                               table.asm:232
0x9E98  0x48            PHA                     // PHA                               table.asm:233
0x9E99  0x48            PHA                     // PHA                               table.asm:234
0x9E9A  0x80 0x54       BRA 0x9EF0 (+84)        // break;                            table.asm:235
0x9E9C  0x64 0x6B       STZ 0x6B                // STZ ZP.LPREVIOUSL                 table.asm:240
0x9E9E  0x64 0x6C       STZ 0x6C                // STZ ZP.LPREVIOUSH                 table.asm:241
0x9EA0  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  table.asm:246
0x9EA2  0x05 0x68       ORA 0x68                // ORA ZP.LCURRENTH                  table.asm:247
0x9EA4  0xD0 0x03       BNE 0x9EA9 (+3)         // if (Z)                            table.asm:248
0x9EA6  0x18            CLC                     // CLC     Node not found            table.asm:250
0x9EA7  0x80 0x47       BRA 0x9EF0 (+71)        // break;    exits inner loop, which will break outer loop
0x9EA9  0xB2 0x67       LDA [0x67]              // LDA [ZP.LCURRENT]                 table.asm:254
0x9EAB  0x85 0x6D       STA 0x6D                // STA ZP.LNEXTL                     table.asm:255
0x9EAD  0xA0 0x01       LDY # 1                 // LDY #1                            table.asm:256
0x9EAF  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              table.asm:257
0x9EB1  0x85 0x6E       STA 0x6E                // STA ZP.LNEXTH                     table.asm:258
0x9EB3  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  table.asm:261
0x9EB5  0xC5 0x1B       CMP 0x1B                // CMP ZP.IDXL                       table.asm:262
0x9EB7  0xD0 0x25       BNE 0x9EDE (+37)        // if (Z)                            table.asm:263
0x9EB9  0xA5 0x68       LDA 0x68                // LDA ZP.LCURRENTH                  table.asm:265
0x9EBB  0xC5 0x1C       CMP 0x1C                // CMP ZP.IDXH                       table.asm:266
0x9EBD  0xD0 0x1F       BNE 0x9EDE (+31)        // if (Z)                            table.asm:267
0x9EBF  0xA5 0x6D       LDA 0x6D                // LDA ZP.LNEXTL                     table.asm:271
0x9EC1  0x92 0x6B       STA [0x6B]              // STA [ZP.LPREVIOUS]                table.asm:272
0x9EC3  0xA0 0x01       LDY # 1                 // LDY #1                            table.asm:273
0x9EC5  0xA5 0x6E       LDA 0x6E                // LDA ZP.LNEXTH                     table.asm:274
0x9EC7  0x91 0x6B       STA [0x6B],Y            // STA [ZP.LPREVIOUS], Y             table.asm:275
0x9EC9  0x68            PLA                     // PLA                               table.asm:278
0x9ECA  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       table.asm:279
0x9ECC  0x68            PLA                     // PLA                               table.asm:280
0x9ECD  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       table.asm:281
0x9ECF  0x68            PLA                     // PLA                               table.asm:282
0x9ED0  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       table.asm:283
0x9ED2  0x68            PLA                     // PLA                               table.asm:284
0x9ED3  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       table.asm:285
0x9ED5  0x20 0xB8 0x92  JSR 0x92B8              // Memory.Free();    Input: ZP.IDX, Munts: A, ZP.IDX, ZP.M* -> C on success
0x9ED8  0x48            PHA                     // PHA                               table.asm:290
0x9ED9  0x48            PHA                     // PHA                               table.asm:291
0x9EDA  0x48            PHA                     // PHA                               table.asm:292
0x9EDB  0x48            PHA                     // PHA                               table.asm:293
0x9EDC  0x80 0x12       BRA 0x9EF0 (+18)        // break;    exits inner loop with success flag set
0x9EDE  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  table.asm:300
0x9EE0  0x85 0x6B       STA 0x6B                // STA ZP.LPREVIOUSL                 table.asm:301
0x9EE2  0xA5 0x68       LDA 0x68                // LDA ZP.LCURRENTH                  table.asm:302
0x9EE4  0x85 0x6C       STA 0x6C                // STA ZP.LPREVIOUSH                 table.asm:303
0x9EE6  0xA5 0x6D       LDA 0x6D                // LDA ZP.LNEXTL                     table.asm:306
0x9EE8  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL                  table.asm:307
0x9EEA  0xA5 0x6E       LDA 0x6E                // LDA ZP.LNEXTH                     table.asm:308
0x9EEC  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  table.asm:309
0x9EEE  0x80 0xB0       BRA 0x9EA0 (-80)        // }    inner loop                   table.asm:310
0x9EF0  0x68            PLA                     // PLA                               table.asm:316
0x9EF1  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       table.asm:317
0x9EF3  0x68            PLA                     // PLA                               table.asm:318
0x9EF4  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       table.asm:319
0x9EF6  0x68            PLA                     // PLA                               table.asm:321
0x9EF7  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       table.asm:322
0x9EF9  0x68            PLA                     // PLA                               table.asm:323
0x9EFA  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       table.asm:324
0x9EFC  0x7A            PLY                     // PLY                               table.asm:326
0x9EFD  0xFA            PLX                     // PLX                               table.asm:327
0x9EFE  0x68            PLA                     // PLA                               table.asm:328
0x9EFF  0x60            RTS                     // }                                 table.asm:329

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:32
// ####  Objects.Initialize()  ####                                             0x0114

0x9F00  0x64 0x3C       STZ 0x3C                // STZ ZP.VariablesListL             objects.asm:33
0x9F02  0x64 0x3D       STZ 0x3D                // STZ ZP.VariablesListH             objects.asm:34
0x9F04  0x64 0x3E       STZ 0x3E                // STZ ZP.FunctionsListL             objects.asm:35
0x9F06  0x64 0x3F       STZ 0x3F                // STZ ZP.FunctionsListH             objects.asm:36
0x9F08  0x60            RTS                     // }                                 objects.asm:37

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:46
// ####  Objects.Add()  ####                                                    0x0115

0x9F09  0x48            PHA                     // PHA                               objects.asm:47
0x9F0A  0xDA            PHX                     // PHX                               objects.asm:48
0x9F0B  0x5A            PHY                     // PHY                               objects.asm:49
0x9F0C  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       objects.asm:51
0x9F0E  0x48            PHA                     // PHA                               objects.asm:52
0x9F0F  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       objects.asm:53
0x9F11  0x48            PHA                     // PHA                               objects.asm:54
0x9F12  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       objects.asm:56
0x9F14  0x48            PHA                     // PHA                               objects.asm:57
0x9F15  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       objects.asm:58
0x9F17  0x48            PHA                     // PHA                               objects.asm:59
0x9F18  0x86 0x49       STX 0x49                // STX ZP.SymbolTemp0                objects.asm:64
0x9F1A  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       objects.asm:67
0x9F1C  0x85 0x40       STA 0x40                // STA ZP.SymbolType      Save symbolType|dataType
0x9F1E  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       objects.asm:71
0x9F20  0x85 0x43       STA 0x43                // STA ZP.SymbolNameL     Save name pointer low
0x9F22  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       objects.asm:73
0x9F24  0x85 0x44       STA 0x44                // STA ZP.SymbolNameH     Save name pointer high
0x9F26  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       objects.asm:77
0x9F28  0x85 0x45       STA 0x45                // STA ZP.SymbolTokensL              objects.asm:78
0x9F2A  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       objects.asm:79
0x9F2C  0x85 0x46       STA 0x46                // STA ZP.SymbolTokensH              objects.asm:80
0x9F2E  0x20 0x2F 0xA0  JSR 0xA02F              // calculateNodeSize();    Returns size in ZP.ACC, sets ZP.SymbolLength
0x9F31  0xA6 0x49       LDX 0x49                // LDX ZP.SymbolTemp0     Restore table head address
0x9F33  0x20 0xFC 0x9D  JSR 0x9DFC              // Table.Add();    Returns new node in IDX, C set if successful
0x9F36  0xB0 0x03       BCS 0x9F3B (+3)         // if (NC)     Allocation failed     objects.asm:88
0x9F38  0x18            CLC                     // CLC     Already clear             objects.asm:90
0x9F39  0x80 0x04       BRA 0x9F3F (+4)         // break;                            objects.asm:91
0x9F3B  0x20 0x4E 0xA0  JSR 0xA04E              // initializeNode();                 objects.asm:95
0x9F3E  0x38            SEC                     // SEC     Success                   objects.asm:97
0x9F3F  0x68            PLA                     // PLA                               objects.asm:101
0x9F40  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       objects.asm:102
0x9F42  0x68            PLA                     // PLA                               objects.asm:103
0x9F43  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       objects.asm:104
0x9F45  0x68            PLA                     // PLA                               objects.asm:106
0x9F46  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       objects.asm:107
0x9F48  0x68            PLA                     // PLA                               objects.asm:108
0x9F49  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       objects.asm:109
0x9F4B  0x7A            PLY                     // PLY                               objects.asm:111
0x9F4C  0xFA            PLX                     // PLX                               objects.asm:112
0x9F4D  0x68            PLA                     // PLA                               objects.asm:113
0x9F4E  0x60            RTS                     // }                                 objects.asm:114

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:122
// ####  Objects.Find()  ####                                                   0x0116

0x9F4F  0x48            PHA                     // PHA                               objects.asm:123
0x9F50  0xDA            PHX                     // PHX                               objects.asm:124
0x9F51  0x5A            PHY                     // PHY                               objects.asm:125
0x9F52  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      objects.asm:127
0x9F54  0x48            PHA                     // PHA                               objects.asm:128
0x9F55  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      objects.asm:129
0x9F57  0x48            PHA                     // PHA                               objects.asm:130
0x9F58  0x64 0x1D       STZ 0x1D                // STZ ZP.IDYL     Initialize counter to 0
0x9F5A  0x64 0x1E       STZ 0x1E                // STZ ZP.IDYH     always zero for now
0x9F5C  0x20 0xC8 0x9D  JSR 0x9DC8              // Table.GetFirst();    Returns first node in IDX
0x9F5F  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       objects.asm:142
0x9F61  0x05 0x1C       ORA 0x1C                // ORA ZP.IDXH                       objects.asm:143
0x9F63  0xD0 0x03       BNE 0x9F68 (+3)         // if (Z)                            objects.asm:144
0x9F65  0x18            CLC                     // CLC     Not found                 objects.asm:146
0x9F66  0x80 0x0D       BRA 0x9F75 (+13)        // break;                            objects.asm:147
0x9F68  0x20 0xA5 0xA0  JSR 0xA0A5              // compareNames();                   objects.asm:150
0x9F6B  0xB0 0x08       BCS 0x9F75 (+8)         // if (C)    Names match             objects.asm:151
0x9F6D  0x20 0x50 0x93  JSR 0x9350              // IncIDY();                         objects.asm:157
0x9F70  0x20 0xDA 0x9D  JSR 0x9DDA              // Table.GetNext();    Updates IDX   objects.asm:160
0x9F73  0x80 0xEA       BRA 0x9F5F (-22)        // }                                 objects.asm:161
0x9F75  0x68            PLA                     // PLA                               objects.asm:166
0x9F76  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      objects.asm:167
0x9F78  0x68            PLA                     // PLA                               objects.asm:168
0x9F79  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      objects.asm:169
0x9F7B  0x7A            PLY                     // PLY                               objects.asm:171
0x9F7C  0xFA            PLX                     // PLX                               objects.asm:172
0x9F7D  0x68            PLA                     // PLA                               objects.asm:173
0x9F7E  0x60            RTS                     // }                                 objects.asm:174

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:191
// ####  Objects.GetData()  ####                                                0x0118

0x9F7F  0x5A            PHY                     // PHY                               objects.asm:192
0x9F80  0xA0 0x02       LDY # 0x02              // LDY # Objects.snType    GetData : load
0x9F82  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   objects.asm:196
0x9F84  0x85 0x10       STA 0x10                // STA ZP.ACCT                       objects.asm:197
0x9F86  0xA0 0x03       LDY # 0x03              // LDY #snTokens                     objects.asm:200
0x9F88  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   objects.asm:201
0x9F8A  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      objects.asm:202
0x9F8C  0xC8            INY                     // INY                               objects.asm:203
0x9F8D  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   objects.asm:204
0x9F8F  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      objects.asm:205
0x9F91  0xA0 0x05       LDY # 0x05              // LDY #snValue                      objects.asm:208
0x9F93  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   objects.asm:209
0x9F95  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       objects.asm:210
0x9F97  0xC8            INY                     // INY                               objects.asm:211
0x9F98  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   objects.asm:212
0x9F9A  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       objects.asm:213
0x9F9C  0x7A            PLY                     // PLY                               objects.asm:215
0x9F9D  0x60            RTS                     // }                                 objects.asm:216

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:222
// ####  Objects.SetValue()  ####                                               0x0119

0x9F9E  0x48            PHA                     // PHA                               objects.asm:223
0x9F9F  0x5A            PHY                     // PHY                               objects.asm:224
0x9FA0  0xA0 0x02       LDY # 0x02              // LDY # Objects.snType    SetValue : load
0x9FA2  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   objects.asm:230
0x9FA4  0x29 0xC0       AND # 0xC0              // AND #SymbolType.MASK              objects.asm:231
0x9FA6  0xC9 0x40       CMP # 0x40              // CMP #SymbolType.VARIABLE          objects.asm:232
0x9FA8  0xF0 0x07       BEQ 0x9FB1 (+7)         // if (NZ)                           objects.asm:233
0x9FAA  0xC9 0x80       CMP # 0x80              // CMP #SymbolType.CONSTANT          objects.asm:235
0x9FAC  0xF0 0x03       BEQ 0x9FB1 (+3)         // if (NZ)                           objects.asm:236
0x9FAE  0x18            CLC                     // CLC     Not a variable or constant
0x9FAF  0x80 0x16       BRA 0x9FC7 (+22)        // break;                            objects.asm:239
0x9FB1  0xA0 0x05       LDY # 0x05              // LDY # snValue                     objects.asm:244
0x9FB3  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       objects.asm:245
0x9FB5  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:246
0x9FB7  0xC8            INY                     // INY                               objects.asm:247
0x9FB8  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       objects.asm:248
0x9FBA  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:249
0x9FBC  0xC8            INY                     // INY                               objects.asm:250
0x9FBD  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       objects.asm:251
0x9FBF  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:252
0x9FC1  0xC8            INY                     // INY                               objects.asm:253
0x9FC2  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       objects.asm:254
0x9FC4  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:255
0x9FC6  0x38            SEC                     // SEC     Success                   objects.asm:257
0x9FC7  0x7A            PLY                     // PLY                               objects.asm:261
0x9FC8  0x68            PLA                     // PLA                               objects.asm:262
0x9FC9  0x60            RTS                     // }                                 objects.asm:263

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:270
// ####  Objects.GetTokens()  ####                                              0x011A

0x9FCA  0x5A            PHY                     // PHY                               objects.asm:271
0x9FCB  0xA0 0x03       LDY # 0x03              // LDY #snTokens                     objects.asm:274
0x9FCD  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   objects.asm:275
0x9FCF  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       objects.asm:276
0x9FD1  0xC8            INY                     // INY                               objects.asm:277
0x9FD2  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   objects.asm:278
0x9FD4  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       objects.asm:279
0x9FD6  0x7A            PLY                     // PLY                               objects.asm:281
0x9FD7  0x60            RTS                     // }                                 objects.asm:282

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:288
// ####  Objects.SetTokens()  ####                                              0x011B

0x9FD8  0x5A            PHY                     // PHY                               objects.asm:289
0x9FD9  0xA0 0x03       LDY # 0x03              // LDY #snTokens                     objects.asm:292
0x9FDB  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       objects.asm:293
0x9FDD  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:294
0x9FDF  0xC8            INY                     // INY                               objects.asm:295
0x9FE0  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       objects.asm:296
0x9FE2  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:297
0x9FE4  0x7A            PLY                     // PLY                               objects.asm:299
0x9FE5  0x60            RTS                     // }                                 objects.asm:300

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:316
// ####  Objects.IterateStart()  ####                                           0x011D

0x9FE6  0x48            PHA                     // PHA                               objects.asm:317
0x9FE7  0xDA            PHX                     // PHX                               objects.asm:318
0x9FE8  0x5A            PHY                     // PHY                               objects.asm:319
0x9FE9  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       objects.asm:321
0x9FEB  0x48            PHA                     // PHA                               objects.asm:322
0x9FEC  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       objects.asm:323
0x9FEE  0x48            PHA                     // PHA                               objects.asm:324
0x9FEF  0x20 0xC8 0x9D  JSR 0x9DC8              // Table.GetFirst();    Returns first node in IDX
0x9FF2  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       objects.asm:332
0x9FF4  0x05 0x1C       ORA 0x1C                // ORA ZP.IDXH                       objects.asm:333
0x9FF6  0xD0 0x03       BNE 0x9FFB (+3)         // if (Z)                            objects.asm:334
0x9FF8  0x18            CLC                     // CLC     Empty list                objects.asm:336
0x9FF9  0x80 0x03       BRA 0x9FFE (+3)         // break;                            objects.asm:337
0x9FFB  0x20 0xD4 0xA0  JSR 0xA0D4              // findNextMatch();                  objects.asm:340
0x9FFE  0x68            PLA                     // PLA                               objects.asm:344
0x9FFF  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       objects.asm:345
0xA001  0x68            PLA                     // PLA                               objects.asm:346
0xA002  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       objects.asm:347
0xA004  0x7A            PLY                     // PLY                               objects.asm:349
0xA005  0xFA            PLX                     // PLX                               objects.asm:350
0xA006  0x68            PLA                     // PLA                               objects.asm:351
0xA007  0x60            RTS                     // }                                 objects.asm:352

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:359
// ####  Objects.IterateNext()  ####                                            0x011E

0xA008  0x48            PHA                     // PHA                               objects.asm:360
0xA009  0xDA            PHX                     // PHX                               objects.asm:361
0xA00A  0x5A            PHY                     // PHY                               objects.asm:362
0xA00B  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       objects.asm:364
0xA00D  0x48            PHA                     // PHA                               objects.asm:365
0xA00E  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       objects.asm:366
0xA010  0x48            PHA                     // PHA                               objects.asm:367
0xA011  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       objects.asm:372
0xA013  0x05 0x1C       ORA 0x1C                // ORA ZP.IDXH                       objects.asm:373
0xA015  0xD0 0x03       BNE 0xA01A (+3)         // if (Z)                            objects.asm:374
0xA017  0x18            CLC                     // CLC     Already at end            objects.asm:376
0xA018  0x80 0x0B       BRA 0xA025 (+11)        // break;                            objects.asm:377
0xA01A  0x20 0xDA 0x9D  JSR 0x9DDA              // Table.GetNext();    Updates IDX   objects.asm:381
0xA01D  0xB0 0x03       BCS 0xA022 (+3)         // if (NC)                           objects.asm:382
0xA01F  0x18            CLC                     // CLC     End of list               objects.asm:384
0xA020  0x80 0x03       BRA 0xA025 (+3)         // break;                            objects.asm:385
0xA022  0x20 0xD4 0xA0  JSR 0xA0D4              // findNextMatch();                  objects.asm:398
0xA025  0x68            PLA                     // PLA                               objects.asm:402
0xA026  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       objects.asm:403
0xA028  0x68            PLA                     // PLA                               objects.asm:404
0xA029  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       objects.asm:405
0xA02B  0x7A            PLY                     // PLY                               objects.asm:407
0xA02C  0xFA            PLX                     // PLX                               objects.asm:408
0xA02D  0x68            PLA                     // PLA                               objects.asm:409
0xA02E  0x60            RTS                     // }                                 objects.asm:410

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:417
// ####  Objects.calculateNodeSize()  ####                                      0x011F

0xA02F  0xDA            PHX                     // PHX                               objects.asm:418
0xA030  0x5A            PHY                     // PHY                               objects.asm:419
0xA031  0xA6 0x43       LDX 0x43                // LDX ZP.SymbolNameL                objects.asm:422
0xA033  0xA4 0x44       LDY 0x44                // LDY ZP.SymbolNameH                objects.asm:423
0xA035  0x20 0xF0 0x95  JSR 0x95F0              // Tools.StringLength();    Returns length in A, preserves X,Y
0xA038  0x85 0x48       STA 0x48                // STA ZP.SymbolLength               objects.asm:425
0xA03A  0x18            CLC                     // CLC                               objects.asm:428
0xA03B  0x69 0x0B       ADC # 0x0B              // ADC #symbolOverhead               objects.asm:429
0xA03D  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       objects.asm:430
0xA03F  0xA9 0x00       LDA # 0                 // LDA #0                            objects.asm:432
0xA041  0x69 0x00       ADC # 0                 // ADC #0     Add carry              objects.asm:433
0xA043  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       objects.asm:434
0xA045  0xE6 0x0E       INC 0x0E                // INC ZP.ACCL                       objects.asm:437
0xA047  0xD0 0x02       BNE 0xA04B (+2)         // if (Z)                            objects.asm:438
0xA049  0xE6 0x0F       INC 0x0F                // INC ZP.ACCH                       objects.asm:440
0xA04B  0x7A            PLY                     // PLY                               objects.asm:443
0xA04C  0xFA            PLX                     // PLX                               objects.asm:444
0xA04D  0x60            RTS                     // }                                 objects.asm:445

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:450
// ####  Objects.initializeNode()  ####                                         0x0120

0xA04E  0x5A            PHY                     // PHY                               objects.asm:451
0xA04F  0xA5 0x40       LDA 0x40                // LDA ZP.SymbolType                 objects.asm:454
0xA051  0xA0 0x02       LDY # 0x02              // LDY # Objects.snType    initializeNode: store
0xA053  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:456
0xA055  0xA5 0x45       LDA 0x45                // LDA ZP.SymbolTokensL              objects.asm:459
0xA057  0xA0 0x03       LDY # 0x03              // LDY #snTokens                     objects.asm:460
0xA059  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:461
0xA05B  0xA5 0x46       LDA 0x46                // LDA ZP.SymbolTokensH              objects.asm:462
0xA05D  0xC8            INY                     // INY                               objects.asm:463
0xA05E  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:464
0xA060  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      objects.asm:467
0xA062  0xA0 0x05       LDY # 0x05              // LDY #snValue                      objects.asm:468
0xA064  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:469
0xA066  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      objects.asm:470
0xA068  0xC8            INY                     // INY                               objects.asm:471
0xA069  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:472
0xA06B  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      objects.asm:473
0xA06D  0xC8            INY                     // INY                               objects.asm:474
0xA06E  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:475
0xA070  0xA5 0x19       LDA 0x19                // LDA ZP.NEXT3                      objects.asm:476
0xA072  0xC8            INY                     // INY                               objects.asm:477
0xA073  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   objects.asm:478
0xA075  0x20 0x7A 0xA0  JSR 0xA07A              // copyNameToNode();                 objects.asm:481
0xA078  0x7A            PLY                     // PLY                               objects.asm:483
0xA079  0x60            RTS                     // }                                 objects.asm:484

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:489
// ####  Objects.copyNameToNode()  ####                                         0x0121

0xA07A  0x48            PHA                     // PHA                               objects.asm:490
0xA07B  0xDA            PHX                     // PHX                               objects.asm:491
0xA07C  0x5A            PHY                     // PHY                               objects.asm:492
0xA07D  0xA5 0x43       LDA 0x43                // LDA ZP.SymbolNameL                objects.asm:495
0xA07F  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            objects.asm:496
0xA081  0xA5 0x44       LDA 0x44                // LDA ZP.SymbolNameH                objects.asm:497
0xA083  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            objects.asm:498
0xA085  0x18            CLC                     // CLC                               objects.asm:501
0xA086  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       objects.asm:502
0xA088  0x69 0x0B       ADC # 0x0B              // ADC #snName                       objects.asm:503
0xA08A  0x85 0x63       STA 0x63                // STA ZP.FDESTINATIONADDRESSL       objects.asm:504
0xA08C  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       objects.asm:505
0xA08E  0x69 0x00       ADC # 0                 // ADC #0                            objects.asm:506
0xA090  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       objects.asm:507
0xA092  0xA5 0x48       LDA 0x48                // LDA ZP.SymbolLength               objects.asm:511
0xA094  0x85 0x65       STA 0x65                // STA ZP.FLENGTHL                   objects.asm:512
0xA096  0x64 0x66       STZ 0x66                // STZ ZP.FLENGTHH                   objects.asm:513
0xA098  0xE6 0x65       INC 0x65                // INC ZP.FLENGTHL                   objects.asm:516
0xA09A  0xD0 0x02       BNE 0xA09E (+2)         // if (Z)                            objects.asm:517
0xA09C  0xE6 0x66       INC 0x66                // INC ZP.FLENGTHH                   objects.asm:519
0xA09E  0x20 0x0B 0x93  JSR 0x930B              // Memory.Copy();    FSOURCEADDRESS=src, FDESTINATIONADDRESS=dst, FLENGTH=count
0xA0A1  0x7A            PLY                     // PLY                               objects.asm:524
0xA0A2  0xFA            PLX                     // PLX                               objects.asm:525
0xA0A3  0x68            PLA                     // PLA                               objects.asm:526
0xA0A4  0x60            RTS                     // }                                 objects.asm:527

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:533
// ####  Objects.compareNames()  ####                                           0x0122

0xA0A5  0x48            PHA                     // PHA                               objects.asm:534
0xA0A6  0xDA            PHX                     // PHX                               objects.asm:535
0xA0A7  0x5A            PHY                     // PHY                               objects.asm:536
0xA0A8  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       objects.asm:538
0xA0AA  0x48            PHA                     // PHA                               objects.asm:539
0xA0AB  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       objects.asm:540
0xA0AD  0x48            PHA                     // PHA                               objects.asm:541
0xA0AE  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      objects.asm:543
0xA0B0  0x48            PHA                     // PHA                               objects.asm:544
0xA0B1  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      objects.asm:545
0xA0B3  0x48            PHA                     // PHA                               objects.asm:546
0xA0B4  0x18            CLC                     // CLC                               objects.asm:549
0xA0B5  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       objects.asm:550
0xA0B7  0x69 0x0B       ADC # 0x0B              // ADC #snName                       objects.asm:551
0xA0B9  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      objects.asm:552
0xA0BB  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       objects.asm:553
0xA0BD  0x69 0x00       ADC # 0                 // ADC #0                            objects.asm:554
0xA0BF  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      objects.asm:555
0xA0C1  0x20 0x0F 0x96  JSR 0x960F              // Tools.StringCompare();    TOP vs NEXT, sets C if equal
0xA0C4  0x68            PLA                     // PLA                               objects.asm:560
0xA0C5  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      objects.asm:561
0xA0C7  0x68            PLA                     // PLA                               objects.asm:562
0xA0C8  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      objects.asm:563
0xA0CA  0x68            PLA                     // PLA                               objects.asm:565
0xA0CB  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       objects.asm:566
0xA0CD  0x68            PLA                     // PLA                               objects.asm:567
0xA0CE  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       objects.asm:568
0xA0D0  0x7A            PLY                     // PLY                               objects.asm:570
0xA0D1  0xFA            PLX                     // PLX                               objects.asm:571
0xA0D2  0x68            PLA                     // PLA                               objects.asm:572
0xA0D3  0x60            RTS                     // }                                 objects.asm:573

// /source/projects/6502sbc/hopperbasic/objects/objects.asm:579
// ####  Objects.findNextMatch()  ####                                          0x0123

0xA0D4  0x5A            PHY                     // PHY                               objects.asm:580
0xA0D5  0xA5 0x47       LDA 0x47                // LDA ZP.SymbolIteratorFilter       objects.asm:585
0xA0D7  0xD0 0x03       BNE 0xA0DC (+3)         // if (Z)                            objects.asm:586
0xA0D9  0x38            SEC                     // SEC     Match all                 objects.asm:588
0xA0DA  0x80 0x17       BRA 0xA0F3 (+23)        // break;                            objects.asm:589
0xA0DC  0xA0 0x02       LDY # 0x02              // LDY # Objects.snType    findNextMatch : load
0xA0DE  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   objects.asm:594
0xA0E0  0x29 0xC0       AND # 0xC0              // AND #SymbolType.MASK              objects.asm:595
0xA0E2  0xC5 0x47       CMP 0x47                // CMP ZP.SymbolIteratorFilter       objects.asm:596
0xA0E4  0xD0 0x03       BNE 0xA0E9 (+3)         // if (Z)                            objects.asm:597
0xA0E6  0x38            SEC                     // SEC     Match found               objects.asm:599
0xA0E7  0x80 0x0A       BRA 0xA0F3 (+10)        // break;                            objects.asm:600
0xA0E9  0x20 0xDA 0x9D  JSR 0x9DDA              // Table.GetNext();                  objects.asm:604
0xA0EC  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       objects.asm:607
0xA0EE  0x05 0x1C       ORA 0x1C                // ORA ZP.IDXH                       objects.asm:608
0xA0F0  0xD0 0xE3       BNE 0xA0D5 (-29)        // if (Z)                            objects.asm:609
0xA0F2  0x18            CLC                     // CLC     End of list               objects.asm:611
0xA0F3  0x7A            PLY                     // PLY                               objects.asm:618
0xA0F4  0x60            RTS                     // }                                 objects.asm:619

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:17
// ####  Variables.Declare()  ####                                              0x0124

0xA0F5  0x48            PHA                     // PHA                               variables.asm:18
0xA0F6  0xDA            PHX                     // PHX                               variables.asm:19
0xA0F7  0x5A            PHY                     // PHY                               variables.asm:20
0xA0F8  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       variables.asm:29
0xA0FA  0x48            PHA                     // PHA                               variables.asm:30
0xA0FB  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       variables.asm:31
0xA0FD  0x48            PHA                     // PHA                               variables.asm:32
0xA0FE  0xA2 0x3C       LDX # 0x3C              // LDX #ZP.VariablesList             variables.asm:35
0xA100  0x20 0x4F 0x9F  JSR 0x9F4F              // Objects.Find();                   variables.asm:36
0xA103  0x68            PLA                     // PLA                               variables.asm:38
0xA104  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       variables.asm:39
0xA106  0x68            PLA                     // PLA                               variables.asm:40
0xA107  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       variables.asm:41
0xA109  0x90 0x05       BCC 0xA110 (+5)         // if (C)     Symbol already exists  variables.asm:43
0xA10B  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xA10E  0x80 0x7A       BRA 0xA18A (+122)       // break;                            variables.asm:46
0xA110  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:49
0xA112  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          variables.asm:50
0xA114  0xC9 0x05       CMP # 0x05              // CMP # BASICType.STRING            variables.asm:51
0xA116  0xD0 0x0A       BNE 0xA122 (+10)        // if (Z)                            variables.asm:52
0xA118  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      variables.asm:55
0xA11A  0x48            PHA                     // PHA                               variables.asm:56
0xA11B  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      variables.asm:57
0xA11D  0x48            PHA                     // PHA                               variables.asm:58
0xA11E  0x64 0x16       STZ 0x16                // STZ ZP.NEXTL                      variables.asm:59
0xA120  0x64 0x17       STZ 0x17                // STZ ZP.NEXTH                      variables.asm:60
0xA122  0x5F 0x10 0x26  BBR5 0x10, 0xA14B (+38) // if (BBS5, ZP.ACCT)    Bit 5 - ARRAY
0xA125  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:67
0xA127  0x29 0x0F       AND # 0x0F              // AND #BASICType.TYPEMASK           variables.asm:68
0xA129  0x85 0x10       STA 0x10                // STA ZP.ACCT     Element type for BASICArray.New
0xA12B  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      variables.asm:72
0xA12D  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       variables.asm:73
0xA12F  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      variables.asm:74
0xA131  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       variables.asm:75
0xA133  0x20 0xF8 0xAA  JSR 0xAAF8              // BASICArray.New();     Returns pointer in ZP.IDX
0xA136  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     variables.asm:78
0xA139  0x90 0x4F       BCC 0xA18A (+79)        // if (NC)                           variables.asm:79
0xA13B  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       variables.asm:85
0xA13D  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      variables.asm:86
0xA13F  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       variables.asm:87
0xA141  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      variables.asm:88
0xA143  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:91
0xA145  0x09 0x20       ORA # 0x20              // ORA # BASICType.ARRAY             variables.asm:92
0xA147  0x09 0x40       ORA # 0x40              // ORA # SymbolType.VARIABLE         variables.asm:93
0xA149  0x85 0x10       STA 0x10                // STA ZP.ACCT                       variables.asm:94
0xA14B  0xA2 0x3C       LDX # 0x3C              // LDX #ZP.VariablesList             variables.asm:98
0xA14D  0x20 0x09 0x9F  JSR 0x9F09              // Objects.Add();                    variables.asm:104
0xA150  0xB0 0x02       BCS 0xA154 (+2)         // if (NC)                           variables.asm:105
0xA152  0x64 0x4E       STZ 0x4E                // States.SetFailure();              variables.asm:107
0xA154  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:110
0xA156  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          variables.asm:111
0xA158  0xC9 0x05       CMP # 0x05              // CMP # BASICType.STRING            variables.asm:112
0xA15A  0xD0 0x0C       BNE 0xA168 (+12)        // if (Z)                            variables.asm:113
0xA15C  0x68            PLA                     // PLA                               variables.asm:116
0xA15D  0x85 0x12       STA 0x12                // STA ZP.TOPH                       variables.asm:117
0xA15F  0x68            PLA                     // PLA                               variables.asm:118
0xA160  0x85 0x11       STA 0x11                // STA ZP.TOPL                       variables.asm:119
0xA162  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:120
0xA164  0x29 0x3F       AND # 0x3F              // AND # BASICType.MASK    keep VAR  variables.asm:121
0xA166  0x85 0x15       STA 0x15                // STA ZP.TOPT                       variables.asm:122
0xA168  0x20 0x8B 0x89  JSR 0x898B              // States.IsFailure();               variables.asm:125
0xA16B  0x90 0x03       BCC 0xA170 (+3)         // if (C)                            variables.asm:126
0xA16D  0x18            CLC                     // CLC                               variables.asm:128
0xA16E  0x80 0x1A       BRA 0xA18A (+26)        // break;                            variables.asm:129
0xA170  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:131
0xA172  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          variables.asm:132
0xA174  0xC9 0x05       CMP # 0x05              // CMP # BASICType.STRING            variables.asm:133
0xA176  0xD0 0x03       BNE 0xA17B (+3)         // if (Z)                            variables.asm:134
0xA178  0x20 0x0A 0xA2  JSR 0xA20A              // Variables.SetValue();    TOP->    variables.asm:136
0xA17B  0x5F 0x10 0x0B  BBR5 0x10, 0xA189 (+11) // if (BBS5, ZP.ACCT)    Bit 5 - ARRAY
0xA17E  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      variables.asm:140
0xA180  0x85 0x11       STA 0x11                // STA ZP.TOPL                       variables.asm:141
0xA182  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      variables.asm:142
0xA184  0x85 0x12       STA 0x12                // STA ZP.TOPH                       variables.asm:143
0xA186  0x20 0x0A 0xA2  JSR 0xA20A              // Variables.SetValue();    TOP->    variables.asm:144
0xA189  0x38            SEC                     // SEC    success                    variables.asm:146
0xA18A  0x7A            PLY                     // PLY                               variables.asm:154
0xA18B  0xFA            PLX                     // PLX                               variables.asm:155
0xA18C  0x68            PLA                     // PLA                               variables.asm:156
0xA18D  0x60            RTS                     // }                                 variables.asm:157

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:164
// ####  Variables.Find()  ####                                                 0x0125

0xA18E  0x48            PHA                     // PHA                               variables.asm:165
0xA18F  0xDA            PHX                     // PHX                               variables.asm:166
0xA190  0x5A            PHY                     // PHY                               variables.asm:167
0xA191  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:169
0xA193  0x48            PHA                     // PHA                               variables.asm:170
0xA194  0xA2 0x3C       LDX # 0x3C              // LDX #ZP.VariablesList             variables.asm:175
0xA196  0x20 0x4F 0x9F  JSR 0x9F4F              // Objects.Find();                   variables.asm:176
0xA199  0xB0 0x03       BCS 0xA19E (+3)         // if (NC)     Not found             variables.asm:177
0xA19B  0x18            CLC                     // CLC                               variables.asm:179
0xA19C  0x80 0x1C       BRA 0xA1BA (+28)        // break;                            variables.asm:180
0xA19E  0xA5 0x47       LDA 0x47                // LDA ZP.SymbolIteratorFilter       variables.asm:184
0xA1A0  0xD0 0x03       BNE 0xA1A5 (+3)         // if (Z)     No type filter         variables.asm:185
0xA1A2  0x38            SEC                     // SEC     Found                     variables.asm:187
0xA1A3  0x80 0x15       BRA 0xA1BA (+21)        // break;                            variables.asm:188
0xA1A5  0xA5 0x47       LDA 0x47                // LDA ZP.SymbolIteratorFilter       variables.asm:192
0xA1A7  0x85 0x49       STA 0x49                // STA ZP.SymbolTemp0     Temporary storage
0xA1A9  0x20 0xA9 0xA2  JSR 0xA2A9              // Variables.GetType();              variables.asm:196
0xA1AC  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:198
0xA1AE  0x29 0xC0       AND # 0xC0              // AND #SymbolType.MASK              variables.asm:199
0xA1B0  0xC5 0x49       CMP 0x49                // CMP ZP.SymbolTemp0     Compare with expected type
0xA1B2  0xD0 0x03       BNE 0xA1B7 (+3)         // if (Z)                 Types match
0xA1B4  0x38            SEC                     // SEC     Found and correct type    variables.asm:203
0xA1B5  0x80 0x03       BRA 0xA1BA (+3)         // break;                            variables.asm:204
0xA1B7  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xA1BA  0x68            PLA                     // PLA                               variables.asm:213
0xA1BB  0x85 0x10       STA 0x10                // STA ZP.ACCT                       variables.asm:214
0xA1BD  0x7A            PLY                     // PLY                               variables.asm:216
0xA1BE  0xFA            PLX                     // PLX                               variables.asm:217
0xA1BF  0x68            PLA                     // PLA                               variables.asm:218
0xA1C0  0x60            RTS                     // }                                 variables.asm:219

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:227
// ####  Variables.getData()  ####                                              0x0126

0xA1C1  0x5A            PHY                     // PHY                               variables.asm:228
0xA1C2  0xA0 0x02       LDY # 0x02              // LDY # Objects.snType              variables.asm:231
0xA1C4  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   variables.asm:232
0xA1C6  0x85 0x10       STA 0x10                // STA ZP.ACCT                       variables.asm:233
0xA1C8  0xA0 0x03       LDY # 0x03              // LDY # Objects.snTokens            variables.asm:236
0xA1CA  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   variables.asm:237
0xA1CC  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      variables.asm:238
0xA1CE  0xC8            INY                     // INY                               variables.asm:239
0xA1CF  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   variables.asm:240
0xA1D1  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      variables.asm:241
0xA1D3  0xA0 0x05       LDY # 0x05              // LDY # Objects.snValue             variables.asm:244
0xA1D5  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   variables.asm:245
0xA1D7  0x85 0x11       STA 0x11                // STA ZP.TOP0                       variables.asm:246
0xA1D9  0xC8            INY                     // INY                               variables.asm:247
0xA1DA  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   variables.asm:248
0xA1DC  0x85 0x12       STA 0x12                // STA ZP.TOP1                       variables.asm:249
0xA1DE  0xC8            INY                     // INY                               variables.asm:250
0xA1DF  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   variables.asm:251
0xA1E1  0x85 0x13       STA 0x13                // STA ZP.TOP2                       variables.asm:252
0xA1E3  0xC8            INY                     // INY                               variables.asm:253
0xA1E4  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   variables.asm:254
0xA1E6  0x85 0x14       STA 0x14                // STA ZP.TOP3                       variables.asm:255
0xA1E8  0x7A            PLY                     // PLY                               variables.asm:257
0xA1E9  0x60            RTS                     // }                                 variables.asm:258

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:265
// ####  Variables.GetValue()  ####                                             0x0127

0xA1EA  0x48            PHA                     // PHA                               variables.asm:266
0xA1EB  0x5A            PHY                     // PHY                               variables.asm:267
0xA1EC  0x20 0xC1 0xA1  JSR 0xA1C1              // Variables.getData();     Returns type in ZP.ACCT, tokens in ZP.NEXT, value in ZP.TOP
0xA1EF  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:274
0xA1F1  0x29 0xC0       AND # 0xC0              // AND #SymbolType.MASK              variables.asm:275
0xA1F3  0xC9 0x40       CMP # 0x40              // CMP #SymbolType.VARIABLE          variables.asm:276
0xA1F5  0xF0 0x09       BEQ 0xA200 (+9)         // if (NZ)                           variables.asm:277
0xA1F7  0xC9 0x80       CMP # 0x80              // CMP #SymbolType.CONSTANT          variables.asm:279
0xA1F9  0xF0 0x05       BEQ 0xA200 (+5)         // if (NZ)                           variables.asm:280
0xA1FB  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xA1FE  0x80 0x07       BRA 0xA207 (+7)         // break;                            variables.asm:284
0xA200  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:288
0xA202  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK      masks off VAR bit (0x10)
0xA204  0x85 0x15       STA 0x15                // STA ZP.TOPT                       variables.asm:290
0xA206  0x38            SEC                     // SEC     Success                   variables.asm:292
0xA207  0x7A            PLY                     // PLY                               variables.asm:296
0xA208  0x68            PLA                     // PLA                               variables.asm:297
0xA209  0x60            RTS                     // }                                 variables.asm:298

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:306
// ####  Variables.SetValue()  ####                                             0x0128

0xA20A  0x48            PHA                     // PHA                               variables.asm:307
0xA20B  0xDA            PHX                     // PHX                               variables.asm:308
0xA20C  0x5A            PHY                     // PHY                               variables.asm:309
0xA20D  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       variables.asm:315
0xA20F  0x48            PHA                     // PHA                               variables.asm:316
0xA210  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       variables.asm:317
0xA212  0x48            PHA                     // PHA                               variables.asm:318
0xA213  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       variables.asm:321
0xA215  0x48            PHA                     // PHA                               variables.asm:322
0xA216  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       variables.asm:323
0xA218  0x48            PHA                     // PHA                               variables.asm:324
0xA219  0xA0 0x02       LDY # 0x02              // LDY # Objects.snType              variables.asm:329
0xA21B  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   variables.asm:330
0xA21D  0x85 0x10       STA 0x10                // STA ZP.ACCT                       variables.asm:331
0xA21F  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:334
0xA221  0x29 0xC0       AND # 0xC0              // AND #SymbolType.MASK              variables.asm:335
0xA223  0xC9 0x40       CMP # 0x40              // CMP #SymbolType.VARIABLE          variables.asm:336
0xA225  0xF0 0x09       BEQ 0xA230 (+9)         // if (NZ)     Not a variable        variables.asm:337
0xA227  0xC9 0x80       CMP # 0x80              // CMP #SymbolType.CONSTANT          variables.asm:339
0xA229  0xF0 0x05       BEQ 0xA230 (+5)         // if (NZ)     Not a constant        variables.asm:340
0xA22B  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xA22E  0x80 0x69       BRA 0xA299 (+105)       // break;                            variables.asm:343
0xA230  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT    symbolType|dataType
0xA232  0x5F 0x10 0x0D  BBR5 0x10, 0xA242 (+13) // if (BBS5, ZP.ACCT)    Bit 5 - ARRAY
0xA235  0xA0 0x03       LDY # 0x03              // LDY #BASICArray.aiOwner           variables.asm:353
0xA237  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL     Variable node address
0xA239  0x91 0x11       STA [0x11],Y            // STA [ZP.TOP], Y                   variables.asm:355
0xA23B  0xC8            INY                     // INY                               variables.asm:356
0xA23C  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       variables.asm:357
0xA23E  0x91 0x11       STA [0x11],Y            // STA [ZP.TOP], Y                   variables.asm:358
0xA240  0x80 0x54       BRA 0xA296 (+84)        // }                                 variables.asm:359
0xA242  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT    symbolType|dataType
0xA244  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          variables.asm:364
0xA246  0xC9 0x05       CMP # 0x05              // CMP # BASICType.STRING            variables.asm:365
0xA248  0xD0 0x23       BNE 0xA26D (+35)        // if (Z)                            variables.asm:366
0xA24A  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       variables.asm:368
0xA24C  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          variables.asm:369
0xA24E  0xC9 0x05       CMP # 0x05              // CMP # BASICType.STRING            variables.asm:370
0xA250  0xD0 0x12       BNE 0xA264 (+18)        // if (Z)                            variables.asm:371
0xA252  0xA0 0x05       LDY # 0x05              // LDY #Objects.snValue              variables.asm:374
0xA254  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   variables.asm:375
0xA256  0xC5 0x11       CMP 0x11                // CMP ZP.TOP0                       variables.asm:376
0xA258  0xD0 0x0A       BNE 0xA264 (+10)        // if (Z)                            variables.asm:377
0xA25A  0xC8            INY                     // INY                               variables.asm:379
0xA25B  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   variables.asm:380
0xA25D  0xC5 0x12       CMP 0x12                // CMP ZP.TOP1                       variables.asm:381
0xA25F  0xD0 0x03       BNE 0xA264 (+3)         // if (Z)                            variables.asm:382
0xA261  0x38            SEC                     // SEC    same pointer, nothing to do
0xA262  0x80 0x35       BRA 0xA299 (+53)        // break;                            variables.asm:385
0xA264  0x38            SEC                     // SEC                               variables.asm:391
0xA265  0x20 0xF7 0xA3  JSR 0xA3F7              // FreeCompoundValue();    frees node IDX snValue field, munts A
0xA268  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     variables.asm:394
0xA26B  0x90 0x2C       BCC 0xA299 (+44)        // if (NC) { break; }                variables.asm:395
0xA26D  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       variables.asm:398
0xA26F  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          variables.asm:399
0xA271  0xC9 0x05       CMP # 0x05              // CMP # BASICType.STRING            variables.asm:400
0xA273  0xD0 0x10       BNE 0xA285 (+16)        // if (Z)                            variables.asm:401
0xA275  0x20 0x97 0xA3  JSR 0xA397              // AllocateAndCopyString();    Returns new string pointer in ZP.TOP -> ZP.IDY, preserves IDX, ACCT
0xA278  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     variables.asm:406
0xA27B  0x90 0x1C       BCC 0xA299 (+28)        // if (NC) { break; }                variables.asm:407
0xA27D  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       variables.asm:408
0xA27F  0x85 0x11       STA 0x11                // STA ZP.TOP0                       variables.asm:409
0xA281  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       variables.asm:410
0xA283  0x85 0x12       STA 0x12                // STA ZP.TOP1                       variables.asm:411
0xA285  0x4F 0x10 0x0E  BBR4 0x10, 0xA296 (+14) // if (BBS4, ZP.ACCT)    Bit 4 - VAR variables.asm:415
0xA288  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:418
0xA28A  0x29 0xD0       AND # 0xD0              // AND # (SymbolType.MASK | BASICType.VAR)    preserve VARIABLE|CONSTANT and VARness
0xA28C  0x05 0x15       ORA 0x15                // ORA ZP.TOPT                       variables.asm:420
0xA28E  0x85 0x10       STA 0x10                // STA ZP.ACCT                       variables.asm:421
0xA290  0xA0 0x02       LDY # 0x02              // LDY # Objects.snType    SetValue : store
0xA292  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:425
0xA294  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   variables.asm:426
0xA296  0x20 0x9E 0x9F  JSR 0x9F9E              // Objects.SetValue();    Uses ZP.TOP for value, C = success, NC = failure
0xA299  0x68            PLA                     // PLA                               variables.asm:437
0xA29A  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       variables.asm:438
0xA29C  0x68            PLA                     // PLA                               variables.asm:439
0xA29D  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       variables.asm:440
0xA29F  0x68            PLA                     // PLA                               variables.asm:442
0xA2A0  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       variables.asm:443
0xA2A2  0x68            PLA                     // PLA                               variables.asm:444
0xA2A3  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       variables.asm:445
0xA2A5  0x7A            PLY                     // PLY                               variables.asm:452
0xA2A6  0xFA            PLX                     // PLX                               variables.asm:453
0xA2A7  0x68            PLA                     // PLA                               variables.asm:454
0xA2A8  0x60            RTS                     // }                                 variables.asm:455

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:462
// ####  Variables.GetType()  ####                                              0x0129

0xA2A9  0x48            PHA                     // PHA                               variables.asm:463
0xA2AA  0x5A            PHY                     // PHY                               variables.asm:464
0xA2AB  0xA0 0x02       LDY # 0x02              // LDY # Objects.snType              variables.asm:467
0xA2AD  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   variables.asm:468
0xA2AF  0x85 0x10       STA 0x10                // STA ZP.ACCT                       variables.asm:469
0xA2B1  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:472
0xA2B3  0x29 0xC0       AND # 0xC0              // AND # SymbolType.MASK             variables.asm:473
0xA2B5  0xC9 0x40       CMP # 0x40              // case SymbolType.VARIABLE:         variables.asm:476
0xA2B7  0xD0 0x03       BNE 0xA2BC (+3)
0xA2B9  0x38            SEC                     // SEC     Success                   variables.asm:478
0xA2BA  0x80 0x0A       BRA 0xA2C6 (+10)        // }                                 variables.asm:479
0xA2BC  0xC9 0x80       CMP # 0x80              // case SymbolType.CONSTANT:         variables.asm:480
0xA2BE  0xD0 0x03       BNE 0xA2C3 (+3)
0xA2C0  0x38            SEC                     // SEC     Success                   variables.asm:482
0xA2C1  0x80 0x03       BRA 0xA2C6 (+3)         // }                                 variables.asm:483
0xA2C3  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xA2C6  0x7A            PLY                     // PLY                               variables.asm:491
0xA2C7  0x68            PLA                     // PLA                               variables.asm:492
0xA2C8  0x60            RTS                     // }                                 variables.asm:493

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:501
// ####  Variables.GetName()  ####                                              0x012A

0xA2C9  0x48            PHA                     // PHA                               variables.asm:502
0xA2CA  0x18            CLC                     // CLC                               variables.asm:505
0xA2CB  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       variables.asm:506
0xA2CD  0x69 0x0B       ADC # 0x0B              // ADC #Objects.snName               variables.asm:507
0xA2CF  0x85 0x79       STA 0x79                // STA ZP.STRL                       variables.asm:508
0xA2D1  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       variables.asm:509
0xA2D3  0x69 0x00       ADC # 0                 // ADC #0                            variables.asm:510
0xA2D5  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       variables.asm:511
0xA2D7  0x68            PLA                     // PLA                               variables.asm:513
0xA2D8  0x60            RTS                     // }                                 variables.asm:514

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:521
// ####  Variables.GetTokens()  ####                                            0x012B

0xA2D9  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       variables.asm:522
0xA2DB  0x48            PHA                     // PHA                               variables.asm:523
0xA2DC  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       variables.asm:524
0xA2DE  0x48            PHA                     // PHA                               variables.asm:525
0xA2DF  0x20 0xCA 0x9F  JSR 0x9FCA              // Objects.GetTokens();    node address in IDX, -> tokens pointer in ZP.IDY, Munts: A
0xA2E2  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       variables.asm:531
0xA2E4  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      variables.asm:532
0xA2E6  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       variables.asm:533
0xA2E8  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      variables.asm:534
0xA2EA  0x68            PLA                     // PLA                               variables.asm:536
0xA2EB  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       variables.asm:537
0xA2ED  0x68            PLA                     // PLA                               variables.asm:538
0xA2EE  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       variables.asm:539
0xA2F0  0x38            SEC                     // SEC     Always succeeds           variables.asm:541
0xA2F1  0x60            RTS                     // }                                 variables.asm:542

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:549
// ####  Variables.Remove()  ####                                               0x012C

0xA2F2  0x48            PHA                     // PHA                               variables.asm:550
0xA2F3  0xDA            PHX                     // PHX                               variables.asm:551
0xA2F4  0x5A            PHY                     // PHY                               variables.asm:552
0xA2F5  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       variables.asm:554
0xA2F7  0x48            PHA                     // PHA                               variables.asm:555
0xA2F8  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       variables.asm:556
0xA2FA  0x48            PHA                     // PHA                               variables.asm:557
0xA2FB  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       variables.asm:558
0xA2FD  0x48            PHA                     // PHA                               variables.asm:559
0xA2FE  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       variables.asm:560
0xA300  0x48            PHA                     // PHA                               variables.asm:561
0xA301  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       variables.asm:562
0xA303  0x48            PHA                     // PHA                               variables.asm:563
0xA304  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       variables.asm:564
0xA306  0x48            PHA                     // PHA                               variables.asm:565
0xA307  0x64 0x47       STZ 0x47                // STZ ZP.SymbolIteratorFilter     Accept any type
0xA309  0x20 0x8E 0xA1  JSR 0xA18E              // Find();                           variables.asm:571
0xA30C  0xB0 0x03       BCS 0xA311 (+3)         // if (NC)     Not found             variables.asm:572
0xA30E  0x18            CLC                     // CLC     Not found                 variables.asm:574
0xA30F  0x80 0x29       BRA 0xA33A (+41)        // break;                            variables.asm:575
0xA311  0x20 0xF7 0xA3  JSR 0xA3F7              // FreeCompoundValue();    frees node IDX snValue field, munts A
0xA314  0x20 0xCA 0x9F  JSR 0x9FCA              // Objects.GetTokens();    node address in IDX, -> snTokens pointer in ZP.IDY, Munts: A
0xA317  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       variables.asm:585
0xA319  0x85 0x49       STA 0x49                // STA ZP.SymbolTemp0     Temporary storage
0xA31B  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       variables.asm:587
0xA31D  0x85 0x4A       STA 0x4A                // STA ZP.SymbolTemp1                variables.asm:588
0xA31F  0xA2 0x3C       LDX # 0x3C              // LDX #ZP.VariablesList             variables.asm:591
0xA321  0x20 0x4C 0x9E  JSR 0x9E4C              // Objects.Remove();     This munts ZP.IDY, ZP.TOP, ZP.NEXT
0xA324  0xB0 0x03       BCS 0xA329 (+3)         // if (NC)                           variables.asm:593
0xA326  0x18            CLC                     // CLC     Failed to remove          variables.asm:595
0xA327  0x80 0x11       BRA 0xA33A (+17)        // break;                            variables.asm:596
0xA329  0xA5 0x49       LDA 0x49                // LDA ZP.SymbolTemp0                variables.asm:600
0xA32B  0x05 0x4A       ORA 0x4A                // ORA ZP.SymbolTemp1                variables.asm:601
0xA32D  0xF0 0x0B       BEQ 0xA33A (+11)        // if (NZ)     Non-zero tokens pointer
0xA32F  0xA5 0x49       LDA 0x49                // LDA ZP.SymbolTemp0                variables.asm:604
0xA331  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       variables.asm:605
0xA333  0xA5 0x4A       LDA 0x4A                // LDA ZP.SymbolTemp1                variables.asm:606
0xA335  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       variables.asm:607
0xA337  0x20 0xB8 0x92  JSR 0x92B8              // Memory.Free();     Input: ZP.IDX, Munts: A, ZP.IDX, ZP.M* -> C on success
0xA33A  0x68            PLA                     // PLA                               variables.asm:613
0xA33B  0x85 0x12       STA 0x12                // STA ZP.TOPH                       variables.asm:614
0xA33D  0x68            PLA                     // PLA                               variables.asm:615
0xA33E  0x85 0x11       STA 0x11                // STA ZP.TOPL                       variables.asm:616
0xA340  0x68            PLA                     // PLA                               variables.asm:617
0xA341  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       variables.asm:618
0xA343  0x68            PLA                     // PLA                               variables.asm:619
0xA344  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       variables.asm:620
0xA346  0x68            PLA                     // PLA                               variables.asm:621
0xA347  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       variables.asm:622
0xA349  0x68            PLA                     // PLA                               variables.asm:623
0xA34A  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       variables.asm:624
0xA34C  0x7A            PLY                     // PLY                               variables.asm:626
0xA34D  0xFA            PLX                     // PLX                               variables.asm:627
0xA34E  0x68            PLA                     // PLA                               variables.asm:628
0xA34F  0x60            RTS                     // }                                 variables.asm:629

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:635
// ####  Variables.IterateVariables()  ####                                     0x012D

0xA350  0x48            PHA                     // PHA                               variables.asm:636
0xA351  0xDA            PHX                     // PHX                               variables.asm:637
0xA352  0xA9 0x40       LDA # 0x40              // LDA #SymbolType.VARIABLE          variables.asm:639
0xA354  0x85 0x47       STA 0x47                // STA ZP.SymbolIteratorFilter       variables.asm:640
0xA356  0xA2 0x3C       LDX # 0x3C              // LDX #ZP.VariablesList             variables.asm:641
0xA358  0x20 0xE6 0x9F  JSR 0x9FE6              // Objects.IterateStart();           variables.asm:642
0xA35B  0xFA            PLX                     // PLX                               variables.asm:644
0xA35C  0x68            PLA                     // PLA                               variables.asm:645
0xA35D  0x60            RTS                     // }                                 variables.asm:646

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:652
// ####  Variables.IterateConstants()  ####                                     0x012E

0xA35E  0x48            PHA                     // PHA                               variables.asm:653
0xA35F  0xDA            PHX                     // PHX                               variables.asm:654
0xA360  0xA9 0x80       LDA # 0x80              // LDA #SymbolType.CONSTANT          variables.asm:656
0xA362  0x85 0x47       STA 0x47                // STA ZP.SymbolIteratorFilter       variables.asm:657
0xA364  0xA2 0x3C       LDX # 0x3C              // LDX #ZP.VariablesList             variables.asm:658
0xA366  0x20 0xE6 0x9F  JSR 0x9FE6              // Objects.IterateStart();           variables.asm:659
0xA369  0xFA            PLX                     // PLX                               variables.asm:661
0xA36A  0x68            PLA                     // PLA                               variables.asm:662
0xA36B  0x60            RTS                     // }                                 variables.asm:663

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:669
// ####  Variables.IterateAll()  ####                                           0x012F

0xA36C  0x48            PHA                     // PHA                               variables.asm:670
0xA36D  0xDA            PHX                     // PHX                               variables.asm:671
0xA36E  0x64 0x47       STZ 0x47                // STZ ZP.SymbolIteratorFilter     No filter
0xA370  0xA2 0x3C       LDX # 0x3C              // LDX #ZP.VariablesList             variables.asm:674
0xA372  0x20 0xE6 0x9F  JSR 0x9FE6              // Objects.IterateStart();           variables.asm:675
0xA375  0xFA            PLX                     // PLX                               variables.asm:677
0xA376  0x68            PLA                     // PLA                               variables.asm:678
0xA377  0x60            RTS                     // }                                 variables.asm:679

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:693
// ####  Variables.Clear()  ####                                                0x0131

0xA378  0xDA            PHX                     // PHX                               variables.asm:694
0xA379  0xA2 0x3C       LDX # 0x3C              // LDX #ZP.VariablesList    for Table.GetFirst() and Table.Delete()
0xA37B  0x20 0xC8 0x9D  JSR 0x9DC8              // Table.GetFirst();                 variables.asm:699
0xA37E  0x90 0x14       BCC 0xA394 (+20)        // if (NC) { break; }   No more symbols
0xA380  0x20 0xF7 0xA3  JSR 0xA3F7              // FreeCompoundValue();    frees node IDX snValue field, munts A
0xA383  0x20 0xCA 0x9F  JSR 0x9FCA              // Objects.GetTokens();    node address in IDX, -> snTokens pointer in ZP.IDY, Munts: A
0xA386  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       variables.asm:708
0xA388  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       variables.asm:709
0xA38A  0xF0 0x03       BEQ 0xA38F (+3)         // if (NZ)     Non-zero tokens pointer
0xA38C  0x20 0xBF 0x92  JSR 0x92BF              // Memory.FreeIDY();     Input: ZP.IDY, Munts: A, ZP.M* -> C on success
0xA38F  0x20 0x4C 0x9E  JSR 0x9E4C              // Table.Delete();     munts ZP.IDY, ZP.TOP, ZP.NEXT
0xA392  0x80 0xE7       BRA 0xA37B (-25)        // }                                 variables.asm:717
0xA394  0xFA            PLX                     // PLX                               variables.asm:719
0xA395  0x38            SEC                     // SEC     Always succeeds           variables.asm:720
0xA396  0x60            RTS                     // }                                 variables.asm:721

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:732
// ####  Variables.AllocateAndCopyString()  ####                                0x0132

0xA397  0x48            PHA                     // PHA                               variables.asm:733
0xA398  0xDA            PHX                     // PHX                               variables.asm:734
0xA399  0x5A            PHY                     // PHY                               variables.asm:735
0xA39A  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       variables.asm:737
0xA39C  0x48            PHA                     // PHA                               variables.asm:738
0xA39D  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       variables.asm:739
0xA39F  0x48            PHA                     // PHA                               variables.asm:740
0xA3A0  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:741
0xA3A2  0x48            PHA                     // PHA                               variables.asm:742
0xA3A3  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       variables.asm:745
0xA3A5  0x48            PHA                     // PHA                               variables.asm:746
0xA3A6  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       variables.asm:747
0xA3A8  0x48            PHA                     // PHA                               variables.asm:748
0xA3A9  0xA6 0x11       LDX 0x11                // LDX ZP.TOPL                       variables.asm:753
0xA3AB  0xA4 0x12       LDY 0x12                // LDY ZP.TOPH                       variables.asm:754
0xA3AD  0x20 0xF0 0x95  JSR 0x95F0              // Tools.StringLength();    Returns length in A
0xA3B0  0x18            CLC                     // CLC                               variables.asm:758
0xA3B1  0x69 0x01       ADC # 1                 // ADC #1                            variables.asm:759
0xA3B3  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       variables.asm:760
0xA3B5  0xA9 0x00       LDA # 0                 // LDA #0                            variables.asm:761
0xA3B7  0x69 0x00       ADC # 0                 // ADC #0     Add carry              variables.asm:762
0xA3B9  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       variables.asm:763
0xA3BB  0x20 0x97 0x92  JSR 0x9297              // Memory.Allocate();    Variables.AllocateAndCopyString(): Input: ZP.ACC = size, Munts: ZP.M*, ZP.FREELIST, ZP.ACCL, -> ZP.IDX
0xA3BE  0x90 0x24       BCC 0xA3E4 (+36)        // if (NC) { BIT ZP.EmulatorPCL break; }
0xA3C0  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       variables.asm:770
0xA3C2  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       variables.asm:771
0xA3C4  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       variables.asm:772
0xA3C6  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       variables.asm:773
0xA3C8  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       variables.asm:777
0xA3CA  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            variables.asm:778
0xA3CC  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       variables.asm:779
0xA3CE  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            variables.asm:780
0xA3D0  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       variables.asm:783
0xA3D2  0x85 0x63       STA 0x63                // STA ZP.FDESTINATIONADDRESSL       variables.asm:784
0xA3D4  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       variables.asm:785
0xA3D6  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       variables.asm:786
0xA3D8  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL     Length + 1 (includes null terminator)
0xA3DA  0x85 0x65       STA 0x65                // STA ZP.FLENGTHL                   variables.asm:790
0xA3DC  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       variables.asm:791
0xA3DE  0x85 0x66       STA 0x66                // STA ZP.FLENGTHH                   variables.asm:792
0xA3E0  0x20 0x0B 0x93  JSR 0x930B              // Memory.Copy();                    variables.asm:795
0xA3E3  0x38            SEC                     // SEC    Success                    variables.asm:797
0xA3E4  0x68            PLA                     // PLA                               variables.asm:802
0xA3E5  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       variables.asm:803
0xA3E7  0x68            PLA                     // PLA                               variables.asm:804
0xA3E8  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       variables.asm:805
0xA3EA  0x68            PLA                     // PLA                               variables.asm:807
0xA3EB  0x85 0x10       STA 0x10                // STA ZP.ACCT                       variables.asm:808
0xA3ED  0x68            PLA                     // PLA                               variables.asm:809
0xA3EE  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       variables.asm:810
0xA3F0  0x68            PLA                     // PLA                               variables.asm:811
0xA3F1  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       variables.asm:812
0xA3F3  0x7A            PLY                     // PLY                               variables.asm:814
0xA3F4  0xFA            PLX                     // PLX                               variables.asm:815
0xA3F5  0x68            PLA                     // PLA                               variables.asm:816
0xA3F6  0x60            RTS                     // }                                 variables.asm:817

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:825
// ####  Variables.FreeCompoundValue()  ####                                    0x0133

0xA3F7  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:826
0xA3F9  0x48            PHA                     // PHA                               variables.asm:827
0xA3FA  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      variables.asm:828
0xA3FC  0x48            PHA                     // PHA                               variables.asm:829
0xA3FD  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      variables.asm:830
0xA3FF  0x48            PHA                     // PHA                               variables.asm:831
0xA400  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       variables.asm:832
0xA402  0x48            PHA                     // PHA                               variables.asm:833
0xA403  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       variables.asm:834
0xA405  0x48            PHA                     // PHA                               variables.asm:835
0xA406  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       variables.asm:836
0xA408  0x48            PHA                     // PHA                               variables.asm:837
0xA409  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       variables.asm:838
0xA40B  0x48            PHA                     // PHA                               variables.asm:839
0xA40C  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       variables.asm:840
0xA40E  0x48            PHA                     // PHA                               variables.asm:841
0xA40F  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       variables.asm:842
0xA411  0x48            PHA                     // PHA                               variables.asm:843
0xA412  0x20 0xC1 0xA1  JSR 0xA1C1              // Variables.getData();    Input: IDX, Returns type in ZP.ACCT, value in ZP.IDY, tokens in ZP.NEXT
0xA415  0xDF 0x10 0x0B  BBS5 0x10, 0xA423 (+11) // if (BBR5, ZP.ACCT)    Bit 5 - ARRAY
0xA418  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:854
0xA41A  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          variables.asm:855
0xA41C  0xC9 0x05       CMP # 0x05              // CMP # BASICType.STRING            variables.asm:856
0xA41E  0xF0 0x03       BEQ 0xA423 (+3)         // if (NZ)                           variables.asm:857
0xA420  0x38            SEC                     // SEC    Success (nop)              variables.asm:860
0xA421  0x80 0x1B       BRA 0xA43E (+27)        // break;                            variables.asm:861
0xA423  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       variables.asm:866
0xA425  0x05 0x12       ORA 0x12                // ORA ZP.TOP1                       variables.asm:867
0xA427  0xD0 0x03       BNE 0xA42C (+3)         // if (Z)                            variables.asm:868
0xA429  0x38            SEC                     // SEC    Success (no-op)            variables.asm:871
0xA42A  0x80 0x12       BRA 0xA43E (+18)        // break;                            variables.asm:872
0xA42C  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       variables.asm:875
0xA42E  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       variables.asm:876
0xA430  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       variables.asm:877
0xA432  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       variables.asm:878
0xA434  0x20 0xBF 0x92  JSR 0x92BF              // Memory.FreeIDY();     Input: ZP.IDY, Munts: A, ZP.M* -> C on success
0xA437  0x20 0x95 0x97  JSR 0x9795              // Long.ZeroTop();                   variables.asm:884
0xA43A  0x20 0x9E 0x9F  JSR 0x9F9E              // Objects.SetValue();    Set variable's string pointer to 0x0000
0xA43D  0x38            SEC                     // SEC    Success                    variables.asm:887
0xA43E  0x68            PLA                     // PLA                               variables.asm:891
0xA43F  0x85 0x14       STA 0x14                // STA ZP.TOP3                       variables.asm:892
0xA441  0x68            PLA                     // PLA                               variables.asm:893
0xA442  0x85 0x13       STA 0x13                // STA ZP.TOP2                       variables.asm:894
0xA444  0x68            PLA                     // PLA                               variables.asm:895
0xA445  0x85 0x12       STA 0x12                // STA ZP.TOP1                       variables.asm:896
0xA447  0x68            PLA                     // PLA                               variables.asm:897
0xA448  0x85 0x11       STA 0x11                // STA ZP.TOP0                       variables.asm:898
0xA44A  0x68            PLA                     // PLA                               variables.asm:899
0xA44B  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       variables.asm:900
0xA44D  0x68            PLA                     // PLA                               variables.asm:901
0xA44E  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       variables.asm:902
0xA450  0x68            PLA                     // PLA                               variables.asm:903
0xA451  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      variables.asm:904
0xA453  0x68            PLA                     // PLA                               variables.asm:905
0xA454  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      variables.asm:906
0xA456  0x68            PLA                     // PLA                               variables.asm:907
0xA457  0x85 0x10       STA 0x10                // STA ZP.ACCT                       variables.asm:908
0xA459  0x60            RTS                     // }                                 variables.asm:909

// /source/projects/6502sbc/hopperbasic/objects/variables.asm:916
// ####  Variables.Resolve()  ####                                              0x0134

0xA45A  0x48            PHA                     // PHA                               variables.asm:917
0xA45B  0xDA            PHX                     // PHX                               variables.asm:918
0xA45C  0x5A            PHY                     // PHY                               variables.asm:919
0xA45D  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       variables.asm:921
0xA45F  0x48            PHA                     // PHA                               variables.asm:922
0xA460  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       variables.asm:923
0xA462  0x48            PHA                     // PHA                               variables.asm:924
0xA463  0x64 0x47       STZ 0x47                // STZ ZP.SymbolIteratorFilter     Accept any symbol type
0xA465  0x20 0x8E 0xA1  JSR 0xA18E              // Find();    ZP.IDX = symbol node address
0xA468  0xB0 0x03       BCS 0xA46D (+3)         // if (NC)    Not found              variables.asm:931
0xA46A  0x18            CLC                     // CLC                               variables.asm:933
0xA46B  0x80 0x21       BRA 0xA48E (+33)        // break;                            variables.asm:934
0xA46D  0x20 0xA9 0xA2  JSR 0xA2A9              // GetType();    Output: ZP.ACCT = symbolType|dataType
0xA470  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       variables.asm:940
0xA472  0x29 0xC0       AND # 0xC0              // AND #SymbolType.MASK              variables.asm:941
0xA474  0xC9 0x40       CMP # 0x40              // CMP #SymbolType.VARIABLE          variables.asm:942
0xA476  0xD0 0x07       BNE 0xA47F (+7)         // if (Z)                            variables.asm:943
0xA478  0xA9 0x01       LDA # 1                 // LDA #IdentifierType.Global        variables.asm:945
0xA47A  0x85 0x10       STA 0x10                // STA ZP.ACCT                       variables.asm:946
0xA47C  0x38            SEC                     // SEC     Found                     variables.asm:947
0xA47D  0x80 0x0F       BRA 0xA48E (+15)        // break;                            variables.asm:948
0xA47F  0xC9 0x80       CMP # 0x80              // CMP #SymbolType.CONSTANT          variables.asm:951
0xA481  0xD0 0x07       BNE 0xA48A (+7)         // if (Z)                            variables.asm:952
0xA483  0xA9 0x02       LDA # 0x02              // LDA #IdentifierType.Constant      variables.asm:954
0xA485  0x85 0x10       STA 0x10                // STA ZP.ACCT                       variables.asm:955
0xA487  0x38            SEC                     // SEC     Found                     variables.asm:956
0xA488  0x80 0x04       BRA 0xA48E (+4)         // break;                            variables.asm:957
0xA48A  0x20 0xCA 0x8B  JSR 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0xA48D  0x18            CLC                     // CLC                               variables.asm:962
0xA48E  0x68            PLA                     // PLA                               variables.asm:966
0xA48F  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       variables.asm:967
0xA491  0x68            PLA                     // PLA                               variables.asm:968
0xA492  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       variables.asm:969
0xA494  0x7A            PLY                     // PLY                               variables.asm:972
0xA495  0xFA            PLX                     // PLX                               variables.asm:973
0xA496  0x68            PLA                     // PLA                               variables.asm:974
0xA497  0x60            RTS                     // }                                 variables.asm:975

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:24
// ####  Locals.Add()  ####                                                     0x0135

0xA498  0x48            PHA                     // PHA                               locals.asm:25
0xA499  0xDA            PHX                     // PHX                               locals.asm:26
0xA49A  0x5A            PHY                     // PHY                               locals.asm:27
0xA49B  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       locals.asm:33
0xA49D  0x85 0x69       STA 0x69                // STA ZP.LHEADL              Function node address
0xA49F  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       locals.asm:35
0xA4A1  0x85 0x6A       STA 0x6A                // STA ZP.LHEADH                     locals.asm:36
0xA4A3  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       locals.asm:39
0xA4A5  0x85 0x43       STA 0x43                // STA ZP.SymbolNameL         Argument name pointer
0xA4A7  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       locals.asm:41
0xA4A9  0x85 0x44       STA 0x44                // STA ZP.SymbolNameH                locals.asm:42
0xA4AB  0x20 0x6B 0xA6  JSR 0xA66B              // calculateNodeSize();          Returns size in ZP.ACC
0xA4AE  0x20 0x97 0x92  JSR 0x9297              // Memory.Allocate();            Locals.Add(): Input: ZP.ACC = size, Munts: ZP.M*, ZP.FREELIST, ZP.ACCL, -> ZP.IDX
0xA4B1  0x90 0x52       BCC 0xA505 (+82)        // if (NC) { BIT ZP.EmulatorPCL break; }
0xA4B3  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       locals.asm:49
0xA4B5  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL           New local node
0xA4B7  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       locals.asm:51
0xA4B9  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  locals.asm:52
0xA4BB  0x20 0x89 0xA6  JSR 0xA689              // initializeNode();                 locals.asm:54
0xA4BE  0xA0 0x02       LDY # 0x02              // LDY #lnType                       locals.asm:56
0xA4C0  0xA5 0x40       LDA 0x40                // LDA ZP.SymbolType     set by caller
0xA4C2  0x91 0x67       STA [0x67],Y            // STA [ZP.LCURRENT], Y              locals.asm:58
0xA4C4  0xA0 0x00       LDY # 0                 // LDY # lnNext                      locals.asm:61
0xA4C6  0xA9 0x00       LDA # 0                 // LDA #0                            locals.asm:62
0xA4C8  0x91 0x67       STA [0x67],Y            // STA [ZP.LCURRENT], Y              locals.asm:63
0xA4CA  0xC8            INY                     // INY                               locals.asm:64
0xA4CB  0x91 0x67       STA [0x67],Y            // STA [ZP.LCURRENT], Y              locals.asm:65
0xA4CD  0x18            CLC                     // CLC                               locals.asm:69
0xA4CE  0xA5 0x69       LDA 0x69                // LDA ZP.LHEADL                     locals.asm:70
0xA4D0  0x69 0x05       ADC # 0x05              // ADC # Objects.snLocals            locals.asm:71
0xA4D2  0x85 0x6B       STA 0x6B                // STA ZP.LPREVIOUSL          Points to insertion location
0xA4D4  0xA5 0x6A       LDA 0x6A                // LDA ZP.LHEADH                     locals.asm:73
0xA4D6  0x69 0x00       ADC # 0                 // ADC #0                            locals.asm:74
0xA4D8  0x85 0x6C       STA 0x6C                // STA ZP.LPREVIOUSH                 locals.asm:75
0xA4DA  0xB2 0x6B       LDA [0x6B]              // LDA [ZP.LPREVIOUS]                locals.asm:80
0xA4DC  0x85 0x6D       STA 0x6D                // STA ZP.LNEXTL                     locals.asm:81
0xA4DE  0xA0 0x01       LDY # 1                 // LDY #1                            locals.asm:82
0xA4E0  0xB1 0x6B       LDA [0x6B],Y            // LDA [ZP.LPREVIOUS], Y             locals.asm:83
0xA4E2  0x85 0x6E       STA 0x6E                // STA ZP.LNEXTH                     locals.asm:84
0xA4E4  0xA5 0x6D       LDA 0x6D                // LDA ZP.LNEXTL                     locals.asm:86
0xA4E6  0x05 0x6E       ORA 0x6E                // ORA ZP.LNEXTH                     locals.asm:87
0xA4E8  0xF0 0x0F       BEQ 0xA4F9 (+15)        // if (Z) { break; }       Found insertion point
0xA4EA  0x18            CLC                     // CLC                               locals.asm:91
0xA4EB  0xA5 0x6D       LDA 0x6D                // LDA ZP.LNEXTL                     locals.asm:92
0xA4ED  0x69 0x00       ADC # 0                 // ADC # lnNext                      locals.asm:93
0xA4EF  0x85 0x6B       STA 0x6B                // STA ZP.LPREVIOUSL                 locals.asm:94
0xA4F1  0xA5 0x6E       LDA 0x6E                // LDA ZP.LNEXTH                     locals.asm:95
0xA4F3  0x69 0x00       ADC # 0                 // ADC #0                            locals.asm:96
0xA4F5  0x85 0x6C       STA 0x6C                // STA ZP.LPREVIOUSH                 locals.asm:97
0xA4F7  0x80 0xE1       BRA 0xA4DA (-31)        // }                                 locals.asm:98
0xA4F9  0xA0 0x00       LDY # 0                 // LDY #0                            locals.asm:101
0xA4FB  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  locals.asm:102
0xA4FD  0x91 0x6B       STA [0x6B],Y            // STA [ZP.LPREVIOUS], Y             locals.asm:103
0xA4FF  0xC8            INY                     // INY                               locals.asm:104
0xA500  0xA5 0x68       LDA 0x68                // LDA ZP.LCURRENTH                  locals.asm:105
0xA502  0x91 0x6B       STA [0x6B],Y            // STA [ZP.LPREVIOUS], Y             locals.asm:106
0xA504  0x38            SEC                     // SEC     Success                   locals.asm:108
0xA505  0xA5 0x69       LDA 0x69                // LDA ZP.LHEADL                     locals.asm:114
0xA507  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       locals.asm:115
0xA509  0xA5 0x6A       LDA 0x6A                // LDA ZP.LHEADH                     locals.asm:116
0xA50B  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       locals.asm:117
0xA50D  0x7A            PLY                     // PLY                               locals.asm:119
0xA50E  0xFA            PLX                     // PLX                               locals.asm:120
0xA50F  0x68            PLA                     // PLA                               locals.asm:121
0xA510  0x60            RTS                     // }                                 locals.asm:122

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:132
// ####  Locals.Find()  ####                                                    0x0136

0xA511  0x48            PHA                     // PHA                               locals.asm:133
0xA512  0xDA            PHX                     // PHX                               locals.asm:134
0xA513  0x5A            PHY                     // PHY                               locals.asm:135
0xA514  0xA0 0x05       LDY # 0x05              // LDY #Objects.snLocals             locals.asm:140
0xA516  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   locals.asm:141
0xA518  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL                  locals.asm:142
0xA51A  0xC8            INY                     // INY                               locals.asm:143
0xA51B  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   locals.asm:144
0xA51D  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  locals.asm:145
0xA51F  0xA2 0x00       LDX # 0                 // LDX #0          Index counter for arguments
0xA521  0x64 0x0F       STZ 0x0F                // STZ ZP.ACCH     Index counter for locals
0xA523  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  locals.asm:152
0xA525  0x05 0x68       ORA 0x68                // ORA ZP.LCURRENTH                  locals.asm:153
0xA527  0xD0 0x03       BNE 0xA52C (+3)         // if (Z)                            locals.asm:154
0xA529  0x18            CLC                     // CLC     Not found                 locals.asm:156
0xA52A  0x80 0x4D       BRA 0xA579 (+77)        // break;                            locals.asm:157
0xA52C  0x20 0xA7 0xA6  JSR 0xA6A7              // compareNames();     Uses ZP.LCURRENT and ZP.TOP
0xA52F  0x90 0x2A       BCC 0xA55B (+42)        // if (C)     Names match            locals.asm:162
0xA531  0xA0 0x02       LDY # 0x02              // LDY #lnType                       locals.asm:165
0xA533  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              locals.asm:166
0xA535  0x29 0xC0       AND # 0xC0              // AND # SymbolType.MASK             locals.asm:167
0xA537  0xC9 0x40       CMP # 0x40              // CMP # SymbolType.ARGUMENT         locals.asm:168
0xA539  0xD0 0x11       BNE 0xA54C (+17)        // if (Z)     It's an argument       locals.asm:169
0xA53B  0x86 0x0E       STX 0x0E                // STX ZP.ACCL     Save index first  locals.asm:172
0xA53D  0xAD 0x87 0x0B  LDA 0x0B87              // LDA (Compiler.compilerFuncArgs + 0)     Get arg_count
0xA540  0x38            SEC                     // SEC                               locals.asm:174
0xA541  0xE5 0x0E       SBC 0x0E                // SBC ZP.ACCL     arg_count - index locals.asm:175
0xA543  0x49 0xFF       EOR # 0xFF              // EOR #0xFF                         locals.asm:176
0xA545  0x18            CLC                     // CLC                               locals.asm:177
0xA546  0x69 0x01       ADC # 1                 // ADC #1     Two's complement for negative
0xA548  0x85 0x0E       STA 0x0E                // STA ZP.ACCL     Negative BP offset
0xA54A  0x80 0x04       BRA 0xA550 (+4)         // }                                 locals.asm:180
0xA54C  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       locals.asm:184
0xA54E  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       locals.asm:185
0xA550  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  locals.asm:190
0xA552  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       locals.asm:191
0xA554  0xA5 0x68       LDA 0x68                // LDA ZP.LCURRENTH                  locals.asm:192
0xA556  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       locals.asm:193
0xA558  0x38            SEC                     // SEC     Found                     locals.asm:195
0xA559  0x80 0x1E       BRA 0xA579 (+30)        // break;                            locals.asm:196
0xA55B  0xA0 0x02       LDY # 0x02              // LDY #lnType                       locals.asm:200
0xA55D  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              locals.asm:201
0xA55F  0x29 0xC0       AND # 0xC0              // AND #SymbolType.MASK              locals.asm:202
0xA561  0xC9 0x40       CMP # 0x40              // CMP #SymbolType.ARGUMENT          locals.asm:203
0xA563  0xD0 0x03       BNE 0xA568 (+3)         // if (Z)                            locals.asm:204
0xA565  0xE8            INX                     // INX     Increment local counter   locals.asm:206
0xA566  0x80 0x02       BRA 0xA56A (+2)         // }                                 locals.asm:207
0xA568  0xE6 0x0F       INC 0x0F                // INC ZP.ACCH                       locals.asm:210
0xA56A  0xA0 0x00       LDY # 0                 // LDY #lnNext                       locals.asm:214
0xA56C  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              locals.asm:215
0xA56E  0x48            PHA                     // PHA                               locals.asm:216
0xA56F  0xC8            INY                     // INY                               locals.asm:217
0xA570  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              locals.asm:218
0xA572  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  locals.asm:219
0xA574  0x68            PLA                     // PLA                               locals.asm:220
0xA575  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL                  locals.asm:221
0xA577  0x80 0xAA       BRA 0xA523 (-86)        // }                                 locals.asm:224
0xA579  0x7A            PLY                     // PLY                               locals.asm:228
0xA57A  0xFA            PLX                     // PLX                               locals.asm:229
0xA57B  0x68            PLA                     // PLA                               locals.asm:230
0xA57C  0x60            RTS                     // }                                 locals.asm:231

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:238
// ####  Locals.GetName()  ####                                                 0x0137

0xA57D  0x48            PHA                     // PHA                               locals.asm:239
0xA57E  0x18            CLC                     // CLC                               locals.asm:242
0xA57F  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       locals.asm:243
0xA581  0x69 0x03       ADC # 0x03              // ADC # lnName                      locals.asm:244
0xA583  0x85 0x79       STA 0x79                // STA ZP.STRL                       locals.asm:245
0xA585  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       locals.asm:246
0xA587  0x69 0x00       ADC # 0                 // ADC #0                            locals.asm:247
0xA589  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       locals.asm:248
0xA58B  0x68            PLA                     // PLA                               locals.asm:250
0xA58C  0x60            RTS                     // }                                 locals.asm:251

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:258
// ####  Locals.GetType()  ####                                                 0x0138

0xA58D  0x48            PHA                     // PHA                               locals.asm:259
0xA58E  0x5A            PHY                     // PHY                               locals.asm:260
0xA58F  0xA0 0x02       LDY # 0x02              // LDY # lnType                      locals.asm:262
0xA591  0xB1 0x1D       LDA [0x1D],Y            // LDA [ZP.IDY], Y                   locals.asm:263
0xA593  0x85 0x10       STA 0x10                // STA ZP.ACCT                       locals.asm:264
0xA595  0x7A            PLY                     // PLY                               locals.asm:266
0xA596  0x68            PLA                     // PLA                               locals.asm:267
0xA597  0x60            RTS                     // }                                 locals.asm:268

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:275
// ####  Locals.FindByIndex()  ####                                             0x0139

0xA598  0x48            PHA                     // PHA                               locals.asm:276
0xA599  0xDA            PHX                     // PHX                               locals.asm:277
0xA59A  0x5A            PHY                     // PHY                               locals.asm:278
0xA59B  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       locals.asm:283
0xA59D  0x85 0x49       STA 0x49                // STA ZP.SymbolTemp0                locals.asm:284
0xA59F  0xA0 0x05       LDY # 0x05              // LDY #Objects.snLocals             locals.asm:287
0xA5A1  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   locals.asm:288
0xA5A3  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL                  locals.asm:289
0xA5A5  0xC8            INY                     // INY                               locals.asm:290
0xA5A6  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   locals.asm:291
0xA5A8  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  locals.asm:292
0xA5AA  0x64 0x0E       STZ 0x0E                // STZ ZP.ACCL     Current index counter
0xA5AC  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  locals.asm:299
0xA5AE  0x05 0x68       ORA 0x68                // ORA ZP.LCURRENTH                  locals.asm:300
0xA5B0  0xD0 0x03       BNE 0xA5B5 (+3)         // if (Z)                            locals.asm:301
0xA5B2  0x18            CLC                     // CLC     Not found                 locals.asm:303
0xA5B3  0x80 0x28       BRA 0xA5DD (+40)        // break;                            locals.asm:304
0xA5B5  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       locals.asm:308
0xA5B7  0xC5 0x49       CMP 0x49                // CMP ZP.SymbolTemp0                locals.asm:309
0xA5B9  0xD0 0x0B       BNE 0xA5C6 (+11)        // if (Z)     Found the target index locals.asm:310
0xA5BB  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  locals.asm:314
0xA5BD  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       locals.asm:315
0xA5BF  0xA5 0x68       LDA 0x68                // LDA ZP.LCURRENTH                  locals.asm:316
0xA5C1  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       locals.asm:317
0xA5C3  0x38            SEC                     // SEC     Found                     locals.asm:319
0xA5C4  0x80 0x17       BRA 0xA5DD (+23)        // break;                            locals.asm:320
0xA5C6  0xA0 0x00       LDY # 0                 // LDY # lnNext                      locals.asm:324
0xA5C8  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              locals.asm:325
0xA5CA  0x85 0x6D       STA 0x6D                // STA ZP.LNEXTL                     locals.asm:326
0xA5CC  0xC8            INY                     // INY                               locals.asm:327
0xA5CD  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              locals.asm:328
0xA5CF  0x85 0x6E       STA 0x6E                // STA ZP.LNEXTH                     locals.asm:329
0xA5D1  0xA5 0x6D       LDA 0x6D                // LDA ZP.LNEXTL                     locals.asm:332
0xA5D3  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL                  locals.asm:333
0xA5D5  0xA5 0x6E       LDA 0x6E                // LDA ZP.LNEXTH                     locals.asm:334
0xA5D7  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  locals.asm:335
0xA5D9  0xE6 0x0E       INC 0x0E                // INC ZP.ACCL     Increment current index
0xA5DB  0x80 0xCF       BRA 0xA5AC (-49)        // }                                 locals.asm:338
0xA5DD  0x7A            PLY                     // PLY                               locals.asm:342
0xA5DE  0xFA            PLX                     // PLX                               locals.asm:343
0xA5DF  0x68            PLA                     // PLA                               locals.asm:344
0xA5E0  0x60            RTS                     // }                                 locals.asm:345

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:352
// ####  Locals.GetArgumentsCount()  ####                                       0x013A

0xA5E1  0x64 0x0E       STZ 0x0E                // STZ ZP.ACCL     arguments count   locals.asm:355
0xA5E3  0xA0 0x06       LDY # 0x06              // LDY #( Objects.snLocals + 1)      locals.asm:358
0xA5E5  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   locals.asm:359
0xA5E7  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  locals.asm:360
0xA5E9  0x88            DEY                     // DEY                               locals.asm:361
0xA5EA  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   locals.asm:362
0xA5EC  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL                  locals.asm:363
0xA5EE  0x05 0x68       ORA 0x68                // ORA ZP.LCURRENTH                  locals.asm:368
0xA5F0  0xF0 0x1A       BEQ 0xA60C (+26)        // if (Z) { break; }     End of list locals.asm:369
0xA5F2  0xA0 0x02       LDY # 0x02              // LDY # lnType                      locals.asm:371
0xA5F4  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              locals.asm:372
0xA5F6  0x29 0xC0       AND # 0xC0              // AND # SymbolType.MASK             locals.asm:373
0xA5F8  0xC9 0x40       CMP # 0x40              // CMP # SymbolType.ARGUMENT         locals.asm:374
0xA5FA  0xD0 0x02       BNE 0xA5FE (+2)         // if (Z)                            locals.asm:375
0xA5FC  0xE6 0x0E       INC 0x0E                // INC ZP.ACCL     Increment arguments count
0xA5FE  0xA0 0x00       LDY # 0                 // LDY # lnNext                      locals.asm:381
0xA600  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              locals.asm:382
0xA602  0xAA            TAX                     // TAX                               locals.asm:383
0xA603  0xC8            INY                     // INY                               locals.asm:384
0xA604  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              locals.asm:385
0xA606  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  locals.asm:386
0xA608  0x86 0x67       STX 0x67                // STX ZP.LCURRENTL                  locals.asm:387
0xA60A  0x80 0xE2       BRA 0xA5EE (-30)        // }                                 locals.asm:388
0xA60C  0x38            SEC                     // SEC     Always succeeds           locals.asm:389
0xA60D  0x60            RTS                     // }                                 locals.asm:391

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:398
// ####  Locals.IterateStart()  ####                                            0x013B

0xA60E  0x48            PHA                     // PHA                               locals.asm:399
0xA60F  0xA0 0x05       LDY # 0x05              // LDY # Objects.snLocals            locals.asm:402
0xA611  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   locals.asm:403
0xA613  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       locals.asm:404
0xA615  0xC8            INY                     // INY                               locals.asm:405
0xA616  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   locals.asm:406
0xA618  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       locals.asm:407
0xA61A  0x05 0x1D       ORA 0x1D                // ORA ZP.IDYL    or with ZP.IDYH from above
0xA61C  0xD0 0x03       BNE 0xA621 (+3)         // if (Z)                            locals.asm:411
0xA61E  0x18            CLC                     // CLC     No locals                 locals.asm:413
0xA61F  0x80 0x01       BRA 0xA622 (+1)         // }                                 locals.asm:414
0xA621  0x38            SEC                     // SEC     Found first local         locals.asm:417
0xA622  0x68            PLA                     // PLA                               locals.asm:420
0xA623  0x60            RTS                     // }                                 locals.asm:422

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:429
// ####  Locals.IterateNext()  ####                                             0x013C

0xA624  0xA0 0x00       LDY # 0                 // LDY # lnNext                      locals.asm:431
0xA626  0xB1 0x1D       LDA [0x1D],Y            // LDA [ZP.IDY], Y                   locals.asm:432
0xA628  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL                  locals.asm:433
0xA62A  0xC8            INY                     // INY                               locals.asm:434
0xA62B  0xB1 0x1D       LDA [0x1D],Y            // LDA [ZP.IDY], Y                   locals.asm:435
0xA62D  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       locals.asm:436
0xA62F  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  locals.asm:438
0xA631  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       locals.asm:439
0xA633  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH    or with ZP.IDYL from above
0xA635  0xD0 0x02       BNE 0xA639 (+2)         // if (Z)                            locals.asm:443
0xA637  0x18            CLC                     // CLC     End of locals             locals.asm:445
0xA638  0x60            RTS                     // }                                 locals.asm:446
0xA639  0x38            SEC                     // SEC     Found next local          locals.asm:449
0xA63A  0x60            RTS                     // }                                 locals.asm:451

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:458
// ####  Locals.Clear()  ####                                                   0x013D

0xA63B  0x5A            PHY                     // PHY                               locals.asm:459
0xA63C  0xA0 0x05       LDY # 0x05              // LDY #Objects.snLocals             locals.asm:464
0xA63E  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   locals.asm:465
0xA640  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       locals.asm:466
0xA642  0xC8            INY                     // INY                               locals.asm:467
0xA643  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   locals.asm:468
0xA645  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       locals.asm:469
0xA647  0x05 0x1D       ORA 0x1D                // ORA ZP.IDYL                       locals.asm:472
0xA649  0xD0 0x03       BNE 0xA64E (+3)         // if (Z) { SEC break; }             locals.asm:473
0xA64B  0x38            SEC
0xA64C  0x80 0x1B       BRA 0xA669 (+27)
0xA64E  0xA0 0x00       LDY # 0                 // LDY # lnNext                      locals.asm:476
0xA650  0xB1 0x1D       LDA [0x1D],Y            // LDA [ZP.IDY], Y                   locals.asm:477
0xA652  0x85 0x6D       STA 0x6D                // STA ZP.LNEXTL                     locals.asm:478
0xA654  0xC8            INY                     // INY                               locals.asm:479
0xA655  0xB1 0x1D       LDA [0x1D],Y            // LDA [ZP.IDY], Y                   locals.asm:480
0xA657  0x85 0x6E       STA 0x6E                // STA ZP.LNEXTH                     locals.asm:481
0xA659  0xA0 0x05       LDY # 0x05              // LDY #Objects.snLocals             locals.asm:484
0xA65B  0xA5 0x6D       LDA 0x6D                // LDA ZP.LNEXTL                     locals.asm:485
0xA65D  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   locals.asm:486
0xA65F  0xC8            INY                     // INY                               locals.asm:487
0xA660  0xA5 0x6E       LDA 0x6E                // LDA ZP.LNEXTH                     locals.asm:488
0xA662  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   locals.asm:489
0xA664  0x20 0xBF 0x92  JSR 0x92BF              // Memory.FreeIDY();     Input: ZP.IDY, Munts: A, ZP.M* -> C on success
0xA667  0xB0 0xD3       BCS 0xA63C (-45)        // if (NC) { break; }                locals.asm:493
0xA669  0x7A            PLY                     // PLY                               locals.asm:495
0xA66A  0x60            RTS                     // }                                 locals.asm:496

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:503
// ####  Locals.calculateNodeSize()  ####                                       0x013E

0xA66B  0xA9 0x03       LDA # 0x03              // LDA # localOverhead               locals.asm:505
0xA66D  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       locals.asm:506
0xA66F  0x64 0x0F       STZ 0x0F                // STZ ZP.ACCH                       locals.asm:507
0xA671  0xA0 0x00       LDY # 0                 // LDY #0                            locals.asm:510
0xA673  0xB1 0x43       LDA [0x43],Y            // LDA [ZP.SymbolName], Y            locals.asm:513
0xA675  0xF0 0x03       BEQ 0xA67A (+3)         // if (Z) { break; }    Hit null terminator
0xA677  0xC8            INY                     // INY                               locals.asm:515
0xA678  0x80 0xF9       BRA 0xA673 (-7)         // }                                 locals.asm:516
0xA67A  0xC8            INY                     // INY                               locals.asm:519
0xA67B  0x84 0x48       STY 0x48                // STY ZP.SymbolLength     Store total name length (including null) for reuse
0xA67D  0x98            TYA                     // TYA                               locals.asm:523
0xA67E  0x18            CLC                     // CLC                               locals.asm:524
0xA67F  0x65 0x0E       ADC 0x0E                // ADC ZP.ACCL                       locals.asm:525
0xA681  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       locals.asm:526
0xA683  0xB0 0x01       BCS 0xA686 (+1)         // if (C) { INC ZP.ACCH }            locals.asm:527
0xA685  0x60            RTS
0xA686  0xE6 0x0F       INC 0x0F
0xA688  0x60            RTS                     // }                                 locals.asm:528

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:545
// ####  Locals.copyNameToNode()  ####                                          0x0140

0xA689  0xA5 0x43       LDA 0x43                // LDA ZP.SymbolNameL                locals.asm:547
0xA68B  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            locals.asm:548
0xA68D  0xA5 0x44       LDA 0x44                // LDA ZP.SymbolNameH                locals.asm:549
0xA68F  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            locals.asm:550
0xA691  0x18            CLC                     // CLC                               locals.asm:553
0xA692  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       locals.asm:554
0xA694  0x69 0x03       ADC # 0x03              // ADC # lnName                      locals.asm:555
0xA696  0x85 0x63       STA 0x63                // STA ZP.FDESTINATIONADDRESSL       locals.asm:556
0xA698  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       locals.asm:557
0xA69A  0x69 0x00       ADC # 0                 // ADC #0                            locals.asm:558
0xA69C  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       locals.asm:559
0xA69E  0xA5 0x48       LDA 0x48                // LDA ZP.SymbolLength               locals.asm:563
0xA6A0  0x85 0x65       STA 0x65                // STA ZP.FLENGTHL                   locals.asm:564
0xA6A2  0x64 0x66       STZ 0x66                // STZ ZP.FLENGTHH                   locals.asm:565
0xA6A4  0x4C 0x0B 0x93  JMP 0x930B              // Memory.Copy();                    locals.asm:568

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:576
// ####  Locals.compareNames()  ####                                            0x0141

0xA6A7  0x48            PHA                     // PHA                               locals.asm:577
0xA6A8  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      locals.asm:580
0xA6AA  0x48            PHA                     // PHA                               locals.asm:581
0xA6AB  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      locals.asm:582
0xA6AD  0x48            PHA                     // PHA                               locals.asm:583
0xA6AE  0x18            CLC                     // CLC                               locals.asm:586
0xA6AF  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  locals.asm:587
0xA6B1  0x69 0x03       ADC # 0x03              // ADC # lnName                      locals.asm:588
0xA6B3  0x85 0x16       STA 0x16                // STA ZP.NEXTL            Use NEXT for string2 pointer
0xA6B5  0xA5 0x68       LDA 0x68                // LDA ZP.LCURRENTH                  locals.asm:590
0xA6B7  0x69 0x00       ADC # 0                 // ADC #0                            locals.asm:591
0xA6B9  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      locals.asm:592
0xA6BB  0x20 0x0F 0x96  JSR 0x960F              // Tools.StringCompare();     Returns C set if match, NC if different
0xA6BE  0x68            PLA                     // PLA                               locals.asm:598
0xA6BF  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      locals.asm:599
0xA6C1  0x68            PLA                     // PLA                               locals.asm:600
0xA6C2  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      locals.asm:601
0xA6C4  0x68            PLA                     // PLA                               locals.asm:603
0xA6C5  0x60            RTS                     // }                                 locals.asm:604

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:611
// ####  Locals.Resolve()  ####                                                 0x0142

0xA6C6  0x48            PHA                     // PHA                               locals.asm:612
0xA6C7  0xDA            PHX                     // PHX                               locals.asm:613
0xA6C8  0x5A            PHY                     // PHY                               locals.asm:614
0xA6C9  0x20 0xD5 0xDC  JSR 0xDCD5              // InFunction();        Are we in a function?
0xA6CC  0xB0 0x03       BCS 0xA6D1 (+3)         // if (NC)                           locals.asm:619
0xA6CE  0x18            CLC                     // CLC     Not found - not in function context
0xA6CF  0x80 0x1F       BRA 0xA6F0 (+31)        // break;                            locals.asm:622
0xA6D1  0xAD 0x89 0x0B  LDA 0x0B89              // LDA (Compiler.compilerSavedNodeAddrL + 0)
0xA6D4  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       locals.asm:627
0xA6D6  0xAD 0x8A 0x0B  LDA 0x0B8A              // LDA (Compiler.compilerSavedNodeAddrH + 0)
0xA6D9  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       locals.asm:629
0xA6DB  0x20 0x11 0xA5  JSR 0xA511              // Find();     Returns BP offset in ACCL directly!
0xA6DE  0x90 0x0F       BCC 0xA6EF (+15)        // if (C)                            locals.asm:633
0xA6E0  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       locals.asm:638
0xA6E2  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       locals.asm:639
0xA6E4  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       locals.asm:640
0xA6E6  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       locals.asm:641
0xA6E8  0xA9 0x04       LDA # 0x04              // LDA #IdentifierType.Local     Works for both locals and arguments
0xA6EA  0x85 0x10       STA 0x10                // STA ZP.ACCT                       locals.asm:644
0xA6EC  0x38            SEC                     // SEC     Found                     locals.asm:645
0xA6ED  0x80 0x01       BRA 0xA6F0 (+1)         // break;                            locals.asm:646
0xA6EF  0x18            CLC                     // CLC     Not found                 locals.asm:649
0xA6F0  0x7A            PLY                     // PLY                               locals.asm:653
0xA6F1  0xFA            PLX                     // PLX                               locals.asm:654
0xA6F2  0x68            PLA                     // PLA                               locals.asm:655
0xA6F3  0x60            RTS                     // }                                 locals.asm:656

// /source/projects/6502sbc/hopperbasic/objects/locals.asm:662
// ####  Locals.RemoveLast()  ####                                              0x0143

0xA6F4  0x48            PHA                     // PHA                               locals.asm:663
0xA6F5  0x5A            PHY                     // PHY                               locals.asm:664
0xA6F6  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       locals.asm:666
0xA6F8  0x48            PHA                     // PHA                               locals.asm:667
0xA6F9  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       locals.asm:668
0xA6FB  0x48            PHA                     // PHA                               locals.asm:669
0xA6FC  0xA0 0x05       LDY # 0x05              // LDY #Objects.snLocals             locals.asm:674
0xA6FE  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   locals.asm:675
0xA700  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL                  locals.asm:676
0xA702  0xC8            INY                     // INY                               locals.asm:677
0xA703  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   locals.asm:678
0xA705  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  locals.asm:679
0xA707  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  locals.asm:682
0xA709  0x05 0x68       ORA 0x68                // ORA ZP.LCURRENTH                  locals.asm:683
0xA70B  0xD0 0x03       BNE 0xA710 (+3)         // if (Z)                            locals.asm:684
0xA70D  0x18            CLC                     // CLC     List was empty            locals.asm:686
0xA70E  0x80 0x46       BRA 0xA756 (+70)        // break;                            locals.asm:687
0xA710  0x18            CLC                     // CLC                               locals.asm:691
0xA711  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       locals.asm:692
0xA713  0x69 0x05       ADC # 0x05              // ADC #Objects.snLocals             locals.asm:693
0xA715  0x85 0x6B       STA 0x6B                // STA ZP.LPREVIOUSL                 locals.asm:694
0xA717  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       locals.asm:695
0xA719  0x69 0x00       ADC # 0                 // ADC #0                            locals.asm:696
0xA71B  0x85 0x6C       STA 0x6C                // STA ZP.LPREVIOUSH                 locals.asm:697
0xA71D  0xA0 0x00       LDY # 0                 // LDY #lnNext                       locals.asm:703
0xA71F  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              locals.asm:704
0xA721  0x85 0x1D       STA 0x1D                // STA ZP.IDYL     Save next pointer low
0xA723  0xC8            INY                     // INY                               locals.asm:706
0xA724  0xB1 0x67       LDA [0x67],Y            // LDA [ZP.LCURRENT], Y              locals.asm:707
0xA726  0x85 0x1E       STA 0x1E                // STA ZP.IDYH     Save next pointer high
0xA728  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       locals.asm:711
0xA72A  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       locals.asm:712
0xA72C  0xD0 0x16       BNE 0xA744 (+22)        // if (Z)                            locals.asm:713
0xA72E  0xA0 0x00       LDY # 0                 // LDY #0                            locals.asm:717
0xA730  0xA9 0x00       LDA # 0                 // LDA #0                            locals.asm:718
0xA732  0x91 0x6B       STA [0x6B],Y            // STA [ZP.LPREVIOUS], Y             locals.asm:719
0xA734  0xC8            INY                     // INY                               locals.asm:720
0xA735  0x91 0x6B       STA [0x6B],Y            // STA [ZP.LPREVIOUS], Y             locals.asm:721
0xA737  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  locals.asm:725
0xA739  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       locals.asm:726
0xA73B  0xA5 0x68       LDA 0x68                // LDA ZP.LCURRENTH                  locals.asm:727
0xA73D  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       locals.asm:728
0xA73F  0x20 0xB8 0x92  JSR 0x92B8              // Memory.Free();    Input: ZP.IDX, Munts: A, ZP.IDX, ZP.M* -> C on success
0xA742  0x80 0x12       BRA 0xA756 (+18)        // break;                            locals.asm:730
0xA744  0xA5 0x67       LDA 0x67                // LDA ZP.LCURRENTL                  locals.asm:735
0xA746  0x85 0x6B       STA 0x6B                // STA ZP.LPREVIOUSL                 locals.asm:736
0xA748  0xA5 0x68       LDA 0x68                // LDA ZP.LCURRENTH                  locals.asm:737
0xA74A  0x85 0x6C       STA 0x6C                // STA ZP.LPREVIOUSH                 locals.asm:738
0xA74C  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       locals.asm:740
0xA74E  0x85 0x67       STA 0x67                // STA ZP.LCURRENTL                  locals.asm:741
0xA750  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       locals.asm:742
0xA752  0x85 0x68       STA 0x68                // STA ZP.LCURRENTH                  locals.asm:743
0xA754  0x80 0xC7       BRA 0xA71D (-57)        // }                                 locals.asm:744
0xA756  0x68            PLA                     // PLA                               locals.asm:748
0xA757  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       locals.asm:749
0xA759  0x68            PLA                     // PLA                               locals.asm:750
0xA75A  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       locals.asm:751
0xA75C  0x7A            PLY                     // PLY                               locals.asm:754
0xA75D  0x68            PLA                     // PLA                               locals.asm:755
0xA75E  0x60            RTS                     // }                                 locals.asm:756

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:21
// ####  Functions.Declare()  ####                                              0x0145

0xA75F  0x48            PHA                     // PHA                               functions.asm:22
0xA760  0xDA            PHX                     // PHX                               functions.asm:23
0xA761  0x5A            PHY                     // PHY                               functions.asm:24
0xA762  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       functions.asm:29
0xA764  0x48            PHA                     // PHA                               functions.asm:30
0xA765  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       functions.asm:31
0xA767  0x48            PHA                     // PHA                               functions.asm:32
0xA768  0xA2 0x3E       LDX # 0x3E              // LDX #ZP.FunctionsList             functions.asm:35
0xA76A  0x20 0x4F 0x9F  JSR 0x9F4F              // Objects.Find();                   functions.asm:36
0xA76D  0x90 0x0B       BCC 0xA77A (+11)        // if (C)     Function already exists
0xA76F  0x68            PLA                     // PLA                               functions.asm:40
0xA770  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       functions.asm:41
0xA772  0x68            PLA                     // PLA                               functions.asm:42
0xA773  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       functions.asm:43
0xA775  0x20 0xF2 0x8B  JSR 0x8BF2              // Error.FunctionExistsTOP(); BIT ZP.EmulatorPCL    name is in ZP.TOP
0xA778  0x80 0x1B       BRA 0xA795 (+27)        // break;                            functions.asm:45
0xA77A  0x68            PLA                     // PLA                               functions.asm:49
0xA77B  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       functions.asm:50
0xA77D  0x68            PLA                     // PLA                               functions.asm:51
0xA77E  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       functions.asm:52
0xA780  0x64 0x10       STZ 0x10                // STZ ZP.ACCT    flags = 0          functions.asm:55
0xA782  0xA2 0x3E       LDX # 0x3E              // LDX #ZP.FunctionsList             functions.asm:56
0xA784  0x20 0x09 0x9F  JSR 0x9F09              // Objects.Add();                    functions.asm:57
0xA787  0xA0 0x02       LDY # 0x02              // LDY # Objects.snFlags             functions.asm:60
0xA789  0xA9 0x00       LDA # 0                 // LDA # 0                           functions.asm:61
0xA78B  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   functions.asm:62
0xA78D  0xA0 0x09       LDY # 0x09              // LDY # Objects.snOpCodes           functions.asm:65
0xA78F  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   functions.asm:66
0xA791  0xC8            INY                     // INY                               functions.asm:67
0xA792  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   functions.asm:68
0xA794  0x38            SEC                     // SEC    success                    functions.asm:70
0xA795  0x7A            PLY                     // PLY                               functions.asm:74
0xA796  0xFA            PLX                     // PLX                               functions.asm:75
0xA797  0x68            PLA                     // PLA                               functions.asm:76
0xA798  0x60            RTS                     // }                                 functions.asm:77

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:84
// ####  Functions.Find()  ####                                                 0x0146

0xA799  0x48            PHA                     // PHA                               functions.asm:85
0xA79A  0xDA            PHX                     // PHX                               functions.asm:86
0xA79B  0x5A            PHY                     // PHY                               functions.asm:87
0xA79C  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       functions.asm:89
0xA79E  0x48            PHA                     // PHA                               functions.asm:90
0xA79F  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      functions.asm:91
0xA7A1  0x48            PHA                     // PHA                               functions.asm:92
0xA7A2  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      functions.asm:93
0xA7A4  0x48            PHA                     // PHA                               functions.asm:94
0xA7A5  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       functions.asm:95
0xA7A7  0x48            PHA                     // PHA                               functions.asm:96
0xA7A8  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       functions.asm:97
0xA7AA  0x48            PHA                     // PHA                               functions.asm:98
0xA7AB  0xA2 0x3E       LDX # 0x3E              // LDX #ZP.FunctionsList             functions.asm:103
0xA7AD  0x20 0x4F 0x9F  JSR 0x9F4F              // Objects.Find();                   functions.asm:104
0xA7B0  0xB0 0x01       BCS 0xA7B3 (+1)         // if (NC)     Not found             functions.asm:105
0xA7B2  0x18            CLC                     // CLC     Not found                 functions.asm:107
0xA7B3  0x68            PLA                     // PLA                               functions.asm:113
0xA7B4  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       functions.asm:114
0xA7B6  0x68            PLA                     // PLA                               functions.asm:115
0xA7B7  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       functions.asm:116
0xA7B9  0x68            PLA                     // PLA                               functions.asm:117
0xA7BA  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      functions.asm:118
0xA7BC  0x68            PLA                     // PLA                               functions.asm:119
0xA7BD  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      functions.asm:120
0xA7BF  0x68            PLA                     // PLA                               functions.asm:121
0xA7C0  0x85 0x10       STA 0x10                // STA ZP.ACCT                       functions.asm:122
0xA7C2  0x7A            PLY                     // PLY                               functions.asm:124
0xA7C3  0xFA            PLX                     // PLX                               functions.asm:125
0xA7C4  0x68            PLA                     // PLA                               functions.asm:126
0xA7C5  0x60            RTS                     // }                                 functions.asm:127

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:134
// ####  Functions.GetBody()  ####                                              0x0147

0xA7C6  0x20 0xCA 0x9F  JSR 0x9FCA              // Objects.GetTokens();     node address in IDX, -> tokens pointer in ZP.IDY, Munts: A
0xA7C9  0x38            SEC                     // SEC     Always succeeds           functions.asm:136
0xA7CA  0x60            RTS                     // }                                 functions.asm:137

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:144
// ####  Functions.GetName()  ####                                              0x0148

0xA7CB  0x48            PHA                     // PHA                               functions.asm:145
0xA7CC  0x18            CLC                     // CLC                               functions.asm:148
0xA7CD  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       functions.asm:149
0xA7CF  0x69 0x0B       ADC # 0x0B              // ADC #Objects.snName               functions.asm:150
0xA7D1  0x85 0x79       STA 0x79                // STA ZP.STRL                       functions.asm:151
0xA7D3  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       functions.asm:152
0xA7D5  0x69 0x00       ADC # 0                 // ADC #0                            functions.asm:153
0xA7D7  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       functions.asm:154
0xA7D9  0x38            SEC                     // SEC     Always succeeds           functions.asm:156
0xA7DA  0x68            PLA                     // PLA                               functions.asm:158
0xA7DB  0x60            RTS                     // }                                 functions.asm:159

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:166
// ####  Functions.GetArguments()  ####                                         0x0149

0xA7DC  0x48            PHA                     // PHA                               functions.asm:167
0xA7DD  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       functions.asm:169
0xA7DF  0x48            PHA                     // PHA                               functions.asm:170
0xA7E0  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      functions.asm:171
0xA7E2  0x48            PHA                     // PHA                               functions.asm:172
0xA7E3  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      functions.asm:173
0xA7E5  0x48            PHA                     // PHA                               functions.asm:174
0xA7E6  0x20 0x7F 0x9F  JSR 0x9F7F              // Objects.GetData();     Returns tokens in ZP.NEXT, value/args in ZP.IDY
0xA7E9  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       functions.asm:179
0xA7EB  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       functions.asm:180
0xA7ED  0xD0 0x03       BNE 0xA7F2 (+3)         // if (Z)                            functions.asm:181
0xA7EF  0x18            CLC                     // CLC     No arguments              functions.asm:183
0xA7F0  0x80 0x01       BRA 0xA7F3 (+1)         // }                                 functions.asm:184
0xA7F2  0x38            SEC                     // SEC     Has arguments             functions.asm:187
0xA7F3  0x68            PLA                     // PLA                               functions.asm:190
0xA7F4  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      functions.asm:191
0xA7F6  0x68            PLA                     // PLA                               functions.asm:192
0xA7F7  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      functions.asm:193
0xA7F9  0x68            PLA                     // PLA                               functions.asm:194
0xA7FA  0x85 0x10       STA 0x10                // STA ZP.ACCT                       functions.asm:195
0xA7FC  0x68            PLA                     // PLA                               functions.asm:197
0xA7FD  0x60            RTS                     // }                                 functions.asm:198

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:205
// ####  Functions.Remove()  ####                                               0x014A

0xA7FE  0x48            PHA                     // PHA                               functions.asm:206
0xA7FF  0xDA            PHX                     // PHX                               functions.asm:207
0xA800  0x5A            PHY                     // PHY                               functions.asm:208
0xA801  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       functions.asm:210
0xA803  0x48            PHA                     // PHA                               functions.asm:211
0xA804  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       functions.asm:212
0xA806  0x48            PHA                     // PHA                               functions.asm:213
0xA807  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       functions.asm:214
0xA809  0x48            PHA                     // PHA                               functions.asm:215
0xA80A  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       functions.asm:216
0xA80C  0x48            PHA                     // PHA                               functions.asm:217
0xA80D  0x20 0x99 0xA7  JSR 0xA799              // Find();   returns IDX             functions.asm:222
0xA810  0xB0 0x03       BCS 0xA815 (+3)         // if (NC)     Not found             functions.asm:223
0xA812  0x18            CLC                     // CLC     Not found                 functions.asm:225
0xA813  0x80 0x17       BRA 0xA82C (+23)        // break;                            functions.asm:226
0xA815  0x20 0x3B 0xA6  JSR 0xA63B              // Locals.Clear();     preserves IDX munts ZP.IDY, ZP.TOP, ZP.NEXT, ZP.LCURRENT, ZP.LNEXT, ZP.SymbolTemp0, ZP.SymbolTemp1
0xA818  0x20 0xCA 0x9F  JSR 0x9FCA              // Objects.GetTokens();    node address in IDX, -> tokens pointer in ZP.IDY, Munts: A
0xA81B  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       functions.asm:234
0xA81D  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       functions.asm:235
0xA81F  0xF0 0x03       BEQ 0xA824 (+3)         // if (NZ)     Non-zero tokens pointer
0xA821  0x20 0xBF 0x92  JSR 0x92BF              // Memory.FreeIDY();     Input: ZP.IDY, Munts: A, ZP.M* -> C on success
0xA824  0x20 0x89 0xA8  JSR 0xA889              // freeOpCodes();                    functions.asm:241
0xA827  0xA2 0x3E       LDX # 0x3E              // LDX #ZP.FunctionsList             functions.asm:243
0xA829  0x20 0x4C 0x9E  JSR 0x9E4C              // Objects.Remove();     remove node IDX, munts: A, ZP.IDX, ZP.L*, ZP.LHEADX, ZP.CURRENT, ZP.PREVIOUS, ZP.LNEXT
0xA82C  0x68            PLA                     // PLA                               functions.asm:248
0xA82D  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       functions.asm:249
0xA82F  0x68            PLA                     // PLA                               functions.asm:250
0xA830  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       functions.asm:251
0xA832  0x68            PLA                     // PLA                               functions.asm:252
0xA833  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       functions.asm:253
0xA835  0x68            PLA                     // PLA                               functions.asm:254
0xA836  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       functions.asm:255
0xA838  0x7A            PLY                     // PLY                               functions.asm:257
0xA839  0xFA            PLX                     // PLX                               functions.asm:258
0xA83A  0x68            PLA                     // PLA                               functions.asm:259
0xA83B  0x60            RTS                     // }                                 functions.asm:260

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:268
// ####  Functions.IterateFunctions()  ####                                     0x014B

0xA83C  0x48            PHA                     // PHA                               functions.asm:269
0xA83D  0xDA            PHX                     // PHX                               functions.asm:270
0xA83E  0xA9 0x00       LDA # 0                 // LDA # 0                           functions.asm:273
0xA840  0x85 0x47       STA 0x47                // STA ZP.SymbolIteratorFilter       functions.asm:274
0xA842  0xA2 0x3E       LDX # 0x3E              // LDX #ZP.FunctionsList             functions.asm:276
0xA844  0x20 0xE6 0x9F  JSR 0x9FE6              // Objects.IterateStart();           functions.asm:277
0xA847  0xFA            PLX                     // PLX                               functions.asm:279
0xA848  0x68            PLA                     // PLA                               functions.asm:280
0xA849  0x60            RTS                     // }                                 functions.asm:281

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:296
// ####  Functions.Clear()  ####                                                0x014D

0xA84A  0xDA            PHX                     // PHX                               functions.asm:297
0xA84B  0x20 0xA7 0xA8  JSR 0xA8A7              // FreeAllOpCodes();                 functions.asm:300
0xA84E  0xA2 0x3E       LDX # 0x3E              // LDX #ZP.FunctionsList    for Table.GetFirst() and Table.Delete()
0xA850  0x20 0xC8 0x9D  JSR 0x9DC8              // Table.GetFirst();    -> ZP.IDX    functions.asm:305
0xA853  0x90 0x14       BCC 0xA869 (+20)        // if (NC) { break; }     No more functions
0xA855  0x20 0x3B 0xA6  JSR 0xA63B              // Locals.Clear();     node address in IDX, munts ZP.IDY, ZP.TOP, ZP.NEXT, ZP.LCURRENT, ZP.LNEXT, ZP.SymbolTemp0, ZP.SymbolTemp1
0xA858  0x20 0xCA 0x9F  JSR 0x9FCA              // Objects.GetTokens();    node address in IDX, -> tokens pointer in ZP.IDY, Munts: A
0xA85B  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       functions.asm:314
0xA85D  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       functions.asm:315
0xA85F  0xF0 0x03       BEQ 0xA864 (+3)         // if (NZ)     Non-zero tokens pointer
0xA861  0x20 0xBF 0x92  JSR 0x92BF              // Memory.FreeIDY();     Input: ZP.IDY, Munts: A, ZP.M* -> C on success
0xA864  0x20 0x4C 0x9E  JSR 0x9E4C              // Table.Delete();    remove node IDX, munts: A, ZP.IDX, ZP.L*, ZP.LHEADX, ZP.CURRENT, ZP.PREVIOUS, ZP.LNEXT
0xA867  0x80 0xE7       BRA 0xA850 (-25)        // }    loop                         functions.asm:323
0xA869  0x38            SEC                     // SEC     Always succeeds           functions.asm:325
0xA86A  0xFA            PLX                     // PLX                               functions.asm:327
0xA86B  0x60            RTS                     // }                                 functions.asm:328

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:335
// ####  Functions.SetBody()  ####                                              0x014E

0xA86C  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       functions.asm:337
0xA86E  0x48            PHA                     // PHA                               functions.asm:338
0xA86F  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       functions.asm:339
0xA871  0x48            PHA                     // PHA                               functions.asm:340
0xA872  0x20 0xCA 0x9F  JSR 0x9FCA              // Objects.GetTokens();    node address in IDX, -> tokens pointer in ZP.IDY, Munts: A
0xA875  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       functions.asm:345
0xA877  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       functions.asm:346
0xA879  0xF0 0x03       BEQ 0xA87E (+3)         // if (NZ)     Non-zero tokens pointer
0xA87B  0x20 0xBF 0x92  JSR 0x92BF              // Memory.FreeIDY();     Input: ZP.IDY, Munts: A, ZP.M* -> C on success
0xA87E  0x68            PLA                     // PLA                               functions.asm:353
0xA87F  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       functions.asm:354
0xA881  0x68            PLA                     // PLA                               functions.asm:355
0xA882  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       functions.asm:356
0xA884  0x20 0xD8 0x9F  JSR 0x9FD8              // Objects.SetTokens();     Uses ZP.IDX and ZP.IDY, Munts A
0xA887  0x38            SEC                     // SEC     Always succeeds           functions.asm:361
0xA888  0x60            RTS                     // }                                 functions.asm:362

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:365
// ####  Functions.freeOpCodes()  ####                                          0x014F

0xA889  0xA0 0x09       LDY # 0x09              // LDY # Objects.snOpCodes           functions.asm:368
0xA88B  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   functions.asm:369
0xA88D  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       functions.asm:370
0xA88F  0xC8            INY                     // INY                               functions.asm:371
0xA890  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   functions.asm:372
0xA892  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       functions.asm:373
0xA894  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       functions.asm:375
0xA896  0x05 0x1D       ORA 0x1D                // ORA ZP.IDYL                       functions.asm:376
0xA898  0xF0 0x03       BEQ 0xA89D (+3)         // if (NZ)                           functions.asm:377
0xA89A  0x20 0xBF 0x92  JSR 0x92BF              // Memory.FreeIDY();     Input: ZP.IDY, Munts: A, ZP.M* -> C on success
0xA89D  0xA0 0x09       LDY # 0x09              // LDY # Objects.snOpCodes           functions.asm:383
0xA89F  0xA9 0x00       LDA # 0                 // LDA # 0                           functions.asm:384
0xA8A1  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   functions.asm:385
0xA8A3  0xC8            INY                     // INY                               functions.asm:386
0xA8A4  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   functions.asm:387
0xA8A6  0x60            RTS                     // }                                 functions.asm:388

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:398
// ####  Functions.FreeAllOpCodes()  ####                                       0x0150

0xA8A7  0x48            PHA                     // PHA                               functions.asm:399
0xA8A8  0xDA            PHX                     // PHX                               functions.asm:400
0xA8A9  0x5A            PHY                     // PHY                               functions.asm:401
0xA8AA  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       functions.asm:404
0xA8AC  0x48            PHA                     // PHA                               functions.asm:405
0xA8AD  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       functions.asm:406
0xA8AF  0x48            PHA                     // PHA                               functions.asm:407
0xA8B0  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       functions.asm:408
0xA8B2  0x48            PHA                     // PHA                               functions.asm:409
0xA8B3  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       functions.asm:410
0xA8B5  0x48            PHA                     // PHA                               functions.asm:411
0xA8B6  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       functions.asm:412
0xA8B8  0x48            PHA                     // PHA                               functions.asm:413
0xA8B9  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       functions.asm:414
0xA8BB  0x48            PHA                     // PHA                               functions.asm:415
0xA8BC  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      functions.asm:416
0xA8BE  0x48            PHA                     // PHA                               functions.asm:417
0xA8BF  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      functions.asm:418
0xA8C1  0x48            PHA                     // PHA                               functions.asm:419
0xA8C2  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       functions.asm:420
0xA8C4  0x48            PHA                     // PHA                               functions.asm:421
0xA8C5  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       functions.asm:422
0xA8C7  0x48            PHA                     // PHA                               functions.asm:423
0xA8C8  0x20 0x3C 0xA8  JSR 0xA83C              // IterateFunctions();    ZP.IDX = first function
0xA8CB  0x90 0x08       BCC 0xA8D5 (+8)         // if (NC) { break; }    No more functions
0xA8CD  0x20 0x89 0xA8  JSR 0xA889              // freeOpCodes();    Frees opcode stream and nulls pointer
0xA8D0  0x20 0x08 0xA0  JSR 0xA008              // IterateNext();    ZP.IDX = next function
0xA8D3  0x80 0xF6       BRA 0xA8CB (-10)        // }                                 functions.asm:438
0xA8D5  0x68            PLA                     // PLA                               functions.asm:441
0xA8D6  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       functions.asm:442
0xA8D8  0x68            PLA                     // PLA                               functions.asm:443
0xA8D9  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       functions.asm:444
0xA8DB  0x68            PLA                     // PLA                               functions.asm:445
0xA8DC  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      functions.asm:446
0xA8DE  0x68            PLA                     // PLA                               functions.asm:447
0xA8DF  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      functions.asm:448
0xA8E1  0x68            PLA                     // PLA                               functions.asm:449
0xA8E2  0x85 0x12       STA 0x12                // STA ZP.TOPH                       functions.asm:450
0xA8E4  0x68            PLA                     // PLA                               functions.asm:451
0xA8E5  0x85 0x11       STA 0x11                // STA ZP.TOPL                       functions.asm:452
0xA8E7  0x68            PLA                     // PLA                               functions.asm:453
0xA8E8  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       functions.asm:454
0xA8EA  0x68            PLA                     // PLA                               functions.asm:455
0xA8EB  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       functions.asm:456
0xA8ED  0x68            PLA                     // PLA                               functions.asm:457
0xA8EE  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       functions.asm:458
0xA8F0  0x68            PLA                     // PLA                               functions.asm:459
0xA8F1  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       functions.asm:460
0xA8F3  0x7A            PLY                     // PLY                               functions.asm:462
0xA8F4  0xFA            PLX                     // PLX                               functions.asm:463
0xA8F5  0x68            PLA                     // PLA                               functions.asm:464
0xA8F6  0x60            RTS                     // }                                 functions.asm:465

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:471
// ####  Functions.IsCompiled()  ####                                           0x0151

0xA8F7  0xA0 0x09       LDY # 0x09              // LDY # Objects.snOpCodes           functions.asm:472
0xA8F9  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   functions.asm:473
0xA8FB  0xE8            INX                     // INX                               functions.asm:474
0xA8FC  0x11 0x1B       ORA [0x1B],Y            // ORA [ZP.IDX], Y                   functions.asm:475
0xA8FE  0xF0 0x02       BEQ 0xA902 (+2)         // if (NZ)                           functions.asm:476
0xA900  0x38            SEC                     // { SEC } else { CLC }              functions.asm:477
0xA901  0x60            RTS
0xA902  0x18            CLC
0xA903  0x60            RTS                     // }                                 functions.asm:478

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:485
// ####  Functions.GetOpCodes()  ####                                           0x0152

0xA904  0x48            PHA                     // PHA                               functions.asm:486
0xA905  0x5A            PHY                     // PHY                               functions.asm:487
0xA906  0x20 0xF7 0xA8  JSR 0xA8F7              // IsCompiled();                     functions.asm:490
0xA909  0xB0 0x07       BCS 0xA912 (+7)         // if (NC)    Not compiled           functions.asm:491
0xA90B  0x64 0x1D       STZ 0x1D                // STZ ZP.IDYL                       functions.asm:494
0xA90D  0x64 0x1E       STZ 0x1E                // STZ ZP.IDYH                       functions.asm:495
0xA90F  0x18            CLC                     // CLC    Not compiled               functions.asm:496
0xA910  0x80 0x0C       BRA 0xA91E (+12)        // }                                 functions.asm:497
0xA912  0xA0 0x09       LDY # 0x09              // LDY # Objects.snOpCodes           functions.asm:501
0xA914  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   functions.asm:502
0xA916  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       functions.asm:503
0xA918  0xC8            INY                     // INY                               functions.asm:504
0xA919  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   functions.asm:505
0xA91B  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       functions.asm:506
0xA91D  0x38            SEC                     // SEC    Compiled                   functions.asm:508
0xA91E  0x7A            PLY                     // PLY                               functions.asm:511
0xA91F  0x68            PLA                     // PLA                               functions.asm:512
0xA920  0x60            RTS                     // }                                 functions.asm:513

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:517
// ####  Functions.JumpToOpCodes()  ####                                        0x0153

0xA921  0x20 0x66 0xE8  JSR 0xE866              // Executor.FetchOperandWord();      functions.asm:519
0xA924  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       functions.asm:520
0xA926  0x85 0xA6       STA 0xA6                // STA ZP.IDCALLL                    functions.asm:521
0xA928  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       functions.asm:522
0xA92A  0x85 0xA7       STA 0xA7                // STA ZP.IDCALLH                    functions.asm:523
0xA92C  0x20 0xCE 0x93  JSR 0x93CE              // Stacks.PushPC();    after FetchOperandWord
0xA92F  0x20 0xEC 0x93  JSR 0x93EC              // Stacks.PushXID();                 functions.asm:527
0xA932  0xA0 0x09       LDY # 0x09              // LDY #Objects.snOpCodes            functions.asm:529
0xA934  0xB1 0xA6       LDA [0xA6],Y            // LDA [ZP.IDCALL], Y                functions.asm:530
0xA936  0x85 0x00       STA 0x00                // STA ZP.PCL                        functions.asm:531
0xA938  0xC8            INY                     // INY                               functions.asm:532
0xA939  0xB1 0xA6       LDA [0xA6],Y            // LDA [ZP.IDCALL], Y                functions.asm:533
0xA93B  0x85 0x01       STA 0x01                // STA ZP.PCH                        functions.asm:534
0xA93D  0xA0 0x03       LDY # 0x03              // LDY #Objects.snTokens             functions.asm:536
0xA93F  0xB1 0xA6       LDA [0xA6],Y            // LDA [ZP.IDCALL], Y                functions.asm:537
0xA941  0x85 0x80       STA 0x80                // STA ZP.XIDL                       functions.asm:538
0xA943  0xC8            INY                     // INY                               functions.asm:539
0xA944  0xB1 0xA6       LDA [0xA6],Y            // LDA [ZP.IDCALL], Y                functions.asm:540
0xA946  0x85 0x81       STA 0x81                // STA ZP.XIDH                       functions.asm:541
0xA948  0x38            SEC                     // SEC                               functions.asm:543
0xA949  0x60            RTS                     // }                                 functions.asm:544

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:549
// ####  Functions.RemoveLocals()  ####                                         0x0154

0xA94A  0x20 0xE1 0xA5  JSR 0xA5E1              // Locals.GetArgumentsCount();    ZP.IDX -> ZP.ACCL
0xA94D  0x20 0x98 0xA5  JSR 0xA598              // Locals.FindByIndex();    function IDX, index ZP.ACCL -> local IDY, C or NC
0xA950  0x90 0x05       BCC 0xA957 (+5)         // if (NC) { break; }       no more locals -> exit loop
0xA952  0x20 0xF4 0xA6  JSR 0xA6F4              // Locals.RemoveLast();     Clear locals for function in ZP.IDX
0xA955  0x80 0xF6       BRA 0xA94D (-10)        // }                                 functions.asm:556
0xA957  0x60            RTS                     // }                                 functions.asm:557

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:560
// ####  Functions.CompileForError()  ####                                      0x0155

0xA958  0xA5 0x2D       LDA 0x2D                // LDA ZP.LastError                  functions.asm:561
0xA95A  0x85 0xA8       STA 0xA8                // STA ZP.RuntimeError               functions.asm:562
0xA95C  0x64 0x2D       STZ 0x2D                // STZ ZP.LastError                  functions.asm:563
0xA95E  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();              functions.asm:564
0xA961  0xA5 0xA6       LDA 0xA6                // LDA ZP.IDCALLL                    functions.asm:567
0xA963  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       functions.asm:568
0xA965  0xA5 0xA7       LDA 0xA7                // LDA ZP.IDCALLH                    functions.asm:569
0xA967  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       functions.asm:570
0xA969  0x20 0x4A 0xA9  JSR 0xA94A              // Functions.RemoveLocals();    IDX = function node
0xA96C  0x20 0x04 0xA9  JSR 0xA904              // Functions.GetOpCodes();    IDX -> IDY
0xA96F  0x38            SEC                     // SEC                               functions.asm:580
0xA970  0xA5 0x00       LDA 0x00                // LDA ZP.PCL                        functions.asm:581
0xA972  0xE5 0x1D       SBC 0x1D                // SBC ZP.IDYL                       functions.asm:582
0xA974  0x85 0x00       STA 0x00                // STA ZP.PCL                        functions.asm:583
0xA976  0xA5 0x01       LDA 0x01                // LDA ZP.PCH                        functions.asm:584
0xA978  0xE5 0x1E       SBC 0x1E                // SBC ZP.IDYH                       functions.asm:585
0xA97A  0x85 0x01       STA 0x01                // STA ZP.PCH                        functions.asm:586
0xA97C  0x18            CLC                     // CLC                               functions.asm:589
0xA97D  0xA5 0x00       LDA 0x00                // LDA ZP.PCL                        functions.asm:590
0xA97F  0x69 0x00       ADC # 0                 // ADC #(Address.FunctionOpCodeBuffer % 256)
0xA981  0x85 0x00       STA 0x00                // STA ZP.PCL                        functions.asm:592
0xA983  0xA5 0x01       LDA 0x01                // LDA ZP.PCH                        functions.asm:593
0xA985  0x69 0x14       ADC # 0x14              // ADC #(Address.FunctionOpCodeBuffer / 256)
0xA987  0x85 0x01       STA 0x01                // STA ZP.PCH                        functions.asm:595
0xA989  0xF7 0x02       SMB7 0x02               // SMB7 ZP.FLAGS    Bit 7 - compiling to find error location
0xA98B  0x20 0x93 0xA9  JSR 0xA993              // Functions.Compile();              functions.asm:601
0xA98E  0x77 0x02       RMB7 0x02               // RMB7 ZP.FLAGS                     functions.asm:602
0xA990  0x4C 0xA7 0xA8  JMP 0xA8A7              // Functions.FreeAllOpCodes();    clear all code (because it will have the wrong CALLF address for this function)

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:609
// ####  Functions.Compile()  ####                                              0x0156

0xA993  0x48            PHA                     // PHA                               functions.asm:610
0xA994  0xDA            PHX                     // PHX                               functions.asm:611
0xA995  0x5A            PHY                     // PHY                               functions.asm:612
0xA996  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              functions.asm:619
0xA998  0x48            PHA                     // PHA                               functions.asm:620
0xA999  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              functions.asm:621
0xA99B  0x48            PHA                     // PHA                               functions.asm:622
0xA99C  0xA5 0x29       LDA 0x29                // LDA ZP.TokenBufferContentLengthL  functions.asm:623
0xA99E  0x48            PHA                     // PHA                               functions.asm:624
0xA99F  0xA5 0x2A       LDA 0x2A                // LDA ZP.TokenBufferContentLengthH  functions.asm:625
0xA9A1  0x48            PHA                     // PHA                               functions.asm:626
0xA9A2  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functions.asm:627
0xA9A4  0x48            PHA                     // PHA                               functions.asm:628
0xA9A5  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               functions.asm:631
0xA9A7  0x48            PHA                     // PHA                               functions.asm:632
0xA9A8  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               functions.asm:633
0xA9AA  0x48            PHA                     // PHA                               functions.asm:634
0xA9AB  0xA5 0x3A       LDA 0x3A                // LDA ZP.OpCodeBufferL              functions.asm:635
0xA9AD  0x48            PHA                     // PHA                               functions.asm:636
0xA9AE  0xA5 0x3B       LDA 0x3B                // LDA ZP.OpCodeBufferH              functions.asm:637
0xA9B0  0x48            PHA                     // PHA                               functions.asm:638
0xA9B1  0x20 0x89 0xA8  JSR 0xA889              // freeOpCodes();    Free existing opcode stream if not null
0xA9B4  0x64 0x0E       STZ 0x0E                // STZ ZP.ACCL    0 arguments        functions.asm:649
0xA9B6  0x20 0xDC 0xA7  JSR 0xA7DC              // GetArguments();    ZP.IDY = arguments list head pointer
0xA9B9  0x90 0x03       BCC 0xA9BE (+3)         // if (C)                            functions.asm:651
0xA9BB  0x20 0xE1 0xA5  JSR 0xA5E1              // Locals.GetArgumentsCount();    ZP.ACCL = argument count
0xA9BE  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       functions.asm:657
0xA9C0  0x48            PHA                     // PHA                               functions.asm:658
0xA9C1  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       functions.asm:659
0xA9C3  0x48            PHA                     // PHA                               functions.asm:660
0xA9C4  0x20 0xEC 0x93  JSR 0x93EC              // Stacks.PushXID();                 functions.asm:662
0xA9C7  0x20 0x9E 0x96  JSR 0x969E              // BufferManager.UseFunctionBuffers();    IDX -> function node
0xA9CA  0x20 0xCA 0x9F  JSR 0x9FCA              // GetTokens();                      functions.asm:666
0xA9CD  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       functions.asm:667
0xA9CF  0x85 0x80       STA 0x80                // STA ZP.XIDL                       functions.asm:668
0xA9D1  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       functions.asm:669
0xA9D3  0x85 0x81       STA 0x81                // STA ZP.XIDH                       functions.asm:670
0xA9D5  0x20 0x45 0xD8  JSR 0xD845              // Compiler.CompileFunction();       functions.asm:673
0xA9D8  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functions.asm:674
0xA9DB  0x20 0xDD 0x93  JSR 0x93DD              // Stacks.PopXID();                  functions.asm:676
0xA9DE  0x68            PLA                     // PLA                               functions.asm:678
0xA9DF  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       functions.asm:679
0xA9E1  0x68            PLA                     // PLA                               functions.asm:680
0xA9E2  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       functions.asm:681
0xA9E4  0xA5 0x4E       LDA 0x4E                // States.GetState();                functions.asm:683
0xA9E6  0xC9 0x01       CMP # 1                 // case State.Success:               functions.asm:686
0xA9E8  0xF0 0x0D       BEQ 0xA9F7 (+13)
0xA9EA  0xC9 0x00       CMP # 0                 // case State.Failure:               functions.asm:690
0xA9EC  0xD0 0x04       BNE 0xA9F2 (+4)
0xA9EE  0x64 0x4E       STZ 0x4E                // States.SetFailure();              functions.asm:693
0xA9F0  0x80 0x10       BRA 0xAA02 (+16)        // break;                            functions.asm:694
0xA9F2  0xC9 0x02       CMP # 0x02              // case State.Exiting:               functions.asm:696
0xA9F4  0xD0 0x01       BNE 0xA9F7 (+1)
0xA9F6  0x00            BRK                     // BRK    should not happen in compilation
0xA9F7  0x20 0x5C 0xAA  JSR 0xAA5C              // copyOpCodesToFunction();          functions.asm:703
0xA9FA  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functions.asm:704
0xA9FD  0x90 0x03       BCC 0xAA02 (+3)         // if (NC) { break; }                functions.asm:705
0xA9FF  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();    should already be the case
0xAA02  0x18            CLC                     // Trace.IsTracing();                functions.asm:713
0xAA03  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functions.asm:718
0xAA06  0xB0 0x35       BCS 0xAA3D (+53)        // if (NC)                           functions.asm:719
0xAA08  0xA5 0x2A       LDA 0x2A                // LDA ZP.TokenBufferContentLengthH  functions.asm:721
0xAA0A  0xC5 0x2C       CMP 0x2C                // CMP ZP.TokenizerPosH              functions.asm:722
0xAA0C  0xD0 0x06       BNE 0xAA14 (+6)         // if (Z)                            functions.asm:723
0xAA0E  0xA5 0x29       LDA 0x29                // LDA ZP.TokenBufferContentLengthL  functions.asm:725
0xAA10  0xC5 0x2B       CMP 0x2B                // CMP ZP.TokenizerPosL              functions.asm:726
0xAA12  0xF0 0x29       BEQ 0xAA3D (+41)        // if (Z)                            functions.asm:727
0xAA14  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               functions.asm:735
0xAA16  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       functions.asm:736
0xAA18  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               functions.asm:737
0xAA1A  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       functions.asm:738
0xAA1C  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       functions.asm:740
0xAA1E  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       functions.asm:741
0xAA20  0xF0 0x1B       BEQ 0xAA3D (+27)        // if (NZ)                           functions.asm:742
0xAA22  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              functions.asm:745
0xAA24  0x85 0x58       STA 0x58                // STA ZP.TOKERRORH                  functions.asm:746
0xAA26  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              functions.asm:747
0xAA28  0x85 0x57       STA 0x57                // STA ZP.TOKERRORL                  functions.asm:748
0xAA2A  0x20 0xB6 0x95  JSR 0x95B6              // Print.NewLine();                  functions.asm:750
0xAA2D  0x20 0xDE 0xF7  JSR 0xF7DE              // Commands.DisplayFunctionSignature();    Input: ZP.IDX = function node
0xAA30  0x20 0x80 0xF2  JSR 0xF280              // TokenIterator.RenderTokenStream();      Input: ZP.IDY = tokens pointer
0xAA33  0x20 0x18 0xF8  JSR 0xF818              // Commands.DisplayFunctionSuffix();       Input: ZP.IDX = function node, munts IDY
0xAA36  0x20 0xB6 0x95  JSR 0x95B6              // Print.NewLine();                  functions.asm:754
0xAA39  0x64 0xA6       STZ 0xA6                // STZ ZP.IDCALLL                    functions.asm:757
0xAA3B  0x64 0xA7       STZ 0xA7                // STZ ZP.IDCALLH                    functions.asm:758
0xAA3D  0x68            PLA                     // PLA                               functions.asm:765
0xAA3E  0x85 0x3B       STA 0x3B                // STA ZP.OpCodeBufferH              functions.asm:766
0xAA40  0x68            PLA                     // PLA                               functions.asm:767
0xAA41  0x85 0x3A       STA 0x3A                // STA ZP.OpCodeBufferL              functions.asm:768
0xAA43  0x68            PLA                     // PLA                               functions.asm:769
0xAA44  0x85 0x39       STA 0x39                // STA ZP.TokenBufferH               functions.asm:770
0xAA46  0x68            PLA                     // PLA                               functions.asm:771
0xAA47  0x85 0x38       STA 0x38                // STA ZP.TokenBufferL               functions.asm:772
0xAA49  0x68            PLA                     // PLA                               functions.asm:775
0xAA4A  0x85 0x2F       STA 0x2F                // STA ZP.CurrentToken               functions.asm:776
0xAA4C  0x68            PLA                     // PLA                               functions.asm:777
0xAA4D  0x85 0x2A       STA 0x2A                // STA ZP.TokenBufferContentLengthH  functions.asm:778
0xAA4F  0x68            PLA                     // PLA                               functions.asm:779
0xAA50  0x85 0x29       STA 0x29                // STA ZP.TokenBufferContentLengthL  functions.asm:780
0xAA52  0x68            PLA                     // PLA                               functions.asm:781
0xAA53  0x85 0x2C       STA 0x2C                // STA ZP.TokenizerPosH              functions.asm:782
0xAA55  0x68            PLA                     // PLA                               functions.asm:783
0xAA56  0x85 0x2B       STA 0x2B                // STA ZP.TokenizerPosL              functions.asm:784
0xAA58  0x7A            PLY                     // PLY                               functions.asm:792
0xAA59  0xFA            PLX                     // PLX                               functions.asm:793
0xAA5A  0x68            PLA                     // PLA                               functions.asm:794
0xAA5B  0x60            RTS                     // }                                 functions.asm:795

// /source/projects/6502sbc/hopperbasic/objects/functions.asm:805
// ####  Functions.copyOpCodesToFunction()  ####                                0x0157

0xAA5C  0x48            PHA                     // PHA                               functions.asm:806
0xAA5D  0xDA            PHX                     // PHX                               functions.asm:807
0xAA5E  0x5A            PHY                     // PHY                               functions.asm:808
0xAA5F  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       functions.asm:811
0xAA61  0x48            PHA                     // PHA                               functions.asm:812
0xAA62  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       functions.asm:813
0xAA64  0x48            PHA                     // PHA                               functions.asm:814
0xAA65  0xA5 0x32       LDA 0x32                // LDA ZP.OpCodeBufferContentLengthL functions.asm:819
0xAA67  0x05 0x33       ORA 0x33                // ORA ZP.OpCodeBufferContentLengthH functions.asm:820
0xAA69  0xD0 0x05       BNE 0xAA70 (+5)         // if (Z)                            functions.asm:821
0xAA6B  0x20 0xCA 0x8B  JSR 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0xAA6E  0x80 0x46       BRA 0xAAB6 (+70)        // break;                            functions.asm:825
0xAA70  0xA5 0x32       LDA 0x32                // LDA ZP.OpCodeBufferContentLengthL functions.asm:830
0xAA72  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       functions.asm:831
0xAA74  0xA5 0x33       LDA 0x33                // LDA ZP.OpCodeBufferContentLengthH functions.asm:832
0xAA76  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       functions.asm:833
0xAA78  0x20 0x97 0x92  JSR 0x9297              // Memory.Allocate();    copyOpCodesToFunction(): Input: ZP.ACC = size, Munts: ZP.M*, ZP.FREELIST, ZP.ACCL, -> ZP.IDX
0xAA7B  0x90 0x39       BCC 0xAAB6 (+57)        // if (NC) { BIT ZP.EmulatorPCL break; }
0xAA7D  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       functions.asm:840
0xAA7F  0x85 0x0E       STA 0x0E                // STA ZP.ACCL     Temporarily store opcode storage address
0xAA81  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       functions.asm:842
0xAA83  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       functions.asm:843
0xAA85  0xA5 0x3A       LDA 0x3A                // LDA ZP.OpCodeBufferL              functions.asm:847
0xAA87  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL           Source: BasicOpCodeBuffer
0xAA89  0xA5 0x3B       LDA 0x3B                // LDA ZP.OpCodeBufferH              functions.asm:849
0xAA8B  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            functions.asm:850
0xAA8D  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       functions.asm:853
0xAA8F  0x85 0x63       STA 0x63                // STA ZP.FDESTINATIONADDRESSL      Destination: allocated storage
0xAA91  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       functions.asm:855
0xAA93  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       functions.asm:856
0xAA95  0xA5 0x32       LDA 0x32                // LDA ZP.OpCodeBufferContentLengthL       Length: opcode buffer length
0xAA97  0x85 0x65       STA 0x65                // STA ZP.FLENGTHL                   functions.asm:860
0xAA99  0xA5 0x33       LDA 0x33                // LDA ZP.OpCodeBufferContentLengthH functions.asm:861
0xAA9B  0x85 0x66       STA 0x66                // STA ZP.FLENGTHH                   functions.asm:862
0xAA9D  0x20 0x0B 0x93  JSR 0x930B              // Memory.Copy();                    functions.asm:865
0xAAA0  0x68            PLA                     // PLA                               functions.asm:868
0xAAA1  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       functions.asm:869
0xAAA3  0x68            PLA                     // PLA                               functions.asm:870
0xAAA4  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       functions.asm:871
0xAAA6  0x48            PHA                     // PHA                               functions.asm:873
0xAAA7  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       functions.asm:874
0xAAA9  0x48            PHA                     // PHA                               functions.asm:875
0xAAAA  0xA0 0x09       LDY # 0x09              // LDY #Objects.snOpCodes            functions.asm:878
0xAAAC  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL     OpCode storage address LSB
0xAAAE  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   functions.asm:880
0xAAB0  0xC8            INY                     // INY                               functions.asm:881
0xAAB1  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH     OpCode storage address MSB
0xAAB3  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   functions.asm:883
0xAAB5  0x38            SEC                     // SEC    Success                    functions.asm:885
0xAAB6  0x68            PLA                     // PLA                               functions.asm:890
0xAAB7  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       functions.asm:891
0xAAB9  0x68            PLA                     // PLA                               functions.asm:892
0xAABA  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       functions.asm:893
0xAABC  0x7A            PLY                     // PLY                               functions.asm:895
0xAABD  0xFA            PLX                     // PLX                               functions.asm:896
0xAABE  0x68            PLA                     // PLA                               functions.asm:897
0xAABF  0x60            RTS                     // }                                 functions.asm:898

// /source/projects/6502sbc/hopperbasic/objects/array.asm:31
// ####  BASICArray.elementsToBytes()  ####                                     0x0158

0xAAC0  0x48            PHA                     // PHA                               array.asm:32
0xAAC1  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       array.asm:35
0xAAC3  0xC9 0x06       CMP # 0x06              // case BASICType.BIT:               array.asm:38
0xAAC5  0xD0 0x23       BNE 0xAAEA (+35)
0xAAC7  0x64 0x6F       STZ 0x6F                // STA ACARRY                        array.asm:42
0xAAC9  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       array.asm:45
0xAACB  0x29 0x07       AND # 0x07              // AND # 0x07                        array.asm:46
0xAACD  0xF0 0x02       BEQ 0xAAD1 (+2)         // if (NZ)                           array.asm:47
0xAACF  0xE6 0x6F       INC 0x6F                // INC ACARRY     Will add 1 for partial byte
0xAAD1  0x46 0x0F       LSR 0x0F                // LSR ZP.ACCH                       array.asm:53
0xAAD3  0x66 0x0E       ROR 0x0E                // ROR ZP.ACCL                       array.asm:54
0xAAD5  0x46 0x0F       LSR 0x0F                // LSR ZP.ACCH                       array.asm:55
0xAAD7  0x66 0x0E       ROR 0x0E                // ROR ZP.ACCL                       array.asm:56
0xAAD9  0x46 0x0F       LSR 0x0F                // LSR ZP.ACCH                       array.asm:57
0xAADB  0x66 0x0E       ROR 0x0E                // ROR ZP.ACCL                       array.asm:58
0xAADD  0x18            CLC                     // CLC                               array.asm:61
0xAADE  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       array.asm:62
0xAAE0  0x65 0x6F       ADC 0x6F                // ADC ACARRY                        array.asm:63
0xAAE2  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       array.asm:64
0xAAE4  0x90 0x10       BCC 0xAAF6 (+16)        // if (C)                            array.asm:65
0xAAE6  0xE6 0x0F       INC 0x0F                // INC ZP.ACCH                       array.asm:67
0xAAE8  0x80 0x0C       BRA 0xAAF6 (+12)        // }                                 array.asm:69
0xAAEA  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              array.asm:70
0xAAEC  0xF0 0x08       BEQ 0xAAF6 (+8)
0xAAEE  0xC9 0x03       CMP # 0x03              // case BASICType.BYTE:              array.asm:71
0xAAF0  0xF0 0x04       BEQ 0xAAF6 (+4)
0xAAF2  0x06 0x0E       ASL 0x0E                // ASL ZP.ACCL                       array.asm:78
0xAAF4  0x26 0x0F       ROL 0x0F                // ROL ZP.ACCH                       array.asm:79
0xAAF6  0x68            PLA                     // PLA                               array.asm:82
0xAAF7  0x60            RTS                     // }                                 array.asm:83

// /source/projects/6502sbc/hopperbasic/objects/array.asm:91
// ####  BASICArray.New()  ####                                                 0x0159

0xAAF8  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       array.asm:92
0xAAFA  0x48            PHA                     // PHA                               array.asm:93
0xAAFB  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       array.asm:94
0xAAFD  0x48            PHA                     // PHA                               array.asm:95
0xAAFE  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       array.asm:101
0xAB00  0x85 0x65       STA 0x65                // STA ZP.FLENGTHL                   array.asm:102
0xAB02  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       array.asm:103
0xAB04  0x85 0x66       STA 0x66                // STA ZP.FLENGTHH                   array.asm:104
0xAB06  0x20 0xC0 0xAA  JSR 0xAAC0              // elementsToBytes();                array.asm:109
0xAB09  0x18            CLC                     // CLC                               array.asm:112
0xAB0A  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       array.asm:113
0xAB0C  0x69 0x05       ADC # 0x05              // ADC # aiElements                  array.asm:114
0xAB0E  0x85 0x0E       STA 0x0E                // STA ACCL                          array.asm:115
0xAB10  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       array.asm:116
0xAB12  0x69 0x00       ADC # 0                 // ADC #0                            array.asm:117
0xAB14  0x85 0x0F       STA 0x0F                // STA ACCH                          array.asm:118
0xAB16  0x20 0x97 0x92  JSR 0x9297              // Memory.Allocate();     Array.New(): Input: ZP.ACC = size, Munts: ZP.M*, ZP.FREELIST, ZP.ACCL, -> ZP.IDX
0xAB19  0x90 0x33       BCC 0xAB4E (+51)        // if (NC) { BIT ZP.EmulatorPCL break; }
0xAB1B  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       array.asm:125
0xAB1D  0x85 0x63       STA 0x63                // STA ZP.FDESTINATIONADDRESSL       array.asm:126
0xAB1F  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       array.asm:127
0xAB21  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       array.asm:128
0xAB23  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       array.asm:133
0xAB25  0xD0 0x04       BNE 0xAB2B (+4)         // if (Z)                            array.asm:134
0xAB27  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       array.asm:136
0xAB29  0xF0 0x11       BEQ 0xAB3C (+17)        // if (Z)                            array.asm:137
0xAB2B  0xA9 0x00       LDA # 0                 // LDA # 0                           array.asm:144
0xAB2D  0x92 0x63       STA [0x63]              // STA [ZP.FDESTINATIONADDRESS]      array.asm:145
0xAB2F  0x20 0x81 0x93  JSR 0x9381              // IncDESTINATIONADDRESS();          array.asm:146
0xAB32  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       array.asm:149
0xAB34  0xD0 0x02       BNE 0xAB38 (+2)         // if (Z)                            array.asm:150
0xAB36  0xC6 0x0F       DEC 0x0F                // DEC ZP.ACCH                       array.asm:152
0xAB38  0xC6 0x0E       DEC 0x0E                // DEC ZP.ACCL                       array.asm:154
0xAB3A  0x80 0xE7       BRA 0xAB23 (-25)        // }                                 array.asm:155
0xAB3C  0xA0 0x00       LDY # 0                 // LDY # aiCount                     array.asm:158
0xAB3E  0xA5 0x65       LDA 0x65                // LDA ZP.FLENGTHL                   array.asm:159
0xAB40  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   array.asm:160
0xAB42  0xC8            INY                     // INY                               array.asm:161
0xAB43  0xA5 0x66       LDA 0x66                // LDA ZP.FLENGTHH                   array.asm:162
0xAB45  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   array.asm:163
0xAB47  0xA0 0x02       LDY # 0x02              // LDY # aiType                      array.asm:166
0xAB49  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       array.asm:167
0xAB4B  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   array.asm:168
0xAB4D  0x38            SEC                     // SEC     Success                   array.asm:172
0xAB4E  0x68            PLA                     // PLA                               array.asm:176
0xAB4F  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       array.asm:177
0xAB51  0x68            PLA                     // PLA                               array.asm:178
0xAB52  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       array.asm:179
0xAB54  0x60            RTS                     // }                                 array.asm:180

// /source/projects/6502sbc/hopperbasic/objects/array.asm:186
// ####  BASICArray.GetCount()  ####                                            0x015A

0xAB55  0x5A            PHY                     // PHY                               array.asm:187
0xAB56  0xA0 0x00       LDY # 0                 // LDY # aiCount                     array.asm:188
0xAB58  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   array.asm:189
0xAB5A  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       array.asm:190
0xAB5C  0xC8            INY                     // INY                               array.asm:191
0xAB5D  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   array.asm:192
0xAB5F  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       array.asm:193
0xAB61  0x7A            PLY                     // PLY                               array.asm:194
0xAB62  0x60            RTS                     // }                                 array.asm:195

// /source/projects/6502sbc/hopperbasic/objects/array.asm:202
// ####  BASICArray.GetItemType()  ####                                         0x015B

0xAB63  0x5A            PHY                     // PHY                               array.asm:203
0xAB64  0xA0 0x02       LDY # 0x02              // LDY # aiType                      array.asm:204
0xAB66  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   array.asm:205
0xAB68  0x85 0x10       STA 0x10                // STA ZP.ACCT                       array.asm:206
0xAB6A  0x7A            PLY                     // PLY                               array.asm:207
0xAB6B  0x60            RTS                     // }                                 array.asm:208

// /source/projects/6502sbc/hopperbasic/objects/array.asm:216
// ####  BASICArray.getIndexAndMask()  ####                                     0x015C

0xAB6C  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       array.asm:217
0xAB6E  0xC9 0x06       CMP # 0x06              // case BASICType.BIT:               array.asm:220
0xAB70  0xD0 0x13       BNE 0xAB85 (+19)
0xAB72  0xA5 0x1D       LDA 0x1D                // LDA IDYL                          array.asm:223
0xAB74  0x29 0x07       AND # 0x07              // AND # 0x07         Extract bit position (0-7)
0xAB76  0xAA            TAX                     // TAX                Save in X for later masking
0xAB77  0x46 0x1E       LSR 0x1E                // LSR IDYH                          array.asm:228
0xAB79  0x66 0x1D       ROR 0x1D                // ROR IDYL                          array.asm:229
0xAB7B  0x46 0x1E       LSR 0x1E                // LSR IDYH                          array.asm:230
0xAB7D  0x66 0x1D       ROR 0x1D                // ROR IDYL                          array.asm:231
0xAB7F  0x46 0x1E       LSR 0x1E                // LSR IDYH                          array.asm:232
0xAB81  0x66 0x1D       ROR 0x1D                // ROR IDYL                          array.asm:233
0xAB83  0x80 0x0C       BRA 0xAB91 (+12)        // }                                 array.asm:234
0xAB85  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              array.asm:235
0xAB87  0xF0 0x08       BEQ 0xAB91 (+8)
0xAB89  0xC9 0x03       CMP # 0x03              // case BASICType.BYTE:              array.asm:236
0xAB8B  0xF0 0x04       BEQ 0xAB91 (+4)
0xAB8D  0x06 0x1D       ASL 0x1D                // ASL IDYL                          array.asm:243
0xAB8F  0x26 0x1E       ROL 0x1E                // ROL IDYH                          array.asm:244
0xAB91  0x18            CLC                     // CLC                               array.asm:249
0xAB92  0xA5 0x1B       LDA 0x1B                // LDA IDXL                          array.asm:250
0xAB94  0x65 0x1D       ADC 0x1D                // ADC IDYL                          array.asm:251
0xAB96  0x85 0x1D       STA 0x1D                // STA IDYL                          array.asm:252
0xAB98  0xA5 0x1C       LDA 0x1C                // LDA IDXH                          array.asm:253
0xAB9A  0x65 0x1E       ADC 0x1E                // ADC IDYH                          array.asm:254
0xAB9C  0x85 0x1E       STA 0x1E                // STA IDYH                          array.asm:255
0xAB9E  0x60            RTS                     // }                                 array.asm:256

// /source/projects/6502sbc/hopperbasic/objects/array.asm:264
// ####  BASICArray.GetItem()  ####                                             0x015D

0xAB9F  0x48            PHA                     // PHA                               array.asm:265
0xABA0  0xDA            PHX                     // PHX                               array.asm:266
0xABA1  0x5A            PHY                     // PHY                               array.asm:267
0xABA2  0xA0 0x01       LDY # 1                 // LDY # aiCount+1                   array.asm:271
0xABA4  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH           Index MSB   array.asm:272
0xABA6  0xD1 0x1B       CMP [0x1B],Y            // CMP [ZP.IDX], Y          Count MSB
0xABA8  0xD0 0x05       BNE 0xABAF (+5)         // if (Z)                            array.asm:274
0xABAA  0x88            DEY                     // DEY                               array.asm:276
0xABAB  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL          Index LSB    array.asm:277
0xABAD  0xD1 0x1B       CMP [0x1B],Y            // CMP [ZP.IDX], Y      Count LSB    array.asm:278
0xABAF  0x90 0x07       BCC 0xABB8 (+7)         // if (C)    Set C if index >= count (out of bounds)
0xABB1  0x20 0xD9 0x8B  JSR 0x8BD9              // Error.IndexOutOfRange(); BIT ZP.EmulatorPCL
0xABB4  0x64 0x4E       STZ 0x4E                // States.SetFailure();              array.asm:283
0xABB6  0x80 0x47       BRA 0xABFF (+71)        // break;                            array.asm:284
0xABB8  0xA0 0x02       LDY # 0x02              // LDY # aiType                      array.asm:288
0xABBA  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   array.asm:289
0xABBC  0x85 0x10       STA 0x10                // STA ZP.ACCT                       array.asm:290
0xABBE  0x20 0x6C 0xAB  JSR 0xAB6C              // getIndexAndMask();    Returns address in IDY, bit # in X
0xABC1  0xA0 0x05       LDY # 0x05              // LDY # aiElements                  array.asm:296
0xABC3  0xA9 0x00       LDA # 0                 // LDA # 0                           array.asm:297
0xABC5  0x20 0x9A 0x97  JSR 0x979A              // Long.ZeroTop3();           Default high bytes = 0
0xABC8  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       array.asm:300
0xABCA  0x85 0x15       STA 0x15                // STA ZP.TOPT                       array.asm:301
0xABCC  0xC9 0x06       CMP # 0x06              // case BASICType.BIT:               array.asm:304
0xABCE  0xD0 0x11       BNE 0xABE1 (+17)
0xABD0  0xB1 0x1D       LDA [0x1D],Y            // LDA [IDY], Y                      array.asm:307
0xABD2  0x3D 0x98 0x85  AND 0x8598,X            // AND BitMasks, X                   array.asm:308
0xABD5  0xD0 0x04       BNE 0xABDB (+4)         // if (Z)                            array.asm:309
0xABD7  0x85 0x11       STA 0x11                // STA ZP.TOP0       Bit is 0        array.asm:311
0xABD9  0x80 0x23       BRA 0xABFE (+35)        // }                                 array.asm:312
0xABDB  0xA9 0x01       LDA # 1                 // LDA # 1                           array.asm:315
0xABDD  0x85 0x11       STA 0x11                // STA ZP.TOP0       Bit is 1        array.asm:316
0xABDF  0x80 0x1D       BRA 0xABFE (+29)        // }                                 array.asm:318
0xABE1  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              array.asm:319
0xABE3  0xD0 0x07       BNE 0xABEC (+7)
0xABE5  0xB1 0x1D       LDA [0x1D],Y            // LDA [IDY], Y                      array.asm:322
0xABE7  0x20 0x90 0x97  JSR 0x9790              // Long.LoadTopByte();     A = byte value
0xABEA  0x80 0x12       BRA 0xABFE (+18)        // }                                 array.asm:324
0xABEC  0xB1 0x1D       LDA [0x1D],Y            // LDA [IDY], Y                      array.asm:328
0xABEE  0x85 0x11       STA 0x11                // STA ZP.TOP0                       array.asm:329
0xABF0  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       array.asm:330
0xABF2  0xC9 0x03       CMP # 0x03              // CMP # BASICType.BYTE              array.asm:331
0xABF4  0xF0 0x05       BEQ 0xABFB (+5)         // if (NZ)                           array.asm:332
0xABF6  0xC8            INY                     // INY                               array.asm:334
0xABF7  0xB1 0x1D       LDA [0x1D],Y            // LDA [IDY], Y                      array.asm:335
0xABF9  0x85 0x12       STA 0x12                // STA ZP.TOP1                       array.asm:336
0xABFB  0x20 0x1F 0x86  JSR 0x861F              // BASICTypes.Promote();    -> LONG  array.asm:338
0xABFE  0x38            SEC                     // SEC                   Success     array.asm:341
0xABFF  0x7A            PLY                     // PLY                               array.asm:344
0xAC00  0xFA            PLX                     // PLX                               array.asm:345
0xAC01  0x68            PLA                     // PLA                               array.asm:346
0xAC02  0x60            RTS                     // }                                 array.asm:347

// /source/projects/6502sbc/hopperbasic/objects/array.asm:357
// ####  BASICArray.SetItem()  ####                                             0x015E

0xAC03  0x48            PHA                     // PHA                               array.asm:358
0xAC04  0xDA            PHX                     // PHX                               array.asm:359
0xAC05  0x5A            PHY                     // PHY                               array.asm:360
0xAC06  0xA0 0x01       LDY # 1                 // LDY # aiCount+1                   array.asm:367
0xAC08  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH           Index MSB   array.asm:368
0xAC0A  0xD1 0x1B       CMP [0x1B],Y            // CMP [ZP.IDX], Y          Count MSB
0xAC0C  0xD0 0x05       BNE 0xAC13 (+5)         // if (Z)                            array.asm:370
0xAC0E  0x88            DEY                     // DEY                               array.asm:372
0xAC0F  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL       Index LSB       array.asm:373
0xAC11  0xD1 0x1B       CMP [0x1B],Y            // CMP [ZP.IDX], Y      Count LSB    array.asm:374
0xAC13  0x90 0x07       BCC 0xAC1C (+7)         // if (C)    Set C if index >= count (out of bounds)
0xAC15  0x20 0xD9 0x8B  JSR 0x8BD9              // Error.IndexOutOfRange(); BIT ZP.EmulatorPCL
0xAC18  0x64 0x4E       STZ 0x4E                // States.SetFailure();              array.asm:381
0xAC1A  0x80 0x61       BRA 0xAC7D (+97)        // break;                            array.asm:382
0xAC1C  0xA0 0x02       LDY # 0x02              // LDY # aiType                      array.asm:386
0xAC1E  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   array.asm:387
0xAC20  0x85 0x10       STA 0x10                // STA ZP.ACCT                       array.asm:388
0xAC22  0x20 0x6C 0xAB  JSR 0xAB6C              // getIndexAndMask();    Returns address in IDY, bit # in X
0xAC25  0xA0 0x05       LDY # 0x05              // LDY # aiElements                  array.asm:394
0xAC27  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       array.asm:396
0xAC29  0xC9 0x06       CMP # 0x06              // case BASICType.BIT:               array.asm:399
0xAC2B  0xD0 0x21       BNE 0xAC4E (+33)
0xAC2D  0xC5 0x15       CMP 0x15                // CMP ZP.TOPT    strict: RHS type = LHS type
0xAC2F  0xF0 0x05       BEQ 0xAC36 (+5)         // if (NZ)                           array.asm:402
0xAC31  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xAC34  0x80 0x47       BRA 0xAC7D (+71)        // break;                            array.asm:405
0xAC36  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       array.asm:407
0xAC38  0xF0 0x09       BEQ 0xAC43 (+9)         // if (NZ)                           array.asm:408
0xAC3A  0xBD 0x98 0x85  LDA 0x8598,X            // LDA BitMasks, X                   array.asm:411
0xAC3D  0x11 0x1D       ORA [0x1D],Y            // ORA [IDY], Y                      array.asm:412
0xAC3F  0x91 0x1D       STA [0x1D],Y            // STA [IDY], Y                      array.asm:413
0xAC41  0x80 0x39       BRA 0xAC7C (+57)        // }                                 array.asm:414
0xAC43  0xBD 0x98 0x85  LDA 0x8598,X            // LDA BitMasks, X                   array.asm:418
0xAC46  0x49 0xFF       EOR # 0xFF              // EOR # 0xFF        Invert mask     array.asm:419
0xAC48  0x31 0x1D       AND [0x1D],Y            // AND [IDY], Y                      array.asm:420
0xAC4A  0x91 0x1D       STA [0x1D],Y            // STA [IDY], Y                      array.asm:421
0xAC4C  0x80 0x2E       BRA 0xAC7C (+46)        // }                                 array.asm:423
0xAC4E  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              array.asm:424
0xAC50  0xD0 0x10       BNE 0xAC62 (+16)
0xAC52  0xC5 0x15       CMP 0x15                // CMP ZP.TOPT    strict: RHS type = LHS type
0xAC54  0xF0 0x06       BEQ 0xAC5C (+6)         // if (NZ)                           array.asm:427
0xAC56  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xAC59  0x18            CLC                     // CLC                               array.asm:430
0xAC5A  0x80 0x21       BRA 0xAC7D (+33)        // break;                            array.asm:431
0xAC5C  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       array.asm:434
0xAC5E  0x91 0x1D       STA [0x1D],Y            // STA [IDY], Y                      array.asm:435
0xAC60  0x80 0x1A       BRA 0xAC7C (+26)        // }                                 array.asm:436
0xAC62  0x20 0x59 0x86  JSR 0x8659              // BASICTypes.Coerce();              array.asm:441
0xAC65  0x90 0x16       BCC 0xAC7D (+22)        // if (NC)                           array.asm:442
0xAC67  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       array.asm:446
0xAC69  0xC9 0x03       CMP # 0x03              // CMP #BASICType.BYTE               array.asm:447
0xAC6B  0xD0 0x06       BNE 0xAC73 (+6)         // if (Z)                            array.asm:448
0xAC6D  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       array.asm:451
0xAC6F  0x91 0x1D       STA [0x1D],Y            // STA [IDY], Y                      array.asm:452
0xAC71  0x80 0x09       BRA 0xAC7C (+9)         // }                                 array.asm:453
0xAC73  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       array.asm:457
0xAC75  0x91 0x1D       STA [0x1D],Y            // STA [IDY], Y                      array.asm:458
0xAC77  0xC8            INY                     // INY                               array.asm:459
0xAC78  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       array.asm:460
0xAC7A  0x91 0x1D       STA [0x1D],Y            // STA [IDY], Y                      array.asm:461
0xAC7C  0x38            SEC                     // SEC                   Success     array.asm:466
0xAC7D  0x7A            PLY                     // PLY                               array.asm:469
0xAC7E  0xFA            PLX                     // PLX                               array.asm:470
0xAC7F  0x68            PLA                     // PLA                               array.asm:471
0xAC80  0x60            RTS                     // }                                 array.asm:472

// /source/projects/6502sbc/hopperbasic/objects/array.asm:480
// ####  BASICArray.Redimension()  ####                                         0x015F

0xAC81  0x48            PHA                     // PHA                               array.asm:481
0xAC82  0xDA            PHX                     // PHX                               array.asm:482
0xAC83  0x5A            PHY                     // PHY                               array.asm:483
0xAC84  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       array.asm:485
0xAC86  0x48            PHA                     // PHA                               array.asm:486
0xAC87  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       array.asm:487
0xAC89  0x48            PHA                     // PHA                               array.asm:488
0xAC8A  0xA0 0x00       LDY # 0                 // LDY # aiCount                     array.asm:492
0xAC8C  0xB1 0x11       LDA [0x11],Y            // LDA [ZP.TOP], Y                   array.asm:493
0xAC8E  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       array.asm:494
0xAC90  0xC8            INY                     // INY                               array.asm:495
0xAC91  0xB1 0x11       LDA [0x11],Y            // LDA [ZP.TOP], Y                   array.asm:496
0xAC93  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       array.asm:497
0xAC95  0xC8            INY                     // INY                               array.asm:498
0xAC96  0xB1 0x11       LDA [0x11],Y            // LDA [ZP.TOP], Y                   array.asm:499
0xAC98  0x85 0x10       STA 0x10                // STA ZP.ACCT                       array.asm:500
0xAC9A  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       array.asm:502
0xAC9C  0xC5 0x17       CMP 0x17                // CMP ZP.NEXTH                      array.asm:503
0xAC9E  0xD0 0x32       BNE 0xACD2 (+50)        // if (Z)                            array.asm:504
0xACA0  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       array.asm:506
0xACA2  0xC5 0x16       CMP 0x16                // CMP ZP.NEXTL                      array.asm:507
0xACA4  0xD0 0x2C       BNE 0xACD2 (+44)        // if (Z)                            array.asm:508
0xACA6  0x20 0xC0 0xAA  JSR 0xAAC0              // elementsToBytes();                array.asm:513
0xACA9  0x18            CLC                     // CLC                               array.asm:515
0xACAA  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       array.asm:516
0xACAC  0x69 0x05       ADC # 0x05              // ADC # aiElements                  array.asm:517
0xACAE  0x85 0x63       STA 0x63                // STA ZP.FDESTINATIONADDRESSL       array.asm:518
0xACB0  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       array.asm:519
0xACB2  0x69 0x00       ADC # 0                 // ADC #0                            array.asm:520
0xACB4  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       array.asm:521
0xACB6  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       array.asm:526
0xACB8  0xD0 0x04       BNE 0xACBE (+4)         // if (Z)                            array.asm:527
0xACBA  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       array.asm:529
0xACBC  0xF0 0x11       BEQ 0xACCF (+17)        // if (Z)                            array.asm:530
0xACBE  0xA9 0x00       LDA # 0                 // LDA # 0x00                        array.asm:537
0xACC0  0x92 0x63       STA [0x63]              // STA [ZP.FDESTINATIONADDRESS]      array.asm:538
0xACC2  0x20 0x81 0x93  JSR 0x9381              // IncDESTINATIONADDRESS();          array.asm:539
0xACC5  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       array.asm:542
0xACC7  0xD0 0x02       BNE 0xACCB (+2)         // if (Z)                            array.asm:543
0xACC9  0xC6 0x0F       DEC 0x0F                // DEC ZP.ACCH                       array.asm:545
0xACCB  0xC6 0x0E       DEC 0x0E                // DEC ZP.ACCL                       array.asm:547
0xACCD  0x80 0xE7       BRA 0xACB6 (-25)        // }                                 array.asm:548
0xACCF  0x38            SEC                     // SEC                               array.asm:550
0xACD0  0x80 0x21       BRA 0xACF3 (+33)        // break;                            array.asm:551
0xACD2  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      array.asm:556
0xACD4  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       array.asm:557
0xACD6  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      array.asm:558
0xACD8  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       array.asm:559
0xACDA  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       array.asm:562
0xACDC  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       array.asm:563
0xACDE  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       array.asm:564
0xACE0  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       array.asm:565
0xACE2  0x20 0xB8 0x92  JSR 0x92B8              // Memory.Free();    Input: ZP.IDX, Munts: A, ZP.IDX, ZP.M* -> C on success
0xACE5  0x20 0xF8 0xAA  JSR 0xAAF8              // BASICArray.New();                 array.asm:570
0xACE8  0x90 0x09       BCC 0xACF3 (+9)         // if (NC) { BIT ZP.EmulatorPCL break; }
0xACEA  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       array.asm:573
0xACEC  0x85 0x11       STA 0x11                // STA ZP.TOPL                       array.asm:574
0xACEE  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       array.asm:575
0xACF0  0x85 0x12       STA 0x12                // STA ZP.TOPH                       array.asm:576
0xACF2  0x38            SEC                     // SEC                   Success     array.asm:577
0xACF3  0x68            PLA                     // PLA                               array.asm:581
0xACF4  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       array.asm:582
0xACF6  0x68            PLA                     // PLA                               array.asm:583
0xACF7  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       array.asm:584
0xACF9  0x7A            PLY                     // PLY                               array.asm:586
0xACFA  0xFA            PLX                     // PLX                               array.asm:587
0xACFB  0x68            PLA                     // PLA                               array.asm:588
0xACFC  0x60            RTS                     // }                                 array.asm:589

// /source/projects/6502sbc/hopperbasic/objects/array.asm:597
// ####  BASICArray.GetExportPointers()  ####                                   0x0160

0xACFD  0xA0 0x00       LDY # 0                 // LDY # aiCount                     array.asm:598
0xACFF  0xB1 0x16       LDA [0x16],Y            // LDA [ZP.NEXT], Y                  array.asm:599
0xAD01  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       array.asm:600
0xAD03  0xC8            INY                     // INY                               array.asm:601
0xAD04  0xB1 0x16       LDA [0x16],Y            // LDA [ZP.NEXT], Y                  array.asm:602
0xAD06  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       array.asm:603
0xAD08  0xC8            INY                     // INY                  taking advantage that aiType follows aiCount
0xAD09  0xB1 0x16       LDA [0x16],Y            // LDA [ZP.NEXT], Y                  array.asm:605
0xAD0B  0x85 0x10       STA 0x10                // STA ZP.ACCT                       array.asm:606
0xAD0D  0x20 0xC0 0xAA  JSR 0xAAC0              // elementsToBytes();       Convert count to bytes -> ZP.ACC
0xAD10  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       array.asm:611
0xAD12  0x85 0x8E       STA 0x8E                // STA File.TransferLengthL          array.asm:612
0xAD14  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       array.asm:613
0xAD16  0x85 0x8F       STA 0x8F                // STA File.TransferLengthH          array.asm:614
0xAD18  0x18            CLC                     // CLC                               array.asm:617
0xAD19  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      array.asm:618
0xAD1B  0x69 0x05       ADC # 0x05              // ADC # aiElements     #3           array.asm:619
0xAD1D  0x85 0x8C       STA 0x8C                // STA File.SectorSourceL            array.asm:620
0xAD1F  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      array.asm:621
0xAD21  0x69 0x00       ADC # 0                 // ADC # 0                           array.asm:622
0xAD23  0x85 0x8D       STA 0x8D                // STA File.SectorSourceH            array.asm:623
0xAD25  0x60            RTS                     // }                                 array.asm:624

// /source/runtime/6502/i2c.asm:17
// ####  I2C.Scan()  ####                                                       0x0161

0xAD26  0x0A            ASL A                   // ASL                   always 'write'
0xAD27  0x85 0x88       STA 0x88                // STA ZP.OutB           Save addr + r/w bit
0xAD29  0x20 0x32 0xAD  JSR 0xAD32              // Start();                          i2c.asm:21
0xAD2C  0x20 0x3F 0xAD  JSR 0xAD3F              // Stop();                           i2c.asm:22
0xAD2F  0xA5 0x8A       LDA 0x8A                // LDA ZP.LastAck    LastAck in A, Z set if found
0xAD31  0x60            RTS                     // }                                 i2c.asm:24

// /source/runtime/6502/i2c.asm:51
// ####  I2C.Start()  ####                                                      0x0165

0xAD32  0x07 0xF2       RMB0 0xF2               // RMB0 ZP.DDRB        Start with SCL as input HIGH - that way we can inc/dec from here
0xAD34  0x97 0xF2       SMB1 0xF2               // SMB1 ZP.DDRB        Ensure SDA is output low before SCL is LOW
0xAD36  0x17 0xF0       RMB1 0xF0               // RMB1 ZP.PORTB                     i2c.asm:55
0xAD38  0x07 0xF0       RMB0 0xF0               // RMB0 ZP.PORTB       Ensure SCL is low when it turns to output
0xAD3A  0x87 0xF2       SMB0 0xF2               // SMB0 ZP.DDRB        Set to output by incrementing the direction register == OUT, LOW
0xAD3C  0x4C 0x92 0xAD  JMP 0xAD92              // ByteOut();                        i2c.asm:75

// /source/runtime/6502/i2c.asm:79
// ####  I2C.Stop()  ####                                                       0x0166

0xAD3F  0x97 0xF2       SMB1 0xF2               // SMB1 ZP.DDRB    SDA low           i2c.asm:81
0xAD41  0x07 0xF2       RMB0 0xF2               // RMB0 ZP.DDRB    SCL high          i2c.asm:82
0xAD43  0x17 0xF2       RMB1 0xF2               // RMB1 ZP.DDRB    SDA high after SCL == Stop condition
0xAD45  0x60            RTS                     // }                                 i2c.asm:95

// /source/runtime/6502/i2c.asm:118
// ####  I2C.RequestFromTOPA()  ####                                            0x0169

0xAD46  0x0A            ASL A                   // ASL                   always 'read'
0xAD47  0x09 0x01       ORA # 1                 // ORA # 0b00000001                  i2c.asm:120
0xAD49  0x85 0x88       STA 0x88                // STA ZP.OutB           Save addr + r/w bit
0xAD4B  0x20 0x32 0xAD  JSR 0xAD32              // Start();                          i2c.asm:122
0xAD4E  0x64 0x77       STZ 0x77                // STZ ZP.I2CInWritePtr              i2c.asm:128
0xAD50  0x64 0x78       STZ 0x78                // STZ ZP.I2CInReadPtr               i2c.asm:129
0xAD52  0xA6 0x11       LDX 0x11                // LDX ZP.TOPL                       i2c.asm:130
0xAD54  0xD0 0x03       BNE 0xAD59 (+3)         // if (NZ)    bytes to read != 0?    i2c.asm:131
0xAD56  0x4C 0x3F 0xAD  JMP 0xAD3F
0xAD59  0x64 0x11       STZ 0x11                // STZ ZP.TOPL                       i2c.asm:133
0xAD5B  0xDA            PHX                     // PHX                               i2c.asm:136
0xAD5C  0x17 0xF2       RMB1 0xF2               // RMB1 ZP.DDRB      SDA input       i2c.asm:138
0xAD5E  0x18            CLC                     // CLC                               i2c.asm:140
0xAD5F  0x64 0x89       STZ 0x89                // STZ ZP.InB                        i2c.asm:141
0xAD61  0xA2 0x08       LDX # 0x08              // LDX # 8                           i2c.asm:142
0xAD63  0x07 0xF2       RMB0 0xF2               // RMB0 ZP.DDRB      SCL high        i2c.asm:145
0xAD65  0x1F 0xF0 0x01  BBR1 0xF0, 0xAD69 (+1)  // if (BBS1, ZP.PORTB)               i2c.asm:148
0xAD68  0x38            SEC                     // SEC          1 -> C               i2c.asm:150
0xAD69  0x26 0x89       ROL 0x89                // ROL  ZP.InB      Shift bit into the input byte
0xAD6B  0x87 0xF2       SMB0 0xF2               // SMB0 ZP.DDRB     SCL low again for the next bit
0xAD6D  0xCA            DEX                     // DEX                               i2c.asm:154
0xAD6E  0xD0 0xF3       BNE 0xAD63 (-13)        // if (Z) { break; }                 i2c.asm:155
0xAD70  0xA5 0x89       LDA 0x89                // LDA ZP.InB                        i2c.asm:158
0xAD72  0xA6 0x77       LDX 0x77                // LDX ZP.I2CInWritePtr       push it into serial input buffer
0xAD74  0x9D 0x00 0x0A  STA 0x0A00,X            // STA Address.I2CInBuffer, X        i2c.asm:161
0xAD77  0xE6 0x77       INC 0x77                // INC ZP.I2CInWritePtr              i2c.asm:162
0xAD79  0xE6 0x11       INC 0x11                // INC ZP.TOPL    count bytes actually read
0xAD7B  0xFA            PLX                     // PLX                               i2c.asm:166
0xAD7C  0xCA            DEX                     // DEX                               i2c.asm:167
0xAD7D  0x17 0xF0       RMB1 0xF0               // RMB1 ZP.PORTB    make sure SDA is indeed low
0xAD7F  0xD0 0x09       BNE 0xAD8A (+9)         // if (Z)                            i2c.asm:170
0xAD81  0x17 0xF2       RMB1 0xF2               // RMB1 ZP.DDRB    SDA high          i2c.asm:173
0xAD83  0x07 0xF2       RMB0 0xF2               // RMB0 ZP.DDRB    SCL high          i2c.asm:174
0xAD85  0x87 0xF2       SMB0 0xF2               // SMB0 ZP.DDRB    SCL low           i2c.asm:175
0xAD87  0x4C 0x3F 0xAD  JMP 0xAD3F              // break;                            i2c.asm:176
0xAD8A  0x97 0xF2       SMB1 0xF2               // SMB1 ZP.DDRB    SDA low           i2c.asm:179
0xAD8C  0x07 0xF2       RMB0 0xF2               // RMB0 ZP.DDRB    SCL high          i2c.asm:180
0xAD8E  0x87 0xF2       SMB0 0xF2               // SMB0 ZP.DDRB    SCL low           i2c.asm:181
0xAD90  0x80 0xC9       BRA 0xAD5B (-55)        // }    loop                         i2c.asm:182

// /source/runtime/6502/i2c.asm:300
// ####  I2C.ByteOut()  ####                                                    0x016B

0xAD92  0x48            PHA                     // PHA                               i2c.asm:301
0xAD93  0xDA            PHX                     // PHX                               i2c.asm:303
0xAD94  0x17 0xF0       RMB1 0xF0               // RMB1 ZP.PORTB    in case this is a data byte we set SDA low
0xAD96  0xA2 0x08       LDX # 0x08              // LDX # 8                           i2c.asm:306
0xAD98  0x87 0xF2       SMB0 0xF2               // SMB0 ZP.DDRB      SCL out, clock low
0xAD9A  0x06 0x88       ASL 0x88                // ASL  ZP.OutB      MSB to carry    i2c.asm:310
0xAD9C  0x90 0x04       BCC 0xADA2 (+4)         // if (C)                            i2c.asm:311
0xAD9E  0x17 0xF2       RMB1 0xF2               // RMB1 ZP.DDRB     set SDA low      i2c.asm:313
0xADA0  0x80 0x02       BRA 0xADA4 (+2)         // }                                 i2c.asm:314
0xADA2  0x97 0xF2       SMB1 0xF2               // SMB1 ZP.DDRB     set SDA high     i2c.asm:317
0xADA4  0x07 0xF2       RMB0 0xF2               // RMB0 ZP.DDRB    Clock high        i2c.asm:319
0xADA6  0xCA            DEX                     // DEX                               i2c.asm:320
0xADA7  0xD0 0xEF       BNE 0xAD98 (-17)        // if (Z) { break; }                 i2c.asm:321
0xADA9  0x87 0xF2       SMB0 0xF2               // SMB0 ZP.DDRB     Clock low        i2c.asm:324
0xADAB  0x17 0xF2       RMB1 0xF2               // RMB1 ZP.DDRB     Set SDA to INPUT (HIGH)
0xADAD  0x07 0xF2       RMB0 0xF2               // RMB0 ZP.DDRB     Clock high       i2c.asm:326
0xADAF  0x9F 0xF0 0x04  BBS1 0xF0, 0xADB6 (+4)  // if (BBR1, ZP.PORTB)               i2c.asm:328
0xADB2  0x64 0x8A       STZ 0x8A                // STZ ZP.LastAck    ACK             i2c.asm:330
0xADB4  0x80 0x02       BRA 0xADB8 (+2)         // }                                 i2c.asm:331
0xADB6  0x87 0x8A       SMB0 0x8A               // SMB0 ZP.LastAck    NACK           i2c.asm:334
0xADB8  0x87 0xF2       SMB0 0xF2               // SMB0 ZP.DDRB       clock low      i2c.asm:336
0xADBA  0xFA            PLX                     // PLX                               i2c.asm:338
0xADBB  0x68            PLA                     // PLA                               i2c.asm:387
0xADBC  0x60            RTS                     // }                                 i2c.asm:388

// /source/runtime/6502/devices/serialeeprom.asm:35
// ####  SerialEEPROM.copyProgramPage()  ####                                   0x016C

0xADBD  0x5A            PHY                     // PHY                               serialeeprom.asm:37
0xADBE  0xA9 0xA0       LDA # 0xA0              // LDA # (I2C.SerialEEPROMAddress << 1)
0xADC0  0x85 0x88       STA 0x88                // STA ZP.OutB                       serialeeprom.asm:43
0xADC2  0x20 0x32 0xAD  JSR 0xAD32              // I2C.Start();                      serialeeprom.asm:44
0xADC5  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       serialeeprom.asm:45
0xADC7  0x85 0x88       STA 0x88                // STA ZP.OutB                       serialeeprom.asm:46
0xADC9  0x20 0x92 0xAD  JSR 0xAD92              // I2C.ByteOut();    EEPROM address MSB (0)
0xADCC  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       serialeeprom.asm:48
0xADCE  0x85 0x88       STA 0x88                // STA ZP.OutB                       serialeeprom.asm:49
0xADD0  0x20 0x92 0xAD  JSR 0xAD92              // I2C.ByteOut();    EEPROM address LSB (0)
0xADD3  0x20 0x3F 0xAD  JSR 0xAD3F              // I2C.Stop();                       serialeeprom.asm:52
0xADD6  0xA9 0x05       LDA # 0x05              // LDA # 5                           serialeeprom.asm:55
0xADD8  0x85 0x11       STA 0x11                // STA ZP.TOPL                       serialeeprom.asm:56
0xADDA  0xA9 0x00       LDA # 0                 // LDA # 0                           serialeeprom.asm:57
0xADDC  0x85 0x12       STA 0x12                // STA ZP.TOPH                       serialeeprom.asm:58
0xADDE  0x20 0x0C 0x95  JSR 0x950C              // Time.DelayTOP();                  serialeeprom.asm:59
0xADE1  0xA9 0x80       LDA # 0x80              // LDA # serialPageSize              serialeeprom.asm:62
0xADE3  0x85 0x11       STA 0x11                // STA ZP.TOPL                       serialeeprom.asm:63
0xADE5  0xA9 0x50       LDA # 0x50              // LDA # I2C.SerialEEPROMAddress     serialeeprom.asm:64
0xADE7  0x20 0x46 0xAD  JSR 0xAD46              // RequestFromTOPA();    A has I2C adddress, TOPL has number of bytes to return, TOPL returns number of bytes read
0xADEA  0xA2 0x00       LDX # 0                 // LDX # 0                           serialeeprom.asm:68
0xADEC  0xBD 0x00 0x0A  LDA 0x0A00,X            // LDA Address.I2CInBuffer, X        serialeeprom.asm:71
0xADEF  0x92 0x1B       STA [0x1B]              // STA [IDX]                         serialeeprom.asm:73
0xADF1  0x20 0x50 0x93  JSR 0x9350              // IncIDY();                         serialeeprom.asm:78
0xADF4  0x20 0x48 0x93  JSR 0x9348              // IncIDX();                         serialeeprom.asm:79
0xADF7  0xE8            INX                     // INX                               serialeeprom.asm:80
0xADF8  0xE0 0x80       CPX # 0x80              // CPX # serialPageSize              serialeeprom.asm:81
0xADFA  0xD0 0xF0       BNE 0xADEC (-16)        // if (Z) { break; }                 serialeeprom.asm:82
0xADFC  0x7A            PLY                     // PLY                               serialeeprom.asm:85
0xADFD  0x60            RTS                     // }                                 serialeeprom.asm:89

// /source/runtime/6502/devices/serialeeprom.asm:141
// ####  SerialEEPROM.copyPageToEEPROM()  ####                                  0x016D

0xADFE  0x48            PHA                     // PHA                               serialeeprom.asm:142
0xADFF  0xDA            PHX                     // PHX                               serialeeprom.asm:144
0xAE00  0x5A            PHY                     // PHY                               serialeeprom.asm:145
0xAE01  0xA9 0x05       LDA # 0x05              // LDA # 5                           serialeeprom.asm:151
0xAE03  0x85 0x11       STA 0x11                // STA ZP.TOPL                       serialeeprom.asm:152
0xAE05  0x64 0x12       STZ 0x12                // STZ ZP.TOPH                       serialeeprom.asm:154
0xAE07  0xA9 0xA0       LDA # 0xA0              // LDA # (I2C.SerialEEPROMAddress << 1)
0xAE09  0x85 0x88       STA 0x88                // STA ZP.OutB                       serialeeprom.asm:162
0xAE0B  0x20 0x32 0xAD  JSR 0xAD32              // I2C.Start();                      serialeeprom.asm:163
0xAE0E  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       serialeeprom.asm:164
0xAE10  0x85 0x88       STA 0x88                // STA ZP.OutB                       serialeeprom.asm:165
0xAE12  0x20 0x92 0xAD  JSR 0xAD92              // I2C.ByteOut();    EEPROM address MSB
0xAE15  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       serialeeprom.asm:167
0xAE17  0x85 0x88       STA 0x88                // STA ZP.OutB                       serialeeprom.asm:168
0xAE19  0x20 0x92 0xAD  JSR 0xAD92              // I2C.ByteOut();    EEPROM address LSB
0xAE1C  0xA2 0x80       LDX # 0x80              // LDX # serialPageSize              serialeeprom.asm:171
0xAE1E  0xB2 0x1B       LDA [0x1B]              // LDA [IDX]                         serialeeprom.asm:175
0xAE20  0x85 0x88       STA 0x88                // STA ZP.OutB                       serialeeprom.asm:180
0xAE22  0x20 0x92 0xAD  JSR 0xAD92              // I2C.ByteOut();    zeros ZP.OutB   serialeeprom.asm:181
0xAE25  0x20 0x48 0x93  JSR 0x9348              // IncIDX();                         serialeeprom.asm:182
0xAE28  0x20 0x50 0x93  JSR 0x9350              // IncIDY();                         serialeeprom.asm:183
0xAE2B  0xCA            DEX                     // DEX                               serialeeprom.asm:184
0xAE2C  0xD0 0xF0       BNE 0xAE1E (-16)        // if (Z) { break; }                 serialeeprom.asm:185
0xAE2E  0x20 0x3F 0xAD  JSR 0xAD3F              // I2C.Stop();                       serialeeprom.asm:187
0xAE31  0x20 0x0C 0x95  JSR 0x950C              // Time.DelayTOP();                  serialeeprom.asm:190
0xAE34  0x7A            PLY                     // PLY                               serialeeprom.asm:193
0xAE35  0xFA            PLX                     // PLX                               serialeeprom.asm:194
0xAE36  0x68            PLA                     // PLA                               serialeeprom.asm:199
0xAE37  0x60            RTS                     // }                                 serialeeprom.asm:200

// /source/projects/6502sbc/hopperbasic/files/eeprom.asm:9
// ####  EEPROM.Initialize()  ####                                              0x016E

0xAE38  0x64 0x8B       STZ 0x8B                // STZ ZP.PLUGNPLAY                  eeprom.asm:10
0xAE3A  0xA9 0x0A       LDA # 0x0A              // LDA # (I2CInBuffer >> 8)          eeprom.asm:13
0xAE3C  0x20 0x2C 0x93  JSR 0x932C              // Memory.ClearPage();               eeprom.asm:14
0xAE3F  0x64 0x8B       STZ 0x8B                // STZ ZP.PLUGNPLAY                  eeprom.asm:16
0xAE41  0xA9 0x50       LDA # 0x50              // LDA # I2C.SerialEEPROMAddress     eeprom.asm:17
0xAE43  0x20 0x26 0xAD  JSR 0xAD26              // I2C.Scan();                       eeprom.asm:18
0xAE46  0xD0 0x04       BNE 0xAE4C (+4)         // if (Z)                            eeprom.asm:19
0xAE48  0x97 0x8B       SMB1 0x8B               // SMB1 ZP.PLUGNPLAY                 eeprom.asm:21
0xAE4A  0x38            SEC                     // SEC                               eeprom.asm:22
0xAE4B  0x60            RTS                     // }                                 eeprom.asm:23
0xAE4C  0x18            CLC                     // CLC                               eeprom.asm:26
0xAE4D  0x60            RTS                     // }                                 eeprom.asm:28

// /source/projects/6502sbc/hopperbasic/files/eeprom.asm:35
// ####  EEPROM.Detect()  ####                                                  0x016F

0xAE4E  0x1F 0x8B 0x02  BBR1 0x8B, 0xAE53 (+2)  // if (BBS1, ZP.PLUGNPLAY)    Test bit 1
0xAE51  0x38            SEC                     // SEC     Set C flag (C = EEPROM present)
0xAE52  0x60            RTS                     // return;                           eeprom.asm:39
0xAE53  0x18            CLC                     // CLC         Clear C flag (NC = no EEPROM)
0xAE54  0x60            RTS                     // }                                 eeprom.asm:42

// /source/projects/6502sbc/hopperbasic/files/eeprom.asm:47
// ####  EEPROM.GetSize()  ####                                                 0x0170

0xAE55  0x9F 0x8B 0x04  BBS1 0x8B, 0xAE5C (+4)  // if (BBR1, ZP.PLUGNPLAY)    Test bit 1 - if clear, no EEPROM
0xAE58  0xA9 0x00       LDA # 0                 // LDA #0                            eeprom.asm:50
0xAE5A  0x18            CLC                     // CLC    No EEPROM detected         eeprom.asm:51
0xAE5B  0x60            RTS                     // return;                           eeprom.asm:52
0xAE5C  0xA9 0x40       LDA # 0x40              // LDA #64        24AA512 = 64K (default for 128-byte pages)
0xAE5E  0x38            SEC                     // SEC                               eeprom.asm:68
0xAE5F  0x60            RTS                     // }                                 eeprom.asm:69

// /source/projects/6502sbc/hopperbasic/files/eeprom.asm:83
// ####  EEPROM.WritePage()  ####                                               0x0171

0xAE60  0x48            PHA                     // PHA                               eeprom.asm:84
0xAE61  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       eeprom.asm:85
0xAE63  0x48            PHA                     // PHA                               eeprom.asm:86
0xAE64  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       eeprom.asm:87
0xAE66  0x48            PHA                     // PHA                               eeprom.asm:88
0xAE67  0x64 0x1D       STZ 0x1D                // STZ ZP.IDYL                       eeprom.asm:91
0xAE69  0x64 0x1B       STZ 0x1B                // STZ ZP.IDXL                       eeprom.asm:92
0xAE6B  0x20 0xFE 0xAD  JSR 0xADFE              // SerialEEPROM.copyPageToEEPROM();  eeprom.asm:95
0xAE6E  0x20 0xFE 0xAD  JSR 0xADFE              // SerialEEPROM.copyPageToEEPROM();  eeprom.asm:96
0xAE71  0xA9 0x0A       LDA # 0x0A              // LDA #10             10 milliseconds delay
0xAE73  0x85 0x11       STA 0x11                // STA ZP.TOPL                       eeprom.asm:106
0xAE75  0xA9 0x00       LDA # 0                 // LDA #0                            eeprom.asm:107
0xAE77  0x85 0x12       STA 0x12                // STA ZP.TOPH                       eeprom.asm:108
0xAE79  0x20 0x0C 0x95  JSR 0x950C              // Time.DelayTOP();    Proper timer-based delay
0xAE7C  0x68            PLA                     // PLA                               eeprom.asm:111
0xAE7D  0x85 0x12       STA 0x12                // STA ZP.TOPH                       eeprom.asm:112
0xAE7F  0x68            PLA                     // PLA                               eeprom.asm:113
0xAE80  0x85 0x11       STA 0x11                // STA ZP.TOPL                       eeprom.asm:114
0xAE82  0x68            PLA                     // PLA                               eeprom.asm:115
0xAE83  0x60            RTS                     // }                                 eeprom.asm:116

// /source/projects/6502sbc/hopperbasic/files/eeprom.asm:129
// ####  EEPROM.ReadPage()  ####                                                0x0172

0xAE84  0x64 0x1D       STZ 0x1D                // STZ ZP.IDYL                       eeprom.asm:134
0xAE86  0x64 0x1B       STZ 0x1B                // STZ ZP.IDXL                       eeprom.asm:135
0xAE88  0x20 0xBD 0xAD  JSR 0xADBD              // SerialEEPROM.copyProgramPage();   eeprom.asm:138
0xAE8B  0x4C 0xBD 0xAD  JMP 0xADBD              // SerialEEPROM.copyProgramPage();   eeprom.asm:139

// /source/projects/6502sbc/hopperbasic/files/file.asm:253
// ####  File.ValidateFilename()  ####                                          0x0173

0xAE8E  0x5A            PHY                     // PHY                               file.asm:257
0xAE8F  0xA0 0x00       LDY # 0                 // LDY #0                            file.asm:261
0xAE91  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   file.asm:264
0xAE93  0xD0 0x06       BNE 0xAE9B (+6)         // if (Z)                            file.asm:265
0xAE95  0x20 0xAC 0x8B  JSR 0x8BAC              // Error.FilenameExpected();         file.asm:267
0xAE98  0x18            CLC                     // CLC     Empty filename invalid    file.asm:268
0xAE99  0x80 0x20       BRA 0xAEBB (+32)        // break;                            file.asm:269
0xAE9B  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   file.asm:275
0xAE9D  0xF0 0x19       BEQ 0xAEB8 (+25)        // if (Z) { break; }     End of string
0xAE9F  0x20 0x40 0x97  JSR 0x9740              // Char.IsAlphaNumeric();            file.asm:279
0xAEA2  0xB0 0x06       BCS 0xAEAA (+6)         // if (NC)                           file.asm:280
0xAEA4  0x20 0xB6 0x8B  JSR 0x8BB6              // Error.IllegalFilename();          file.asm:282
0xAEA7  0x18            CLC                     // CLC     Invalid character found   file.asm:283
0xAEA8  0x80 0x0E       BRA 0xAEB8 (+14)        // break;                            file.asm:284
0xAEAA  0xC8            INY                     // INY                               file.asm:287
0xAEAB  0xC0 0x0E       CPY # 0x0E              // CPY #14     Max 13 characters + null terminator
0xAEAD  0xD0 0x06       BNE 0xAEB5 (+6)         // if (Z)                            file.asm:289
0xAEAF  0x20 0xB1 0x8B  JSR 0x8BB1              // Error.FilenameTooLong();          file.asm:291
0xAEB2  0x18            CLC                     // CLC     Filename too long         file.asm:292
0xAEB3  0x80 0x03       BRA 0xAEB8 (+3)         // break;                            file.asm:293
0xAEB5  0x38            SEC                     // SEC                               file.asm:295
0xAEB6  0x80 0xE3       BRA 0xAE9B (-29)        // }                                 file.asm:296
0xAEB8  0x90 0x01       BCC 0xAEBB (+1)         // if (NC) { break; }                file.asm:297
0xAEBA  0x38            SEC                     // SEC                               file.asm:300
0xAEBB  0x7A            PLY                     // PLY                               file.asm:304
0xAEBC  0x60            RTS                     // }                                 file.asm:308

// /source/projects/6502sbc/hopperbasic/files/file.asm:311
// ####  File.initializeFATandDirectory()  ####                                 0x0174

0xAEBD  0x20 0xCC 0xB3  JSR 0xB3CC              // loadFAT();                        file.asm:313
0xAEC0  0xA9 0x01       LDA # 1                 // LDA #1       Default to sector 1  file.asm:314
0xAEC2  0x4C 0xE2 0xB3  JMP 0xB3E2              // loadDirectorySector();            file.asm:315

// /source/projects/6502sbc/hopperbasic/files/file.asm:322
// ####  File.fileEntryToDirectoryEntry()  ####                                 0x0175

0xAEC5  0x48            PHA                     // PHA                               file.asm:323
0xAEC6  0xA5 0x92       LDA 0x92                // LDA CurrentFileEntry              file.asm:324
0xAEC8  0x29 0x0F       AND # 0x0F              // AND #0x0F                       Convert global to local (0-15)
0xAECA  0x0A            ASL A                   // ASL A ASL A ASL A ASL A         * 16
0xAECB  0x0A            ASL A
0xAECC  0x0A            ASL A
0xAECD  0x0A            ASL A
0xAECE  0xA8            TAY                     // TAY                             Y = directory entry offset
0xAECF  0x68            PLA                     // PLA                               file.asm:328
0xAED0  0x60            RTS                     // }                                 file.asm:329

// /source/projects/6502sbc/hopperbasic/files/file.asm:335
// ####  File.entryToOffset()  ####                                             0x0176

0xAED1  0x98            TYA                     // TYA                               file.asm:336
0xAED2  0x0A            ASL A                   // ASL A ASL A ASL A ASL A    Y * 16 file.asm:337
0xAED3  0x0A            ASL A
0xAED4  0x0A            ASL A
0xAED5  0x0A            ASL A
0xAED6  0xAA            TAX                     // TAX                        X = byte offset in DirectoryBuffer
0xAED7  0x60            RTS                     // }                                 file.asm:339

// /source/projects/6502sbc/hopperbasic/files/file.asm:347
// ####  File.GetAvailable()  ####                                              0x0177

0xAED8  0xDA            PHX                     // PHX                               file.asm:351
0xAED9  0x5A            PHY                     // PHY                               file.asm:352
0xAEDA  0x20 0xBD 0xAE  JSR 0xAEBD              // initializeFATandDirectory();      file.asm:356
0xAEDD  0xA0 0x02       LDY # 0x02              // LDY #2                      Start from sector 2 (skip FAT and directory)
0xAEDF  0x64 0x12       STZ 0x12                // STZ ZP.TOPH         Free sector count
0xAEE1  0xB9 0x00 0x18  LDA 0x1800,Y            // LDA FATBuffer, Y                  file.asm:364
0xAEE4  0xD0 0x02       BNE 0xAEE8 (+2)         // if (Z)                            file.asm:365
0xAEE6  0xE6 0x12       INC 0x12                // INC ZP.TOPH     Count free sectors
0xAEE8  0xC8            INY                     // INY                               file.asm:370
0xAEE9  0xD0 0xF6       BNE 0xAEE1 (-10)        // if (Z) { break; }       Y wrapped to 0 - all sectors checked
0xAEEB  0x64 0x11       STZ 0x11                // STZ ZP.TOPL                       file.asm:376
0xAEED  0x64 0x15       STZ 0x15                // STZ ZP.TOPT                       file.asm:377
0xAEEF  0x38            SEC                     // SEC                         Success
0xAEF0  0x7A            PLY                     // PLY                               file.asm:384
0xAEF1  0xFA            PLX                     // PLX                               file.asm:385
0xAEF2  0x60            RTS                     // }                                 file.asm:389

// /source/projects/6502sbc/hopperbasic/files/file.asm:395
// ####  File.Format()  ####                                                    0x0178

0xAEF3  0x20 0xC2 0xB3  JSR 0xB3C2              // clearFATBuffer();                 file.asm:402
0xAEF6  0x20 0xC7 0xB3  JSR 0xB3C7              // clearDirectoryBuffer();           file.asm:403
0xAEF9  0x20 0xBD 0xB3  JSR 0xB3BD              // clearFileDataBuffer();            file.asm:404
0xAEFC  0xA9 0x01       LDA # 1                 // LDA #1     Reserved marker        file.asm:407
0xAEFE  0x8D 0x00 0x18  STA 0x1800              // STA FATBuffer + 0      Sector 0 (FAT)
0xAF01  0x8D 0x01 0x18  STA 0x1801              // STA FATBuffer + 1      Sector 1 (Directory)
0xAF04  0x20 0xD8 0xB3  JSR 0xB3D8              // writeFAT();                       file.asm:412
0xAF07  0x20 0xC7 0xB3  JSR 0xB3C7              // clearDirectoryBuffer();           file.asm:415
0xAF0A  0xA9 0x01       LDA # 1                 // LDA #1                              Default to sector 1
0xAF0C  0x20 0xEE 0xB3  JSR 0xB3EE              // writeDirectorySector();           file.asm:417
0xAF0F  0x38            SEC                     // SEC                               file.asm:420
0xAF10  0x60            RTS                     // break;                            file.asm:421

// /source/projects/6502sbc/hopperbasic/files/file.asm:434
// ####  File.StartSave()  ####                                                 0x0179

0xAF11  0x20 0x8E 0xAE  JSR 0xAE8E              // File.ValidateFilename();          file.asm:441
0xAF14  0x90 0x26       BCC 0xAF3C (+38)        // if (NC) { BIT ZP.EmulatorPCL break; }
0xAF16  0x20 0xBD 0xAE  JSR 0xAEBD              // initializeFATandDirectory();      file.asm:444
0xAF19  0x20 0x1F 0xB4  JSR 0xB41F              // findFreeDirectoryEntry();         file.asm:447
0xAF1C  0xB0 0x05       BCS 0xAF23 (+5)         // if (NC)                           file.asm:448
0xAF1E  0xA9 0x32       LDA # 0x32              // Error.DirectoryFull(); BIT ZP.EmulatorPCL
0xAF20  0x4C 0x5F 0x8B  JMP 0x8B5F
0xAF23  0x20 0x01 0xB3  JSR 0xB301              // writeFilenameToDirectory();       file.asm:456
0xAF26  0x20 0x61 0xB3  JSR 0xB361              // allocateFirstFreeSector();    -> Y
0xAF29  0xB0 0x03       BCS 0xAF2E (+3)         // if (NC)                           file.asm:460
0xAF2B  0x4C 0xBB 0x8B  JMP 0x8BBB              // Error.EEPROMFull(); BIT ZP.EmulatorPCL
0xAF2E  0x84 0x91       STY 0x91                // STY FileStartSector               file.asm:465
0xAF30  0x84 0x90       STY 0x90                // STY CurrentFileSector             file.asm:466
0xAF32  0x20 0x2F 0xB3  JSR 0xB32F              // updateDirectoryStartSector();     file.asm:469
0xAF35  0x20 0xB2 0xB3  JSR 0xB3B2              // initializeSaveState();            file.asm:472
0xAF38  0x20 0xBD 0xB3  JSR 0xB3BD              // clearFileDataBuffer();            file.asm:475
0xAF3B  0x38            SEC                     // SEC                               file.asm:478
0xAF3C  0x60            RTS                     // }                                 file.asm:484

// /source/projects/6502sbc/hopperbasic/files/file.asm:493
// ####  File.AppendStream()  ####                                              0x017A

0xAF3D  0xDA            PHX                     // PHX                               file.asm:497
0xAF3E  0x5A            PHY                     // PHY                               file.asm:498
0xAF3F  0xA5 0x8E       LDA 0x8E                // LDA TransferLengthL               file.asm:503
0xAF41  0x85 0x96       STA 0x96                // STA BytesRemainingL               file.asm:504
0xAF43  0xA5 0x8F       LDA 0x8F                // LDA TransferLengthH               file.asm:505
0xAF45  0x85 0x97       STA 0x97                // STA BytesRemainingH               file.asm:506
0xAF47  0xA5 0x96       LDA 0x96                // LDA BytesRemainingL               file.asm:511
0xAF49  0x05 0x97       ORA 0x97                // ORA BytesRemainingH               file.asm:512
0xAF4B  0xD0 0x03       BNE 0xAF50 (+3)         // if (Z)                            file.asm:513
0xAF4D  0x38            SEC                     // SEC break;    Set C - success     file.asm:515
0xAF4E  0x80 0x33       BRA 0xAF83 (+51)
0xAF50  0xA0 0x00       LDY # 0                 // LDY #0                            file.asm:519
0xAF52  0xB1 0x8C       LDA [0x8C],Y            // LDA [SectorSource], Y             file.asm:520
0xAF54  0xA4 0x98       LDY 0x98                // LDY SectorPositionL               file.asm:521
0xAF56  0x99 0x00 0x1A  STA 0x1A00,Y            // STA FileDataBuffer, Y             file.asm:522
0xAF59  0xE6 0x8C       INC 0x8C                // INC SectorSourceL                 file.asm:525
0xAF5B  0xD0 0x02       BNE 0xAF5F (+2)         // if (Z) { INC SectorSourceH }      file.asm:526
0xAF5D  0xE6 0x8D       INC 0x8D
0xAF5F  0xE6 0x98       INC 0x98                // INC SectorPositionL               file.asm:529
0xAF61  0xD0 0x02       BNE 0xAF65 (+2)         // if (Z) { INC SectorPositionH }    file.asm:530
0xAF63  0xE6 0x99       INC 0x99
0xAF65  0xA5 0x99       LDA 0x99                // LDA SectorPositionH               file.asm:533
0xAF67  0xF0 0x0A       BEQ 0xAF73 (+10)        // if (NZ)    High byte non-zero means >= 256
0xAF69  0x20 0x3A 0xB3  JSR 0xB33A              // flushAndAllocateNext();           file.asm:536
0xAF6C  0xB0 0x05       BCS 0xAF73 (+5)         // if (NC) { Error.EEPROMFull(); BIT ZP.EmulatorPCL break; }
0xAF6E  0x20 0xBB 0x8B  JSR 0x8BBB
0xAF71  0x80 0x10       BRA 0xAF83 (+16)
0xAF73  0xA5 0x96       LDA 0x96                // LDA BytesRemainingL               file.asm:541
0xAF75  0xD0 0x02       BNE 0xAF79 (+2)         // if (Z)                            file.asm:542
0xAF77  0xC6 0x97       DEC 0x97                // DEC BytesRemainingH               file.asm:544
0xAF79  0xC6 0x96       DEC 0x96                // DEC BytesRemainingL               file.asm:546
0xAF7B  0xE6 0x93       INC 0x93                // INC FilePositionL                 file.asm:549
0xAF7D  0xD0 0xC8       BNE 0xAF47 (-56)        // if (Z) { INC FilePositionH }      file.asm:550
0xAF7F  0xE6 0x94       INC 0x94
0xAF81  0x80 0xC4       BRA 0xAF47 (-60)        // }                                 file.asm:551
0xAF83  0x7A            PLY                     // PLY                               file.asm:555
0xAF84  0xFA            PLX                     // PLX                               file.asm:556
0xAF85  0x60            RTS                     // }                                 file.asm:560

// /source/projects/6502sbc/hopperbasic/files/file.asm:568
// ####  File.EndSave()  ####                                                   0x017B

0xAF86  0xDA            PHX                     // PHX                               file.asm:572
0xAF87  0x5A            PHY                     // PHY                               file.asm:573
0xAF88  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       file.asm:575
0xAF8A  0xA5 0x98       LDA 0x98                // LDA SectorPositionL               file.asm:580
0xAF8C  0x05 0x99       ORA 0x99                // ORA SectorPositionH               file.asm:581
0xAF8E  0xF0 0x05       BEQ 0xAF95 (+5)         // if (NZ)                           file.asm:582
0xAF90  0xA5 0x90       LDA 0x90                // LDA CurrentFileSector             file.asm:584
0xAF92  0x20 0x85 0xB4  JSR 0xB485              // writeSector();                    file.asm:585
0xAF95  0x20 0xC5 0xAE  JSR 0xAEC5              // fileEntryToDirectoryEntry();    -> Y
0xAF98  0xA5 0x93       LDA 0x93                // LDA FilePositionL                 file.asm:593
0xAF9A  0x99 0x00 0x19  STA 0x1900,Y            // STA DirectoryBuffer + 0, Y        file.asm:594
0xAF9D  0xA5 0x94       LDA 0x94                // LDA FilePositionH                 file.asm:595
0xAF9F  0x05 0x0F       ORA 0x0F                // ORA ZP.ACCH                       or 0x80 if executable type
0xAFA1  0x99 0x01 0x19  STA 0x1901,Y            // STA DirectoryBuffer + 1, Y        file.asm:597
0xAFA4  0x20 0xD8 0xB3  JSR 0xB3D8              // writeFAT();                       file.asm:600
0xAFA7  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:602
0xAFA9  0x20 0xEE 0xB3  JSR 0xB3EE              // writeDirectorySector();           file.asm:603
0xAFAC  0x38            SEC                     // SEC    Success                    file.asm:605
0xAFAD  0x7A            PLY                     // PLY                               file.asm:609
0xAFAE  0xFA            PLX                     // PLX                               file.asm:610
0xAFAF  0x60            RTS                     // }                                 file.asm:614

// /source/projects/6502sbc/hopperbasic/files/file.asm:621
// ####  File.Dir()  ####                                                       0x017C

0xAFB0  0xDA            PHX                     // PHX                               file.asm:625
0xAFB1  0x5A            PHY                     // PHY                               file.asm:626
0xAFB2  0x20 0xBD 0xAE  JSR 0xAEBD              // initializeFATandDirectory();      file.asm:630
0xAFB5  0x20 0x55 0xB2  JSR 0xB255              // countFilesAndBytes();    -> TransferLengthL = file count, TransferLengthH/BytesRemainingL = total bytes
0xAFB8  0xA5 0x8E       LDA 0x8E                // LDA TransferLengthL               file.asm:635
0xAFBA  0xF0 0x0A       BEQ 0xAFC6 (+10)        // if (NZ)                           file.asm:636
0xAFBC  0xA9 0x3B       LDA # 0x3B              // LDA # ErrorID.Files LDX # MessageExtras.SuffixColon Error.MessageNL();
0xAFBE  0xA2 0x04       LDX # 0x04
0xAFC0  0x20 0xE3 0x8A  JSR 0x8AE3
0xAFC3  0x20 0x62 0xB2  JSR 0xB262              // printAllFileEntries();            file.asm:642
0xAFC6  0x20 0xDB 0xB2  JSR 0xB2DB              // printDirectorySummary();          file.asm:645
0xAFC9  0x38            SEC                     // SEC                               file.asm:655
0xAFCA  0x7A            PLY                     // PLY                               file.asm:659
0xAFCB  0xFA            PLX                     // PLX                               file.asm:660
0xAFCC  0x60            RTS                     // }                                 file.asm:664

// /source/projects/6502sbc/hopperbasic/files/file.asm:667
// ####  File.findLastOccupiedEntry()  ####                                     0x017D

0xAFCD  0x64 0x9B       STZ 0x9B                // STZ LastOccupiedEntry             file.asm:668
0xAFCF  0x64 0x93       STZ 0x93                // STZ LastOccupiedSector            file.asm:669
0xAFD1  0x64 0x94       STZ 0x94                // STZ PreviousSector          Still needed for unlinking
0xAFD3  0xA9 0x04       LDA # 0x04              // LDA #DirWalkAction.FindLast       file.asm:672
0xAFD5  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       file.asm:673
0xAFD7  0x20 0x9A 0xB1  JSR 0xB19A              // walkDirectoryChain();       Walker handles ACCL increment
0xAFDA  0xA5 0x93       LDA 0x93                // LDA LastOccupiedSector            file.asm:677
0xAFDC  0xF0 0x02       BEQ 0xAFE0 (+2)         // if (NZ) { SEC } else { CLC }      file.asm:678
0xAFDE  0x38            SEC
0xAFDF  0x60            RTS
0xAFE0  0x18            CLC
0xAFE1  0x60            RTS                     // }                                 file.asm:679

// /source/projects/6502sbc/hopperbasic/files/file.asm:686
// ####  File.moveDirectoryEntry()  ####                                        0x017E

0xAFE2  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:688
0xAFE4  0x20 0xE2 0xB3  JSR 0xB3E2              // loadDirectorySector();            file.asm:689
0xAFE7  0x64 0x63       STZ 0x63                // STA ZP.FDESTINATIONADDRESSL       file.asm:691
0xAFE9  0xA9 0x19       LDA # 0x19              // LDA #(DirectoryBuffer / 256)      file.asm:692
0xAFEB  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       file.asm:693
0xAFED  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:696
0xAFEF  0xC5 0x93       CMP 0x93                // CMP LastOccupiedSector            file.asm:697
0xAFF1  0xD0 0x0A       BNE 0xAFFD (+10)        // if (Z)                            file.asm:698
0xAFF3  0xA5 0x63       LDA 0x63                // LDA ZP.FDESTINATIONADDRESSL       file.asm:701
0xAFF5  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            file.asm:702
0xAFF7  0xA5 0x64       LDA 0x64                // LDA ZP.FDESTINATIONADDRESSH       file.asm:703
0xAFF9  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            file.asm:704
0xAFFB  0x80 0x0B       BRA 0xB008 (+11)        // }                                 file.asm:705
0xAFFD  0xA5 0x93       LDA 0x93                // LDA LastOccupiedSector            file.asm:709
0xAFFF  0x20 0x7B 0xB4  JSR 0xB47B              // readSector();                     file.asm:710
0xB002  0x64 0x61       STZ 0x61                // STA ZP.FSOURCEADDRESSL            file.asm:714
0xB004  0xA9 0x1A       LDA # 0x1A              // LDA #(FileDataBuffer / 256)       file.asm:715
0xB006  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            file.asm:716
0xB008  0xA5 0x9B       LDA 0x9B                // LDA LastOccupiedEntry             file.asm:720
0xB00A  0x29 0x0F       AND # 0x0F              // AND #0x0F                         file.asm:721
0xB00C  0xA8            TAY                     // TAY                               file.asm:722
0xB00D  0x20 0xD1 0xAE  JSR 0xAED1              // entryToOffset();                Y * 16 -> X
0xB010  0x18            CLC                     // CLC                               file.asm:725
0xB011  0x8A            TXA                     // TXA                               file.asm:726
0xB012  0x65 0x61       ADC 0x61                // ADC ZP.FSOURCEADDRESSL            file.asm:727
0xB014  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            file.asm:728
0xB016  0xA5 0x62       LDA 0x62                // LDA ZP.FSOURCEADDRESSH            file.asm:729
0xB018  0x69 0x00       ADC # 0                 // ADC #0                            file.asm:730
0xB01A  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            file.asm:731
0xB01C  0x20 0xC5 0xAE  JSR 0xAEC5              // fileEntryToDirectoryEntry();    (CurrentFileEntry & 0x0F) * 16 -> Y
0xB01F  0x18            CLC                     // CLC                               file.asm:736
0xB020  0x98            TYA                     // TYA                               file.asm:737
0xB021  0x65 0x63       ADC 0x63                // ADC ZP.FDESTINATIONADDRESSL       file.asm:738
0xB023  0x85 0x63       STA 0x63                // STA ZP.FDESTINATIONADDRESSL       file.asm:739
0xB025  0xA5 0x64       LDA 0x64                // LDA ZP.FDESTINATIONADDRESSH       file.asm:740
0xB027  0x69 0x00       ADC # 0                 // ADC #0                            file.asm:741
0xB029  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       file.asm:742
0xB02B  0xA0 0x0F       LDY # 0x0F              // LDY #15                           file.asm:745
0xB02D  0xB1 0x61       LDA [0x61],Y            // LDA [ZP.FSOURCEADDRESS], Y        file.asm:748
0xB02F  0x91 0x63       STA [0x63],Y            // STA [ZP.FDESTINATIONADDRESS], Y   file.asm:749
0xB031  0xA9 0x00       LDA # 0                 // LDA #0                            file.asm:750
0xB033  0x91 0x61       STA [0x61],Y            // STA [ZP.FSOURCEADDRESS], Y        file.asm:751
0xB035  0x88            DEY                     // DEY                               file.asm:752
0xB036  0x10 0xF5       BPL 0xB02D (-11)        // if (MI) { break; }    Break when Y goes negative
0xB038  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:757
0xB03A  0xC5 0x93       CMP 0x93                // CMP LastOccupiedSector            file.asm:758
0xB03C  0xD0 0x03       BNE 0xB041 (+3)         // if (Z)                            file.asm:759
0xB03E  0x4C 0xEE 0xB3  JMP 0xB3EE              // writeDirectorySector();           file.asm:762
0xB041  0x20 0xEE 0xB3  JSR 0xB3EE              // writeDirectorySector();           file.asm:767
0xB044  0xA5 0x93       LDA 0x93                // LDA LastOccupiedSector            file.asm:769
0xB046  0x4C 0x85 0xB4  JMP 0xB485              // writeSector();                    file.asm:770

// /source/projects/6502sbc/hopperbasic/files/file.asm:780
// ####  File.Delete()  ####                                                    0x017F

0xB049  0xDA            PHX                     // PHX                               file.asm:784
0xB04A  0x5A            PHY                     // PHY                               file.asm:785
0xB04B  0xA5 0x79       LDA 0x79                // LDA ZP.STRL                       file.asm:788
0xB04D  0x48            PHA                     // PHA                               file.asm:789
0xB04E  0xA5 0x7A       LDA 0x7A                // LDA ZP.STRH                       file.asm:790
0xB050  0x48            PHA                     // PHA                               file.asm:791
0xB051  0x20 0x8E 0xAE  JSR 0xAE8E              // File.ValidateFilename();          file.asm:796
0xB054  0x90 0x5C       BCC 0xB0B2 (+92)        // if (NC) { BIT ZP.EmulatorPCL break; }
0xB056  0x20 0xBD 0xAE  JSR 0xAEBD              // initializeFATandDirectory();      file.asm:799
0xB059  0xA9 0x02       LDA # 0x02              // LDA # DirWalkAction.FindFile    all files
0xB05B  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       file.asm:803
0xB05D  0x20 0x56 0xB1  JSR 0xB156              // findFileInDirectory();            file.asm:804
0xB060  0xB0 0x05       BCS 0xB067 (+5)         // if (NC)                           file.asm:805
0xB062  0x20 0xA7 0x8B  JSR 0x8BA7              // Error.FileNotFound(); BIT ZP.EmulatorPCL
0xB065  0x80 0x4B       BRA 0xB0B2 (+75)        // break;                            file.asm:808
0xB067  0x20 0x5F 0xB1  JSR 0xB15F              // getFileStartSector();    -> FileStartSector
0xB06A  0x20 0x6A 0xB1  JSR 0xB16A              // freeFileSectorChain();            file.asm:816
0xB06D  0x20 0x8B 0xB1  JSR 0xB18B              // clearDirectoryEntry();            file.asm:819
0xB070  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:822
0xB072  0x20 0xEE 0xB3  JSR 0xB3EE              // writeDirectorySector();           file.asm:823
0xB075  0x20 0xD8 0xB3  JSR 0xB3D8              // writeFAT();                       file.asm:824
0xB078  0xA5 0x92       LDA 0x92                // LDA CurrentFileEntry              file.asm:827
0xB07A  0x48            PHA                     // PHA                               file.asm:828
0xB07B  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:829
0xB07D  0x48            PHA                     // PHA                               file.asm:830
0xB07E  0x20 0xCD 0xAF  JSR 0xAFCD              // findLastOccupiedEntry();          file.asm:832
0xB081  0x68            PLA                     // PLA                               file.asm:835
0xB082  0x85 0x9A       STA 0x9A                // STA CurrentDirectorySector        file.asm:836
0xB084  0x68            PLA                     // PLA                               file.asm:837
0xB085  0x85 0x92       STA 0x92                // STA CurrentFileEntry              file.asm:838
0xB087  0x90 0x28       BCC 0xB0B1 (+40)        // if (C)                            file.asm:840
0xB089  0xA5 0x9B       LDA 0x9B                // LDA LastOccupiedEntry             file.asm:843
0xB08B  0xC5 0x92       CMP 0x92                // CMP CurrentFileEntry              file.asm:844
0xB08D  0x90 0x23       BCC 0xB0B2 (+35)        // if (NC) { break; }     LastOccupiedEntry <= CurrentFileEntry, no move
0xB08F  0xF0 0x21       BEQ 0xB0B2 (+33)        // if (Z)  { break; }     LastOccupiedEntry == CurrentFileEntry, no move
0xB091  0x20 0xE2 0xAF  JSR 0xAFE2              // moveDirectoryEntry();             file.asm:850
0xB094  0xA5 0x93       LDA 0x93                // LDA LastOccupiedSector            file.asm:853
0xB096  0xC9 0x01       CMP # 1                 // CMP #1                      Never unlink sector 1
0xB098  0xF0 0x17       BEQ 0xB0B1 (+23)        // if (NZ)                           file.asm:855
0xB09A  0xA5 0x9B       LDA 0x9B                // LDA LastOccupiedEntry             file.asm:857
0xB09C  0x29 0x0F       AND # 0x0F              // AND #0x0F               Was it slot 0?
0xB09E  0xD0 0x11       BNE 0xB0B1 (+17)        // if (Z)                  Yes - sector is now empty
0xB0A0  0xA4 0x94       LDY 0x94                // LDY PreviousSector                file.asm:862
0xB0A2  0xA9 0x01       LDA # 1                 // LDA #1                  End-of-chain marker
0xB0A4  0x99 0x00 0x18  STA 0x1800,Y            // STA FATBuffer, Y                  file.asm:864
0xB0A7  0xA4 0x93       LDY 0x93                // LDY LastOccupiedSector            file.asm:867
0xB0A9  0xA9 0x00       LDA # 0                 // LDA #0                            file.asm:868
0xB0AB  0x99 0x00 0x18  STA 0x1800,Y            // STA FATBuffer, Y                  file.asm:869
0xB0AE  0x20 0xD8 0xB3  JSR 0xB3D8              // writeFAT();                       file.asm:871
0xB0B1  0x38            SEC                     // SEC    Success                    file.asm:877
0xB0B2  0x68            PLA                     // PLA                               file.asm:881
0xB0B3  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       file.asm:882
0xB0B5  0x68            PLA                     // PLA                               file.asm:883
0xB0B6  0x85 0x79       STA 0x79                // STA ZP.STRL                       file.asm:884
0xB0B8  0x7A            PLY                     // PLY                               file.asm:887
0xB0B9  0xFA            PLX                     // PLX                               file.asm:888
0xB0BA  0x60            RTS                     // }                                 file.asm:892

// /source/projects/6502sbc/hopperbasic/files/file.asm:904
// ####  File.Exists()  ####                                                    0x0180

0xB0BB  0xDA            PHX                     // PHX                               file.asm:908
0xB0BC  0x5A            PHY                     // PHY                               file.asm:909
0xB0BD  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       file.asm:911
0xB0BF  0xA5 0x79       LDA 0x79                // LDA ZP.STRL                       file.asm:914
0xB0C1  0x48            PHA                     // PHA                               file.asm:915
0xB0C2  0xA5 0x7A       LDA 0x7A                // LDA ZP.STRH                       file.asm:916
0xB0C4  0x48            PHA                     // PHA                               file.asm:917
0xB0C5  0x20 0x8E 0xAE  JSR 0xAE8E              // File.ValidateFilename();          file.asm:922
0xB0C8  0x90 0x06       BCC 0xB0D0 (+6)         // if (NC) { BIT ZP.EmulatorPCL break; }
0xB0CA  0x20 0xBD 0xAE  JSR 0xAEBD              // initializeFATandDirectory();      file.asm:925
0xB0CD  0x20 0x56 0xB1  JSR 0xB156              // findFileInDirectory();            file.asm:928
0xB0D0  0x68            PLA                     // PLA                               file.asm:933
0xB0D1  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       file.asm:934
0xB0D3  0x68            PLA                     // PLA                               file.asm:935
0xB0D4  0x85 0x79       STA 0x79                // STA ZP.STRL                       file.asm:936
0xB0D6  0x7A            PLY                     // PLY                               file.asm:938
0xB0D7  0xFA            PLX                     // PLX                               file.asm:939
0xB0D8  0x60            RTS                     // }                                 file.asm:943

// /source/projects/6502sbc/hopperbasic/files/file.asm:953
// ####  File.StartLoad()  ####                                                 0x0181

0xB0D9  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       file.asm:954
0xB0DB  0xDA            PHX                     // PHX                               file.asm:958
0xB0DC  0x5A            PHY                     // PHY                               file.asm:959
0xB0DD  0xA5 0x79       LDA 0x79                // LDA ZP.STRL                       file.asm:962
0xB0DF  0x48            PHA                     // PHA                               file.asm:963
0xB0E0  0xA5 0x7A       LDA 0x7A                // LDA ZP.STRH                       file.asm:964
0xB0E2  0x48            PHA                     // PHA                               file.asm:965
0xB0E3  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       file.asm:970
0xB0E5  0x20 0xBB 0xB0  JSR 0xB0BB              // File.Exists();                    file.asm:971
0xB0E8  0xB0 0x05       BCS 0xB0EF (+5)         // if (NC)                           file.asm:972
0xB0EA  0x20 0xA7 0x8B  JSR 0x8BA7              // Error.FileNotFound(); BIT ZP.EmulatorPCL
0xB0ED  0x80 0x0B       BRA 0xB0FA (+11)        // break;                            file.asm:975
0xB0EF  0x20 0x5F 0xB1  JSR 0xB15F              // getFileStartSector();    -> FileStartSector
0xB0F2  0x20 0x46 0xB1  JSR 0xB146              // GetFileLength();    -> BytesRemainingL/H
0xB0F5  0xA5 0x91       LDA 0x91                // LDA FileStartSector               file.asm:986
0xB0F7  0x85 0x90       STA 0x90                // STA CurrentFileSector             file.asm:987
0xB0F9  0x38            SEC                     // SEC                               file.asm:990
0xB0FA  0x68            PLA                     // PLA                               file.asm:994
0xB0FB  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       file.asm:995
0xB0FD  0x68            PLA                     // PLA                               file.asm:996
0xB0FE  0x85 0x79       STA 0x79                // STA ZP.STRL                       file.asm:997
0xB100  0x7A            PLY                     // PLY                               file.asm:999
0xB101  0xFA            PLX                     // PLX                               file.asm:1000
0xB102  0x60            RTS                     // }                                 file.asm:1004

// /source/projects/6502sbc/hopperbasic/files/file.asm:1022
// ####  File.NextStream()  ####                                                0x0182

0xB103  0xDA            PHX                     // PHX                               file.asm:1026
0xB104  0x5A            PHY                     // PHY                               file.asm:1027
0xB105  0xA5 0x96       LDA 0x96                // LDA BytesRemainingL               file.asm:1032
0xB107  0x05 0x97       ORA 0x97                // ORA BytesRemainingH               file.asm:1033
0xB109  0xD0 0x03       BNE 0xB10E (+3)         // if (Z)                            file.asm:1034
0xB10B  0x18            CLC                     // CLC     End of file               file.asm:1036
0xB10C  0x80 0x35       BRA 0xB143 (+53)        // break;                            file.asm:1037
0xB10E  0xA5 0x90       LDA 0x90                // LDA CurrentFileSector             file.asm:1041
0xB110  0x20 0x7B 0xB4  JSR 0xB47B              // readSector();     Load into FileDataBuffer
0xB113  0xA5 0x97       LDA 0x97                // LDA BytesRemainingH               file.asm:1045
0xB115  0xD0 0x08       BNE 0xB11F (+8)         // if (Z)     BytesRemaining < 256   file.asm:1046
0xB117  0xA5 0x96       LDA 0x96                // LDA BytesRemainingL               file.asm:1048
0xB119  0x85 0x8E       STA 0x8E                // STA TransferLengthL               file.asm:1049
0xB11B  0x64 0x8F       STZ 0x8F                // STZ TransferLengthH               file.asm:1050
0xB11D  0x80 0x16       BRA 0xB135 (+22)        // }                                 file.asm:1052
0xB11F  0x64 0x8E       STZ 0x8E                // STZ TransferLengthL               file.asm:1055
0xB121  0xA9 0x01       LDA # 1                 // LDA #1                            file.asm:1056
0xB123  0x85 0x8F       STA 0x8F                // STA TransferLengthH               file.asm:1057
0xB125  0xA4 0x90       LDY 0x90                // LDY CurrentFileSector             file.asm:1060
0xB127  0xB9 0x00 0x18  LDA 0x1800,Y            // LDA FATBuffer, Y                  file.asm:1061
0xB12A  0xC9 0x01       CMP # 1                 // CMP #1                         End-of-chain marker?
0xB12C  0xD0 0x05       BNE 0xB133 (+5)         // if (Z)                            file.asm:1063
0xB12E  0x20 0xC0 0x8B  JSR 0x8BC0              // Error.EEPROMError();              file.asm:1066
0xB131  0x80 0x10       BRA 0xB143 (+16)        // break;                            file.asm:1067
0xB133  0x85 0x90       STA 0x90                // STA CurrentFileSector          Ready for next call
0xB135  0x38            SEC                     // SEC                               file.asm:1073
0xB136  0xA5 0x96       LDA 0x96                // LDA BytesRemainingL               file.asm:1074
0xB138  0xE5 0x8E       SBC 0x8E                // SBC TransferLengthL               file.asm:1075
0xB13A  0x85 0x96       STA 0x96                // STA BytesRemainingL               file.asm:1076
0xB13C  0xA5 0x97       LDA 0x97                // LDA BytesRemainingH               file.asm:1077
0xB13E  0xE5 0x8F       SBC 0x8F                // SBC TransferLengthH               file.asm:1078
0xB140  0x85 0x97       STA 0x97                // STA BytesRemainingH               file.asm:1079
0xB142  0x38            SEC                     // SEC     Success                   file.asm:1081
0xB143  0x7A            PLY                     // PLY                               file.asm:1085
0xB144  0xFA            PLX                     // PLX                               file.asm:1086
0xB145  0x60            RTS                     // }                                 file.asm:1090

// /source/projects/6502sbc/hopperbasic/files/file.asm:1099
// ####  File.GetFileLength()  ####                                             0x0183

0xB146  0x20 0xC5 0xAE  JSR 0xAEC5              // fileEntryToDirectoryEntry();    -> Y
0xB149  0xB9 0x00 0x19  LDA 0x1900,Y            // LDA DirectoryBuffer + 0, Y                 Length LSB
0xB14C  0x85 0x96       STA 0x96                // STA BytesRemainingL               file.asm:1108
0xB14E  0xB9 0x01 0x19  LDA 0x1901,Y            // LDA DirectoryBuffer + 1, Y                 Length MSB
0xB151  0x29 0x7F       AND # 0x7F              // AND # 0x7F    strip bit 15 - file type
0xB153  0x85 0x97       STA 0x97                // STA BytesRemainingH               file.asm:1111
0xB155  0x60            RTS                     // }                                 file.asm:1115

// /source/projects/6502sbc/hopperbasic/files/file.asm:1123
// ####  File.findFileInDirectory()  ####                                       0x0184

0xB156  0x20 0x9A 0xB1  JSR 0xB19A              // walkDirectoryChain();             file.asm:1128
0xB159  0x90 0x02       BCC 0xB15D (+2)         // if (C)                            file.asm:1130
0xB15B  0x18            CLC                     // CLC     Not found                 file.asm:1132
0xB15C  0x60            RTS                     // }                                 file.asm:1133
0xB15D  0x38            SEC                     // SEC     Found                     file.asm:1136
0xB15E  0x60            RTS                     // }                                 file.asm:1142

// /source/projects/6502sbc/hopperbasic/files/file.asm:1150
// ####  File.getFileStartSector()  ####                                        0x0185

0xB15F  0x20 0xC5 0xAE  JSR 0xAEC5              // fileEntryToDirectoryEntry();    -> Y
0xB162  0xC8            INY                     // INY INY                         + 2 (start sector field)
0xB163  0xC8            INY
0xB164  0xB9 0x00 0x19  LDA 0x1900,Y            // LDA DirectoryBuffer, Y            file.asm:1159
0xB167  0x85 0x91       STA 0x91                // STA FileStartSector               file.asm:1160
0xB169  0x60            RTS                     // }                                 file.asm:1164

// /source/projects/6502sbc/hopperbasic/files/file.asm:1171
// ####  File.freeFileSectorChain()  ####                                       0x0186

0xB16A  0xA5 0x91       LDA 0x91                // LDA FileStartSector               file.asm:1175
0xB16C  0x85 0x90       STA 0x90                // STA CurrentFileSector             file.asm:1176
0xB16E  0xA5 0x90       LDA 0x90                // LDA CurrentFileSector             file.asm:1181
0xB170  0xF0 0x18       BEQ 0xB18A (+24)        // if (Z) { break; }           Sanity check - should not happen
0xB172  0xA4 0x90       LDY 0x90                // LDY CurrentFileSector             file.asm:1185
0xB174  0xB9 0x00 0x18  LDA 0x1800,Y            // LDA FATBuffer, Y                  file.asm:1186
0xB177  0x85 0x95       STA 0x95                // STA NextFileSector                file.asm:1187
0xB179  0xA9 0x00       LDA # 0                 // LDA #0                            file.asm:1190
0xB17B  0x99 0x00 0x18  STA 0x1800,Y            // STA FATBuffer, Y                  file.asm:1191
0xB17E  0xA5 0x95       LDA 0x95                // LDA NextFileSector                file.asm:1194
0xB180  0xC9 0x01       CMP # 1                 // CMP #1                      1 = end-of-chain marker
0xB182  0xF0 0x06       BEQ 0xB18A (+6)         // if (Z) { break; }           End of chain reached
0xB184  0xA5 0x95       LDA 0x95                // LDA NextFileSector                file.asm:1199
0xB186  0x85 0x90       STA 0x90                // STA CurrentFileSector             file.asm:1200
0xB188  0x80 0xE4       BRA 0xB16E (-28)        // }                                 file.asm:1201
0xB18A  0x60            RTS                     // }                                 file.asm:1205

// /source/projects/6502sbc/hopperbasic/files/file.asm:1212
// ####  File.clearDirectoryEntry()  ####                                       0x0187

0xB18B  0x20 0xC5 0xAE  JSR 0xAEC5              // fileEntryToDirectoryEntry();    -> Y
0xB18E  0xA9 0x00       LDA # 0                 // LDA #0                            file.asm:1220
0xB190  0xA2 0x10       LDX # 0x10              // LDX #16                           file.asm:1221
0xB192  0x99 0x00 0x19  STA 0x1900,Y            // STA DirectoryBuffer, Y            file.asm:1224
0xB195  0xC8            INY                     // INY                               file.asm:1225
0xB196  0xCA            DEX                     // DEX                               file.asm:1226
0xB197  0xD0 0xF9       BNE 0xB192 (-7)         // if (Z) { break; }                 file.asm:1227
0xB199  0x60            RTS                     // }                                 file.asm:1232

// /source/projects/6502sbc/hopperbasic/files/file.asm:1259
// ####  File.walkDirectoryChain()  ####                                        0x0188

0xB19A  0xA9 0x01       LDA # 1                 // LDA #1                            file.asm:1260
0xB19C  0x85 0x9A       STA 0x9A                // STA CurrentDirectorySector        file.asm:1261
0xB19E  0x64 0x0E       STZ 0x0E                // STZ ZP.ACCL                 Tracks position in chain (0x00, 0x10, 0x20...)
0xB1A0  0x64 0x94       STZ 0x94                // STZ PreviousSector          Tracks previous sector for unlinking
0xB1A2  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:1267
0xB1A4  0x20 0xE2 0xB3  JSR 0xB3E2              // loadDirectorySector();            file.asm:1268
0xB1A7  0xA0 0x00       LDY # 0                 // LDY #0                          Slot index (0-15)
0xB1A9  0x20 0xD1 0xAE  JSR 0xAED1              // entryToOffset();            Y * 16 -> X (byte offset)
0xB1AC  0xBD 0x00 0x19  LDA 0x1900,X            // LDA DirectoryBuffer + 0, X        file.asm:1277
0xB1AF  0x1D 0x01 0x19  ORA 0x1901,X            // ORA DirectoryBuffer + 1, X        file.asm:1278
0xB1B2  0xF0 0x2C       BEQ 0xB1E0 (+44)        // if (NZ)                           file.asm:1279
0xB1B4  0x5A            PHY                     // PHY                     Preserve slot and offset
0xB1B5  0xDA            PHX                     // PHX                               file.asm:1283
0xB1B6  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       file.asm:1285
0xB1B8  0xD0 0x05       BNE 0xB1BF (+5)         // case DirWalkAction.Count:         file.asm:1288
0xB1BA  0x20 0x28 0xB2  JSR 0xB228              // processCountEntry();         X = offset
0xB1BD  0x80 0x1D       BRA 0xB1DC (+29)        // }                                 file.asm:1291
0xB1BF  0xC9 0x01       CMP # 1                 // case DirWalkAction.Print:         file.asm:1292
0xB1C1  0xD0 0x05       BNE 0xB1C8 (+5)
0xB1C3  0x20 0x3D 0xB2  JSR 0xB23D              // processPrintEntry();         X = offset
0xB1C6  0x80 0x14       BRA 0xB1DC (+20)        // }                                 file.asm:1295
0xB1C8  0xC9 0x03       CMP # 0x03              // case DirWalkAction.FindExecutable:
0xB1CA  0xF0 0x04       BEQ 0xB1D0 (+4)
0xB1CC  0xC9 0x02       CMP # 0x02              // case DirWalkAction.FindFile:      file.asm:1297
0xB1CE  0xD0 0x05       BNE 0xB1D5 (+5)
0xB1D0  0x20 0x0D 0xB2  JSR 0xB20D              // processFindFileEntry();      X = offset, Y = slot
0xB1D3  0x80 0x07       BRA 0xB1DC (+7)         // }                                 file.asm:1300
0xB1D5  0xC9 0x04       CMP # 0x04              // case DirWalkAction.FindLast:      file.asm:1301
0xB1D7  0xD0 0x03       BNE 0xB1DC (+3)
0xB1D9  0x20 0x02 0xB2  JSR 0xB202              // processFindLastEntry();      X = offset, Y = slot
0xB1DC  0xFA            PLX                     // PLX                               file.asm:1307
0xB1DD  0x7A            PLY                     // PLY                               file.asm:1308
0xB1DE  0x90 0x05       BCC 0xB1E5 (+5)         // if (NC) { break; }                file.asm:1311
0xB1E0  0xC8            INY                     // INY                               file.asm:1314
0xB1E1  0xC0 0x10       CPY # 0x10              // CPY #16                           file.asm:1315
0xB1E3  0xD0 0xC4       BNE 0xB1A9 (-60)        // if (Z) { break; }                 file.asm:1316
0xB1E5  0x90 0x1A       BCC 0xB201 (+26)        // if (NC) { break; }     Propagate early exit from callback
0xB1E7  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:1322
0xB1E9  0x20 0xF8 0xB3  JSR 0xB3F8              // getNextDirectorySector();       Returns next sector in A (1 = end-of-chain)
0xB1EC  0xC9 0x01       CMP # 1                 // CMP #1                            file.asm:1324
0xB1EE  0xD0 0x02       BNE 0xB1F2 (+2)         // if (Z)                            file.asm:1325
0xB1F0  0x38            SEC                     // SEC                          Set C = completed full iteration
0xB1F1  0x60            RTS                     // break;                            file.asm:1328
0xB1F2  0xA6 0x9A       LDX 0x9A                // LDX CurrentDirectorySector        file.asm:1332
0xB1F4  0x86 0x94       STX 0x94                // STX PreviousSector              Save for potential unlinking
0xB1F6  0x85 0x9A       STA 0x9A                // STA CurrentDirectorySector      A still has next sector
0xB1F8  0x18            CLC                     // CLC                               file.asm:1337
0xB1F9  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       file.asm:1338
0xB1FB  0x69 0x10       ADC # 0x10              // ADC #16                         Each sector adds 16 to global entry index
0xB1FD  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       file.asm:1340
0xB1FF  0x80 0xA1       BRA 0xB1A2 (-95)        // }    outer loop                   file.asm:1341
0xB201  0x60            RTS                     // }                                 file.asm:1342

// /source/projects/6502sbc/hopperbasic/files/file.asm:1346
// ####  File.processFindLastEntry()  ####                                      0x0189

0xB202  0x98            TYA                     // TYA                               file.asm:1348
0xB203  0x05 0x0E       ORA 0x0E                // ORA ZP.ACCL             Combine with sector position
0xB205  0x85 0x9B       STA 0x9B                // STA LastOccupiedEntry             file.asm:1350
0xB207  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:1352
0xB209  0x85 0x93       STA 0x93                // STA LastOccupiedSector            file.asm:1353
0xB20B  0x38            SEC                     // SEC                     Always continue scanning
0xB20C  0x60            RTS                     // }                                 file.asm:1356

// /source/projects/6502sbc/hopperbasic/files/file.asm:1359
// ####  File.processFindFileEntry()  ####                                      0x018A

0xB20D  0x5A            PHY                     // PHY                    Save slot on stack
0xB20E  0x20 0x74 0xB3  JSR 0xB374              // checkFilenameAndTypeMatch();     Compare ZP.STR with DirectoryBuffer, X
0xB211  0x68            PLA                     // PLA                    Get slot back in A
0xB212  0x90 0x12       BCC 0xB226 (+18)        // if (C)     Match found            file.asm:1368
0xB214  0x48            PHA                     // PHA                         Save slot again
0xB215  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:1372
0xB217  0x3A            DEC A                   // DEC                               file.asm:1373
0xB218  0x0A            ASL A                   // ASL A ASL A ASL A ASL A           file.asm:1374
0xB219  0x0A            ASL A
0xB21A  0x0A            ASL A
0xB21B  0x0A            ASL A
0xB21C  0x85 0x92       STA 0x92                // STA CurrentFileEntry              file.asm:1375
0xB21E  0x68            PLA                     // PLA                         Get slot
0xB21F  0x18            CLC                     // CLC                               file.asm:1377
0xB220  0x65 0x92       ADC 0x92                // ADC CurrentFileEntry              file.asm:1378
0xB222  0x85 0x92       STA 0x92                // STA CurrentFileEntry              file.asm:1379
0xB224  0x18            CLC                     // CLC                    Signal stop scanning
0xB225  0x60            RTS                     // return;                           file.asm:1382
0xB226  0x38            SEC                     // SEC                        Continue scanning
0xB227  0x60            RTS                     // }                                 file.asm:1386

// /source/projects/6502sbc/hopperbasic/files/file.asm:1389
// ####  File.processCountEntry()  ####                                         0x018B

0xB228  0xE6 0x8E       INC 0x8E                // INC TransferLengthL             Count file
0xB22A  0x18            CLC                     // CLC                               file.asm:1393
0xB22B  0xBD 0x00 0x19  LDA 0x1900,X            // LDA DirectoryBuffer + 0, X        file.asm:1394
0xB22E  0x65 0x96       ADC 0x96                // ADC BytesRemainingL               file.asm:1395
0xB230  0x85 0x96       STA 0x96                // STA BytesRemainingL               file.asm:1396
0xB232  0xBD 0x01 0x19  LDA 0x1901,X            // LDA DirectoryBuffer + 1, X        file.asm:1397
0xB235  0x29 0x7F       AND # 0x7F              // AND # 0x7F    strip bit 15 - file type (AND does not affect C flag)
0xB237  0x65 0x8F       ADC 0x8F                // ADC TransferLengthH               file.asm:1399
0xB239  0x85 0x8F       STA 0x8F                // STA TransferLengthH               file.asm:1400
0xB23B  0x38            SEC                     // SEC     Continue scanning         file.asm:1402
0xB23C  0x60            RTS                     // }                                 file.asm:1403

// /source/projects/6502sbc/hopperbasic/files/file.asm:1406
// ####  File.processPrintEntry()  ####                                         0x018C

0xB23D  0x8A            TXA                     // TXA    X = directory entry byte offset
0xB23E  0xA8            TAY                     // TAY                               file.asm:1409
0xB23F  0xA2 0x04       LDX # 0x04              // LDX #4                            file.asm:1411
0xB241  0x20 0xC0 0x95  JSR 0x95C0              // Print.Spaces();                   file.asm:1412
0xB244  0x20 0x6B 0xB2  JSR 0xB26B              // printFilenameFromDirectory();    Uses Y = filename start offset, preserves X, Y
0xB247  0x20 0x9E 0xB2  JSR 0xB29E              // printFileSizeFromDirectory();    Uses Y = directory entry offset, preserves X, Y
0xB24A  0xA9 0x3C       LDA # 0x3C              // LDA # ErrorID.BytesLabel LDX # MessageExtras.PrefixSpace Error.MessageNL();
0xB24C  0xA2 0x01       LDX # 1
0xB24E  0x20 0xE3 0x8A  JSR 0x8AE3
0xB251  0xE6 0x0E       INC 0x0E                // INC ZP.ACCL            Increment printed count
0xB253  0x38            SEC                     // SEC                    Continue scanning
0xB254  0x60            RTS                     // }                                 file.asm:1425

// /source/projects/6502sbc/hopperbasic/files/file.asm:1431
// ####  File.countFilesAndBytes()  ####                                        0x018D

0xB255  0x64 0x8E       STZ 0x8E                // STZ TransferLengthL         Initialize file count
0xB257  0x64 0x8F       STZ 0x8F                // STZ TransferLengthH         Initialize byte count MSB
0xB259  0x64 0x96       STZ 0x96                // STZ BytesRemainingL         Initialize byte count LSB
0xB25B  0xA9 0x00       LDA # 0                 // LDA #DirWalkAction.Count          file.asm:1439
0xB25D  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       file.asm:1440
0xB25F  0x4C 0x9A 0xB1  JMP 0xB19A              // walkDirectoryChain();             file.asm:1441

// /source/projects/6502sbc/hopperbasic/files/file.asm:1451
// ####  File.printAllFileEntries()  ####                                       0x018E

0xB262  0x64 0x0E       STZ 0x0E                // STZ ZP.ACCL                 Entry counter
0xB264  0xA9 0x01       LDA # 1                 // LDA #DirWalkAction.Print          file.asm:1457
0xB266  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       file.asm:1458
0xB268  0x4C 0x9A 0xB1  JMP 0xB19A              // walkDirectoryChain();             file.asm:1460

// /source/projects/6502sbc/hopperbasic/files/file.asm:1474
// ####  File.printFilenameFromDirectory()  ####                                0x018F

0xB26B  0xDA            PHX                     // PHX                               file.asm:1478
0xB26C  0x5A            PHY                     // PHY                               file.asm:1479
0xB26D  0x98            TYA                     // TYA                               file.asm:1480
0xB26E  0x18            CLC                     // CLC                               file.asm:1481
0xB26F  0x69 0x03       ADC # 0x03              // ADC #3                      Offset to filename field
0xB271  0xA8            TAY                     // TAY                               file.asm:1483
0xB272  0x5A            PHY                     // PHY    store name position        file.asm:1485
0xB273  0xA2 0x10       LDX # 0x10              // LDX #(13 + 2 + 1)    filename + optional " *" + at least one space
0xB275  0xB9 0x00 0x19  LDA 0x1900,Y            // LDA DirectoryBuffer, Y            file.asm:1490
0xB278  0x48            PHA                     // PHA                         Save character
0xB279  0x29 0x7F       AND # 0x7F              // AND #0x7F                   Clear high bit
0xB27B  0x20 0xB0 0x95  JSR 0x95B0              // Print.Char();               Print character
0xB27E  0xCA            DEX                     // DEX                         count the character (for space padding below)
0xB27F  0x68            PLA                     // PLA                         Restore character
0xB280  0x30 0x03       BMI 0xB285 (+3)         // if (MI) { break; }          High bit set = last character
0xB282  0xC8            INY                     // INY                               file.asm:1499
0xB283  0x80 0xF0       BRA 0xB275 (-16)        // }    single exit                  file.asm:1501
0xB285  0x7A            PLY                     // PLY    restore name position      file.asm:1503
0xB286  0xB9 0xFE 0x18  LDA 0x18FE,Y            // LDA (DirectoryBuffer - 2), Y     Size high byte
0xB289  0x10 0x0A       BPL 0xB295 (+10)        // if (MI)     Bit 7 set = executable
0xB28B  0x20 0xBB 0x95  JSR 0x95BB              // Space();                          file.asm:1509
0xB28E  0xA9 0x2A       LDA # 0x2A              // LDA #'*'                          file.asm:1510
0xB290  0x20 0xB0 0x95  JSR 0x95B0              // Print.Char();                     file.asm:1511
0xB293  0xCA            DEX                     // DEX DEX                           file.asm:1512
0xB294  0xCA            DEX
0xB295  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    file.asm:1517
0xB298  0xCA            DEX                     // DEX                               file.asm:1518
0xB299  0xD0 0xFA       BNE 0xB295 (-6)         // if (Z) { break; }                 file.asm:1519
0xB29B  0x7A            PLY                     // PLY                               file.asm:1522
0xB29C  0xFA            PLX                     // PLX                               file.asm:1523
0xB29D  0x60            RTS                     // }                                 file.asm:1527

// /source/projects/6502sbc/hopperbasic/files/file.asm:1534
// ####  File.printFileSizeFromDirectory()  ####                                0x0190

0xB29E  0xB9 0x00 0x19  LDA 0x1900,Y            // LDA DirectoryBuffer + 0, Y     Length LSB
0xB2A1  0x85 0x11       STA 0x11                // STA ZP.TOPL                       file.asm:1539
0xB2A3  0xB9 0x01 0x19  LDA 0x1901,Y            // LDA DirectoryBuffer + 1, Y     Length MSB
0xB2A6  0x29 0x7F       AND # 0x7F              // AND #0x7F                      strip file type bit from size
0xB2A8  0x85 0x12       STA 0x12                // STA ZP.TOPH                       file.asm:1542
0xB2AA  0x64 0x15       STZ 0x15                // STZ ZP.TOPT                       file.asm:1543
0xB2AC  0xDA            PHX                     // PHX                               file.asm:1546
0xB2AD  0xA2 0x00       LDX # 0                 // LDX #0                          assume 0 spaces of padding
0xB2AF  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       file.asm:1548
0xB2B1  0xC9 0x04       CMP # 0x04              // CMP #4                          Check for 1024+
0xB2B3  0xB0 0x1F       BCS 0xB2D4 (+31)        // if (NC)                         < 1024, need more analysis
0xB2B5  0xC9 0x03       CMP # 0x03              // CMP #3                      Check if TOPH = 3 (768-1023)
0xB2B7  0xD0 0x09       BNE 0xB2C2 (+9)         // if (Z)                      TOPH = 3
0xB2B9  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       file.asm:1555
0xB2BB  0xC9 0xE8       CMP # 0xE8              // CMP #232                1000 = 3*256 + 232
0xB2BD  0xB0 0x15       BCS 0xB2D4 (+21)        // if (NC)                 < 1000 (768-999 range)
0xB2BF  0xE8            INX                     // {        INX }              3-digit numbers get 1 space
0xB2C0  0x80 0x12       BRA 0xB2D4 (+18)        // }                                 file.asm:1560
0xB2C2  0xC9 0x00       CMP # 0                 // CMP #0                            file.asm:1563
0xB2C4  0xF0 0x03       BEQ 0xB2C9 (+3)         // if (NZ)                 TOPH = 1 or 2 (256-767)
0xB2C6  0xE8            INX                     // {        INX }              3-digit numbers get 1 space
0xB2C7  0x80 0x0B       BRA 0xB2D4 (+11)
0xB2C9  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       file.asm:1568
0xB2CB  0xC9 0x64       CMP # 0x64              // CMP #100                          file.asm:1569
0xB2CD  0xB0 0x04       BCS 0xB2D3 (+4)         // if (NC)             < 100 (10-99 range)
0xB2CF  0xA2 0x02       LDX # 0x02              // { LDX #2 }              2-digit numbers get 2 spaces
0xB2D1  0x80 0x01       BRA 0xB2D4 (+1)
0xB2D3  0xE8            INX                     // {    INX }              3-digit numbers get 1 space
0xB2D4  0x20 0xC0 0x95  JSR 0x95C0              // Print.Spaces();                 print X spaces (zero is ok)
0xB2D7  0xFA            PLX                     // PLX                               file.asm:1579
0xB2D8  0x4C 0xCF 0x95  JMP 0x95CF              // Print.Decimal();                  file.asm:1581

// /source/projects/6502sbc/hopperbasic/files/file.asm:1592
// ####  File.printDirectorySummary()  ####                                     0x0191

0xB2DB  0xA5 0x8E       LDA 0x8E                // LDA TransferLengthL               file.asm:1597
0xB2DD  0x85 0x11       STA 0x11                // STA ZP.TOPL                       file.asm:1598
0xB2DF  0x64 0x12       STZ 0x12                // STZ ZP.TOPH                       file.asm:1599
0xB2E1  0x64 0x15       STZ 0x15                // STZ ZP.TOPT                       file.asm:1600
0xB2E3  0x20 0xCF 0x95  JSR 0x95CF              // Print.Decimal();                  file.asm:1601
0xB2E6  0xA9 0x3B       LDA # 0x3B              // LDA # ErrorID.Files LDX # (MessageExtras.PrefixSpace|MessageExtras.SuffixComma|MessageExtras.SuffixSpace) Error.Message();
0xB2E8  0xA2 0x13       LDX # 0x13
0xB2EA  0x20 0xE9 0x8A  JSR 0x8AE9
0xB2ED  0xA5 0x96       LDA 0x96                // LDA BytesRemainingL               file.asm:1607
0xB2EF  0x85 0x11       STA 0x11                // STA ZP.TOPL                       file.asm:1608
0xB2F1  0xA5 0x8F       LDA 0x8F                // LDA TransferLengthH               file.asm:1609
0xB2F3  0x85 0x12       STA 0x12                // STA ZP.TOPH                       file.asm:1610
0xB2F5  0x64 0x15       STZ 0x15                // STZ ZP.TOPT                       file.asm:1611
0xB2F7  0x20 0xCF 0x95  JSR 0x95CF              // Print.Decimal();                  file.asm:1612
0xB2FA  0xA9 0x3D       LDA # 0x3D              // LDA # ErrorID.BytesUsedLabel LDX # MessageExtras.PrefixSpace Error.MessageNL();
0xB2FC  0xA2 0x01       LDX # 1
0xB2FE  0x4C 0xE3 0x8A  JMP 0x8AE3

// /source/projects/6502sbc/hopperbasic/files/file.asm:1626
// ####  File.writeFilenameToDirectory()  ####                                  0x0192

0xB301  0x5A            PHY                     // PHY                               file.asm:1630
0xB302  0x20 0xC5 0xAE  JSR 0xAEC5              // fileEntryToDirectoryEntry();    -> Y
0xB305  0x98            TYA                     // TYA TAX                           file.asm:1634
0xB306  0xAA            TAX
0xB307  0xE8            INX                     // INX INX INX    + 3 (filename field)
0xB308  0xE8            INX
0xB309  0xE8            INX
0xB30A  0xA0 0x00       LDY # 0                 // LDY #0                            file.asm:1638
0xB30C  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   file.asm:1641
0xB30E  0xD0 0x0B       BNE 0xB31B (+11)        // if (Z)                            file.asm:1642
0xB310  0xCA            DEX                     // DEX                               file.asm:1645
0xB311  0xBD 0x00 0x19  LDA 0x1900,X            // LDA DirectoryBuffer, X            file.asm:1646
0xB314  0x09 0x80       ORA # 0x80              // ORA #0x80              Set high bit
0xB316  0x9D 0x00 0x19  STA 0x1900,X            // STA DirectoryBuffer, X            file.asm:1648
0xB319  0x80 0x12       BRA 0xB32D (+18)        // break;                            file.asm:1649
0xB31B  0x9D 0x00 0x19  STA 0x1900,X            // STA DirectoryBuffer, X            file.asm:1652
0xB31E  0xE8            INX                     // INX                               file.asm:1653
0xB31F  0xC8            INY                     // INY                               file.asm:1654
0xB320  0xC0 0x0D       CPY # 0x0D              // CPY #13                    Max filename length
0xB322  0xD0 0xE8       BNE 0xB30C (-24)        // if (Z)                            file.asm:1656
0xB324  0xCA            DEX                     // DEX                               file.asm:1659
0xB325  0xBD 0x00 0x19  LDA 0x1900,X            // LDA DirectoryBuffer, X            file.asm:1660
0xB328  0x09 0x80       ORA # 0x80              // ORA #0x80              Set high bit
0xB32A  0x9D 0x00 0x19  STA 0x1900,X            // STA DirectoryBuffer, X            file.asm:1662
0xB32D  0x7A            PLY                     // PLY                               file.asm:1667
0xB32E  0x60            RTS                     // }                                 file.asm:1671

// /source/projects/6502sbc/hopperbasic/files/file.asm:1677
// ####  File.updateDirectoryStartSector()  ####                                0x0193

0xB32F  0x20 0xC5 0xAE  JSR 0xAEC5              // fileEntryToDirectoryEntry();    -> Y
0xB332  0xC8            INY                     // INY INY                         + 2 for start sector field offset
0xB333  0xC8            INY
0xB334  0xA5 0x91       LDA 0x91                // LDA FileStartSector               file.asm:1686
0xB336  0x99 0x00 0x19  STA 0x1900,Y            // STA DirectoryBuffer, Y            file.asm:1687
0xB339  0x60            RTS                     // }                                 file.asm:1691

// /source/projects/6502sbc/hopperbasic/files/file.asm:1699
// ####  File.flushAndAllocateNext()  ####                                      0x0194

0xB33A  0xDA            PHX                     // PHX                               file.asm:1703
0xB33B  0x5A            PHY                     // PHY                               file.asm:1704
0xB33C  0xA5 0x90       LDA 0x90                // LDA CurrentFileSector             file.asm:1709
0xB33E  0x20 0x85 0xB4  JSR 0xB485              // writeSector();                    file.asm:1710
0xB341  0x20 0x61 0xB3  JSR 0xB361              // allocateFirstFreeSector();    -> Y
0xB344  0xB0 0x05       BCS 0xB34B (+5)         // if (NC)                           file.asm:1714
0xB346  0x20 0xBB 0x8B  JSR 0x8BBB              // Error.EEPROMFull(); BIT ZP.EmulatorPCL
0xB349  0x80 0x13       BRA 0xB35E (+19)        // break;                            file.asm:1718
0xB34B  0x84 0x95       STY 0x95                // STY NextFileSector                file.asm:1720
0xB34D  0xA4 0x90       LDY 0x90                // LDY CurrentFileSector             file.asm:1723
0xB34F  0xA5 0x95       LDA 0x95                // LDA NextFileSector                file.asm:1724
0xB351  0x99 0x00 0x18  STA 0x1800,Y            // STA FATBuffer, Y                  file.asm:1725
0xB354  0x85 0x90       STA 0x90                // STA CurrentFileSector             file.asm:1729
0xB356  0x64 0x98       STZ 0x98                // STZ SectorPositionL          Reset to start of new sector
0xB358  0x64 0x99       STZ 0x99                // STZ SectorPositionH               file.asm:1731
0xB35A  0x20 0xBD 0xB3  JSR 0xB3BD              // clearFileDataBuffer();            file.asm:1734
0xB35D  0x38            SEC                     // SEC    Success                    file.asm:1736
0xB35E  0x7A            PLY                     // PLY                               file.asm:1740
0xB35F  0xFA            PLX                     // PLX                               file.asm:1741
0xB360  0x60            RTS                     // }                                 file.asm:1745

// /source/projects/6502sbc/hopperbasic/files/file.asm:1752
// ####  File.allocateFirstFreeSector()  ####                                   0x0195

0xB361  0xA0 0x02       LDY # 0x02              // LDY #2                      Start from sector 2 (skip FAT and directory)
0xB363  0xB9 0x00 0x18  LDA 0x1800,Y            // LDA FATBuffer, Y                  file.asm:1759
0xB366  0xD0 0x07       BNE 0xB36F (+7)         // if (Z)                   Free sector found
0xB368  0xA9 0x01       LDA # 1                 // LDA #1                            file.asm:1763
0xB36A  0x99 0x00 0x18  STA 0x1800,Y            // STA FATBuffer, Y                  file.asm:1764
0xB36D  0x38            SEC                     // SEC                               file.asm:1765
0xB36E  0x60            RTS                     // break;                            file.asm:1766
0xB36F  0xC8            INY                     // INY                               file.asm:1768
0xB370  0xD0 0xF1       BNE 0xB363 (-15)        // if (Z)                   Y wrapped to 0 - checked all sectors
0xB372  0x18            CLC                     // CLC                  Disk full    file.asm:1771
0xB373  0x60            RTS                     // break;                            file.asm:1772

// /source/projects/6502sbc/hopperbasic/files/file.asm:1785
// ####  File.checkFilenameAndTypeMatch()  ####                                 0x0196

0xB374  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       file.asm:1794
0xB376  0xC9 0x03       CMP # 0x03              // CMP #DirWalkAction.FindExecutable file.asm:1795
0xB378  0xD0 0x07       BNE 0xB381 (+7)         // if (Z)     Looking for executable files only
0xB37A  0xBD 0x01 0x19  LDA 0x1901,X            // LDA (DirectoryBuffer + 1), X     Size high byte at offset 1
0xB37D  0x30 0x02       BMI 0xB381 (+2)         // if (PL)     Bit 7 not set (not executable)
0xB37F  0x18            CLC                     // CLC     Not a match - wrong file type
0xB380  0x60            RTS                     // break;                            file.asm:1803
0xB381  0x8A            TXA                     // TXA                               file.asm:1808
0xB382  0x18            CLC                     // CLC                               file.asm:1809
0xB383  0x69 0x03       ADC # 0x03              // ADC #3                            file.asm:1810
0xB385  0xAA            TAX                     // TAX                         X = filename start in DirectoryBuffer
0xB386  0xA0 0x00       LDY # 0                 // LDY #0                      Index into ZP.STR filename
0xB388  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   file.asm:1817
0xB38A  0xD0 0x09       BNE 0xB395 (+9)         // if (Z)                  End of input filename?
0xB38C  0xBD 0xFF 0x18  LDA 0x18FF,X            // LDA (DirectoryBuffer-1), X        file.asm:1821
0xB38F  0x10 0x02       BPL 0xB393 (+2)         // if (MI)             High bit set = that was the last char
0xB391  0x38            SEC                     // SEC             Perfect match     file.asm:1824
0xB392  0x60            RTS                     // }                                 file.asm:1825
0xB393  0x18            CLC                     // CLC             Input ended but directory continues
0xB394  0x60            RTS                     // break;                            file.asm:1830
0xB395  0xBD 0x00 0x19  LDA 0x1900,X            // LDA DirectoryBuffer, X            file.asm:1836
0xB398  0x48            PHA                     // PHA                     Save original with high bit
0xB399  0x29 0x7F       AND # 0x7F              // AND #0x7F              Clear high bit for comparison
0xB39B  0xD1 0x79       CMP [0x79],Y            // CMP [ZP.STR], Y                   file.asm:1839
0xB39D  0xF0 0x03       BEQ 0xB3A2 (+3)         // if (NZ)                           file.asm:1840
0xB39F  0x68            PLA                     // PLA                clean stack    file.asm:1842
0xB3A0  0x18            CLC                     // CLC                Characters don't match
0xB3A1  0x60            RTS                     // break;                            file.asm:1844
0xB3A2  0x68            PLA                     // PLA                Get original back
0xB3A3  0x10 0x09       BPL 0xB3AE (+9)         // if (MI)                High bit set = last character
0xB3A5  0xC8            INY                     // INY                               file.asm:1852
0xB3A6  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   file.asm:1853
0xB3A8  0xD0 0x02       BNE 0xB3AC (+2)         // if (Z)                            file.asm:1854
0xB3AA  0x38            SEC                     // SEC            Perfect match      file.asm:1856
0xB3AB  0x60            RTS                     // }                                 file.asm:1857
0xB3AC  0x18            CLC                     // CLC            Directory ended but input continues
0xB3AD  0x60            RTS                     // break;                            file.asm:1862
0xB3AE  0xC8            INY                     // INY                               file.asm:1866
0xB3AF  0xE8            INX                     // INX                               file.asm:1867
0xB3B0  0x80 0xD6       BRA 0xB388 (-42)        // }                                 file.asm:1868

// /source/projects/6502sbc/hopperbasic/files/file.asm:1883
// ####  File.initializeSaveState()  ####                                       0x0197

0xB3B2  0x64 0x93       STZ 0x93                // STZ FilePosition            FilePositionL
0xB3B4  0x64 0x94       STZ 0x94                // STZ FilePosition + 1        FilePositionH
0xB3B6  0x64 0x98       STZ 0x98                // STZ SectorPositionL         Byte position within current sector
0xB3B8  0x64 0x99       STZ 0x99                // STZ SectorPositionH               file.asm:1891
0xB3BA  0x64 0x95       STZ 0x95                // STZ NextFileSector                file.asm:1894
0xB3BC  0x60            RTS                     // }                                 file.asm:1898

// /source/projects/6502sbc/hopperbasic/files/file.asm:1903
// ####  File.clearFileDataBuffer()  ####                                       0x0198

0xB3BD  0xA9 0x1A       LDA # 0x1A              // LDA #(FileDataBuffer / 256)    MSB - assume page aligned
0xB3BF  0x4C 0x2C 0x93  JMP 0x932C              // Memory.ClearPage();               file.asm:1908

// /source/projects/6502sbc/hopperbasic/files/file.asm:1917
// ####  File.clearFATBuffer()  ####                                            0x0199

0xB3C2  0xA9 0x18       LDA # 0x18              // LDA #(FATBuffer / 256)    MSB - assume page aligned
0xB3C4  0x4C 0x2C 0x93  JMP 0x932C              // Memory.ClearPage();               file.asm:1922

// /source/projects/6502sbc/hopperbasic/files/file.asm:1931
// ####  File.clearDirectoryBuffer()  ####                                      0x019A

0xB3C7  0xA9 0x19       LDA # 0x19              // LDA #(DirectoryBuffer / 256)    MSB - assume page aligned
0xB3C9  0x4C 0x2C 0x93  JMP 0x932C              // Memory.ClearPage();               file.asm:1936

// /source/projects/6502sbc/hopperbasic/files/file.asm:1947
// ####  File.loadFAT()  ####                                                   0x019B

0xB3CC  0x64 0x1E       STZ 0x1E                // STZ ZP.IDYH                 EEPROM address MSB = sector 0 (must be page aligned)
0xB3CE  0x64 0x1D       STZ 0x1D                // STZ ZP.IDYL                       file.asm:1952
0xB3D0  0xA9 0x18       LDA # 0x18              // LDA #(FATBuffer / 256)      RAM address MSB = FATBuffer (must be page aligned)
0xB3D2  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       file.asm:1955
0xB3D4  0x20 0x84 0xAE  JSR 0xAE84              // EEPROM.ReadPage();                file.asm:1957
0xB3D7  0x60            RTS                     // }                                 file.asm:1963

// /source/projects/6502sbc/hopperbasic/files/file.asm:1967
// ####  File.writeFAT()  ####                                                  0x019C

0xB3D8  0x64 0x1E       STZ 0x1E                // STZ ZP.IDYH                 EEPROM address MSB = sector 0 (must be page aligned)
0xB3DA  0xA9 0x18       LDA # 0x18              // LDA #(FATBuffer / 256)      RAM address MSB = FATBuffer (must be page aligned)
0xB3DC  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       file.asm:1974
0xB3DE  0x20 0x60 0xAE  JSR 0xAE60              // EEPROM.WritePage();               file.asm:1976
0xB3E1  0x60            RTS                     // }                                 file.asm:1982

// /source/projects/6502sbc/hopperbasic/files/file.asm:1988
// ####  File.loadDirectorySector()  ####                                       0x019D

0xB3E2  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                         EEPROM address MSB = sector number
0xB3E4  0x85 0x9A       STA 0x9A                // STA CurrentDirectorySector          Remember which sector we loaded
0xB3E6  0xA9 0x19       LDA # 0x19              // LDA #(DirectoryBuffer / 256)       RAM address MSB = DirectoryBuffer
0xB3E8  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       file.asm:1998
0xB3EA  0x20 0x84 0xAE  JSR 0xAE84              // EEPROM.ReadPage();                file.asm:2000
0xB3ED  0x60            RTS                     // }                                 file.asm:2007

// /source/projects/6502sbc/hopperbasic/files/file.asm:2014
// ####  File.writeDirectorySector()  ####                                      0x019E

0xB3EE  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                         EEPROM address MSB = sector number
0xB3F0  0xA9 0x19       LDA # 0x19              // LDA #(DirectoryBuffer / 256)       RAM address MSB = DirectoryBuffer
0xB3F2  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       file.asm:2023
0xB3F4  0x20 0x60 0xAE  JSR 0xAE60              // EEPROM.WritePage();               file.asm:2025
0xB3F7  0x60            RTS                     // }                                 file.asm:2032

// /source/projects/6502sbc/hopperbasic/files/file.asm:2039
// ####  File.getNextDirectorySector()  ####                                    0x019F

0xB3F8  0xA8            TAY                     // TAY                                 Y = current sector
0xB3F9  0xB9 0x00 0x18  LDA 0x1800,Y            // LDA FATBuffer, Y                    Get next sector from FAT
0xB3FC  0x60            RTS                     // }                                 file.asm:2042

// /source/projects/6502sbc/hopperbasic/files/file.asm:2050
// ####  File.allocateDirectorySector()  ####                                   0x01A0

0xB3FD  0x48            PHA                     // PHA                                 Save current last sector
0xB3FE  0x20 0x61 0xB3  JSR 0xB361              // allocateFirstFreeSector();      Returns Y = new sector
0xB401  0xB0 0x03       BCS 0xB406 (+3)         // if (NC)                           file.asm:2062
0xB403  0x68            PLA                     // PLA                         Clean stack
0xB404  0x18            CLC                     // CLC                         Disk full
0xB405  0x60            RTS                     // break;                            file.asm:2066
0xB406  0x68            PLA                     // PLA                             A = previous last sector
0xB407  0xAA            TAX                     // TAX                             X = previous sector
0xB408  0x98            TYA                     // TYA                             A = new sector
0xB409  0x9D 0x00 0x18  STA 0x1800,X            // STA FATBuffer, X                Link previous to new
0xB40C  0xA8            TAY                     // TAY                               file.asm:2076
0xB40D  0xA9 0x01       LDA # 1                 // LDA #1                          End-of-chain marker
0xB40F  0x99 0x00 0x18  STA 0x1800,Y            // STA FATBuffer, Y                  file.asm:2078
0xB412  0x98            TYA                     // TYA                             A = new sector number
0xB413  0x48            PHA                     // PHA                             Save for return value
0xB414  0x20 0xBD 0xB3  JSR 0xB3BD              // clearFileDataBuffer();            file.asm:2085
0xB417  0x68            PLA                     // PLA                               file.asm:2086
0xB418  0x48            PHA                     // PHA                               file.asm:2087
0xB419  0x20 0x85 0xB4  JSR 0xB485              // writeSector();                  Write cleared buffer to new sector
0xB41C  0x68            PLA                     // PLA                             Return new sector number in A
0xB41D  0x38            SEC                     // SEC                             Success
0xB41E  0x60            RTS                     // break;                            file.asm:2092

// /source/projects/6502sbc/hopperbasic/files/file.asm:2108
// ####  File.findFreeDirectoryEntry()  ####                                    0x01A1

0xB41F  0xA9 0x01       LDA # 1                 // LDA #1                              Start with first directory sector
0xB421  0x85 0x9A       STA 0x9A                // STA CurrentDirectorySector        file.asm:2116
0xB423  0x64 0x92       STZ 0x92                // STZ CurrentFileEntry                Start with entry 0
0xB425  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:2122
0xB427  0x20 0xE2 0xB3  JSR 0xB3E2              // loadDirectorySector();            file.asm:2123
0xB42A  0xA0 0x00       LDY # 0                 // LDY #0                          Entry index within sector (0-15)
0xB42C  0x20 0xD1 0xAE  JSR 0xAED1              // entryToOffset();    Y * 16 -> X, munts A
0xB42F  0xBD 0x00 0x19  LDA 0x1900,X            // LDA DirectoryBuffer + 0, X     Length LSB
0xB432  0x1D 0x01 0x19  ORA 0x1901,X            // ORA DirectoryBuffer + 1, X     Length MSB
0xB435  0xD0 0x12       BNE 0xB449 (+18)        // if (Z)                            file.asm:2135
0xB437  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:2139
0xB439  0x3A            DEC A                   // DEC                        Sector 1 = entries 0-15
0xB43A  0x0A            ASL A                   // ASL A ASL A ASL A ASL A    * 16   file.asm:2141
0xB43B  0x0A            ASL A
0xB43C  0x0A            ASL A
0xB43D  0x0A            ASL A
0xB43E  0x85 0x92       STA 0x92                // STA CurrentFileEntry              file.asm:2142
0xB440  0x98            TYA                     // TYA                        Add local entry index
0xB441  0x18            CLC                     // CLC                               file.asm:2144
0xB442  0x65 0x92       ADC 0x92                // ADC CurrentFileEntry              file.asm:2145
0xB444  0x85 0x92       STA 0x92                // STA CurrentFileEntry              file.asm:2146
0xB446  0x38            SEC                     // SEC                       Success - found entry
0xB447  0x80 0x06       BRA 0xB44F (+6)         // break;                    Exit main loop with success
0xB449  0xC8            INY                     // INY                               file.asm:2151
0xB44A  0xC0 0x10       CPY # 0x10              // CPY #16                           file.asm:2152
0xB44C  0xD0 0xDE       BNE 0xB42C (-34)        // if (Z) { CLC break; }           Checked all entries in this sector
0xB44E  0x18            CLC
0xB44F  0xB0 0x29       BCS 0xB47A (+41)        // if (C) { break; }               Exit with found entry
0xB451  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:2160
0xB453  0x20 0xF8 0xB3  JSR 0xB3F8              // getNextDirectorySector();         file.asm:2161
0xB456  0xC9 0x01       CMP # 1                 // CMP #1                          End-of-chain?
0xB458  0xD0 0x1C       BNE 0xB476 (+28)        // if (Z)                            file.asm:2163
0xB45A  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:2166
0xB45C  0x20 0xFD 0xB3  JSR 0xB3FD              // allocateDirectorySector();        file.asm:2167
0xB45F  0xB0 0x02       BCS 0xB463 (+2)         // if (NC)                           file.asm:2168
0xB461  0x18            CLC                     // CLC                               file.asm:2171
0xB462  0x60            RTS                     // break;                  Exit with failure
0xB463  0x85 0x9A       STA 0x9A                // STA CurrentDirectorySector        file.asm:2176
0xB465  0x20 0xE2 0xB3  JSR 0xB3E2              // loadDirectorySector();            file.asm:2177
0xB468  0xA5 0x9A       LDA 0x9A                // LDA CurrentDirectorySector        file.asm:2180
0xB46A  0x3A            DEC A                   // DEC                               file.asm:2181
0xB46B  0x0A            ASL A                   // ASL A ASL A ASL A ASL A             * 16
0xB46C  0x0A            ASL A
0xB46D  0x0A            ASL A
0xB46E  0x0A            ASL A
0xB46F  0x85 0x92       STA 0x92                // STA CurrentFileEntry              file.asm:2183
0xB471  0x20 0xD8 0xB3  JSR 0xB3D8              // writeFAT();                       file.asm:2186
0xB474  0x38            SEC                     // SEC                         Success
0xB475  0x60            RTS                     // break;                      Exit with new entry
0xB476  0x85 0x9A       STA 0x9A                // STA CurrentDirectorySector        file.asm:2193
0xB478  0x80 0xAB       BRA 0xB425 (-85)        // }                                 file.asm:2195
0xB47A  0x60            RTS                     // }                                 file.asm:2202

// /source/projects/6502sbc/hopperbasic/files/file.asm:2210
// ####  File.readSector()  ####                                                0x01A2

0xB47B  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                    EEPROM address MSB = sector number (must be page aligned)
0xB47D  0xA9 0x1A       LDA # 0x1A              // LDA #(FileDataBuffer / 256)    RAM address MSB = FileDataBuffer (must be page aligned)
0xB47F  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       file.asm:2217
0xB481  0x20 0x84 0xAE  JSR 0xAE84              // EEPROM.ReadPage();                file.asm:2219
0xB484  0x60            RTS                     // }                                 file.asm:2225

// /source/projects/6502sbc/hopperbasic/files/file.asm:2230
// ####  File.writeSector()  ####                                               0x01A3

0xB485  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                    EEPROM address MSB = sector number (must be page aligned)
0xB487  0xA9 0x1A       LDA # 0x1A              // LDA #(FileDataBuffer / 256)    RAM address MSB = FileDataBuffer (must be page aligned)
0xB489  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       file.asm:2237
0xB48B  0x20 0x60 0xAE  JSR 0xAE60              // EEPROM.WritePage();               file.asm:2238
0xB48E  0x60            RTS                     // }                                 file.asm:2244

// /source/projects/6502sbc/hopperbasic/files/storage.asm:71
// ####  Storage.LoadProgram()  ####                                            0x01A4

0xB48F  0xC9 0x00       CMP # 0                 // CMP #0                            storage.asm:75
0xB491  0xF0 0x06       BEQ 0xB499 (+6)         // if (NZ)    Non-zero means do NEW first
0xB493  0x20 0x78 0xA3  JSR 0xA378              // Variables.Clear();                storage.asm:79
0xB496  0x20 0x4A 0xA8  JSR 0xA84A              // Functions.Clear();                storage.asm:80
0xB499  0xA9 0x03       LDA # 0x03              // LDA # DirWalkAction.FindExecutable
0xB49B  0x20 0xD9 0xB0  JSR 0xB0D9              // File.StartLoad();    Input: ZP.STR = filename
0xB49E  0x90 0x60       BCC 0xB500 (+96)        // if (NC) { break; }                storage.asm:86
0xB4A0  0x20 0x49 0xB9  JSR 0xB949              // setupSlidingWindowBuffer();       storage.asm:89
0xB4A3  0x90 0x5B       BCC 0xB500 (+91)        // if (NC) { break; }                storage.asm:90
0xB4A5  0x64 0xA2       STZ 0xA2                // STZ LoaderFlags                   storage.asm:96
0xB4A7  0x20 0x3B 0xB7  JSR 0xB73B              // nextToken();                      storage.asm:101
0xB4AA  0xC9 0xA5       CMP # 0xA5              // case Token.FUNC:                  storage.asm:104
0xB4AC  0xD0 0x0C       BNE 0xB4BA (+12)
0xB4AE  0x20 0x7D 0xB8  JSR 0xB87D              // parseFunctionHeader();            storage.asm:106
0xB4B1  0x90 0x4D       BCC 0xB500 (+77)        // if (NC) { break; }                storage.asm:107
0xB4B3  0x20 0xC4 0xB8  JSR 0xB8C4              // parseFunctionOrMain();            storage.asm:108
0xB4B6  0x90 0x48       BCC 0xB500 (+72)        // if (NC) { break; }                storage.asm:109
0xB4B8  0x80 0xED       BRA 0xB4A7 (-19)
0xB4BA  0xC9 0xA8       CMP # 0xA8              // case Token.BEGIN:                 storage.asm:111
0xB4BC  0xD0 0x0E       BNE 0xB4CC (+14)
0xB4BE  0x20 0x6C 0xB8  JSR 0xB86C              // parseMainHeader();                storage.asm:113
0xB4C1  0x90 0x3D       BCC 0xB500 (+61)        // if (NC) { break; }                storage.asm:114
0xB4C3  0xA7 0xA2       SMB2 0xA2               // SMB2 LoaderFlags                  storage.asm:115
0xB4C5  0x20 0xC4 0xB8  JSR 0xB8C4              // parseFunctionOrMain();            storage.asm:116
0xB4C8  0x90 0x36       BCC 0xB500 (+54)        // if (NC) { break; }                storage.asm:117
0xB4CA  0x80 0xDB       BRA 0xB4A7 (-37)
0xB4CC  0xC9 0x9E       CMP # 0x9E              // case Token.CONST:                 storage.asm:119
0xB4CE  0xD0 0x04       BNE 0xB4D4 (+4)
0xB4D0  0x97 0xA2       SMB1 0xA2               // SMB1 LoaderFlags                  storage.asm:121
0xB4D2  0x80 0xD3       BRA 0xB4A7 (-45)        // }                                 storage.asm:122
0xB4D4  0xC9 0x98       CMP # 0x98              // case Token.BIT:                   storage.asm:125
0xB4D6  0xF0 0x1C       BEQ 0xB4F4 (+28)
0xB4D8  0xC9 0x96       CMP # 0x96              // case Token.INT:                   storage.asm:126
0xB4DA  0xF0 0x18       BEQ 0xB4F4 (+24)
0xB4DC  0xC9 0x99       CMP # 0x99              // case Token.BYTE:                  storage.asm:127
0xB4DE  0xF0 0x14       BEQ 0xB4F4 (+20)
0xB4E0  0xC9 0x97       CMP # 0x97              // case Token.WORD:                  storage.asm:128
0xB4E2  0xF0 0x10       BEQ 0xB4F4 (+16)
0xB4E4  0xC9 0x9C       CMP # 0x9C              // case Token.CHAR:                  storage.asm:129
0xB4E6  0xF0 0x0C       BEQ 0xB4F4 (+12)
0xB4E8  0xC9 0x9A       CMP # 0x9A              // case Token.LONG:                  storage.asm:130
0xB4EA  0xF0 0x08       BEQ 0xB4F4 (+8)
0xB4EC  0xC9 0x9D       CMP # 0x9D              // case Token.VAR:                   storage.asm:132
0xB4EE  0xF0 0x04       BEQ 0xB4F4 (+4)
0xB4F0  0xC9 0x9B       CMP # 0x9B              // case Token.STRING:                storage.asm:133
0xB4F2  0xD0 0x07       BNE 0xB4FB (+7)
0xB4F4  0x20 0xD9 0xB7  JSR 0xB7D9              // parseVariableOrConst();           storage.asm:135
0xB4F7  0x90 0x07       BCC 0xB500 (+7)         // if (NC) { break; }                storage.asm:136
0xB4F9  0x80 0xAC       BRA 0xB4A7 (-84)
0xB4FB  0xC9 0xDB       CMP # 0xDB              // case Token.EOF:                   storage.asm:138
0xB4FD  0xD0 0xA8       BNE 0xB4A7 (-88)
0xB4FF  0x38            SEC                     // SEC                               storage.asm:140
0xB500  0xB7 0xA2       SMB3 0xA2               // SMB3 Storage.LoaderFlags    initialize constants too, not just variables
0xB502  0x4C 0xB5 0xFD  JMP 0xFDB5              // Console.InitializeGlobals();      storage.asm:167

// /source/projects/6502sbc/hopperbasic/files/storage.asm:176
// ####  Storage.SaveProgram()  ####                                            0x01A5

0xB505  0x20 0x06 0xB7  JSR 0xB706              // prepareTokenBuffer();             storage.asm:182
0xB508  0x20 0x11 0xAF  JSR 0xAF11              // File.StartSave();    Input: ZP.STR = filename
0xB50B  0x90 0x1F       BCC 0xB52C (+31)        // if (NC) { break; }                storage.asm:188
0xB50D  0x20 0x2D 0xB5  JSR 0xB52D              // saveConstants();                  storage.asm:191
0xB510  0x90 0x1A       BCC 0xB52C (+26)        // if (NC) { break; }                storage.asm:192
0xB512  0x20 0x46 0xB5  JSR 0xB546              // saveVariables();                  storage.asm:195
0xB515  0x90 0x15       BCC 0xB52C (+21)        // if (NC) { break; }                storage.asm:196
0xB517  0x20 0xD0 0xB5  JSR 0xB5D0              // saveFunctions();                  storage.asm:200
0xB51A  0x90 0x10       BCC 0xB52C (+16)        // if (NC) { break; }                storage.asm:201
0xB51C  0xA9 0xDB       LDA # 0xDB              // LDA # Token.EOF                   storage.asm:204
0xB51E  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();             storage.asm:205
0xB521  0x20 0x13 0xB7  JSR 0xB713              // flushTokenBuffer();               storage.asm:208
0xB524  0xA9 0x80       LDA # 0x80              // LDA #0x80    executable file      storage.asm:211
0xB526  0x20 0x86 0xAF  JSR 0xAF86              // File.EndSave();                   storage.asm:212
0xB529  0x90 0x01       BCC 0xB52C (+1)         // if (NC) { break; }                storage.asm:213
0xB52B  0x38            SEC                     // SEC                               storage.asm:216
0xB52C  0x60            RTS                     // }                                 storage.asm:223

// /source/projects/6502sbc/hopperbasic/files/storage.asm:229
// ####  Storage.saveConstants()  ####                                          0x01A6

0xB52D  0x20 0x5E 0xA3  JSR 0xA35E              // Variables.IterateConstants();     storage.asm:237
0xB530  0x90 0x12       BCC 0xB544 (+18)        // if (NC) { break; }    No more constants
0xB532  0xA9 0x9E       LDA # 0x9E              // LDA #Token.CONST                  storage.asm:244
0xB534  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();             storage.asm:245
0xB537  0x20 0x5A 0xB5  JSR 0xB55A              // streamVariableOrConstant();    Input: ZP.IDX = constant node
0xB53A  0xB0 0x03       BCS 0xB53F (+3)         // if (NC) { CLC break; }    Propagate error
0xB53C  0x18            CLC
0xB53D  0x80 0x05       BRA 0xB544 (+5)
0xB53F  0x20 0x08 0xA0  JSR 0xA008              // Variables.IterateNext();    Input: ZP.IDX = current, Output: ZP.IDX = next
0xB542  0x80 0xEC       BRA 0xB530 (-20)        // }                                 storage.asm:250
0xB544  0x38            SEC                     // SEC    Success                    storage.asm:251
0xB545  0x60            RTS                     // break;                            storage.asm:252

// /source/projects/6502sbc/hopperbasic/files/storage.asm:264
// ####  Storage.saveVariables()  ####                                          0x01A7

0xB546  0x20 0x50 0xA3  JSR 0xA350              // Variables.IterateVariables();     storage.asm:272
0xB549  0x90 0x0D       BCC 0xB558 (+13)        // if (NC) { break; }    No more variables
0xB54B  0x20 0x5A 0xB5  JSR 0xB55A              // streamVariableOrConstant();    Input: ZP.IDX = variable node
0xB54E  0xB0 0x03       BCS 0xB553 (+3)         // if (NC) { CLC break; }    Propagate error
0xB550  0x18            CLC
0xB551  0x80 0x05       BRA 0xB558 (+5)
0xB553  0x20 0x08 0xA0  JSR 0xA008              // Variables.IterateNext();    Input: ZP.IDX = current, Output: ZP.IDX = next
0xB556  0x80 0xF1       BRA 0xB549 (-15)        // }                                 storage.asm:280
0xB558  0x38            SEC                     // SEC    Success                    storage.asm:281
0xB559  0x60            RTS                     // break;                            storage.asm:282

// /source/projects/6502sbc/hopperbasic/files/storage.asm:295
// ####  Storage.streamVariableOrConstant()  ####                               0x01A8

0xB55A  0x20 0xA9 0xA2  JSR 0xA2A9              // Variables.GetType();    Input: ZP.IDX, Output: ZP.ACCT = symbolType|dataType
0xB55D  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       storage.asm:306
0xB55F  0x29 0x10       AND # 0x10              // AND # BASICType.VAR               storage.asm:307
0xB561  0xD0 0x04       BNE 0xB567 (+4)         // if (Z)    not VAR type            storage.asm:308
0xB563  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       storage.asm:310
0xB565  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          storage.asm:311
0xB567  0x20 0x4A 0x88  JSR 0x884A              // BASICTypes.ToToken();     Input: A = base type, Output: A = token value
0xB56A  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();    uses XID storage.asm:314
0xB56D  0xA9 0xDA       LDA # 0xDA              // LDA #Token.IDENTIFIER             storage.asm:317
0xB56F  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();     uses XID
0xB572  0x20 0xC9 0xA2  JSR 0xA2C9              // Variables.GetName();    Input: ZP.IDX, Output: ZP.STR = name pointer
0xB575  0x20 0xEF 0xB5  JSR 0xB5EF              // appendStringToBuffer();    Input: ZP.STR = name pointer, uses XID
0xB578  0x90 0x31       BCC 0xB5AB (+49)        // if (NC) { break; }                storage.asm:322
0xB57A  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       storage.asm:325
0xB57C  0x29 0x20       AND # 0x20              // AND # BASICType.ARRAY             storage.asm:326
0xB57E  0xF0 0x07       BEQ 0xB587 (+7)         // if (NZ)    Is an array            storage.asm:327
0xB580  0x20 0xAC 0xB5  JSR 0xB5AC              // streamArrayDeclaration();    Input: ZP.IDX = variable node
0xB583  0x90 0x26       BCC 0xB5AB (+38)        // if (NC) { break; }                storage.asm:331
0xB585  0x80 0x1E       BRA 0xB5A5 (+30)
0xB587  0x20 0xD9 0xA2  JSR 0xA2D9              // Variables.GetTokens();    Input: ZP.IDX, Output: ZP.NEXT = tokens pointer or null
0xB58A  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      storage.asm:337
0xB58C  0x05 0x17       ORA 0x17                // ORA ZP.NEXTH                      storage.asm:338
0xB58E  0xF0 0x15       BEQ 0xB5A5 (+21)        // if (NZ)    Has initialization/dimension tokens
0xB590  0xA9 0xE1       LDA # 0xE1              // LDA #Token.EQUALS                 storage.asm:342
0xB592  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();             storage.asm:343
0xB595  0x20 0xD9 0xA2  JSR 0xA2D9              // Variables.GetTokens();    Input: ZP.IDX, Output: ZP.ACC = tokens pointer or null
0xB598  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      storage.asm:348
0xB59A  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       storage.asm:349
0xB59C  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      storage.asm:350
0xB59E  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       storage.asm:351
0xB5A0  0x20 0xA7 0xB6  JSR 0xB6A7              // writeTokenStream();    Input: ZP.IDY
0xB5A3  0x90 0x06       BCC 0xB5AB (+6)         // if (NC) { break; }                storage.asm:353
0xB5A5  0xA9 0xDD       LDA # 0xDD              // LDA # Token.EOE     add EOE and stream after constant or variable
0xB5A7  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();             storage.asm:357
0xB5AA  0x38            SEC                     // SEC    Success                    storage.asm:359
0xB5AB  0x60            RTS                     // }                                 storage.asm:366

// /source/projects/6502sbc/hopperbasic/files/storage.asm:373
// ####  Storage.streamArrayDeclaration()  ####                                 0x01A9

0xB5AC  0xA9 0xF0       LDA # 0xF0              // LDA #Token.LBRACKET               storage.asm:381
0xB5AE  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();             storage.asm:382
0xB5B1  0x20 0xD9 0xA2  JSR 0xA2D9              // Variables.GetTokens();    Input: ZP.IDX, Output: ZP.NEXT = tokens pointer
0xB5B4  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      storage.asm:386
0xB5B6  0x05 0x17       ORA 0x17                // ORA ZP.NEXTH                      storage.asm:387
0xB5B8  0xF0 0x0D       BEQ 0xB5C7 (+13)        // if (NZ)    Has dimension tokens   storage.asm:388
0xB5BA  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      storage.asm:392
0xB5BC  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       storage.asm:393
0xB5BE  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      storage.asm:394
0xB5C0  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       storage.asm:395
0xB5C2  0x20 0xA7 0xB6  JSR 0xB6A7              // writeTokenStream();    Input: ZP.IDY
0xB5C5  0x90 0x08       BCC 0xB5CF (+8)         // if (NC) { break; }                storage.asm:397
0xB5C7  0xA9 0xF1       LDA # 0xF1              // LDA #Token.RBRACKET               storage.asm:401
0xB5C9  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();             storage.asm:402
0xB5CC  0x90 0x01       BCC 0xB5CF (+1)         // if (NC) { break; }                storage.asm:403
0xB5CE  0x38            SEC                     // SEC    Success                    storage.asm:405
0xB5CF  0x60            RTS                     // }                                 storage.asm:412

// /source/projects/6502sbc/hopperbasic/files/storage.asm:418
// ####  Storage.saveFunctions()  ####                                          0x01AA

0xB5D0  0x20 0x3C 0xA8  JSR 0xA83C              // Functions.IterateFunctions();     storage.asm:426
0xB5D3  0x90 0x18       BCC 0xB5ED (+24)        // if (NC) { break; }    No more functions
0xB5D5  0x20 0xCB 0xA7  JSR 0xA7CB              // Functions.GetName();    Input: ZP.IDX, Output: ZP.STR = name pointer
0xB5D8  0xB2 0x79       LDA [0x79]              // LDA [ZP.STR]                      storage.asm:434
0xB5DA  0xC9 0x24       CMP # 0x24              // CMP #'$'                          storage.asm:435
0xB5DC  0xD0 0x05       BNE 0xB5E3 (+5)         // if (Z)                            storage.asm:436
0xB5DE  0x20 0x54 0xB6  JSR 0xB654              // streamMainProgram();    Input: ZP.IDX = function node
0xB5E1  0x80 0x03       BRA 0xB5E6 (+3)         // }                                 storage.asm:439
0xB5E3  0x20 0x43 0xB6  JSR 0xB643              // streamFunction();    Input: ZP.IDX = function node
0xB5E6  0x90 0x05       BCC 0xB5ED (+5)         // if (NC) { break; }                storage.asm:444
0xB5E8  0x20 0x08 0xA0  JSR 0xA008              // Functions.IterateNext();    Input: ZP.IDX = current, Output: ZP.IDX = next
0xB5EB  0x80 0xE6       BRA 0xB5D3 (-26)        // }                                 storage.asm:447
0xB5ED  0x38            SEC                     // SEC    Success                    storage.asm:449
0xB5EE  0x60            RTS                     // break;                            storage.asm:450

// /source/projects/6502sbc/hopperbasic/files/storage.asm:463
// ####  Storage.appendStringToBuffer()  ####                                   0x01AB

0xB5EF  0x5A            PHY                     // PHY                               storage.asm:467
0xB5F0  0xA0 0x00       LDY # 0                 // LDY #0                            storage.asm:468
0xB5F2  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   storage.asm:472
0xB5F4  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();    A ->     storage.asm:473
0xB5F7  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   storage.asm:476
0xB5F9  0xD0 0x03       BNE 0xB5FE (+3)         // if (Z) { SEC break; }    Success - null terminator written
0xB5FB  0x38            SEC
0xB5FC  0x80 0x03       BRA 0xB601 (+3)
0xB5FE  0xC8            INY                     // INY                               storage.asm:478
0xB5FF  0x80 0xF1       BRA 0xB5F2 (-15)        // }                                 storage.asm:480
0xB601  0x7A            PLY                     // PLY                               storage.asm:481
0xB602  0x60            RTS                     // }                                 storage.asm:486

// /source/projects/6502sbc/hopperbasic/files/storage.asm:493
// ####  Storage.appendArgumentsToBuffer()  ####                                0x01AC

0xB603  0xDA            PHX                     // PHX                               storage.asm:498
0xB604  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       storage.asm:501
0xB606  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       storage.asm:502
0xB608  0xD0 0x03       BNE 0xB60D (+3)         // if (Z)                            storage.asm:503
0xB60A  0x38            SEC                     // SEC break;    No arguments - success
0xB60B  0x80 0x34       BRA 0xB641 (+52)
0xB60D  0xA2 0x00       LDX # 0                 // LDX #0    Argument counter for comma separation
0xB60F  0x20 0x0E 0xA6  JSR 0xA60E              // Locals.IterateStart();    IDX -> IDY
0xB612  0xB0 0x03       BCS 0xB617 (+3)         // if (NC) { SEC break; }    No more arguments
0xB614  0x38            SEC
0xB615  0x80 0x2A       BRA 0xB641 (+42)
0xB617  0x20 0x8D 0xA5  JSR 0xA58D              // Locals.GetType();    Input: ZP.IDY, Output: ZP.ACCT = symbolType|dataType
0xB61A  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       storage.asm:515
0xB61C  0x29 0xC0       AND # 0xC0              // AND # SymbolType.MASK             storage.asm:516
0xB61E  0xC9 0x40       CMP # 0x40              // CMP # SymbolType.ARGUMENT         storage.asm:517
0xB620  0xD0 0x1A       BNE 0xB63C (+26)        // if (Z)                            storage.asm:518
0xB622  0xE0 0x00       CPX # 0                 // CPX #0                            storage.asm:521
0xB624  0xF0 0x05       BEQ 0xB62B (+5)         // if (NZ)                           storage.asm:522
0xB626  0xA9 0xDF       LDA # 0xDF              // LDA # Token.COMMA                 storage.asm:524
0xB628  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();             storage.asm:525
0xB62B  0xA9 0xDA       LDA # 0xDA              // LDA # Token.IDENTIFIER            storage.asm:528
0xB62D  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();             storage.asm:529
0xB630  0x20 0x7D 0xA5  JSR 0xA57D              // Locals.GetName();    Input: ZP.IDY, Output: ZP.STR = name pointer
0xB633  0x20 0xEF 0xB5  JSR 0xB5EF              // appendStringToBuffer();    Input: ZP.STR
0xB636  0xB0 0x03       BCS 0xB63B (+3)         // if (NC) { CLC break; }    Propagate error
0xB638  0x18            CLC
0xB639  0x80 0x06       BRA 0xB641 (+6)
0xB63B  0xE8            INX                     // INX    Increment argument counter storage.asm:535
0xB63C  0x20 0x24 0xA6  JSR 0xA624              // Locals.IterateNext();    Input: ZP.IDY = current, Output: ZP.IDY = next, munts ZP.LCURRENT
0xB63F  0x80 0xD1       BRA 0xB612 (-47)        // }                                 storage.asm:538
0xB641  0xFA            PLX                     // PLX                               storage.asm:541
0xB642  0x60            RTS                     // }                                 storage.asm:546

// /source/projects/6502sbc/hopperbasic/files/storage.asm:553
// ####  Storage.streamFunction()  ####                                         0x01AD

0xB643  0x20 0x65 0xB6  JSR 0xB665              // streamFunctionHeader();           storage.asm:561
0xB646  0x90 0x0B       BCC 0xB653 (+11)        // if (NC) { break; }                storage.asm:562
0xB648  0x20 0x8F 0xB6  JSR 0xB68F              // streamFunctionBody();             storage.asm:565
0xB64B  0x90 0x06       BCC 0xB653 (+6)         // if (NC) { break; }                storage.asm:566
0xB64D  0x20 0x9D 0xB6  JSR 0xB69D              // streamFunctionFooter();           storage.asm:569
0xB650  0x90 0x01       BCC 0xB653 (+1)         // if (NC) { break; }                storage.asm:570
0xB652  0x38            SEC                     // SEC    Success                    storage.asm:572
0xB653  0x60            RTS                     // }                                 storage.asm:579

// /source/projects/6502sbc/hopperbasic/files/storage.asm:586
// ####  Storage.streamMainProgram()  ####                                      0x01AE

0xB654  0x20 0x8A 0xB6  JSR 0xB68A              // streamMainHeader();               storage.asm:594
0xB657  0x90 0x0B       BCC 0xB664 (+11)        // if (NC) { break; }                storage.asm:595
0xB659  0x20 0x8F 0xB6  JSR 0xB68F              // streamFunctionBody();             storage.asm:598
0xB65C  0x90 0x06       BCC 0xB664 (+6)         // if (NC) { break; }                storage.asm:599
0xB65E  0x20 0xA2 0xB6  JSR 0xB6A2              // streamMainFooter();               storage.asm:602
0xB661  0x90 0x01       BCC 0xB664 (+1)         // if (NC) { break; }                storage.asm:603
0xB663  0x38            SEC                     // SEC    Success                    storage.asm:605
0xB664  0x60            RTS                     // }                                 storage.asm:612

// /source/projects/6502sbc/hopperbasic/files/storage.asm:619
// ####  Storage.streamFunctionHeader()  ####                                   0x01AF

0xB665  0xA9 0xA5       LDA # 0xA5              // LDA #Token.FUNC                   storage.asm:627
0xB667  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();             storage.asm:628
0xB66A  0xA9 0xDA       LDA # 0xDA              // LDA #Token.IDENTIFIER             storage.asm:631
0xB66C  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();             storage.asm:632
0xB66F  0x20 0xCB 0xA7  JSR 0xA7CB              // Functions.GetName();    Input: ZP.IDX, Output: ZP.STR = name pointer
0xB672  0x20 0xEF 0xB5  JSR 0xB5EF              // appendStringToBuffer();    Input: ZP.STR = string pointer
0xB675  0x90 0x12       BCC 0xB689 (+18)        // if (NC) { break; }                storage.asm:636
0xB677  0xA9 0xE4       LDA # 0xE4              // LDA #Token.LPAREN                 storage.asm:639
0xB679  0x20 0xED 0xB6  JSR 0xB6ED              // appendByteToBuffer();             storage.asm:640
0xB67C  0x20 0xDC 0xA7  JSR 0xA7DC              // Functions.GetArguments();    Input: ZP.IDX, Output: ZP.IDY = args list or null
0xB67F  0x20 0x03 0xB6  JSR 0xB603              // appendArgumentsToBuffer();    Input: ZP.IDY = arguments list
0xB682  0x90 0x05       BCC 0xB689 (+5)         // if (NC) { break; }                storage.asm:645
0xB684  0xA9 0xE5       LDA # 0xE5              // LDA #Token.RPAREN                 storage.asm:648
0xB686  0x4C 0xED 0xB6  JMP 0xB6ED              // appendByteToBuffer();             storage.asm:649
0xB689  0x60            RTS                     // }                                 storage.asm:657

// /source/projects/6502sbc/hopperbasic/files/storage.asm:663
// ####  Storage.streamMainHeader()  ####                                       0x01B0

0xB68A  0xA9 0xA8       LDA # 0xA8              // LDA #Token.BEGIN                  storage.asm:667
0xB68C  0x4C 0xED 0xB6  JMP 0xB6ED              // appendByteToBuffer();             storage.asm:668

// /source/projects/6502sbc/hopperbasic/files/storage.asm:679
// ####  Storage.streamFunctionBody()  ####                                     0x01B1

0xB68F  0x20 0xC6 0xA7  JSR 0xA7C6              // Functions.GetBody();    Input: ZP.IDX, Output: ZP.IDY = tokens pointer
0xB692  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       storage.asm:685
0xB694  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       storage.asm:686
0xB696  0xF0 0x03       BEQ 0xB69B (+3)         // if (Z)                            storage.asm:687
0xB698  0x4C 0xA7 0xB6  JMP 0xB6A7
0xB69B  0x38            SEC                     // SEC    No body - success          storage.asm:689
0xB69C  0x60            RTS                     // return;                           storage.asm:693

// /source/projects/6502sbc/hopperbasic/files/storage.asm:706
// ####  Storage.streamFunctionFooter()  ####                                   0x01B2

0xB69D  0xA9 0xA6       LDA # 0xA6              // LDA #Token.ENDFUNC                storage.asm:711
0xB69F  0x4C 0xED 0xB6  JMP 0xB6ED              // appendByteToBuffer();             storage.asm:712

// /source/projects/6502sbc/hopperbasic/files/storage.asm:723
// ####  Storage.streamMainFooter()  ####                                       0x01B3

0xB6A2  0xA9 0xA9       LDA # 0xA9              // LDA #Token.END                    storage.asm:728
0xB6A4  0x4C 0xED 0xB6  JMP 0xB6ED              // appendByteToBuffer();             storage.asm:729

// /source/projects/6502sbc/hopperbasic/files/storage.asm:741
// ####  Storage.writeTokenStream()  ####                                       0x01B4

0xB6A7  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       storage.asm:747
0xB6A9  0x48            PHA                     // PHA                               storage.asm:748
0xB6AA  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       storage.asm:749
0xB6AC  0x48            PHA                     // PHA                               storage.asm:750
0xB6AD  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       storage.asm:751
0xB6AF  0x85 0x81       STA 0x81                // STA ZP.XIDH                       storage.asm:752
0xB6B1  0x48            PHA                     // PHA                               storage.asm:753
0xB6B2  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       storage.asm:754
0xB6B4  0x85 0x80       STA 0x80                // STA ZP.XIDL                       storage.asm:755
0xB6B6  0x48            PHA                     // PHA                               storage.asm:756
0xB6B7  0x20 0x13 0xB7  JSR 0xB713              // flushTokenBuffer();    flush what we have in TokenBuffer before switching to Variable or Function token stream
0xB6BA  0x64 0x8E       STZ 0x8E                // STZ File.TransferLengthL          storage.asm:759
0xB6BC  0x64 0x8F       STZ 0x8F                // STZ File.TransferLengthH          storage.asm:760
0xB6BE  0xB2 0x80       LDA [0x80]              // LDA [ZP.XID]             Check for EOF
0xB6C0  0xC9 0xDB       CMP # 0xDB              // CMP # Token.EOF                   storage.asm:765
0xB6C2  0xF0 0x0E       BEQ 0xB6D2 (+14)        // if (Z) { break; }    Don't include EOF
0xB6C4  0xE6 0x8E       INC 0x8E                // INC File.TransferLengthL          storage.asm:769
0xB6C6  0xD0 0x02       BNE 0xB6CA (+2)         // if (Z)                            storage.asm:770
0xB6C8  0xE6 0x8F       INC 0x8F                // INC File.TransferLengthH          storage.asm:772
0xB6CA  0xE6 0x80       INC 0x80                // INC ZP.XIDL              Advance to next token
0xB6CC  0xD0 0xF0       BNE 0xB6BE (-16)        // if (Z)                            storage.asm:775
0xB6CE  0xE6 0x81       INC 0x81                // INC ZP.XIDH                       storage.asm:777
0xB6D0  0x80 0xEC       BRA 0xB6BE (-20)        // }                                 storage.asm:779
0xB6D2  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       storage.asm:781
0xB6D4  0x85 0x8C       STA 0x8C                // STA File.SectorSourceL            storage.asm:782
0xB6D6  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       storage.asm:783
0xB6D8  0x85 0x8D       STA 0x8D                // STA File.SectorSourceH            storage.asm:784
0xB6DA  0x20 0x3D 0xAF  JSR 0xAF3D              // File.AppendStream();              storage.asm:785
0xB6DD  0x20 0x06 0xB7  JSR 0xB706              // prepareTokenBuffer();    switch back to our use of TokenBuffer, reseting to length = 0
0xB6E0  0x68            PLA                     // PLA                               storage.asm:789
0xB6E1  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       storage.asm:790
0xB6E3  0x68            PLA                     // PLA                               storage.asm:791
0xB6E4  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       storage.asm:792
0xB6E6  0x68            PLA                     // PLA                               storage.asm:793
0xB6E7  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       storage.asm:794
0xB6E9  0x68            PLA                     // PLA                               storage.asm:795
0xB6EA  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       storage.asm:796
0xB6EC  0x60            RTS                     // }                                 storage.asm:801

// /source/projects/6502sbc/hopperbasic/files/storage.asm:809
// ####  Storage.appendByteToBuffer()  ####                                     0x01B5

0xB6ED  0x48            PHA                     // PHA                               storage.asm:813
0xB6EE  0x18            CLC                     // CLC                               storage.asm:815
0xB6EF  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               storage.asm:816
0xB6F1  0x65 0x29       ADC 0x29                // ADC ZP.TokenBufferContentLengthL  storage.asm:817
0xB6F3  0x85 0x80       STA 0x80                // STA ZP.XIDL                       storage.asm:818
0xB6F5  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               storage.asm:819
0xB6F7  0x65 0x2A       ADC 0x2A                // ADC ZP.TokenBufferContentLengthH  storage.asm:820
0xB6F9  0x85 0x81       STA 0x81                // STA ZP.XIDH                       storage.asm:821
0xB6FB  0x68            PLA                     // PLA                               storage.asm:822
0xB6FC  0x92 0x80       STA [0x80]              // STA [ZP.XID]                          Write token
0xB6FE  0xE6 0x29       INC 0x29                // INC ZP.TokenBufferContentLengthL      Increment content length
0xB700  0xD0 0x02       BNE 0xB704 (+2)         // if (Z)                            storage.asm:825
0xB702  0xE6 0x2A       INC 0x2A                // INC ZP.TokenBufferContentLengthH  storage.asm:827
0xB704  0x38            SEC                     // SEC    all good (TODO : buffer overflow)
0xB705  0x60            RTS                     // }                                 storage.asm:835

// /source/projects/6502sbc/hopperbasic/files/storage.asm:841
// ####  Storage.prepareTokenBuffer()  ####                                     0x01B6

0xB706  0x64 0x29       STZ 0x29                // STZ ZP.TokenBufferContentLengthL  storage.asm:847
0xB708  0x64 0x2A       STZ 0x2A                // STZ ZP.TokenBufferContentLengthH  storage.asm:848
0xB70A  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               storage.asm:851
0xB70C  0x85 0x8C       STA 0x8C                // STA File.SectorSourceL            storage.asm:852
0xB70E  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               storage.asm:853
0xB710  0x85 0x8D       STA 0x8D                // STA File.SectorSourceH            storage.asm:854
0xB712  0x60            RTS                     // }                                 storage.asm:859

// /source/projects/6502sbc/hopperbasic/files/storage.asm:863
// ####  Storage.flushTokenBuffer()  ####                                       0x01B7

0xB713  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       storage.asm:869
0xB715  0x48            PHA                     // PHA                               storage.asm:870
0xB716  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       storage.asm:871
0xB718  0x48            PHA                     // PHA                               storage.asm:872
0xB719  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       storage.asm:873
0xB71B  0x48            PHA                     // PHA                               storage.asm:874
0xB71C  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       storage.asm:875
0xB71E  0x48            PHA                     // PHA                               storage.asm:876
0xB71F  0xA5 0x29       LDA 0x29                // LDA ZP.TokenBufferContentLengthL  storage.asm:878
0xB721  0x85 0x8E       STA 0x8E                // STA File.TransferLengthL          storage.asm:879
0xB723  0xA5 0x2A       LDA 0x2A                // LDA ZP.TokenBufferContentLengthH  storage.asm:880
0xB725  0x85 0x8F       STA 0x8F                // STA File.TransferLengthH          storage.asm:881
0xB727  0x20 0x3D 0xAF  JSR 0xAF3D              // File.AppendStream();    C or NC ->
0xB72A  0x64 0x29       STZ 0x29                // STZ ZP.TokenBufferContentLengthL  storage.asm:884
0xB72C  0x64 0x2A       STZ 0x2A                // STZ ZP.TokenBufferContentLengthH  storage.asm:885
0xB72E  0x68            PLA                     // PLA                               storage.asm:887
0xB72F  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       storage.asm:888
0xB731  0x68            PLA                     // PLA                               storage.asm:889
0xB732  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       storage.asm:890
0xB734  0x68            PLA                     // PLA                               storage.asm:891
0xB735  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       storage.asm:892
0xB737  0x68            PLA                     // PLA                               storage.asm:893
0xB738  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       storage.asm:894
0xB73A  0x60            RTS                     // }                                 storage.asm:899

// /source/projects/6502sbc/hopperbasic/files/storage.asm:902
// ####  Storage.nextToken()  ####                                              0x01B8

0xB73B  0xB2 0x9E       LDA [0x9E]              // LDA [LoadBufferIndex]             storage.asm:903
0xB73D  0xE6 0x9C       INC 0x9C                // INC LoadBufferPosL                storage.asm:904
0xB73F  0xD0 0x02       BNE 0xB743 (+2)         // if (Z)                            storage.asm:905
0xB741  0xE6 0x9D       INC 0x9D                // INC LoadBufferPosH                storage.asm:907
0xB743  0xE6 0x9E       INC 0x9E                // INC LoadBufferIndexL              storage.asm:909
0xB745  0xF0 0x01       BEQ 0xB748 (+1)         // if (Z)                            storage.asm:910
0xB747  0x60            RTS
0xB748  0xE6 0x9F       INC 0x9F                // INC LoadBufferIndexH              storage.asm:912
0xB74A  0x60            RTS                     // }                                 storage.asm:914

// /source/projects/6502sbc/hopperbasic/files/storage.asm:922
// ####  Storage.parseIdentifier()  ####                                        0x01BA

0xB74B  0x20 0x3B 0xB7  JSR 0xB73B              // nextToken();                      storage.asm:928
0xB74E  0xC9 0xDA       CMP # 0xDA              // CMP # Token.IDENTIFIER            storage.asm:929
0xB750  0xF0 0x05       BEQ 0xB757 (+5)         // if (NZ) { Error.InternalError(); BIT ZP.EmulatorPCL CLC break; }    IDENTIFIER expected
0xB752  0x20 0xCA 0x8B  JSR 0x8BCA
0xB755  0x18            CLC
0xB756  0x60            RTS
0xB757  0xA5 0x9E       LDA 0x9E                // LDA LoadBufferIndexL              storage.asm:932
0xB759  0x85 0x79       STA 0x79                // STA ZP.STRL                       storage.asm:933
0xB75B  0xA5 0x9F       LDA 0x9F                // LDA LoadBufferIndexH              storage.asm:934
0xB75D  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       storage.asm:935
0xB75F  0x20 0x3B 0xB7  JSR 0xB73B              // nextToken();                      storage.asm:937
0xB762  0x20 0x32 0x97  JSR 0x9732              // Char.IsAlpha();                   storage.asm:938
0xB765  0xB0 0x05       BCS 0xB76C (+5)         // if (NC) { Error.InternalError(); BIT ZP.EmulatorPCL CLC break; }    <alpha> expected
0xB767  0x20 0xCA 0x8B  JSR 0x8BCA
0xB76A  0x18            CLC
0xB76B  0x60            RTS
0xB76C  0x20 0x3B 0xB7  JSR 0xB73B              // nextToken();                      storage.asm:942
0xB76F  0xC9 0x00       CMP # 0                 // CMP #0                            storage.asm:943
0xB771  0xD0 0x02       BNE 0xB775 (+2)         // if (Z)                            storage.asm:944
0xB773  0x38            SEC                     // SEC                               storage.asm:947
0xB774  0x60            RTS                     // break;                            storage.asm:948
0xB775  0x20 0x40 0x97  JSR 0x9740              // Char.IsAlphaNumeric();            storage.asm:950
0xB778  0xB0 0xF2       BCS 0xB76C (-14)        // if (NC) {  Error.InternalError(); BIT ZP.EmulatorPCL CLC break; }    <alphanumeric> expected
0xB77A  0x20 0xCA 0x8B  JSR 0x8BCA
0xB77D  0x18            CLC
0xB77E  0x60            RTS

// /source/projects/6502sbc/hopperbasic/files/storage.asm:963
// ####  Storage.parseTokenStream()  ####                                       0x01BB

0xB77F  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       storage.asm:967
0xB781  0x48            PHA                     // PHA                               storage.asm:968
0xB782  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       storage.asm:969
0xB784  0x48            PHA                     // PHA                               storage.asm:970
0xB785  0xA5 0x9E       LDA 0x9E                // LDA LoadBufferIndexL              storage.asm:975
0xB787  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            storage.asm:976
0xB789  0xA5 0x9F       LDA 0x9F                // LDA LoadBufferIndexH              storage.asm:977
0xB78B  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            storage.asm:978
0xB78D  0x20 0x3B 0xB7  JSR 0xB73B              // nextToken();                      storage.asm:981
0xB790  0xC5 0x0E       CMP 0x0E                // CMP ZP.ACCL                       storage.asm:982
0xB792  0xD0 0xF9       BNE 0xB78D (-7)         // if (Z) { break; }                 storage.asm:983
0xB794  0x38            SEC                     // SEC                               storage.asm:987
0xB795  0xA5 0x9E       LDA 0x9E                // LDA LoadBufferIndexL              storage.asm:988
0xB797  0xE9 0x01       SBC # 1                 // SBC # 1                           storage.asm:989
0xB799  0x85 0x65       STA 0x65                // STA ZP.FLENGTHL                   storage.asm:990
0xB79B  0xA5 0x9F       LDA 0x9F                // LDA LoadBufferIndexH              storage.asm:991
0xB79D  0xE9 0x00       SBC # 0                 // SBC # 0                           storage.asm:992
0xB79F  0x85 0x66       STA 0x66                // STA ZP.FLENGTHH                   storage.asm:993
0xB7A1  0xA9 0xDB       LDA # 0xDB              // LDA # Token.EOF                   storage.asm:994
0xB7A3  0x92 0x65       STA [0x65]              // STA [ZP.FLENGTH]    patch terminator -> EOF
0xB7A5  0x38            SEC                     // SEC                               storage.asm:997
0xB7A6  0xA5 0x65       LDA 0x65                // LDA ZP.FLENGTHL                   storage.asm:998
0xB7A8  0xE5 0x61       SBC 0x61                // SBC ZP.FSOURCEADDRESSL            storage.asm:999
0xB7AA  0x85 0x65       STA 0x65                // STA ZP.FLENGTHL                   storage.asm:1000
0xB7AC  0xA5 0x66       LDA 0x66                // LDA ZP.FLENGTHH                   storage.asm:1001
0xB7AE  0xE5 0x62       SBC 0x62                // SBC ZP.FSOURCEADDRESSH            storage.asm:1002
0xB7B0  0x85 0x66       STA 0x66                // STA ZP.FLENGTHH                   storage.asm:1003
0xB7B2  0x20 0x89 0x93  JSR 0x9389              // IncLENGTH();                      storage.asm:1005
0xB7B5  0xA5 0x65       LDA 0x65                // LDA ZP.FLENGTHL                   storage.asm:1008
0xB7B7  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       storage.asm:1009
0xB7B9  0xA5 0x66       LDA 0x66                // LDA ZP.FLENGTHH                   storage.asm:1010
0xB7BB  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       storage.asm:1011
0xB7BD  0x20 0x97 0x92  JSR 0x9297              // Memory.Allocate();    Input: ZP.ACC = size, Munts: ZP.M*, ZP.FREELIST, ZP.ACCL, -> ZP.IDX
0xB7C0  0x90 0x10       BCC 0xB7D2 (+16)        // if (NC) { BIT ZP.EmulatorPCL break; }
0xB7C2  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       storage.asm:1027
0xB7C4  0x85 0x63       STA 0x63                // STA ZP.FDESTINATIONADDRESSL       storage.asm:1028
0xB7C6  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       storage.asm:1029
0xB7C8  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       storage.asm:1030
0xB7CA  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       storage.asm:1031
0xB7CC  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       storage.asm:1032
0xB7CE  0x20 0x0B 0x93  JSR 0x930B              // Memory.Copy();                    storage.asm:1034
0xB7D1  0x38            SEC                     // SEC                               storage.asm:1036
0xB7D2  0x68            PLA                     // PLA                               storage.asm:1040
0xB7D3  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       storage.asm:1041
0xB7D5  0x68            PLA                     // PLA                               storage.asm:1042
0xB7D6  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       storage.asm:1043
0xB7D8  0x60            RTS                     // }                                 storage.asm:1048

// /source/projects/6502sbc/hopperbasic/files/storage.asm:1053
// ####  Storage.parseVariableOrConst()  ####                                   0x01BC

0xB7D9  0xAA            TAX                     // TAX                               storage.asm:1059
0xB7DA  0x20 0x00 0x88  JSR 0x8800              // BASICTypes.FromToken();    X -> A storage.asm:1060
0xB7DD  0xB0 0x03       BCS 0xB7E2 (+3)         // if (NC) { Error.InternalError(); BIT ZP.EmulatorPCL break; }    <type> expected
0xB7DF  0x4C 0xCA 0x8B  JMP 0x8BCA
0xB7E2  0x1F 0xA2 0x04  BBR1 0xA2, 0xB7E9 (+4)  // if (BBS1, LoaderFlags)            storage.asm:1062
0xB7E5  0x09 0x80       ORA # 0x80              // ORA # SymbolType.CONSTANT         storage.asm:1064
0xB7E7  0x80 0x02       BRA 0xB7EB (+2)         // }                                 storage.asm:1065
0xB7E9  0x09 0x40       ORA # 0x40              // ORA # SymbolType.VARIABLE         storage.asm:1068
0xB7EB  0x85 0x10       STA 0x10                // STA ZP.ACCT                       storage.asm:1070
0xB7ED  0x20 0x4B 0xB7  JSR 0xB74B              // parseIdentifier();                storage.asm:1073
0xB7F0  0xB0 0x01       BCS 0xB7F3 (+1)         // if (NC) { break; }                storage.asm:1074
0xB7F2  0x60            RTS
0xB7F3  0x64 0x16       STZ 0x16                // STZ ZP.NEXTL                      storage.asm:1077
0xB7F5  0x64 0x17       STZ 0x17                // STZ ZP.NEXTH                      storage.asm:1078
0xB7F7  0x20 0x3B 0xB7  JSR 0xB73B              // nextToken();                      storage.asm:1080
0xB7FA  0xC9 0xDC       CMP # 0xDC              // CMP # Token.EOL                   storage.asm:1081
0xB7FC  0xD0 0x03       BNE 0xB801 (+3)         // if (Z)                            storage.asm:1082
0xB7FE  0x20 0x3B 0xB7  JSR 0xB73B              // nextToken();                      storage.asm:1084
0xB801  0xC9 0xF0       CMP # 0xF0              // case Token.LBRACKET:              storage.asm:1088
0xB803  0xD0 0x1D       BNE 0xB822 (+29)
0xB805  0xA9 0xF1       LDA # 0xF1              // LDA # Token.RBRACKET    terminator
0xB807  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       storage.asm:1092
0xB809  0x20 0x7F 0xB7  JSR 0xB77F              // parseTokenStream();    -> IDY     storage.asm:1093
0xB80C  0xB0 0x01       BCS 0xB80F (+1)         // if (NC) { break; }                storage.asm:1094
0xB80E  0x60            RTS
0xB80F  0x20 0x3B 0xB7  JSR 0xB73B              // nextToken();                      storage.asm:1096
0xB812  0xC9 0xDD       CMP # 0xDD              // CMP # Token.EOE    RBRACKET already converted to EOF
0xB814  0xB0 0x03       BCS 0xB819 (+3)         // if (NC) { Error.InternalError(); BIT ZP.EmulatorPCL break; }    <type> expected
0xB816  0x4C 0xCA 0x8B  JMP 0x8BCA
0xB819  0xD7 0x10       SMB5 0x10               // STA ZP.ACCT                       storage.asm:1102
0xB81B  0xA9 0x0A       LDA # 0x0A              // LDA #10                           storage.asm:1105
0xB81D  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      storage.asm:1106
0xB81F  0x18            CLC                     // CLC                               storage.asm:1107
0xB820  0x80 0x37       BRA 0xB859 (+55)        // }                                 storage.asm:1108
0xB822  0xC9 0xDD       CMP # 0xDD              // case Token.EOE:                   storage.asm:1109
0xB824  0xD0 0x26       BNE 0xB84C (+38)
0xB826  0x64 0x1D       STZ 0x1D                // STZ ZP.IDYL                       storage.asm:1112
0xB828  0x64 0x1E       STZ 0x1E                // STZ ZP.IDYH                       storage.asm:1113
0xB82A  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       storage.asm:1115
0xB82C  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          storage.asm:1116
0xB82E  0xC9 0x05       CMP # 0x05              // CMP # BASICType.STRING            storage.asm:1117
0xB830  0xD0 0x27       BNE 0xB859 (+39)        // if (Z)                            storage.asm:1118
0xB832  0xA9 0xC3       LDA # 0xC3              // LDA #(Variables.EmptyString % 256)
0xB834  0x85 0x11       STA 0x11                // STA ZP.TOPL                       storage.asm:1122
0xB836  0xA9 0x83       LDA # 0x83              // LDA #(Variables.EmptyString / 256)
0xB838  0x85 0x12       STA 0x12                // STA ZP.TOPH                       storage.asm:1124
0xB83A  0x20 0x97 0xA3  JSR 0xA397              // Variables.AllocateAndCopyString();    Input: ZP.TOP = source, Output: ZP.IDY = allocated copy
0xB83D  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     storage.asm:1127
0xB840  0x90 0x29       BCC 0xB86B (+41)        // if (NC) { break; }    allocation failed
0xB842  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       storage.asm:1131
0xB844  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      storage.asm:1132
0xB846  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       storage.asm:1133
0xB848  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      storage.asm:1134
0xB84A  0x80 0x0D       BRA 0xB859 (+13)        // }                                 storage.asm:1136
0xB84C  0xC9 0xE1       CMP # 0xE1              // case Token.EQUALS:                storage.asm:1137
0xB84E  0xD0 0x09       BNE 0xB859 (+9)
0xB850  0xA9 0xDD       LDA # 0xDD              // LDA # Token.EOE    terminator     storage.asm:1140
0xB852  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       storage.asm:1141
0xB854  0x20 0x7F 0xB7  JSR 0xB77F              // parseTokenStream();    -> IDY     storage.asm:1142
0xB857  0x90 0x12       BCC 0xB86B (+18)        // if (NC) { break; }                storage.asm:1143
0xB859  0x17 0xA2       RMB1 0xA2               // RMB1 LoaderFlags                  storage.asm:1154
0xB85B  0x20 0x55 0xF6  JSR 0xF655              // MoveSTRtoTOP();                   storage.asm:1157
0xB85E  0x20 0xF5 0xA0  JSR 0xA0F5              // Variables.Declare();    -> C or NC
0xB861  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     storage.asm:1160
0xB864  0x90 0x01       BCC 0xB867 (+1)         // if (NC)                           storage.asm:1161
0xB866  0x60            RTS
0xB867  0x20 0xCA 0x8B  JSR 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL CLC    what's this?
0xB86A  0x18            CLC
0xB86B  0x60            RTS                     // }                                 storage.asm:1170

// /source/projects/6502sbc/hopperbasic/files/storage.asm:1174
// ####  Storage.parseMainHeader()  ####                                        0x01BD

0xB86C  0x64 0x16       STZ 0x16                // STZ ZP.NEXTL                      storage.asm:1181
0xB86E  0x64 0x17       STZ 0x17                // STZ ZP.NEXTH                      storage.asm:1182
0xB870  0x20 0x16 0x86  JSR 0x8616              // Messages.Main();    point ZP.TOP -> "$MAIN"
0xB873  0x64 0x1D       STZ 0x1D                // STZ ZP.IDYL                       storage.asm:1186
0xB875  0x64 0x1E       STZ 0x1E                // STZ ZP.IDYH                       storage.asm:1187
0xB877  0x20 0x5F 0xA7  JSR 0xA75F              // Functions.Declare();              storage.asm:1188
0xB87A  0x4C 0x59 0x8C  JMP 0x8C59              // CheckError();                     storage.asm:1189

// /source/projects/6502sbc/hopperbasic/files/storage.asm:1200
// ####  Storage.parseFunctionHeader()  ####                                    0x01BE

0xB87D  0x20 0x4B 0xB7  JSR 0xB74B              // parseIdentifier();                storage.asm:1207
0xB880  0x90 0x41       BCC 0xB8C3 (+65)        // if (NC) { break; }                storage.asm:1208
0xB882  0x20 0x55 0xF6  JSR 0xF655              // MoveSTRtoTOP();                   storage.asm:1211
0xB885  0x64 0x16       STZ 0x16                // STZ ZP.NEXTL                      storage.asm:1214
0xB887  0x64 0x17       STZ 0x17                // STZ ZP.NEXTH                      storage.asm:1215
0xB889  0x64 0x1D       STZ 0x1D                // STZ ZP.IDYL                       storage.asm:1217
0xB88B  0x64 0x1E       STZ 0x1E                // STZ ZP.IDYH                       storage.asm:1218
0xB88D  0x20 0x5F 0xA7  JSR 0xA75F              // Functions.Declare();              storage.asm:1219
0xB890  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     storage.asm:1220
0xB893  0x90 0x2E       BCC 0xB8C3 (+46)        // if (NC) { break; }                storage.asm:1221
0xB895  0x20 0x3B 0xB7  JSR 0xB73B              // nextToken();                      storage.asm:1223
0xB898  0xC9 0xE4       CMP # 0xE4              // CMP # Token.LPAREN                storage.asm:1224
0xB89A  0xF0 0x03       BEQ 0xB89F (+3)         // if (NZ) { Error.InternalError(); BIT ZP.EmulatorPCL break; }    ( expected
0xB89C  0x4C 0xCA 0x8B  JMP 0x8BCA
0xB89F  0xB2 0x9E       LDA [0x9E]              // peekToken();                      storage.asm:1228
0xB8A1  0xC9 0xE5       CMP # 0xE5              // CMP # Token.RPAREN                storage.asm:1229
0xB8A3  0xD0 0x03       BNE 0xB8A8 (+3)         // if (Z)                            storage.asm:1230
0xB8A5  0x4C 0x3B 0xB7  JMP 0xB73B              // nextToken();    consume )         storage.asm:1232
0xB8A8  0xC9 0xDF       CMP # 0xDF              // CMP # Token.COMMA                 storage.asm:1235
0xB8AA  0xD0 0x03       BNE 0xB8AF (+3)         // if (Z)                            storage.asm:1236
0xB8AC  0x20 0x3B 0xB7  JSR 0xB73B              // nextToken();    consume ,         storage.asm:1238
0xB8AF  0x20 0x4B 0xB7  JSR 0xB74B              // parseIdentifier();                storage.asm:1242
0xB8B2  0x20 0x55 0xF6  JSR 0xF655              // MoveSTRtoTOP();                   storage.asm:1245
0xB8B5  0xA9 0x40       LDA # 0x40              // LDA #SymbolType.ARGUMENT          storage.asm:1247
0xB8B7  0x09 0x10       ORA # 0x10              // ORA #BASICType.VAR                storage.asm:1248
0xB8B9  0x85 0x40       STA 0x40                // STA ZP.SymbolType    argument for Locals.Add()
0xB8BB  0x20 0x98 0xA4  JSR 0xA498              // Locals.Add();                     storage.asm:1250
0xB8BE  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     storage.asm:1251
0xB8C1  0xB0 0xDC       BCS 0xB89F (-36)        // if (NC) { break; }                storage.asm:1252
0xB8C3  0x60            RTS                     // }                                 storage.asm:1261

// /source/projects/6502sbc/hopperbasic/files/storage.asm:1265
// ####  Storage.parseFunctionOrMain()  ####                                    0x01BF

0xB8C4  0x8F 0xA2 0x05  BBS0 0xA2, 0xB8CC (+5)  // if (BBR0, LoaderFlags)    have not seen EOF yet
0xB8C7  0x20 0xE4 0xB8  JSR 0xB8E4              // slideWindow();                    storage.asm:1274
0xB8CA  0x90 0x15       BCC 0xB8E1 (+21)        // if (NC) { break; }                storage.asm:1275
0xB8CC  0x2F 0xA2 0x06  BBR2 0xA2, 0xB8D5 (+6)  // if (BBS2, LoaderFlags)            storage.asm:1279
0xB8CF  0xA9 0xA9       LDA # 0xA9              // LDA # Token.END    terminator     storage.asm:1281
0xB8D1  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       storage.asm:1282
0xB8D3  0x80 0x04       BRA 0xB8D9 (+4)         // }                                 storage.asm:1283
0xB8D5  0xA9 0xA6       LDA # 0xA6              // LDA #Token.ENDFUNC    terminator  storage.asm:1286
0xB8D7  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       storage.asm:1287
0xB8D9  0x20 0x7F 0xB7  JSR 0xB77F              // parseTokenStream();    -> IDY     storage.asm:1289
0xB8DC  0x90 0x03       BCC 0xB8E1 (+3)         // if (NC) { break; }                storage.asm:1290
0xB8DE  0x20 0x6C 0xA8  JSR 0xA86C              // Functions.SetBody();              storage.asm:1292
0xB8E1  0x27 0xA2       RMB2 0xA2               // RMB2 LoaderFlags                  storage.asm:1295
0xB8E3  0x60            RTS                     // }                                 storage.asm:1300

// /source/projects/6502sbc/hopperbasic/files/storage.asm:1306
// ####  Storage.slideWindow()  ####                                            0x01C0

0xB8E4  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       storage.asm:1310
0xB8E6  0x48            PHA                     // PHA                               storage.asm:1311
0xB8E7  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       storage.asm:1312
0xB8E9  0x48            PHA                     // PHA                               storage.asm:1313
0xB8EA  0x64 0x63       STZ 0x63                // STA ZP.FDESTINATIONADDRESSL       storage.asm:1317
0xB8EC  0xA9 0x0C       LDA # 0x0C              // LDA #(LoadBuffer / 256)           storage.asm:1318
0xB8EE  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       storage.asm:1319
0xB8F0  0x18            CLC                     // CLC                               storage.asm:1321
0xB8F1  0xA5 0x63       LDA 0x63                // LDA ZP.FDESTINATIONADDRESSL       storage.asm:1322
0xB8F3  0x65 0x9C       ADC 0x9C                // ADC LoadBufferPosL                storage.asm:1323
0xB8F5  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            storage.asm:1324
0xB8F7  0xA5 0x64       LDA 0x64                // LDA ZP.FDESTINATIONADDRESSH       storage.asm:1325
0xB8F9  0x65 0x9D       ADC 0x9D                // ADC LoadBufferPosH                storage.asm:1326
0xB8FB  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            storage.asm:1327
0xB8FD  0x38            SEC                     // SEC                               storage.asm:1329
0xB8FE  0xA5 0xA0       LDA 0xA0                // LDA LoadBufferLengthL             storage.asm:1330
0xB900  0xE5 0x9C       SBC 0x9C                // SBC LoadBufferPosL                storage.asm:1331
0xB902  0x85 0xA0       STA 0xA0                // STA LoadBufferLengthL             storage.asm:1332
0xB904  0xA5 0xA1       LDA 0xA1                // LDA LoadBufferLengthH             storage.asm:1333
0xB906  0xE5 0x9D       SBC 0x9D                // SBC LoadBufferPosH                storage.asm:1334
0xB908  0x85 0xA1       STA 0xA1                // STA LoadBufferLengthH             storage.asm:1335
0xB90A  0x64 0x9E       STZ 0x9E                // STA LoadBufferIndexL              storage.asm:1338
0xB90C  0xA9 0x0C       LDA # 0x0C              // LDA #(LoadBuffer / 256)           storage.asm:1339
0xB90E  0x85 0x9F       STA 0x9F                // STA LoadBufferIndexH              storage.asm:1340
0xB910  0x64 0x9C       STZ 0x9C                // STZ LoadBufferPosL                storage.asm:1341
0xB912  0x64 0x9D       STZ 0x9D                // STZ LoadBufferPosH                storage.asm:1342
0xB914  0xA5 0xA0       LDA 0xA0                // LDA LoadBufferLengthL             storage.asm:1345
0xB916  0x85 0x65       STA 0x65                // STA ZP.FLENGTHL                   storage.asm:1346
0xB918  0xA5 0xA1       LDA 0xA1                // LDA LoadBufferLengthH             storage.asm:1347
0xB91A  0x85 0x66       STA 0x66                // STA ZP.FLENGTHH                   storage.asm:1348
0xB91C  0x20 0x0B 0x93  JSR 0x930B              // Memory.Copy();                    storage.asm:1350
0xB91F  0x0F 0xA2 0x03  BBR0 0xA2, 0xB925 (+3)  // if (BBS0, LoaderFlags)       { SEC break; }    no more data to read
0xB922  0x38            SEC
0xB923  0x80 0x1D       BRA 0xB942 (+29)
0xB925  0xA5 0xA1       LDA 0xA1                // LDA LoadBufferLengthH             storage.asm:1358
0xB927  0xC9 0x05       CMP # 0x05              // CMP #0x05                         storage.asm:1359
0xB929  0x90 0x03       BCC 0xB92E (+3)         // if (C) { SEC break; }    current data >= 1280 bytes (potentially less than 256 bytes remaining in our buffer space)
0xB92B  0x38            SEC
0xB92C  0x80 0x14       BRA 0xB942 (+20)
0xB92E  0x20 0x03 0xB1  JSR 0xB103              // File.NextStream();                storage.asm:1361
0xB931  0xB0 0x0A       BCS 0xB93D (+10)        // if (NC)                           storage.asm:1362
0xB933  0x20 0xAE 0x89  JSR 0x89AE              // States.IsSuccess();               storage.asm:1364
0xB936  0x90 0x0A       BCC 0xB942 (+10)        // if (C)                            storage.asm:1365
0xB938  0x38            SEC                     // SEC                               storage.asm:1368
0xB939  0x87 0xA2       SMB0 0xA2               // SMB0 LoaderFlags                  storage.asm:1369
0xB93B  0x80 0x05       BRA 0xB942 (+5)         // break;                            storage.asm:1371
0xB93D  0x20 0x77 0xB9  JSR 0xB977              // appendSectorToBuffer();           storage.asm:1373
0xB940  0x80 0xDD       BRA 0xB91F (-35)        // }                                 storage.asm:1376
0xB942  0x68            PLA                     // PLA                               storage.asm:1378
0xB943  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       storage.asm:1379
0xB945  0x68            PLA                     // PLA                               storage.asm:1380
0xB946  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       storage.asm:1381
0xB948  0x60            RTS                     // }                                 storage.asm:1386

// /source/projects/6502sbc/hopperbasic/files/storage.asm:1392
// ####  Storage.setupSlidingWindowBuffer()  ####                               0x01C1

0xB949  0x64 0x9C       STZ 0x9C                // STZ LoadBufferPosL                storage.asm:1397
0xB94B  0x64 0x9D       STZ 0x9D                // STZ LoadBufferPosH                storage.asm:1398
0xB94D  0x64 0xA0       STZ 0xA0                // STZ LoadBufferLengthL             storage.asm:1399
0xB94F  0x64 0xA1       STZ 0xA1                // STZ LoadBufferLengthH             storage.asm:1400
0xB951  0x64 0x9E       STZ 0x9E                // STA LoadBufferIndexL              storage.asm:1402
0xB953  0xA9 0x0C       LDA # 0x0C              // LDA #(LoadBuffer / 256)           storage.asm:1403
0xB955  0x85 0x9F       STA 0x9F                // STA LoadBufferIndexH              storage.asm:1404
0xB957  0xA2 0x0A       LDX # 0x0A              // LDX #(LoadBufferSize / 256)       storage.asm:1409
0xB959  0x20 0x03 0xB1  JSR 0xB103              // File.NextStream();                storage.asm:1413
0xB95C  0xB0 0x09       BCS 0xB967 (+9)         // if (NC)                           storage.asm:1414
0xB95E  0x20 0xAE 0x89  JSR 0x89AE              // States.IsSuccess();               storage.asm:1416
0xB961  0x90 0x0A       BCC 0xB96D (+10)        // if (C)                            storage.asm:1417
0xB963  0x87 0xA2       SMB0 0xA2               // SMB0 LoaderFlags                  storage.asm:1420
0xB965  0x80 0x06       BRA 0xB96D (+6)         // break;                            storage.asm:1422
0xB967  0x20 0x77 0xB9  JSR 0xB977              // appendSectorToBuffer();           storage.asm:1425
0xB96A  0xCA            DEX                     // DEX                               storage.asm:1429
0xB96B  0xD0 0xEC       BNE 0xB959 (-20)        // if (Z) { break; }    Buffer full  storage.asm:1430
0xB96D  0xA5 0xA0       LDA 0xA0                // LDA LoadBufferLengthL             storage.asm:1434
0xB96F  0x05 0xA1       ORA 0xA1                // ORA LoadBufferLengthH             storage.asm:1435
0xB971  0xD0 0x02       BNE 0xB975 (+2)         // if (Z) { CLC return; }    Empty file
0xB973  0x18            CLC
0xB974  0x60            RTS
0xB975  0x38            SEC                     // SEC    Success                    storage.asm:1438
0xB976  0x60            RTS                     // }                                 storage.asm:1442

// /source/projects/6502sbc/hopperbasic/files/storage.asm:1449
// ####  Storage.appendSectorToBuffer()  ####                                   0x01C2

0xB977  0x18            CLC                     // CLC                               storage.asm:1457
0xB978  0xA9 0x00       LDA # 0                 // LDA #(LoadBuffer % 256)           storage.asm:1458
0xB97A  0x65 0xA0       ADC 0xA0                // ADC LoadBufferLengthL             storage.asm:1459
0xB97C  0x85 0x63       STA 0x63                // STA ZP.FDESTINATIONADDRESSL       storage.asm:1460
0xB97E  0xA9 0x0C       LDA # 0x0C              // LDA #(LoadBuffer / 256)           storage.asm:1461
0xB980  0x65 0xA1       ADC 0xA1                // ADC LoadBufferLengthH             storage.asm:1462
0xB982  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       storage.asm:1463
0xB984  0x64 0x61       STZ 0x61                // STA ZP.FSOURCEADDRESSL            storage.asm:1468
0xB986  0xA9 0x1A       LDA # 0x1A              // LDA #(File.FileDataBuffer / 256)  storage.asm:1469
0xB988  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            storage.asm:1470
0xB98A  0xA5 0x8E       LDA 0x8E                // LDA File.TransferLengthL          storage.asm:1473
0xB98C  0x85 0x65       STA 0x65                // STA ZP.FLENGTHL                   storage.asm:1474
0xB98E  0xA5 0x8F       LDA 0x8F                // LDA File.TransferLengthH          storage.asm:1475
0xB990  0x85 0x66       STA 0x66                // STA ZP.FLENGTHH                   storage.asm:1476
0xB992  0x20 0x0B 0x93  JSR 0x930B              // Memory.Copy();                    storage.asm:1482
0xB995  0x18            CLC                     // CLC                               storage.asm:1486
0xB996  0xA5 0xA0       LDA 0xA0                // LDA LoadBufferLengthL             storage.asm:1487
0xB998  0x65 0x8E       ADC 0x8E                // ADC File.TransferLengthL          storage.asm:1488
0xB99A  0x85 0xA0       STA 0xA0                // STA LoadBufferLengthL             storage.asm:1489
0xB99C  0xA5 0xA1       LDA 0xA1                // LDA LoadBufferLengthH             storage.asm:1490
0xB99E  0x65 0x8F       ADC 0x8F                // ADC File.TransferLengthH          storage.asm:1491
0xB9A0  0x85 0xA1       STA 0xA1                // STA LoadBufferLengthH             storage.asm:1492
0xB9A2  0x60            RTS                     // }                                 storage.asm:1548

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:18
// ####  Tokenizer.Initialize()  ####                                           0x01C3

0xB9A3  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL              tokenizer.asm:19
0xB9A5  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              tokenizer.asm:20
0xB9A7  0x20 0xE0 0x96  JSR 0x96E0              // BufferManager.ResetTokenizerBuffer();
0xB9AA  0x64 0x28       STZ 0x28                // STZ ZP.BasicInputLength           tokenizer.asm:22
0xB9AC  0x64 0x2F       STZ 0x2F                // STZ ZP.CurrentToken               tokenizer.asm:23
0xB9AE  0x64 0x30       STZ 0x30                // STZ ZP.TokenLiteralPosL           tokenizer.asm:24
0xB9B0  0x64 0x31       STZ 0x31                // STZ ZP.TokenLiteralPosH           tokenizer.asm:25
0xB9B2  0x60            RTS                     // }                                 tokenizer.asm:26

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:33
// ####  Tokenizer.setTokenizerPointer()  ####                                  0x01C4

0xB9B3  0x18            CLC                     // CLC                               tokenizer.asm:34
0xB9B4  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               tokenizer.asm:35
0xB9B6  0x65 0x2B       ADC 0x2B                // ADC ZP.TokenizerPosL              tokenizer.asm:36
0xB9B8  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       tokenizer.asm:37
0xB9BA  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               tokenizer.asm:38
0xB9BC  0x65 0x2C       ADC 0x2C                // ADC ZP.TokenizerPosH              tokenizer.asm:39
0xB9BE  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       tokenizer.asm:40
0xB9C0  0x60            RTS                     // }                                 tokenizer.asm:41

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:48
// ####  Tokenizer.setTokenBufferEndPointer()  ####                             0x01C5

0xB9C1  0x18            CLC                     // CLC                               tokenizer.asm:49
0xB9C2  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               tokenizer.asm:50
0xB9C4  0x65 0x29       ADC 0x29                // ADC ZP.TokenBufferContentLengthL  tokenizer.asm:51
0xB9C6  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       tokenizer.asm:52
0xB9C8  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               tokenizer.asm:53
0xB9CA  0x65 0x2A       ADC 0x2A                // ADC ZP.TokenBufferContentLengthH  tokenizer.asm:54
0xB9CC  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       tokenizer.asm:55
0xB9CE  0x60            RTS                     // }                                 tokenizer.asm:56

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:63
// ####  Tokenizer.incrementTokenizerPos()  ####                                0x01C6

0xB9CF  0xE6 0x2B       INC 0x2B                // INC ZP.TokenizerPosL              tokenizer.asm:64
0xB9D1  0xF0 0x01       BEQ 0xB9D4 (+1)         // if (Z)                            tokenizer.asm:65
0xB9D3  0x60            RTS
0xB9D4  0xE6 0x2C       INC 0x2C                // INC ZP.TokenizerPosH              tokenizer.asm:67
0xB9D6  0x60            RTS                     // }                                 tokenizer.asm:69

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:76
// ####  Tokenizer.incrementTokenBufferContentLength()  ####                    0x01C7

0xB9D7  0xE6 0x29       INC 0x29                // INC ZP.TokenBufferContentLengthL  tokenizer.asm:77
0xB9D9  0xF0 0x01       BEQ 0xB9DC (+1)         // if (Z)                            tokenizer.asm:78
0xB9DB  0x60            RTS
0xB9DC  0xE6 0x2A       INC 0x2A                // INC ZP.TokenBufferContentLengthH  tokenizer.asm:80
0xB9DE  0x60            RTS                     // }                                 tokenizer.asm:82

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:89
// ####  Tokenizer.CompareTokenizerPosToLength()  ####                          0x01C8

0xB9DF  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              tokenizer.asm:90
0xB9E1  0xC5 0x2A       CMP 0x2A                // CMP ZP.TokenBufferContentLengthH  tokenizer.asm:91
0xB9E3  0xF0 0x01       BEQ 0xB9E6 (+1)         // if (NZ) { return; }     Not equal, C flag is correct
0xB9E5  0x60            RTS
0xB9E6  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              tokenizer.asm:95
0xB9E8  0xC5 0x29       CMP 0x29                // CMP ZP.TokenBufferContentLengthL  tokenizer.asm:96
0xB9EA  0x60            RTS                     // }                                 tokenizer.asm:97

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:104
// ####  Tokenizer.skipWhitespace()  ####                                       0x01C9

0xB9EB  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:107
0xB9ED  0xF0 0x12       BEQ 0xBA01 (+18)        // if (Z) { break; }     End of input
0xB9EF  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:110
0xB9F2  0xC9 0x20       CMP # 0x20              // CMP #' '                          tokenizer.asm:111
0xB9F4  0xD0 0x03       BNE 0xB9F9 (+3)         // if (Z)                            tokenizer.asm:112
0xB9F6  0xE8            INX                     // INX                               tokenizer.asm:114
0xB9F7  0x80 0xF2       BRA 0xB9EB (-14)        // continue;                         tokenizer.asm:115
0xB9F9  0xC9 0x09       CMP # 0x09              // CMP #'\t'                         tokenizer.asm:117
0xB9FB  0xF0 0x01       BEQ 0xB9FE (+1)         // if (Z)                            tokenizer.asm:118
0xB9FD  0x60            RTS
0xB9FE  0xE8            INX                     // INX                               tokenizer.asm:120
0xB9FF  0x80 0xEA       BRA 0xB9EB (-22)        // continue;                         tokenizer.asm:121
0xBA01  0x60            RTS                     // }                                 tokenizer.asm:125

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:135
// ####  Tokenizer.appendToTokenBuffer()  ####                                  0x01CA

0xBA02  0x48            PHA                     // PHA     Save byte to append       tokenizer.asm:136
0xBA03  0xA5 0x2A       LDA 0x2A                // LDA ZP.TokenBufferContentLengthH  tokenizer.asm:141
0xBA05  0xC9 0x08       CMP # 0x08              // CMP #(Limits.TokenizerBufferSize >> 8)
0xBA07  0x90 0x14       BCC 0xBA1D (+20)        // if (C)    ContentSizeH >= LimitH  tokenizer.asm:143
0xBA09  0xF0 0x06       BEQ 0xBA11 (+6)         // if (NZ)     ContentSizeH > LimitH (not equal)
0xBA0B  0x20 0x2E 0x8C  JSR 0x8C2E              // Error.BufferOverflow(); BIT ZP.EmulatorPCL
0xBA0E  0x18            CLC                     // CLC                               tokenizer.asm:148
0xBA0F  0x80 0x10       BRA 0xBA21 (+16)        // break;                            tokenizer.asm:149
0xBA11  0xA5 0x29       LDA 0x29                // LDA ZP.TokenBufferContentLengthL  tokenizer.asm:152
0xBA13  0xC9 0x00       CMP # 0                 // CMP #(Limits.TokenizerBufferSize & 0xFF)
0xBA15  0x90 0x06       BCC 0xBA1D (+6)         // if (C)     ContentSizeL >= LimitL tokenizer.asm:154
0xBA17  0x20 0x2E 0x8C  JSR 0x8C2E              // Error.BufferOverflow(); BIT ZP.EmulatorPCL
0xBA1A  0x18            CLC                     // CLC                               tokenizer.asm:157
0xBA1B  0x80 0x04       BRA 0xBA21 (+4)         // break;                            tokenizer.asm:158
0xBA1D  0x20 0xC1 0xB9  JSR 0xB9C1              // setTokenBufferEndPointer();       tokenizer.asm:163
0xBA20  0x38            SEC                     // SEC    all good                   tokenizer.asm:164
0xBA21  0x68            PLA                     // PLA     Get byte to store         tokenizer.asm:168
0xBA22  0xB0 0x01       BCS 0xBA25 (+1)         // if (C)                            tokenizer.asm:169
0xBA24  0x60            RTS
0xBA25  0x92 0x1B       STA [0x1B]              // STA [ZP.IDX]                      tokenizer.asm:171
0xBA27  0x20 0xD7 0xB9  JSR 0xB9D7              // incrementTokenBufferContentLength();
0xBA2A  0x38            SEC                     // SEC    all good                   tokenizer.asm:175
0xBA2B  0x60            RTS                     // }                                 tokenizer.asm:177

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:180
// ####  Tokenizer.scanHexNumber()  ####                                        0x01CB

0xBA2C  0xA9 0xD7       LDA # 0xD7              // LDA #Token.NUMBER                 tokenizer.asm:182
0xBA2E  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:183
0xBA31  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:184
0xBA34  0xB0 0x01       BCS 0xBA37 (+1)         // if (NC) { return; }               tokenizer.asm:185
0xBA36  0x60            RTS
0xBA37  0xA9 0x30       LDA # 0x30              // LDA #'0'                          tokenizer.asm:188
0xBA39  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:189
0xBA3C  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:190
0xBA3F  0xB0 0x01       BCS 0xBA42 (+1)         // if (NC) { return; }               tokenizer.asm:191
0xBA41  0x60            RTS
0xBA42  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X     'x' or 'X'
0xBA45  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:194
0xBA48  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:195
0xBA4B  0xB0 0x01       BCS 0xBA4E (+1)         // if (NC) { return; }               tokenizer.asm:196
0xBA4D  0x60            RTS
0xBA4E  0xE8            INX                     // INX                               tokenizer.asm:197
0xBA4F  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:202
0xBA51  0xF0 0x17       BEQ 0xBA6A (+23)        // if (Z) { break; }                 tokenizer.asm:203
0xBA53  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:205
0xBA56  0x20 0x5C 0x97  JSR 0x975C              // Char.IsHex();                     tokenizer.asm:206
0xBA59  0x90 0x0F       BCC 0xBA6A (+15)        // if (NC) { break; }     Not hex digit
0xBA5B  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:209
0xBA5E  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:210
0xBA61  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:211
0xBA64  0xB0 0x01       BCS 0xBA67 (+1)         // if (NC) { return; }               tokenizer.asm:212
0xBA66  0x60            RTS
0xBA67  0xE8            INX                     // INX                               tokenizer.asm:213
0xBA68  0x80 0xE5       BRA 0xBA4F (-27)        // }                                 tokenizer.asm:214
0xBA6A  0xA9 0x00       LDA # 0                 // LDA #0                            tokenizer.asm:217
0xBA6C  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:218
0xBA6F  0x4C 0x59 0x8C  JMP 0x8C59              // CheckError();                     tokenizer.asm:219

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:229
// ####  Tokenizer.processEscapeCharacter()  ####                               0x01CC

0xBA72  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X     Get current character
0xBA75  0xC9 0x5C       CMP # 0x5C              // CMP #'\\'                         tokenizer.asm:233
0xBA77  0xF0 0x09       BEQ 0xBA82 (+9)         // if (NZ)    Not an escape sequence, return character as-is
0xBA79  0xC9 0x80       CMP # 0x80              // CMP #0x80                         tokenizer.asm:237
0xBA7B  0x90 0x57       BCC 0xBAD4 (+87)        // if (C)     >= 128, invalid character
0xBA7D  0x20 0x1F 0x8C  JSR 0x8C1F              // Error.IllegalCharacter(); CLC     tokenizer.asm:240
0xBA80  0x18            CLC
0xBA81  0x60            RTS                     // break;                            tokenizer.asm:241
0xBA82  0xE8            INX                     // INX     Move to character after backslash
0xBA83  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:249
0xBA85  0xD0 0x05       BNE 0xBA8C (+5)         // if (Z)    End of input after backslash
0xBA87  0x20 0x42 0x8C  JSR 0x8C42              // Error.UnexpectedEOL(); CLC        tokenizer.asm:252
0xBA8A  0x18            CLC
0xBA8B  0x60            RTS                     // break;                            tokenizer.asm:253
0xBA8C  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X     Get escape character
0xBA8F  0xC9 0x62       CMP # 0x62              // case 'b':  { LDA #0x08 }    Backspace
0xBA91  0xD0 0x04       BNE 0xBA97 (+4)
0xBA93  0xA9 0x08       LDA # 0x08
0xBA95  0x80 0x3D       BRA 0xBAD4 (+61)
0xBA97  0xC9 0x74       CMP # 0x74              // case 't':  { LDA #0x09 }    Tab   tokenizer.asm:262
0xBA99  0xD0 0x04       BNE 0xBA9F (+4)
0xBA9B  0xA9 0x09       LDA # 0x09
0xBA9D  0x80 0x35       BRA 0xBAD4 (+53)
0xBA9F  0xC9 0x6E       CMP # 0x6E              // case 'n':  { LDA #0x0A }    Newline
0xBAA1  0xD0 0x04       BNE 0xBAA7 (+4)
0xBAA3  0xA9 0x0A       LDA # 0x0A
0xBAA5  0x80 0x2D       BRA 0xBAD4 (+45)
0xBAA7  0xC9 0x66       CMP # 0x66              // case 'f':  { LDA #0x0C }    Formfeed
0xBAA9  0xD0 0x04       BNE 0xBAAF (+4)
0xBAAB  0xA9 0x0C       LDA # 0x0C
0xBAAD  0x80 0x25       BRA 0xBAD4 (+37)
0xBAAF  0xC9 0x72       CMP # 0x72              // case 'r':  { LDA #0x0D }    Carriage return
0xBAB1  0xD0 0x04       BNE 0xBAB7 (+4)
0xBAB3  0xA9 0x0D       LDA # 0x0D
0xBAB5  0x80 0x1D       BRA 0xBAD4 (+29)
0xBAB7  0xC9 0x5C       CMP # 0x5C              // case '\\': { LDA #0x5C }    Backslash
0xBAB9  0xD0 0x04       BNE 0xBABF (+4)
0xBABB  0xA9 0x5C       LDA # 0x5C
0xBABD  0x80 0x15       BRA 0xBAD4 (+21)
0xBABF  0xC9 0x22       CMP # 0x22              // case '"':  { LDA #0x22 }    Double quote
0xBAC1  0xD0 0x04       BNE 0xBAC7 (+4)
0xBAC3  0xA9 0x22       LDA # 0x22
0xBAC5  0x80 0x0D       BRA 0xBAD4 (+13)
0xBAC7  0xC9 0x27       CMP # 0x27              // case '\'': { LDA #0x27 }    Single quote
0xBAC9  0xD0 0x04       BNE 0xBACF (+4)
0xBACB  0xA9 0x27       LDA # 0x27
0xBACD  0x80 0x05       BRA 0xBAD4 (+5)
0xBACF  0x20 0x1F 0x8C  JSR 0x8C1F              // Error.IllegalCharacter(); CLC     Invalid escape sequence: TODO better message
0xBAD2  0x18            CLC
0xBAD3  0x60            RTS                     // break;                            tokenizer.asm:272
0xBAD4  0x38            SEC                     // SEC                               tokenizer.asm:277
0xBAD5  0x60            RTS                     // break;                            tokenizer.asm:278

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:289
// ####  Tokenizer.TokenizeLineWithMode()  ####                                 0x01CD

0xBAD6  0xA5 0x37       LDA 0x37                // LDA ZP.OpCodeTemp                 tokenizer.asm:290
0xBAD8  0xD0 0x06       BNE 0xBAE0 (+6)         // if (Z)                            tokenizer.asm:291
0xBADA  0x20 0xE0 0x96  JSR 0x96E0              // BufferManager.ResetTokenizerBuffer();
0xBADD  0x20 0x4C 0x8C  JSR 0x8C4C              // Error.ClearError();               tokenizer.asm:295
0xBAE0  0xA5 0x28       LDA 0x28                // LDA ZP.BasicInputLength           tokenizer.asm:299
0xBAE2  0xD0 0x0D       BNE 0xBAF1 (+13)        // if (Z)                            tokenizer.asm:300
0xBAE4  0xA5 0x37       LDA 0x37                // LDA ZP.OpCodeTemp                 tokenizer.asm:303
0xBAE6  0xD0 0x07       BNE 0xBAEF (+7)         // if (Z)                            tokenizer.asm:304
0xBAE8  0xA9 0xDC       LDA # 0xDC              // LDA #Token.EOL                    tokenizer.asm:307
0xBAEA  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:308
0xBAED  0x38            SEC                     // SEC     Success                   tokenizer.asm:309
0xBAEE  0x60            RTS                     // return;                           tokenizer.asm:310
0xBAEF  0x38            SEC                     // SEC     Success - but don't add anything to buffer
0xBAF0  0x60            RTS                     // return;                           tokenizer.asm:316
0xBAF1  0xA2 0x00       LDX # 0                 // LDX #0                            tokenizer.asm:321
0xBAF3  0x20 0xEB 0xB9  JSR 0xB9EB              // skipWhitespace();    Updates X to first non-whitespace
0xBAF6  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:323
0xBAF8  0xD0 0x0D       BNE 0xBB07 (+13)        // if (Z)                            tokenizer.asm:324
0xBAFA  0xA5 0x37       LDA 0x37                // LDA ZP.OpCodeTemp                 tokenizer.asm:327
0xBAFC  0xD0 0x07       BNE 0xBB05 (+7)         // if (Z)                            tokenizer.asm:328
0xBAFE  0xA9 0xDC       LDA # 0xDC              // LDA #Token.EOL                    tokenizer.asm:331
0xBB00  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:332
0xBB03  0x38            SEC                     // SEC     Success                   tokenizer.asm:333
0xBB04  0x60            RTS                     // return;                           tokenizer.asm:334
0xBB05  0x38            SEC                     // SEC     Success - but don't add anything to buffer
0xBB06  0x60            RTS                     // return;                           tokenizer.asm:340
0xBB07  0xA2 0x00       LDX # 0                 // LDX #0     Reset position in input buffer
0xBB09  0x67 0x36       RMB6 0x36               // RMB6 ZP.CompilerFlags             tokenizer.asm:347
0xBB0B  0x38            SEC                     // SEC                               tokenizer.asm:349
0xBB0C  0x6F 0x36 0x0C  BBR6 0x36, 0xBB1B (+12) // if (BBS6, CompilerFlags)          tokenizer.asm:352
0xBB0F  0x67 0x36       RMB6 0x36               // RMB6 ZP.CompilerFlags             tokenizer.asm:355
0xBB11  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:356
0xBB14  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:357
0xBB17  0xB0 0x01       BCS 0xBB1A (+1)         // if (NC) { return; }               tokenizer.asm:358
0xBB19  0x60            RTS
0xBB1A  0xE8            INX                     // INX                               tokenizer.asm:359
0xBB1B  0x20 0xEB 0xB9  JSR 0xB9EB              // skipWhitespace();     Updates X   tokenizer.asm:361
0xBB1E  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:362
0xBB20  0xD0 0x03       BNE 0xBB25 (+3)         // if (Z) { break; }     End of input
0xBB22  0x4C 0xAE 0xBD  JMP 0xBDAE
0xBB25  0xE7 0x36       SMB6 0x36               // SMB6 ZP.CompilerFlags    assume it is a simple token
0xBB27  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:367
0xBB2A  0xC9 0x3A       CMP # 0x3A              // case ':':                         tokenizer.asm:370
0xBB2C  0xD0 0x04       BNE 0xBB32 (+4)
0xBB2E  0xA9 0xDE       LDA # 0xDE              // LDA #Token.COLON                  tokenizer.asm:372
0xBB30  0x80 0xDA       BRA 0xBB0C (-38)        // }                                 tokenizer.asm:373
0xBB32  0xC9 0x2C       CMP # 0x2C              // case ',':                         tokenizer.asm:374
0xBB34  0xD0 0x04       BNE 0xBB3A (+4)
0xBB36  0xA9 0xDF       LDA # 0xDF              // LDA #Token.COMMA                  tokenizer.asm:376
0xBB38  0x80 0xD2       BRA 0xBB0C (-46)        // }                                 tokenizer.asm:377
0xBB3A  0xC9 0x3B       CMP # 0x3B              // case ';':                         tokenizer.asm:378
0xBB3C  0xD0 0x04       BNE 0xBB42 (+4)
0xBB3E  0xA9 0xE0       LDA # 0xE0              // LDA #Token.SEMICOLON              tokenizer.asm:380
0xBB40  0x80 0xCA       BRA 0xBB0C (-54)        // }                                 tokenizer.asm:381
0xBB42  0xC9 0x3D       CMP # 0x3D              // case '=':                         tokenizer.asm:382
0xBB44  0xD0 0x04       BNE 0xBB4A (+4)
0xBB46  0xA9 0xE1       LDA # 0xE1              // LDA #Token.EQUALS                 tokenizer.asm:384
0xBB48  0x80 0xC2       BRA 0xBB0C (-62)        // }                                 tokenizer.asm:385
0xBB4A  0xC9 0x2B       CMP # 0x2B              // case '+':                         tokenizer.asm:386
0xBB4C  0xD0 0x04       BNE 0xBB52 (+4)
0xBB4E  0xA9 0xE2       LDA # 0xE2              // LDA #Token.PLUS                   tokenizer.asm:388
0xBB50  0x80 0xBA       BRA 0xBB0C (-70)        // }                                 tokenizer.asm:389
0xBB52  0xC9 0x2D       CMP # 0x2D              // case '-':                         tokenizer.asm:390
0xBB54  0xD0 0x04       BNE 0xBB5A (+4)
0xBB56  0xA9 0xE3       LDA # 0xE3              // LDA #Token.MINUS                  tokenizer.asm:392
0xBB58  0x80 0xB2       BRA 0xBB0C (-78)        // }                                 tokenizer.asm:393
0xBB5A  0xC9 0x2A       CMP # 0x2A              // case '*':                         tokenizer.asm:394
0xBB5C  0xD0 0x04       BNE 0xBB62 (+4)
0xBB5E  0xA9 0xEB       LDA # 0xEB              // LDA #Token.MULTIPLY               tokenizer.asm:396
0xBB60  0x80 0xAA       BRA 0xBB0C (-86)        // }                                 tokenizer.asm:397
0xBB62  0xC9 0x2F       CMP # 0x2F              // case '/':                         tokenizer.asm:398
0xBB64  0xD0 0x04       BNE 0xBB6A (+4)
0xBB66  0xA9 0xEC       LDA # 0xEC              // LDA #Token.DIVIDE                 tokenizer.asm:400
0xBB68  0x80 0xA2       BRA 0xBB0C (-94)        // }                                 tokenizer.asm:401
0xBB6A  0xC9 0x26       CMP # 0x26              // case '&':                         tokenizer.asm:402
0xBB6C  0xD0 0x04       BNE 0xBB72 (+4)
0xBB6E  0xA9 0xED       LDA # 0xED              // LDA #Token.BITWISE_AND            tokenizer.asm:404
0xBB70  0x80 0x9A       BRA 0xBB0C (-102)       // }                                 tokenizer.asm:405
0xBB72  0xC9 0x7C       CMP # 0x7C              // case '|':                         tokenizer.asm:406
0xBB74  0xD0 0x04       BNE 0xBB7A (+4)
0xBB76  0xA9 0xEE       LDA # 0xEE              // LDA #Token.BITWISE_OR             tokenizer.asm:408
0xBB78  0x80 0x92       BRA 0xBB0C (-110)       // }                                 tokenizer.asm:409
0xBB7A  0xC9 0x7E       CMP # 0x7E              // case '~':                         tokenizer.asm:410
0xBB7C  0xD0 0x04       BNE 0xBB82 (+4)
0xBB7E  0xA9 0xEF       LDA # 0xEF              // LDA #Token.BITWISE_NOT            tokenizer.asm:412
0xBB80  0x80 0x8A       BRA 0xBB0C (-118)       // }                                 tokenizer.asm:413
0xBB82  0xC9 0x28       CMP # 0x28              // case '(':                         tokenizer.asm:414
0xBB84  0xD0 0x04       BNE 0xBB8A (+4)
0xBB86  0xA9 0xE4       LDA # 0xE4              // LDA #Token.LPAREN                 tokenizer.asm:416
0xBB88  0x80 0x82       BRA 0xBB0C (-126)       // }                                 tokenizer.asm:417
0xBB8A  0xC9 0x29       CMP # 0x29              // case ')':                         tokenizer.asm:418
0xBB8C  0xD0 0x05       BNE 0xBB93 (+5)
0xBB8E  0xA9 0xE5       LDA # 0xE5              // LDA #Token.RPAREN                 tokenizer.asm:420
0xBB90  0x4C 0x0C 0xBB  JMP 0xBB0C              // }                                 tokenizer.asm:421
0xBB93  0xC9 0x5B       CMP # 0x5B              // case '[':                         tokenizer.asm:422
0xBB95  0xD0 0x05       BNE 0xBB9C (+5)
0xBB97  0xA9 0xF0       LDA # 0xF0              // LDA #Token.LBRACKET               tokenizer.asm:424
0xBB99  0x4C 0x0C 0xBB  JMP 0xBB0C              // }                                 tokenizer.asm:425
0xBB9C  0xC9 0x5D       CMP # 0x5D              // case ']':                         tokenizer.asm:426
0xBB9E  0xD0 0x05       BNE 0xBBA5 (+5)
0xBBA0  0xA9 0xF1       LDA # 0xF1              // LDA #Token.RBRACKET               tokenizer.asm:428
0xBBA2  0x4C 0x0C 0xBB  JMP 0xBB0C              // }                                 tokenizer.asm:429
0xBBA5  0xC9 0x3C       CMP # 0x3C              // case '<':                         tokenizer.asm:430
0xBBA7  0xD0 0x20       BNE 0xBBC9 (+32)
0xBBA9  0xE8            INX                     // INX                               tokenizer.asm:433
0xBBAA  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:434
0xBBAC  0xF0 0x15       BEQ 0xBBC3 (+21)        // if (NZ)                           tokenizer.asm:435
0xBBAE  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:437
0xBBB1  0xC9 0x3D       CMP # 0x3D              // CMP #'='                          tokenizer.asm:438
0xBBB3  0xD0 0x05       BNE 0xBBBA (+5)         // if (Z)                            tokenizer.asm:439
0xBBB5  0xA9 0xE9       LDA # 0xE9              // LDA #Token.LE                     tokenizer.asm:441
0xBBB7  0x4C 0x0C 0xBB  JMP 0xBB0C              // continue;                         tokenizer.asm:442
0xBBBA  0xC9 0x3E       CMP # 0x3E              // CMP #'>'                          tokenizer.asm:444
0xBBBC  0xD0 0x05       BNE 0xBBC3 (+5)         // if (Z)                            tokenizer.asm:445
0xBBBE  0xA9 0xE6       LDA # 0xE6              // LDA #Token.NOTEQUAL               tokenizer.asm:447
0xBBC0  0x4C 0x0C 0xBB  JMP 0xBB0C              // continue;                         tokenizer.asm:448
0xBBC3  0xCA            DEX                     // DEX     Back up to point at '<'   tokenizer.asm:452
0xBBC4  0xA9 0xE7       LDA # 0xE7              // LDA #Token.LT                     tokenizer.asm:453
0xBBC6  0x4C 0x0C 0xBB  JMP 0xBB0C              // }                                 tokenizer.asm:454
0xBBC9  0xC9 0x3E       CMP # 0x3E              // case '>':                         tokenizer.asm:455
0xBBCB  0xD0 0x17       BNE 0xBBE4 (+23)
0xBBCD  0xE8            INX                     // INX                               tokenizer.asm:458
0xBBCE  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:459
0xBBD0  0xF0 0x0C       BEQ 0xBBDE (+12)        // if (NZ)                           tokenizer.asm:460
0xBBD2  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:462
0xBBD5  0xC9 0x3D       CMP # 0x3D              // CMP #'='                          tokenizer.asm:463
0xBBD7  0xD0 0x05       BNE 0xBBDE (+5)         // if (Z)                            tokenizer.asm:464
0xBBD9  0xA9 0xEA       LDA # 0xEA              // LDA #Token.GE                     tokenizer.asm:466
0xBBDB  0x4C 0x0C 0xBB  JMP 0xBB0C              // continue;                         tokenizer.asm:467
0xBBDE  0xCA            DEX                     // DEX     Back up to point at '>'   tokenizer.asm:471
0xBBDF  0xA9 0xE8       LDA # 0xE8              // LDA #Token.GT                     tokenizer.asm:472
0xBBE1  0x4C 0x0C 0xBB  JMP 0xBB0C              // }                                 tokenizer.asm:473
0xBBE4  0xC9 0x22       CMP # 0x22              // case '"':                         tokenizer.asm:474
0xBBE6  0xD0 0x4B       BNE 0xBC33 (+75)
0xBBE8  0x67 0x36       RMB6 0x36               // RMB6 ZP.CompilerFlags    not a simple token
0xBBEA  0xA9 0xD8       LDA # 0xD8              // LDA # Token.STRINGLIT             tokenizer.asm:479
0xBBEC  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:480
0xBBEF  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:481
0xBBF2  0xB0 0x01       BCS 0xBBF5 (+1)         // if (NC) { return; }               tokenizer.asm:482
0xBBF4  0x60            RTS
0xBBF5  0xA5 0x29       LDA 0x29                // LDA ZP.TokenBufferContentLengthL  tokenizer.asm:485
0xBBF7  0x85 0x30       STA 0x30                // STA ZP.TokenLiteralPosL           tokenizer.asm:486
0xBBF9  0xA5 0x2A       LDA 0x2A                // LDA ZP.TokenBufferContentLengthH  tokenizer.asm:487
0xBBFB  0x85 0x31       STA 0x31                // STA ZP.TokenLiteralPosH           tokenizer.asm:488
0xBBFD  0xE8            INX                     // INX    Skip opening quote         tokenizer.asm:490
0xBBFE  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength     Check input buffer bounds
0xBC00  0xD0 0x05       BNE 0xBC07 (+5)         // if (Z)    End of input without closing quote
0xBC02  0x20 0x42 0x8C  JSR 0x8C42              // Error.UnexpectedEOL(); BIT ZP.EmulatorPCL
0xBC05  0x18            CLC                     // CLC                               tokenizer.asm:498
0xBC06  0x60            RTS                     // return;                           tokenizer.asm:499
0xBC07  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:503
0xBC0A  0xC9 0x22       CMP # 0x22              // CMP #'"'                          tokenizer.asm:504
0xBC0C  0xD0 0x0E       BNE 0xBC1C (+14)        // if (Z)    Found closing quote     tokenizer.asm:505
0xBC0E  0xA9 0x00       LDA # 0                 // LDA #0                            tokenizer.asm:508
0xBC10  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:509
0xBC13  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:510
0xBC16  0xB0 0x01       BCS 0xBC19 (+1)         // if (NC) { return; }               tokenizer.asm:511
0xBC18  0x60            RTS
0xBC19  0xE8            INX                     // INX     Skip closing quote in input buffer
0xBC1A  0x80 0x13       BRA 0xBC2F (+19)        // break;                            tokenizer.asm:514
0xBC1C  0x20 0x72 0xBA  JSR 0xBA72              // processEscapeCharacter();     Input: X, Output: A = byte value, X updated
0xBC1F  0xB0 0x02       BCS 0xBC23 (+2)         // if (NC)    Error in escape sequence or invalid character
0xBC21  0x18            CLC                     // CLC                               tokenizer.asm:522
0xBC22  0x60            RTS                     // return;                           tokenizer.asm:523
0xBC23  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:527
0xBC26  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:528
0xBC29  0xB0 0x01       BCS 0xBC2C (+1)         // if (NC) { return; }               tokenizer.asm:529
0xBC2B  0x60            RTS
0xBC2C  0xE8            INX                     // INX     Advance input buffer position
0xBC2D  0x80 0xCF       BRA 0xBBFE (-49)        // }                                 tokenizer.asm:532
0xBC2F  0x38            SEC                     // SEC     Success                   tokenizer.asm:533
0xBC30  0x4C 0x0C 0xBB  JMP 0xBB0C              // }                                 tokenizer.asm:534
0xBC33  0xC9 0x27       CMP # 0x27              // case '\'':                        tokenizer.asm:535
0xBC35  0xD0 0x41       BNE 0xBC78 (+65)
0xBC37  0x67 0x36       RMB6 0x36               // RMB6 ZP.CompilerFlags    not a simple token
0xBC39  0xA9 0xD9       LDA # 0xD9              // LDA #Token.CHARLIT                tokenizer.asm:540
0xBC3B  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:541
0xBC3E  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:542
0xBC41  0xB0 0x01       BCS 0xBC44 (+1)         // if (NC) { return; }               tokenizer.asm:543
0xBC43  0x60            RTS
0xBC44  0xE8            INX                     // INX     Skip opening quote        tokenizer.asm:545
0xBC45  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:548
0xBC47  0xD0 0x05       BNE 0xBC4E (+5)         // if (Z)     End of input without character
0xBC49  0x20 0x42 0x8C  JSR 0x8C42              // Error.UnexpectedEOL(); BIT ZP.EmulatorPCL
0xBC4C  0x18            CLC                     // CLC                               tokenizer.asm:552
0xBC4D  0x60            RTS                     // return;                           tokenizer.asm:553
0xBC4E  0x20 0x72 0xBA  JSR 0xBA72              // processEscapeCharacter();     Input: X, Output: A = byte value, X updated
0xBC51  0xB0 0x02       BCS 0xBC55 (+2)         // if (NC)     Error in escape sequence or invalid character
0xBC53  0x18            CLC                     // CLC                               tokenizer.asm:561
0xBC54  0x60            RTS                     // return;                           tokenizer.asm:562
0xBC55  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:566
0xBC58  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:567
0xBC5B  0xB0 0x01       BCS 0xBC5E (+1)         // if (NC) { return; }               tokenizer.asm:568
0xBC5D  0x60            RTS
0xBC5E  0xE8            INX                     // INX     Move past character       tokenizer.asm:570
0xBC5F  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:573
0xBC61  0xD0 0x05       BNE 0xBC68 (+5)         // if (Z)     End of input without closing quote
0xBC63  0x20 0x42 0x8C  JSR 0x8C42              // Error.UnexpectedEOL(); BIT ZP.EmulatorPCL
0xBC66  0x18            CLC                     // CLC                               tokenizer.asm:577
0xBC67  0x60            RTS                     // return;                           tokenizer.asm:578
0xBC68  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:581
0xBC6B  0xC9 0x27       CMP # 0x27              // CMP #'\''                         tokenizer.asm:582
0xBC6D  0xF0 0x05       BEQ 0xBC74 (+5)         // if (NZ)     Not a closing quote   tokenizer.asm:583
0xBC6F  0x20 0x42 0x8C  JSR 0x8C42              // Error.UnexpectedEOL(); BIT ZP.EmulatorPCL
0xBC72  0x18            CLC                     // CLC                               tokenizer.asm:586
0xBC73  0x60            RTS                     // return;                           tokenizer.asm:587
0xBC74  0xE8            INX                     // INX     Skip closing quote        tokenizer.asm:590
0xBC75  0x4C 0x0C 0xBB  JMP 0xBB0C              // }                                 tokenizer.asm:592
0xBC78  0xC9 0x21       CMP # 0x21              // case '!':                         tokenizer.asm:593
0xBC7A  0xD0 0x2F       BNE 0xBCAB (+47)
0xBC7C  0x67 0x36       RMB6 0x36               // RMB6 ZP.CompilerFlags    not a simple token
0xBC7E  0xA9 0x95       LDA # 0x95              // LDA #Token.COMMENT                tokenizer.asm:598
0xBC80  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:599
0xBC83  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:600
0xBC86  0xB0 0x01       BCS 0xBC89 (+1)         // if (NC) { return; }               tokenizer.asm:601
0xBC88  0x60            RTS
0xBC89  0xE8            INX                     // INX     Skip the quote character  tokenizer.asm:603
0xBC8A  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:608
0xBC8C  0xF0 0x0F       BEQ 0xBC9D (+15)        // if (Z) { break; }     End of input
0xBC8E  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:611
0xBC91  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:612
0xBC94  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:613
0xBC97  0xB0 0x01       BCS 0xBC9A (+1)         // if (NC) { return; }               tokenizer.asm:614
0xBC99  0x60            RTS
0xBC9A  0xE8            INX                     // INX                               tokenizer.asm:615
0xBC9B  0x80 0xED       BRA 0xBC8A (-19)        // }                                 tokenizer.asm:616
0xBC9D  0xA9 0x00       LDA # 0                 // LDA #0                            tokenizer.asm:619
0xBC9F  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:620
0xBCA2  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:621
0xBCA5  0xB0 0x01       BCS 0xBCA8 (+1)         // if (NC) { return; }               tokenizer.asm:622
0xBCA7  0x60            RTS
0xBCA8  0x4C 0x0C 0xBB  JMP 0xBB0C              // }                                 tokenizer.asm:626
0xBCAB  0x67 0x36       RMB6 0x36               // RMB6 ZP.CompilerFlags    not a simple token
0xBCAD  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:632
0xBCB0  0xC9 0x30       CMP # 0x30              // CMP #'0'                          tokenizer.asm:633
0xBCB2  0xD0 0x20       BNE 0xBCD4 (+32)        // if (Z)                            tokenizer.asm:634
0xBCB4  0xE8            INX                     // INX                               tokenizer.asm:637
0xBCB5  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:638
0xBCB7  0xF0 0x17       BEQ 0xBCD0 (+23)        // if (NZ)                           tokenizer.asm:639
0xBCB9  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:641
0xBCBC  0xC9 0x78       CMP # 0x78              // CMP #'x'                          tokenizer.asm:642
0xBCBE  0xD0 0x06       BNE 0xBCC6 (+6)         // if (Z) { scanHexNumber(); continue; }    EXCEPTION
0xBCC0  0x20 0x2C 0xBA  JSR 0xBA2C
0xBCC3  0x4C 0x0C 0xBB  JMP 0xBB0C
0xBCC6  0xC9 0x58       CMP # 0x58              // CMP #'X'                          tokenizer.asm:644
0xBCC8  0xD0 0x06       BNE 0xBCD0 (+6)         // if (Z) { scanHexNumber(); continue; }    EXCEPTION
0xBCCA  0x20 0x2C 0xBA  JSR 0xBA2C
0xBCCD  0x4C 0x0C 0xBB  JMP 0xBB0C
0xBCD0  0xCA            DEX                     // DEX     Back up, not hex          tokenizer.asm:647
0xBCD1  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:648
0xBCD4  0x20 0x24 0x97  JSR 0x9724              // Char.IsDigit();                   tokenizer.asm:652
0xBCD7  0x90 0x34       BCC 0xBD0D (+52)        // if (C)                            tokenizer.asm:653
0xBCD9  0xA9 0xD7       LDA # 0xD7              // LDA #Token.NUMBER                 tokenizer.asm:656
0xBCDB  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:657
0xBCDE  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:658
0xBCE1  0xB0 0x01       BCS 0xBCE4 (+1)         // if (NC) { return; }               tokenizer.asm:659
0xBCE3  0x60            RTS
0xBCE4  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:664
0xBCE6  0xF0 0x17       BEQ 0xBCFF (+23)        // if (Z) { break; }                 tokenizer.asm:665
0xBCE8  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:667
0xBCEB  0x20 0x24 0x97  JSR 0x9724              // Char.IsDigit();                   tokenizer.asm:668
0xBCEE  0xB0 0x03       BCS 0xBCF3 (+3)         // if (NC) { SEC break; }     Not a digit
0xBCF0  0x38            SEC
0xBCF1  0x80 0x0C       BRA 0xBCFF (+12)
0xBCF3  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:671
0xBCF6  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:672
0xBCF9  0xB0 0x01       BCS 0xBCFC (+1)         // if (NC) { return; }               tokenizer.asm:673
0xBCFB  0x60            RTS
0xBCFC  0xE8            INX                     // INX                               tokenizer.asm:674
0xBCFD  0x80 0xE5       BRA 0xBCE4 (-27)        // }                                 tokenizer.asm:675
0xBCFF  0xA9 0x00       LDA # 0                 // LDA #0                            tokenizer.asm:678
0xBD01  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:679
0xBD04  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:680
0xBD07  0xB0 0x01       BCS 0xBD0A (+1)         // if (NC) { return; }               tokenizer.asm:681
0xBD09  0x60            RTS
0xBD0A  0x4C 0x0C 0xBB  JMP 0xBB0C              // continue;                         tokenizer.asm:682
0xBD0D  0x20 0x32 0x97  JSR 0x9732              // Char.IsAlpha();                   tokenizer.asm:685
0xBD10  0xB0 0x05       BCS 0xBD17 (+5)         // if (NC)                           tokenizer.asm:686
0xBD12  0x20 0x1F 0x8C  JSR 0x8C1F              // Error.IllegalCharacter(); BIT ZP.EmulatorPCL
0xBD15  0x18            CLC                     // CLC     Error                     tokenizer.asm:690
0xBD16  0x60            RTS                     // return;                           tokenizer.asm:691
0xBD17  0xA0 0x00       LDY # 0                 // LDY #0     Index into working buffer (FIXED: was using X)
0xBD19  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:698
0xBD1B  0xF0 0x26       BEQ 0xBD43 (+38)        // if (Z) { break; }                 tokenizer.asm:699
0xBD1D  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:701
0xBD20  0xC9 0x80       CMP # 0x80              // CMP # 0x80                        tokenizer.asm:703
0xBD22  0x90 0x05       BCC 0xBD29 (+5)         // if (C)     >= 128, invalid character
0xBD24  0x20 0x1F 0x8C  JSR 0x8C1F              // Error.IllegalCharacter(); BIT ZP.EmulatorPCL
0xBD27  0x18            CLC                     // CLC                               tokenizer.asm:707
0xBD28  0x60            RTS                     // return;                           tokenizer.asm:708
0xBD29  0x20 0x40 0x97  JSR 0x9740              // Char.IsAlphaNumeric();            tokenizer.asm:711
0xBD2C  0x90 0x15       BCC 0xBD43 (+21)        // if (NC) { break; }     Not alphanumeric
0xBD2E  0x20 0x4E 0x97  JSR 0x974E              // Char.IsLower();    preserves A    tokenizer.asm:715
0xBD31  0x90 0x02       BCC 0xBD35 (+2)         // if (C)                            tokenizer.asm:716
0xBD33  0x29 0xDF       AND # 0xDF              // AND #0xDF         Convert to uppercase by stripping bit 5
0xBD35  0x99 0xE0 0x0B  STA 0x0BE0,Y            // STA Address.BasicProcessBuffer, Y     FIXED: Use Y for working buffer
0xBD38  0xE8            INX                     // INX     Advance input position    tokenizer.asm:722
0xBD39  0xC8            INY                     // INY     FIXED: Advance working buffer index separately
0xBD3A  0xC0 0x20       CPY # 0x20              // CPY #Limits.BasicProcessBufferSize
0xBD3C  0xD0 0xDB       BNE 0xBD19 (-37)        // if (Z)                            tokenizer.asm:725
0xBD3E  0x20 0x2E 0x8C  JSR 0x8C2E              // Error.BufferOverflow(); BIT ZP.EmulatorPCL
0xBD41  0x18            CLC                     // CLC     Error                     tokenizer.asm:728
0xBD42  0x60            RTS                     // return;                           tokenizer.asm:729
0xBD43  0xA9 0x00       LDA # 0                 // LDA #0                            tokenizer.asm:734
0xBD45  0x99 0xE0 0x0B  STA 0x0BE0,Y            // STA Address.BasicProcessBuffer, Y     FIXED: Use Y for working buffer
0xBD48  0x20 0xFC 0x89  JSR 0x89FC              // Tokens.FindKeyword();             tokenizer.asm:738
0xBD4B  0xC9 0x00       CMP # 0                 // CMP #0                            tokenizer.asm:739
0xBD4D  0xF0 0x3A       BEQ 0xBD89 (+58)        // if (NZ)     Found keyword         tokenizer.asm:740
0xBD4F  0xC9 0x94       CMP # 0x94              // CMP #Token.REM                    tokenizer.asm:743
0xBD51  0xD0 0x2D       BNE 0xBD80 (+45)        // if (Z)                            tokenizer.asm:744
0xBD53  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:746
0xBD56  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:747
0xBD59  0xB0 0x01       BCS 0xBD5C (+1)         // if (NC) { return; }               tokenizer.asm:748
0xBD5B  0x60            RTS
0xBD5C  0x20 0xEB 0xB9  JSR 0xB9EB              // skipWhitespace();     Skip spaces after REM
0xBD5F  0xE4 0x28       CPX 0x28                // CPX ZP.BasicInputLength           tokenizer.asm:756
0xBD61  0xF0 0x0F       BEQ 0xBD72 (+15)        // if (Z) { break; }     End of input
0xBD63  0xBD 0x00 0x0B  LDA 0x0B00,X            // LDA Address.BasicInputBuffer, X   tokenizer.asm:759
0xBD66  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:760
0xBD69  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:761
0xBD6C  0xB0 0x01       BCS 0xBD6F (+1)         // if (NC) { return; }               tokenizer.asm:762
0xBD6E  0x60            RTS
0xBD6F  0xE8            INX                     // INX                               tokenizer.asm:763
0xBD70  0x80 0xED       BRA 0xBD5F (-19)        // }                                 tokenizer.asm:764
0xBD72  0xA9 0x00       LDA # 0                 // LDA #0                            tokenizer.asm:767
0xBD74  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:768
0xBD77  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:769
0xBD7A  0xB0 0x01       BCS 0xBD7D (+1)         // if (NC) { return; }               tokenizer.asm:770
0xBD7C  0x60            RTS
0xBD7D  0x4C 0x0C 0xBB  JMP 0xBB0C              // continue;    EXCEPTION            tokenizer.asm:773
0xBD80  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:777
0xBD83  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:778
0xBD86  0xB0 0x23       BCS 0xBDAB (+35)        // if (NC) { return; }               tokenizer.asm:779
0xBD88  0x60            RTS
0xBD89  0xA9 0xDA       LDA # 0xDA              // LDA #Token.IDENTIFIER             tokenizer.asm:784
0xBD8B  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:785
0xBD8E  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:786
0xBD91  0xB0 0x01       BCS 0xBD94 (+1)         // if (NC) { return; }               tokenizer.asm:787
0xBD93  0x60            RTS
0xBD94  0xA0 0x00       LDY # 0                 // LDY #0     Reset Y for copying    tokenizer.asm:790
0xBD96  0xB9 0xE0 0x0B  LDA 0x0BE0,Y            // LDA Address.BasicProcessBuffer, Y tokenizer.asm:793
0xBD99  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       tokenizer.asm:794
0xBD9B  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:795
0xBD9E  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:796
0xBDA1  0xB0 0x01       BCS 0xBDA4 (+1)         // if (NC)                           tokenizer.asm:797
0xBDA3  0x60            RTS                     // return;                           tokenizer.asm:799
0xBDA4  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL    set Z              tokenizer.asm:801
0xBDA6  0xF0 0x03       BEQ 0xBDAB (+3)         // if (Z)                            tokenizer.asm:802
0xBDA8  0xC8            INY                     // INY                               tokenizer.asm:806
0xBDA9  0x80 0xEB       BRA 0xBD96 (-21)        // }    loop                         tokenizer.asm:807
0xBDAB  0x4C 0x0C 0xBB  JMP 0xBB0C              // }    loop                         tokenizer.asm:812
0xBDAE  0xA9 0xDC       LDA # 0xDC              // LDA #Token.EOL                    tokenizer.asm:815
0xBDB0  0x20 0x02 0xBA  JSR 0xBA02              // appendToTokenBuffer();            tokenizer.asm:816
0xBDB3  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     tokenizer.asm:817
0xBDB6  0xB0 0x01       BCS 0xBDB9 (+1)         // if (NC) { return; }               tokenizer.asm:818
0xBDB8  0x60            RTS
0xBDB9  0xA5 0x37       LDA 0x37                // LDA ZP.OpCodeTemp                 tokenizer.asm:820
0xBDBB  0xD0 0x04       BNE 0xBDC1 (+4)         // if (Z)                            tokenizer.asm:821
0xBDBD  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL              tokenizer.asm:824
0xBDBF  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              tokenizer.asm:825
0xBDC1  0x38            SEC                     // SEC     Success                   tokenizer.asm:829
0xBDC2  0x60            RTS                     // }                                 tokenizer.asm:830

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:833
// ####  Tokenizer.NextTokenCheck()  ####                                       0x01CE

0xBDC3  0x20 0xD2 0xBD  JSR 0xBDD2              // NextToken();                      tokenizer.asm:834
0xBDC6  0x4C 0x59 0x8C  JMP 0x8C59              // CheckError();                     tokenizer.asm:835

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:839
// ####  Tokenizer.NextTokenCheckSetFailure()  ####                             0x01CF

0xBDC9  0x20 0xC3 0xBD  JSR 0xBDC3              // NextTokenCheck();                 tokenizer.asm:840
0xBDCC  0x90 0x01       BCC 0xBDCF (+1)         // if (NC)                           tokenizer.asm:841
0xBDCE  0x60            RTS
0xBDCF  0x64 0x4E       STZ 0x4E                // States.SetFailure();              tokenizer.asm:843
0xBDD1  0x60            RTS                     // }                                 tokenizer.asm:845

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:855
// ####  Tokenizer.NextToken()  ####                                            0x01D0

0xBDD2  0x20 0xDF 0xB9  JSR 0xB9DF              // CompareTokenizerPosToLength();    tokenizer.asm:857
0xBDD5  0x90 0x05       BCC 0xBDDC (+5)         // if (C)     TokenizerPos >= TokenBufferContentSize
0xBDD7  0xA9 0xDB       LDA # 0xDB              // LDA # Token.EOF                   tokenizer.asm:860
0xBDD9  0x85 0x2F       STA 0x2F                // STA ZP.CurrentToken               tokenizer.asm:861
0xBDDB  0x60            RTS                     // return;                           tokenizer.asm:862
0xBDDC  0x20 0xB3 0xB9  JSR 0xB9B3              // setTokenizerPointer();            tokenizer.asm:866
0xBDDF  0xA0 0x00       LDY # 0                 // LDY #0                            tokenizer.asm:869
0xBDE1  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   tokenizer.asm:870
0xBDE3  0x85 0x2F       STA 0x2F                // STA ZP.CurrentToken               tokenizer.asm:871
0xBDE5  0x20 0xCF 0xB9  JSR 0xB9CF              // incrementTokenizerPos();          tokenizer.asm:874
0xBDE8  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               tokenizer.asm:877
0xBDEA  0xC9 0xD7       CMP # 0xD7              // case Token.NUMBER:                tokenizer.asm:880
0xBDEC  0xF0 0x08       BEQ 0xBDF6 (+8)
0xBDEE  0xC9 0xDA       CMP # 0xDA              // case Token.IDENTIFIER:            tokenizer.asm:881
0xBDF0  0xF0 0x04       BEQ 0xBDF6 (+4)
0xBDF2  0xC9 0xD8       CMP # 0xD8              // case Token.STRINGLIT:             tokenizer.asm:882
0xBDF4  0xD0 0x0E       BNE 0xBE04 (+14)
0xBDF6  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              tokenizer.asm:885
0xBDF8  0x85 0x30       STA 0x30                // STA ZP.TokenLiteralPosL           tokenizer.asm:886
0xBDFA  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              tokenizer.asm:887
0xBDFC  0x85 0x31       STA 0x31                // STA ZP.TokenLiteralPosH           tokenizer.asm:888
0xBDFE  0x20 0x77 0xBE  JSR 0xBE77              // skipInlineString();               tokenizer.asm:889
0xBE01  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               tokenizer.asm:890
0xBE03  0x60            RTS                     // }                                 tokenizer.asm:891
0xBE04  0xC9 0xD9       CMP # 0xD9              // case Token.CHARLIT:               tokenizer.asm:892
0xBE06  0xD0 0x0E       BNE 0xBE16 (+14)
0xBE08  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              tokenizer.asm:895
0xBE0A  0x85 0x30       STA 0x30                // STA ZP.TokenLiteralPosL           tokenizer.asm:896
0xBE0C  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              tokenizer.asm:897
0xBE0E  0x85 0x31       STA 0x31                // STA ZP.TokenLiteralPosH           tokenizer.asm:898
0xBE10  0x20 0xCF 0xB9  JSR 0xB9CF              // incrementTokenizerPos();          tokenizer.asm:901
0xBE13  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               tokenizer.asm:902
0xBE15  0x60            RTS                     // }                                 tokenizer.asm:903
0xBE16  0xC9 0x94       CMP # 0x94              // case Token.REM:                   tokenizer.asm:904
0xBE18  0xF0 0x05       BEQ 0xBE1F (+5)
0xBE1A  0xC9 0x95       CMP # 0x95              // case Token.COMMENT:               tokenizer.asm:905
0xBE1C  0xF0 0x01       BEQ 0xBE1F (+1)
0xBE1E  0x60            RTS
0xBE1F  0x20 0x77 0xBE  JSR 0xBE77              // skipInlineString();               tokenizer.asm:908
0xBE22  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               tokenizer.asm:909
0xBE24  0x60            RTS                     // }                                 tokenizer.asm:910

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:921
// ####  Tokenizer.PeekToken()  ####                                            0x01D1

0xBE25  0x20 0xDF 0xB9  JSR 0xB9DF              // CompareTokenizerPosToLength();    tokenizer.asm:923
0xBE28  0x90 0x03       BCC 0xBE2D (+3)         // if (C)     TokenizerPos >= TokenBufferContentSize
0xBE2A  0xA9 0xDB       LDA # 0xDB              // LDA #Token.EOF                    tokenizer.asm:926
0xBE2C  0x60            RTS                     // return;                           tokenizer.asm:927
0xBE2D  0x5A            PHY                     // PHY                               tokenizer.asm:930
0xBE2E  0x18            CLC                     // CLC                               tokenizer.asm:934
0xBE2F  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               tokenizer.asm:935
0xBE31  0x65 0x2B       ADC 0x2B                // ADC ZP.TokenizerPosL              tokenizer.asm:936
0xBE33  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       tokenizer.asm:937
0xBE35  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               tokenizer.asm:938
0xBE37  0x65 0x2C       ADC 0x2C                // ADC ZP.TokenizerPosH              tokenizer.asm:939
0xBE39  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       tokenizer.asm:940
0xBE3B  0xA0 0x00       LDY # 0                 // LDY #0                            tokenizer.asm:942
0xBE3D  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y     Load the next token ID
0xBE3F  0x7A            PLY                     // PLY                               tokenizer.asm:945
0xBE40  0x60            RTS                     // }                                 tokenizer.asm:948

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:955
// ####  Tokenizer.GetTokenNumber()  ####                                       0x01D2

0xBE41  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               tokenizer.asm:957
0xBE43  0x18            CLC                     // CLC                               tokenizer.asm:958
0xBE44  0x65 0x30       ADC 0x30                // ADC ZP.TokenLiteralPosL           tokenizer.asm:959
0xBE46  0x85 0x79       STA 0x79                // STA ZP.STRL                       tokenizer.asm:960
0xBE48  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               tokenizer.asm:961
0xBE4A  0x65 0x31       ADC 0x31                // ADC ZP.TokenLiteralPosH           tokenizer.asm:962
0xBE4C  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       tokenizer.asm:963
0xBE4E  0xA0 0x00       LDY # 0                 // LDY #0                            tokenizer.asm:969
0xBE50  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   tokenizer.asm:972
0xBE52  0xC9 0x30       CMP # 0x30              // CMP #'0'                          tokenizer.asm:973
0xBE54  0xD0 0x16       BNE 0xBE6C (+22)        // if (Z)                            tokenizer.asm:974
0xBE56  0xC8            INY                     // INY                               tokenizer.asm:976
0xBE57  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   tokenizer.asm:977
0xBE59  0x29 0xDF       AND # 0xDF              // AND #0xDF     Convert to uppercase
0xBE5B  0xC9 0x58       CMP # 0x58              // CMP #'X'                          tokenizer.asm:979
0xBE5D  0xD0 0x0C       BNE 0xBE6B (+12)        // if (Z)                            tokenizer.asm:980
0xBE5F  0xC8            INY                     // INY     Skip 'x'                  tokenizer.asm:982
0xBE60  0x20 0xEB 0x9C  JSR 0x9CEB              // Long.FromHex();                   tokenizer.asm:983
0xBE63  0x90 0x03       BCC 0xBE68 (+3)         // if (NC)                           tokenizer.asm:984
0xBE65  0x4C 0x2A 0x9D  JMP 0x9D2A
0xBE68  0x4C 0x10 0x8C  JMP 0x8C10              // Error.NumericOverflow();          tokenizer.asm:986
0xBE6B  0x88            DEY                     // DEY     Back up, not hex          tokenizer.asm:993
0xBE6C  0x20 0xB0 0x9C  JSR 0x9CB0              // Long.FromDecimal();               tokenizer.asm:997
0xBE6F  0x90 0x03       BCC 0xBE74 (+3)         // if (NC)                           tokenizer.asm:998
0xBE71  0x4C 0x2A 0x9D  JMP 0x9D2A
0xBE74  0x4C 0x10 0x8C  JMP 0x8C10              // Error.NumericOverflow();          tokenizer.asm:1000

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:1019
// ####  Tokenizer.skipInlineString()  ####                                     0x01D3

0xBE77  0x20 0xDF 0xB9  JSR 0xB9DF              // CompareTokenizerPosToLength();     Proper 16-bit comparison
0xBE7A  0x90 0x02       BCC 0xBE7E (+2)         // if (C)     TokenizerPos >= TokenBufferContentSize
0xBE7C  0x18            CLC                     // CLC     Error flag                tokenizer.asm:1027
0xBE7D  0x60            RTS                     // break;                            tokenizer.asm:1028
0xBE7E  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               tokenizer.asm:1032
0xBE80  0x18            CLC                     // CLC                               tokenizer.asm:1033
0xBE81  0x65 0x2B       ADC 0x2B                // ADC ZP.TokenizerPosL              tokenizer.asm:1034
0xBE83  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       tokenizer.asm:1035
0xBE85  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               tokenizer.asm:1036
0xBE87  0x65 0x2C       ADC 0x2C                // ADC ZP.TokenizerPosH              tokenizer.asm:1037
0xBE89  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       tokenizer.asm:1038
0xBE8B  0xA0 0x00       LDY # 0                 // LDY #0                            tokenizer.asm:1041
0xBE8D  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   tokenizer.asm:1042
0xBE8F  0x48            PHA                     // PHA     Save the character        tokenizer.asm:1043
0xBE90  0xE6 0x2B       INC 0x2B                // INC ZP.TokenizerPosL              tokenizer.asm:1046
0xBE92  0xD0 0x02       BNE 0xBE96 (+2)         // if (Z)                            tokenizer.asm:1047
0xBE94  0xE6 0x2C       INC 0x2C                // INC ZP.TokenizerPosH              tokenizer.asm:1049
0xBE96  0x68            PLA                     // PLA     Restore the character     tokenizer.asm:1053
0xBE97  0xD0 0xDE       BNE 0xBE77 (-34)        // if (Z)                            tokenizer.asm:1054
0xBE99  0x38            SEC                     // SEC     Success - found null terminator
0xBE9A  0x60            RTS                     // break;                            tokenizer.asm:1057

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:1069
// ####  Tokenizer.ReadLine()  ####                                             0x01D4

0xBE9B  0x20 0x0F 0xDD  JSR 0xDD0F              // Statement.IsCaptureModeOff();     tokenizer.asm:1071
0xBE9E  0xB0 0x08       BCS 0xBEA8 (+8)         // if (C)                            tokenizer.asm:1072
0xBEA0  0xA9 0x2A       LDA # 0x2A              // LDA #'*'                          tokenizer.asm:1079
0xBEA2  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokenizer.asm:1080
0xBEA5  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    tokenizer.asm:1081
0xBEA8  0xA2 0x00       LDX # 0                 // LDX #0     Buffer position        tokenizer.asm:1084
0xBEAA  0x20 0x88 0x8D  JSR 0x8D88              // Serial.WaitForChar();     Returns character in A
0xBEAD  0xC9 0x0D       CMP # 0x0D              // case '\r':                        tokenizer.asm:1092
0xBEAF  0xF0 0x04       BEQ 0xBEB5 (+4)
0xBEB1  0xC9 0x0A       CMP # 0x0A              // case '\n':                        tokenizer.asm:1093
0xBEB3  0xD0 0x07       BNE 0xBEBC (+7)
0xBEB5  0xA9 0x0A       LDA # 0x0A              // LDA #'\n'                         tokenizer.asm:1096
0xBEB7  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();     Echo newline
0xBEBA  0x80 0x6C       BRA 0xBF28 (+108)       // break;                            tokenizer.asm:1098
0xBEBC  0xC9 0x09       CMP # 0x09              // case 0x09:     Tab key            tokenizer.asm:1100
0xBEBE  0xD0 0x14       BNE 0xBED4 (+20)
0xBEC0  0xE0 0x7C       CPX # 0x7C              // CPX #(Limits.BasicInputSize - 4)  tokenizer.asm:1103
0xBEC2  0xB0 0xE6       BCS 0xBEAA (-26)        // if (C) { continue; }     Not enough space, ignore tab
0xBEC4  0xA0 0x04       LDY # 0x04              // LDY #4                            tokenizer.asm:1107
0xBEC6  0xA9 0x20       LDA # 0x20              // LDA #' '                          tokenizer.asm:1110
0xBEC8  0x9D 0x00 0x0B  STA 0x0B00,X            // STA Address.BasicInputBuffer, X   tokenizer.asm:1111
0xBECB  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();     Echo space
0xBECE  0xE8            INX                     // INX                               tokenizer.asm:1113
0xBECF  0x88            DEY                     // DEY                               tokenizer.asm:1114
0xBED0  0xF0 0xD8       BEQ 0xBEAA (-40)        // if (Z) { break; }                 tokenizer.asm:1115
0xBED2  0x80 0xF2       BRA 0xBEC6 (-14)
0xBED4  0xC9 0x08       CMP # 0x08              // case 0x08:     Backspace          tokenizer.asm:1120
0xBED6  0xF0 0x04       BEQ 0xBEDC (+4)
0xBED8  0xC9 0x7F       CMP # 0x7F              // case 0x7F:     Delete             tokenizer.asm:1121
0xBEDA  0xD0 0x14       BNE 0xBEF0 (+20)
0xBEDC  0xE0 0x00       CPX # 0                 // CPX #0                            tokenizer.asm:1123
0xBEDE  0xF0 0xCA       BEQ 0xBEAA (-54)        // if (Z) { continue; }     Nothing to delete
0xBEE0  0xCA            DEX                     // DEX                               tokenizer.asm:1126
0xBEE1  0xA9 0x08       LDA # 0x08              // LDA #0x08      Backspace          tokenizer.asm:1127
0xBEE3  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokenizer.asm:1128
0xBEE6  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    tokenizer.asm:1129
0xBEE9  0xA9 0x08       LDA # 0x08              // LDA #0x08      Backspace          tokenizer.asm:1130
0xBEEB  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokenizer.asm:1131
0xBEEE  0x80 0xBA       BRA 0xBEAA (-70)        // continue;                         tokenizer.asm:1132
0xBEF0  0xC9 0x03       CMP # 0x03              // case 0x03:     Ctrl+C             tokenizer.asm:1134
0xBEF2  0xD0 0x1B       BNE 0xBF0F (+27)
0xBEF4  0xA9 0x5E       LDA # 0x5E              // LDA #'^'                          tokenizer.asm:1136
0xBEF6  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokenizer.asm:1137
0xBEF9  0xA9 0x43       LDA # 0x43              // LDA #'C'                          tokenizer.asm:1138
0xBEFB  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokenizer.asm:1139
0xBEFE  0xA9 0x0A       LDA # 0x0A              // LDA #'\n'                         tokenizer.asm:1140
0xBF00  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokenizer.asm:1141
0xBF03  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      tokenizer.asm:1144
0xBF06  0x90 0x03       BCC 0xBF0B (+3)         // if (C)                            tokenizer.asm:1145
0xBF08  0x20 0x80 0xFA  JSR 0xFA80              // Console.ExitFunctionCaptureMode();
0xBF0B  0xA2 0x00       LDX # 0                 // LDX #0     Clear buffer           tokenizer.asm:1150
0xBF0D  0x80 0x19       BRA 0xBF28 (+25)        // break;                            tokenizer.asm:1151
0xBF0F  0xC9 0x20       CMP # 0x20              // CMP #' '                          tokenizer.asm:1156
0xBF11  0x90 0x97       BCC 0xBEAA (-105)       // if (C)     >= 32                  tokenizer.asm:1157
0xBF13  0xC9 0x7F       CMP # 0x7F              // CMP #0x7F                         tokenizer.asm:1159
0xBF15  0xB0 0x93       BCS 0xBEAA (-109)       // if (NC)     < 127                 tokenizer.asm:1160
0xBF17  0xC9 0x80       CMP # 0x80              // CMP # 0x80                        tokenizer.asm:1162
0xBF19  0xB0 0x8F       BCS 0xBEAA (-113)       // continue;     Ignore extended ASCII
0xBF1B  0xE0 0x80       CPX # 0x80              // CPX #Limits.BasicInputSize        tokenizer.asm:1168
0xBF1D  0xF0 0x8B       BEQ 0xBEAA (-117)       // if (Z) { continue; }     Buffer full
0xBF1F  0x9D 0x00 0x0B  STA 0x0B00,X            // STA Address.BasicInputBuffer, X   tokenizer.asm:1171
0xBF22  0xE8            INX                     // INX                               tokenizer.asm:1172
0xBF23  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();     Echo      tokenizer.asm:1173
0xBF26  0x80 0x82       BRA 0xBEAA (-126)       // continue;                         tokenizer.asm:1174
0xBF28  0x86 0x28       STX 0x28                // STX ZP.BasicInputLength           tokenizer.asm:1183
0xBF2A  0x8A            TXA                     // TXA     Return length             tokenizer.asm:1184
0xBF2B  0x60            RTS                     // }                                 tokenizer.asm:1185

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:1192
// ####  Tokenizer.GetTokenString()  ####                                       0x01D5

0xBF2C  0x48            PHA                     // PHA                               tokenizer.asm:1193
0xBF2D  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               tokenizer.asm:1197
0xBF2F  0x18            CLC                     // CLC                               tokenizer.asm:1198
0xBF30  0x65 0x30       ADC 0x30                // ADC ZP.TokenLiteralPosL           tokenizer.asm:1199
0xBF32  0x85 0x11       STA 0x11                // STA ZP.TOPL                       tokenizer.asm:1200
0xBF34  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               tokenizer.asm:1202
0xBF36  0x65 0x31       ADC 0x31                // ADC ZP.TokenLiteralPosH           tokenizer.asm:1203
0xBF38  0x85 0x12       STA 0x12                // STA ZP.TOPH                       tokenizer.asm:1204
0xBF3A  0x68            PLA                     // PLA                               tokenizer.asm:1206
0xBF3B  0x60            RTS                     // }                                 tokenizer.asm:1207

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:1214
// ####  Tokenizer.GetTokenStringSTR()  ####                                    0x01D6

0xBF3C  0x48            PHA                     // PHA                               tokenizer.asm:1215
0xBF3D  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               tokenizer.asm:1219
0xBF3F  0x18            CLC                     // CLC                               tokenizer.asm:1220
0xBF40  0x65 0x30       ADC 0x30                // ADC ZP.TokenLiteralPosL           tokenizer.asm:1221
0xBF42  0x85 0x79       STA 0x79                // STA ZP.STRL                       tokenizer.asm:1222
0xBF44  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               tokenizer.asm:1224
0xBF46  0x65 0x31       ADC 0x31                // ADC ZP.TokenLiteralPosH           tokenizer.asm:1225
0xBF48  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       tokenizer.asm:1226
0xBF4A  0x68            PLA                     // PLA                               tokenizer.asm:1228
0xBF4B  0x60            RTS                     // }                                 tokenizer.asm:1229

// /source/projects/6502sbc/hopperbasic/tokenizer.asm:1233
// ####  Tokenizer.Rollback()  ####                                             0x01D7

0xBF4C  0x48            PHA                     // PHA                               tokenizer.asm:1234
0xBF4D  0x5A            PHY                     // PHY                               tokenizer.asm:1235
0xBF4E  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              tokenizer.asm:1240
0xBF50  0x05 0x2C       ORA 0x2C                // ORA ZP.TokenizerPosH              tokenizer.asm:1241
0xBF52  0xD0 0x07       BNE 0xBF5B (+7)         // if (Z)                            tokenizer.asm:1242
0xBF54  0x20 0xCA 0x8B  JSR 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0xBF57  0x7A            PLY                     // PLY                               tokenizer.asm:1246
0xBF58  0x68            PLA                     // PLA                               tokenizer.asm:1247
0xBF59  0x80 0x19       BRA 0xBF74 (+25)        // break;                            tokenizer.asm:1248
0xBF5B  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              tokenizer.asm:1255
0xBF5D  0xD0 0x02       BNE 0xBF61 (+2)         // if (Z)                            tokenizer.asm:1256
0xBF5F  0xC6 0x2C       DEC 0x2C                // DEC ZP.TokenizerPosH              tokenizer.asm:1258
0xBF61  0xC6 0x2B       DEC 0x2B                // DEC ZP.TokenizerPosL              tokenizer.asm:1260
0xBF63  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              tokenizer.asm:1263
0xBF65  0x05 0x2C       ORA 0x2C                // ORA ZP.TokenizerPosH              tokenizer.asm:1264
0xBF67  0xF0 0x09       BEQ 0xBF72 (+9)         // if (Z)                            tokenizer.asm:1265
0xBF69  0x20 0xB3 0xB9  JSR 0xB9B3              // setTokenizerPointer();    Sets ZP.IDX = BasicTokenizerBuffer + TokenizerPos
0xBF6C  0xA0 0x00       LDY # 0                 // LDY #0                            tokenizer.asm:1273
0xBF6E  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   tokenizer.asm:1274
0xBF70  0x10 0xE9       BPL 0xBF5B (-23)        // if (MI) { break; }    Branch if minus (bit 7 set) - we found a token!
0xBF72  0x64 0x2F       STZ 0x2F                // STZ ZP.CurrentToken               tokenizer.asm:1283
0xBF74  0x7A            PLY                     // PLY                               tokenizer.asm:1287
0xBF75  0x68            PLA                     // PLA                               tokenizer.asm:1288
0xBF76  0x60            RTS                     // }                                 tokenizer.asm:1289

// /source/projects/6502sbc/hopperbasic/instructions.asm:81
// ####  Instructions.Addition()  ####                                          0x01D9

0xBF77  0x48            PHA                     // PHA                               instructions.asm:82
0xBF78  0xDA            PHX                     // PHX                               instructions.asm:83
0xBF79  0x5A            PHY                     // PHY                               instructions.asm:84
0xBF7A  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNextStrict();          instructions.asm:89
0xBF7D  0x90 0x1F       BCC 0xBF9E (+31)        // if (NC) { break; }                instructions.asm:90
0xBF7F  0x18            CLC                     // CLC                               instructions.asm:94
0xBF80  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      instructions.asm:95
0xBF82  0x65 0x11       ADC 0x11                // ADC ZP.TOP0                       instructions.asm:96
0xBF84  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      instructions.asm:97
0xBF86  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      instructions.asm:98
0xBF88  0x65 0x12       ADC 0x12                // ADC ZP.TOP1                       instructions.asm:99
0xBF8A  0x85 0x17       STA 0x17                // STA ZP.NEXT1                      instructions.asm:100
0xBF8C  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      instructions.asm:101
0xBF8E  0x65 0x13       ADC 0x13                // ADC ZP.TOP2                       instructions.asm:102
0xBF90  0x85 0x18       STA 0x18                // STA ZP.NEXT2                      instructions.asm:103
0xBF92  0xA5 0x19       LDA 0x19                // LDA ZP.NEXT3                      instructions.asm:104
0xBF94  0x65 0x14       ADC 0x14                // ADC ZP.TOP3                       instructions.asm:105
0xBF96  0x85 0x19       STA 0x19                // STA ZP.NEXT3                      instructions.asm:106
0xBF98  0x20 0x58 0x98  JSR 0x9858              // Long.PushNext();                  instructions.asm:110
0xBF9B  0x90 0x01       BCC 0xBF9E (+1)         // if (NC) { break; }                instructions.asm:111
0xBF9D  0x38            SEC                     // SEC                               instructions.asm:112
0xBF9E  0x7A            PLY                     // PLY                               instructions.asm:116
0xBF9F  0xFA            PLX                     // PLX                               instructions.asm:117
0xBFA0  0x68            PLA                     // PLA                               instructions.asm:118
0xBFA1  0x60            RTS                     // }                                 instructions.asm:119

// /source/projects/6502sbc/hopperbasic/instructions.asm:127
// ####  Instructions.Subtraction()  ####                                       0x01DA

0xBFA2  0x48            PHA                     // PHA                               instructions.asm:128
0xBFA3  0xDA            PHX                     // PHX                               instructions.asm:129
0xBFA4  0x5A            PHY                     // PHY                               instructions.asm:130
0xBFA5  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNextStrict();          instructions.asm:135
0xBFA8  0x90 0x21       BCC 0xBFCB (+33)        // if (NC) { break; }                instructions.asm:136
0xBFAA  0x38            SEC                     // SEC                               instructions.asm:139
0xBFAB  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      instructions.asm:140
0xBFAD  0xE5 0x11       SBC 0x11                // SBC ZP.TOP0                       instructions.asm:141
0xBFAF  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      instructions.asm:142
0xBFB1  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      instructions.asm:143
0xBFB3  0xE5 0x12       SBC 0x12                // SBC ZP.TOP1                       instructions.asm:144
0xBFB5  0x85 0x17       STA 0x17                // STA ZP.NEXT1                      instructions.asm:145
0xBFB7  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      instructions.asm:146
0xBFB9  0xE5 0x13       SBC 0x13                // SBC ZP.TOP2                       instructions.asm:147
0xBFBB  0x85 0x18       STA 0x18                // STA ZP.NEXT2                      instructions.asm:148
0xBFBD  0xA5 0x19       LDA 0x19                // LDA ZP.NEXT3                      instructions.asm:149
0xBFBF  0xE5 0x14       SBC 0x14                // SBC ZP.TOP3                       instructions.asm:150
0xBFC1  0x85 0x19       STA 0x19                // STA ZP.NEXT3                      instructions.asm:151
0xBFC3  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      instructions.asm:154
0xBFC5  0x20 0x58 0x98  JSR 0x9858              // Long.PushNext();                  instructions.asm:155
0xBFC8  0x90 0x01       BCC 0xBFCB (+1)         // if (NC) { break; }                instructions.asm:156
0xBFCA  0x38            SEC                     // SEC                               instructions.asm:158
0xBFCB  0x7A            PLY                     // PLY                               instructions.asm:161
0xBFCC  0xFA            PLX                     // PLX                               instructions.asm:162
0xBFCD  0x68            PLA                     // PLA                               instructions.asm:163
0xBFCE  0x60            RTS                     // }                                 instructions.asm:164

// /source/projects/6502sbc/hopperbasic/instructions.asm:201
// ####  Instructions.UnaryMinus()  ####                                        0x01DC

0xBFCF  0x48            PHA                     // PHA                               instructions.asm:202
0xBFD0  0xDA            PHX                     // PHX                               instructions.asm:203
0xBFD1  0x5A            PHY                     // PHY                               instructions.asm:204
0xBFD2  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();                    instructions.asm:208
0xBFD5  0xBF 0x15 0x05  BBS3 0x15, 0xBFDD (+5)  // if (BBR3, ZP.TOPT)                instructions.asm:209
0xBFD8  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xBFDB  0x80 0x23       BRA 0xC000 (+35)        // break;                            instructions.asm:212
0xBFDD  0x38            SEC                     // SEC                               instructions.asm:215
0xBFDE  0xA9 0x00       LDA # 0                 // LDA # 0                           instructions.asm:216
0xBFE0  0xE5 0x11       SBC 0x11                // SBC ZP.TOP0                       instructions.asm:217
0xBFE2  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      instructions.asm:218
0xBFE4  0xA9 0x00       LDA # 0                 // LDA # 0                           instructions.asm:219
0xBFE6  0xE5 0x12       SBC 0x12                // SBC ZP.TOP1                       instructions.asm:220
0xBFE8  0x85 0x17       STA 0x17                // STA ZP.NEXT1                      instructions.asm:221
0xBFEA  0xA9 0x00       LDA # 0                 // LDA # 0                           instructions.asm:222
0xBFEC  0xE5 0x13       SBC 0x13                // SBC ZP.TOP2                       instructions.asm:223
0xBFEE  0x85 0x18       STA 0x18                // STA ZP.NEXT2                      instructions.asm:224
0xBFF0  0xA9 0x00       LDA # 0                 // LDA # 0                           instructions.asm:225
0xBFF2  0xE5 0x14       SBC 0x14                // SBC ZP.TOP3                       instructions.asm:226
0xBFF4  0x85 0x19       STA 0x19                // STA ZP.NEXT3                      instructions.asm:227
0xBFF6  0xA9 0x08       LDA # 0x08              // LDA #BASICType.LONG               instructions.asm:229
0xBFF8  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT                      instructions.asm:230
0xBFFA  0x20 0x58 0x98  JSR 0x9858              // Long.PushNext();                  instructions.asm:231
0xBFFD  0x90 0x01       BCC 0xC000 (+1)         // if (NC) { break; }                instructions.asm:232
0xBFFF  0x38            SEC                     // SEC                               instructions.asm:233
0xC000  0x7A            PLY                     // PLY                               instructions.asm:236
0xC001  0xFA            PLX                     // PLX                               instructions.asm:237
0xC002  0x68            PLA                     // PLA                               instructions.asm:238
0xC003  0x60            RTS                     // }                                 instructions.asm:239

// /source/projects/6502sbc/hopperbasic/instructions.asm:248
// ####  Instructions.Multiply()  ####                                          0x01DD

0xC004  0x48            PHA                     // PHA                               instructions.asm:249
0xC005  0xDA            PHX                     // PHX                               instructions.asm:250
0xC006  0x5A            PHY                     // PHY                               instructions.asm:251
0xC007  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNextStrict();          instructions.asm:256
0xC00A  0x90 0x06       BCC 0xC012 (+6)         // if (NC) { break; }                instructions.asm:257
0xC00C  0x20 0x60 0x99  JSR 0x9960              // Long.Mul();                       instructions.asm:259
0xC00F  0x90 0x01       BCC 0xC012 (+1)         // if (NC) { break; }                instructions.asm:260
0xC011  0x38            SEC                     // SEC                               instructions.asm:261
0xC012  0x7A            PLY                     // PLY                               instructions.asm:265
0xC013  0xFA            PLX                     // PLX                               instructions.asm:266
0xC014  0x68            PLA                     // PLA                               instructions.asm:267
0xC015  0x60            RTS                     // }                                 instructions.asm:268

// /source/projects/6502sbc/hopperbasic/instructions.asm:277
// ####  Instructions.Divide()  ####                                            0x01DE

0xC016  0x48            PHA                     // PHA                               instructions.asm:278
0xC017  0xDA            PHX                     // PHX                               instructions.asm:279
0xC018  0x5A            PHY                     // PHY                               instructions.asm:280
0xC019  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNextStrict();          instructions.asm:285
0xC01C  0x90 0x06       BCC 0xC024 (+6)         // if (NC) { break; }                instructions.asm:286
0xC01E  0x20 0x49 0x99  JSR 0x9949              // Long.Div();                       instructions.asm:288
0xC021  0x90 0x01       BCC 0xC024 (+1)         // if (NC) { break; }                instructions.asm:289
0xC023  0x38            SEC                     // SEC                               instructions.asm:291
0xC024  0x7A            PLY                     // PLY                               instructions.asm:295
0xC025  0xFA            PLX                     // PLX                               instructions.asm:296
0xC026  0x68            PLA                     // PLA                               instructions.asm:297
0xC027  0x60            RTS                     // }                                 instructions.asm:298

// /source/projects/6502sbc/hopperbasic/instructions.asm:305
// ####  Instructions.Modulo()  ####                                            0x01DF

0xC028  0x48            PHA                     // PHA                               instructions.asm:306
0xC029  0x5A            PHY                     // PHY                               instructions.asm:307
0xC02A  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNextStrict();          instructions.asm:311
0xC02D  0x90 0x06       BCC 0xC035 (+6)         // if (NC) { break; }                instructions.asm:312
0xC02F  0x20 0x2F 0x99  JSR 0x992F              // Long.Mod();                       instructions.asm:314
0xC032  0x90 0x01       BCC 0xC035 (+1)         // if (NC) { break; }                instructions.asm:315
0xC034  0x38            SEC                     // SEC                               instructions.asm:316
0xC035  0x7A            PLY                     // PLY                               instructions.asm:320
0xC036  0x68            PLA                     // PLA                               instructions.asm:321
0xC037  0x60            RTS                     // }                                 instructions.asm:322

// /source/projects/6502sbc/hopperbasic/instructions.asm:330
// ####  Instructions.BitwiseAnd()  ####                                        0x01E0

0xC038  0x48            PHA                     // PHA                               instructions.asm:331
0xC039  0xDA            PHX                     // PHX                               instructions.asm:332
0xC03A  0x5A            PHY                     // PHY                               instructions.asm:333
0xC03B  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNextStrict();          instructions.asm:337
0xC03E  0x90 0x1E       BCC 0xC05E (+30)        // if (NC) { break; }                instructions.asm:338
0xC040  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      instructions.asm:341
0xC042  0x25 0x11       AND 0x11                // AND ZP.TOP0                       instructions.asm:342
0xC044  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      instructions.asm:343
0xC046  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      instructions.asm:344
0xC048  0x25 0x12       AND 0x12                // AND ZP.TOP1                       instructions.asm:345
0xC04A  0x85 0x17       STA 0x17                // STA ZP.NEXT1                      instructions.asm:346
0xC04C  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      instructions.asm:347
0xC04E  0x25 0x13       AND 0x13                // AND ZP.TOP2                       instructions.asm:348
0xC050  0x85 0x18       STA 0x18                // STA ZP.NEXT2                      instructions.asm:349
0xC052  0xA5 0x19       LDA 0x19                // LDA ZP.NEXT3                      instructions.asm:350
0xC054  0x25 0x14       AND 0x14                // AND ZP.TOP3                       instructions.asm:351
0xC056  0x85 0x19       STA 0x19                // STA ZP.NEXT3                      instructions.asm:352
0xC058  0x20 0x58 0x98  JSR 0x9858              // Long.PushNext();                  instructions.asm:354
0xC05B  0x90 0x01       BCC 0xC05E (+1)         // if (NC) { break; }                instructions.asm:355
0xC05D  0x38            SEC                     // SEC                               instructions.asm:356
0xC05E  0x7A            PLY                     // PLY                               instructions.asm:360
0xC05F  0xFA            PLX                     // PLX                               instructions.asm:361
0xC060  0x68            PLA                     // PLA                               instructions.asm:362
0xC061  0x60            RTS                     // }                                 instructions.asm:363

// /source/projects/6502sbc/hopperbasic/instructions.asm:368
// ####  Instructions.BitwiseNot()  ####                                        0x01E1

0xC062  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();                    instructions.asm:375
0xC065  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       instructions.asm:378
0xC067  0x49 0xFF       EOR # 0xFF              // EOR #0xFF                         instructions.asm:379
0xC069  0x85 0x11       STA 0x11                // STA ZP.TOP0                       instructions.asm:380
0xC06B  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       instructions.asm:381
0xC06D  0x49 0xFF       EOR # 0xFF              // EOR #0xFF                         instructions.asm:382
0xC06F  0x85 0x12       STA 0x12                // STA ZP.TOP1                       instructions.asm:383
0xC071  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       instructions.asm:384
0xC073  0x49 0xFF       EOR # 0xFF              // EOR #0xFF                         instructions.asm:385
0xC075  0x85 0x13       STA 0x13                // STA ZP.TOP2                       instructions.asm:386
0xC077  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       instructions.asm:387
0xC079  0x49 0xFF       EOR # 0xFF              // EOR #0xFF                         instructions.asm:388
0xC07B  0x85 0x14       STA 0x14                // STA ZP.TOP3                       instructions.asm:389
0xC07D  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();                   instructions.asm:391
0xC080  0x38            SEC                     // SEC     Success                   instructions.asm:393
0xC081  0x60            RTS                     // break;                            instructions.asm:394

// /source/projects/6502sbc/hopperbasic/instructions.asm:408
// ####  Instructions.BitwiseOr()  ####                                         0x01E2

0xC082  0x48            PHA                     // PHA                               instructions.asm:409
0xC083  0xDA            PHX                     // PHX                               instructions.asm:410
0xC084  0x5A            PHY                     // PHY                               instructions.asm:411
0xC085  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNextStrict();          instructions.asm:415
0xC088  0x90 0x1E       BCC 0xC0A8 (+30)        // if (NC) { break; }                instructions.asm:416
0xC08A  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      instructions.asm:419
0xC08C  0x05 0x11       ORA 0x11                // ORA ZP.TOP0                       instructions.asm:420
0xC08E  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      instructions.asm:421
0xC090  0xA5 0x17       LDA 0x17                // LDA ZP.NEXT1                      instructions.asm:422
0xC092  0x05 0x12       ORA 0x12                // ORA ZP.TOP1                       instructions.asm:423
0xC094  0x85 0x17       STA 0x17                // STA ZP.NEXT1                      instructions.asm:424
0xC096  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      instructions.asm:425
0xC098  0x05 0x13       ORA 0x13                // ORA ZP.TOP2                       instructions.asm:426
0xC09A  0x85 0x18       STA 0x18                // STA ZP.NEXT2                      instructions.asm:427
0xC09C  0xA5 0x19       LDA 0x19                // LDA ZP.NEXT3                      instructions.asm:428
0xC09E  0x05 0x14       ORA 0x14                // ORA ZP.TOP3                       instructions.asm:429
0xC0A0  0x85 0x19       STA 0x19                // STA ZP.NEXT3                      instructions.asm:430
0xC0A2  0x20 0x58 0x98  JSR 0x9858              // Long.PushNext();                  instructions.asm:432
0xC0A5  0x90 0x01       BCC 0xC0A8 (+1)         // if (NC) { break; }                instructions.asm:433
0xC0A7  0x38            SEC                     // SEC                               instructions.asm:434
0xC0A8  0x7A            PLY                     // PLY                               instructions.asm:438
0xC0A9  0xFA            PLX                     // PLX                               instructions.asm:439
0xC0AA  0x68            PLA                     // PLA                               instructions.asm:440
0xC0AB  0x60            RTS                     // }                                 instructions.asm:441

// /source/projects/6502sbc/hopperbasic/instructions.asm:449
// ####  Instructions.LogicalAnd()  ####                                        0x01E3

0xC0AC  0x48            PHA                     // PHA                               instructions.asm:450
0xC0AD  0xDA            PHX                     // PHX                               instructions.asm:451
0xC0AE  0x5A            PHY                     // PHY                               instructions.asm:452
0xC0AF  0x20 0xB3 0x94  JSR 0x94B3              // Stacks.PopTopNext();              instructions.asm:456
0xC0B2  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       instructions.asm:458
0xC0B4  0x05 0x1A       ORA 0x1A                // ORA ZP.NEXTT                      instructions.asm:459
0xC0B6  0xC9 0x06       CMP # 0x06              // CMP #BASICType.BIT                instructions.asm:460
0xC0B8  0xF0 0x05       BEQ 0xC0BF (+5)         // if (NZ)                           instructions.asm:461
0xC0BA  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xC0BD  0x80 0x0E       BRA 0xC0CD (+14)        // break;                            instructions.asm:464
0xC0BF  0xA2 0x00       LDX # 0                 // LDX #0     Assume result is 0 (false)
0xC0C1  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      instructions.asm:471
0xC0C3  0x25 0x11       AND 0x11                // AND ZP.TOP0                       instructions.asm:472
0xC0C5  0xF0 0x02       BEQ 0xC0C9 (+2)         // if (NZ)                           instructions.asm:473
0xC0C7  0xA2 0x01       LDX # 1                 // LDX #1                            instructions.asm:475
0xC0C9  0x20 0xEA 0x94  JSR 0x94EA              // Stacks.PushX();                   instructions.asm:478
0xC0CC  0x38            SEC                     // SEC                               instructions.asm:479
0xC0CD  0x7A            PLY                     // PLY                               instructions.asm:483
0xC0CE  0xFA            PLX                     // PLX                               instructions.asm:484
0xC0CF  0x68            PLA                     // PLA                               instructions.asm:485
0xC0D0  0x60            RTS                     // }                                 instructions.asm:486

// /source/projects/6502sbc/hopperbasic/instructions.asm:494
// ####  Instructions.LogicalOr()  ####                                         0x01E4

0xC0D1  0x48            PHA                     // PHA                               instructions.asm:495
0xC0D2  0xDA            PHX                     // PHX                               instructions.asm:496
0xC0D3  0x5A            PHY                     // PHY                               instructions.asm:497
0xC0D4  0x20 0xB3 0x94  JSR 0x94B3              // Stacks.PopTopNext();              instructions.asm:501
0xC0D7  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       instructions.asm:503
0xC0D9  0x05 0x1A       ORA 0x1A                // ORA ZP.NEXTT                      instructions.asm:504
0xC0DB  0xC9 0x06       CMP # 0x06              // CMP #BASICType.BIT                instructions.asm:505
0xC0DD  0xF0 0x05       BEQ 0xC0E4 (+5)         // if (NZ)                           instructions.asm:506
0xC0DF  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xC0E2  0x80 0x0E       BRA 0xC0F2 (+14)        // break;                            instructions.asm:509
0xC0E4  0xA2 0x00       LDX # 0                 // LDX #0     Assume result is 0 (false)
0xC0E6  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      instructions.asm:516
0xC0E8  0x05 0x11       ORA 0x11                // ORA ZP.TOP0                       instructions.asm:517
0xC0EA  0xF0 0x02       BEQ 0xC0EE (+2)         // if (NZ)                           instructions.asm:518
0xC0EC  0xA2 0x01       LDX # 1                 // LDX #1                            instructions.asm:520
0xC0EE  0x20 0xEA 0x94  JSR 0x94EA              // Stacks.PushX();                   instructions.asm:523
0xC0F1  0x38            SEC                     // SEC                               instructions.asm:524
0xC0F2  0x7A            PLY                     // PLY                               instructions.asm:528
0xC0F3  0xFA            PLX                     // PLX                               instructions.asm:529
0xC0F4  0x68            PLA                     // PLA                               instructions.asm:530
0xC0F5  0x60            RTS                     // }                                 instructions.asm:531

// /source/projects/6502sbc/hopperbasic/instructions.asm:538
// ####  Instructions.LogicalNot()  ####                                        0x01E5

0xC0F6  0x48            PHA                     // PHA                               instructions.asm:539
0xC0F7  0xDA            PHX                     // PHX                               instructions.asm:540
0xC0F8  0x5A            PHY                     // PHY                               instructions.asm:541
0xC0F9  0x20 0x79 0x94  JSR 0x9479              // Stacks.PopTop();                  instructions.asm:545
0xC0FC  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       instructions.asm:548
0xC0FE  0xC9 0x06       CMP # 0x06              // CMP #BASICType.BIT                instructions.asm:549
0xC100  0xF0 0x05       BEQ 0xC107 (+5)         // if (NZ)                           instructions.asm:550
0xC102  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xC105  0x80 0x09       BRA 0xC110 (+9)         // break;                            instructions.asm:553
0xC107  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       instructions.asm:557
0xC109  0x49 0x01       EOR # 1                 // EOR #0x01                         instructions.asm:558
0xC10B  0xAA            TAX                     // TAX                               instructions.asm:559
0xC10C  0x20 0xEA 0x94  JSR 0x94EA              // Stacks.PushX();                   instructions.asm:561
0xC10F  0x38            SEC                     // SEC                               instructions.asm:562
0xC110  0x7A            PLY                     // PLY                               instructions.asm:566
0xC111  0xFA            PLX                     // PLX                               instructions.asm:567
0xC112  0x68            PLA                     // PLA                               instructions.asm:568
0xC113  0x60            RTS                     // }                                 instructions.asm:569

// /source/projects/6502sbc/hopperbasic/functiondeclaration.asm:8
// ####  FunctionDeclaration.stmtObjectPtrToIDX()  ####                         0x01E6

0xC114  0xAD 0xAF 0x0B  LDA 0x0BAF              // LDA (Statement.stmtObjectPtr + 0) functiondeclaration.asm:9
0xC117  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       functiondeclaration.asm:10
0xC119  0xAD 0xB0 0x0B  LDA 0x0BB0              // LDA (Statement.stmtObjectPtr + 1) functiondeclaration.asm:11
0xC11C  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       functiondeclaration.asm:12
0xC11E  0x60            RTS                     // }                                 functiondeclaration.asm:13

// /source/projects/6502sbc/hopperbasic/functiondeclaration.asm:17
// ####  FunctionDeclaration.illegalCommentCheck()  ####                        0x01E7

0xC11F  0xC9 0x95       CMP # 0x95              // CMP # Token.COMMENT               functiondeclaration.asm:18
0xC121  0xD0 0x03       BNE 0xC126 (+3)         // if (Z)                            functiondeclaration.asm:19
0xC123  0x4C 0x8A 0x8B  JMP 0x8B8A              // Error.IllegalComment();    does CLC
0xC126  0x38            SEC                     // SEC                               functiondeclaration.asm:24
0xC127  0x60            RTS                     // }                                 functiondeclaration.asm:25

// /source/projects/6502sbc/hopperbasic/functiondeclaration.asm:28
// ####  FunctionDeclaration.IDXtoStmtObjectPtr()  ####                         0x01E8

0xC128  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       functiondeclaration.asm:29
0xC12A  0x8D 0xAF 0x0B  STA 0x0BAF              // STA (Statement.stmtObjectPtr + 0) functiondeclaration.asm:30
0xC12D  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       functiondeclaration.asm:31
0xC12F  0x8D 0xB0 0x0B  STA 0x0BB0              // STA (Statement.stmtObjectPtr + 1) functiondeclaration.asm:32
0xC132  0x60            RTS                     // }                                 functiondeclaration.asm:33

// /source/projects/6502sbc/hopperbasic/functiondeclaration.asm:42
// ####  FunctionDeclaration.ExecuteBeginDeclaration()  ####                    0x01E9

0xC133  0x20 0x16 0x86  JSR 0x8616              // Messages.Main();    point ZP.TOP -> "$MAIN"
0xC136  0x20 0x99 0xA7  JSR 0xA799              // Functions.Find();    Input: ZP.TOP = name
0xC139  0x90 0x08       BCC 0xC143 (+8)         // if (C)                            functiondeclaration.asm:52
0xC13B  0x20 0xFE 0xA7  JSR 0xA7FE              // Functions.Remove();               functiondeclaration.asm:55
0xC13E  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:56
0xC141  0x90 0x2C       BCC 0xC16F (+44)        // if (NC) { break; }                functiondeclaration.asm:57
0xC143  0x64 0x16       STZ 0x16                // STZ ZP.NEXTL    Arguments list head = null (no arguments)
0xC145  0x64 0x17       STZ 0x17                // STZ ZP.NEXTH                      functiondeclaration.asm:68
0xC147  0x64 0x1D       STZ 0x1D                // STZ ZP.IDYL     Function body tokens = null (will be set later)
0xC149  0x64 0x1E       STZ 0x1E                // STZ ZP.IDYH                       functiondeclaration.asm:70
0xC14B  0x20 0x5F 0xA7  JSR 0xA75F              // Functions.Declare();    Input: ZP.TOP = name, ZP.NEXT = args head, ZP.IDY = body tokens
0xC14E  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:74
0xC151  0x90 0x1C       BCC 0xC16F (+28)        // if (NC) { break; }                functiondeclaration.asm:75
0xC153  0x20 0x28 0xC1  JSR 0xC128              // IDXtoStmtObjectPtr();             functiondeclaration.asm:78
0xC156  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:81
0xC159  0x90 0x14       BCC 0xC16F (+20)        // if (NC) { break; }                functiondeclaration.asm:82
0xC15B  0x20 0x1F 0xC1  JSR 0xC11F              // illegalCommentCheck(); if (NC) { BIT ZP.EmulatorPCL break; }
0xC15E  0x90 0x0F       BCC 0xC16F (+15)
0xC160  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    functiondeclaration.asm:89
0xC162  0xD0 0x02       BNE 0xC166 (+2)         // if (Z)                            functiondeclaration.asm:90
0xC164  0x38            SEC                     // SEC    Success - incomplete function ready for capture
0xC165  0x60            RTS                     // break;                            functiondeclaration.asm:94
0xC166  0x20 0x71 0xC2  JSR 0xC271              // captureBeginBody();               functiondeclaration.asm:98
0xC169  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:99
0xC16C  0x90 0x01       BCC 0xC16F (+1)         // if (NC) { break; }                functiondeclaration.asm:100
0xC16E  0x38            SEC                     // SEC    Success                    functiondeclaration.asm:102
0xC16F  0x60            RTS                     // }                                 functiondeclaration.asm:109

// /source/projects/6502sbc/hopperbasic/functiondeclaration.asm:120
// ####  FunctionDeclaration.ExecuteFunctionDeclaration()  ####                 0x01EA

0xC170  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:128
0xC173  0xB0 0x01       BCS 0xC176 (+1)         // if (NC) { break; }                functiondeclaration.asm:129
0xC175  0x60            RTS
0xC176  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:132
0xC178  0xC9 0xDA       CMP # 0xDA              // CMP #Token.IDENTIFIER             functiondeclaration.asm:133
0xC17A  0xF0 0x0B       BEQ 0xC187 (+11)        // if (NZ)                           functiondeclaration.asm:134
0xC17C  0x20 0x6A 0x8A  JSR 0x8A6A              // Tokens.IsKeyword();               functiondeclaration.asm:136
0xC17F  0x90 0x03       BCC 0xC184 (+3)         // if (C)                            functiondeclaration.asm:137
0xC181  0x4C 0x99 0x8B  JMP 0x8B99              // Error.IllegalType(); BIT ZP.EmulatorPCL     ZP.CurrentToken
0xC184  0x4C 0x7B 0x8B  JMP 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xC187  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();    Returns pointer in ZP.TOP
0xC18A  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:150
0xC18D  0xB0 0x01       BCS 0xC190 (+1)         // if (NC) { break; }                functiondeclaration.asm:151
0xC18F  0x60            RTS
0xC190  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       functiondeclaration.asm:154
0xC192  0x8D 0xA0 0x0B  STA 0x0BA0              // STA (Statement.stmtNamePtr + 0)   functiondeclaration.asm:155
0xC195  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       functiondeclaration.asm:156
0xC197  0x8D 0xA1 0x0B  STA 0x0BA1              // STA (Statement.stmtNamePtr + 1)   functiondeclaration.asm:157
0xC19A  0x20 0x99 0xA7  JSR 0xA799              // Functions.Find();    Input: ZP.TOP = name
0xC19D  0x90 0x09       BCC 0xC1A8 (+9)         // if (C)                            functiondeclaration.asm:161
0xC19F  0x20 0xFE 0xA7  JSR 0xA7FE              // Functions.Remove();               functiondeclaration.asm:164
0xC1A2  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:165
0xC1A5  0xB0 0x01       BCS 0xC1A8 (+1)         // if (NC) { break; }                functiondeclaration.asm:166
0xC1A7  0x60            RTS
0xC1A8  0x64 0x47       STZ 0x47                // STZ ZP.SymbolIteratorFilter    Accept any symbol type
0xC1AA  0x20 0x8E 0xA1  JSR 0xA18E              // Variables.Find();    Input: ZP.TOP = name
0xC1AD  0x90 0x17       BCC 0xC1C6 (+23)        // if (C)                            functiondeclaration.asm:172
0xC1AF  0x20 0xA9 0xA2  JSR 0xA2A9              // Variables.GetType();    Input: ZP.IDX, Output: ZP.ACCT = symbolType|dataType
0xC1B2  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:176
0xC1B5  0xB0 0x01       BCS 0xC1B8 (+1)         // if (NC) { break; }                functiondeclaration.asm:177
0xC1B7  0x60            RTS
0xC1B8  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       functiondeclaration.asm:179
0xC1BA  0x29 0xC0       AND # 0xC0              // AND #SymbolType.MASK              functiondeclaration.asm:180
0xC1BC  0xC9 0x80       CMP # 0x80              // CMP #SymbolType.CONSTANT          functiondeclaration.asm:181
0xC1BE  0xD0 0x03       BNE 0xC1C3 (+3)         // if (Z)                            functiondeclaration.asm:182
0xC1C0  0x4C 0xF7 0x8B  JMP 0x8BF7              // Error.ConstantExistsTOP(); BIT ZP.EmulatorPCL    name is in ZP.TOP
0xC1C3  0x4C 0xFC 0x8B  JMP 0x8BFC              // Error.VariableExistsTOP(); BIT ZP.EmulatorPCL     name is in ZP.TOP
0xC1C6  0xAD 0xA0 0x0B  LDA 0x0BA0              // LDA (Statement.stmtNamePtr + 0)   functiondeclaration.asm:194
0xC1C9  0x85 0x11       STA 0x11                // STA ZP.TOPL                       functiondeclaration.asm:195
0xC1CB  0xAD 0xA1 0x0B  LDA 0x0BA1              // LDA (Statement.stmtNamePtr + 1)   functiondeclaration.asm:196
0xC1CE  0x85 0x12       STA 0x12                // STA ZP.TOPH                       functiondeclaration.asm:197
0xC1D0  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:200
0xC1D3  0xB0 0x01       BCS 0xC1D6 (+1)         // if (NC) { break; }                functiondeclaration.asm:201
0xC1D5  0x60            RTS
0xC1D6  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:203
0xC1D8  0xC9 0xE4       CMP # 0xE4              // CMP #Token.LPAREN                 functiondeclaration.asm:204
0xC1DA  0xF0 0x03       BEQ 0xC1DF (+3)         // if (NZ)                           functiondeclaration.asm:205
0xC1DC  0x4C 0x3D 0x8C  JMP 0x8C3D              // Error.ExpectedLeftParen(); BIT ZP.EmulatorPCL
0xC1DF  0xAD 0xA0 0x0B  LDA 0x0BA0              // LDA (Statement.stmtNamePtr + 0)   functiondeclaration.asm:213
0xC1E2  0x85 0x11       STA 0x11                // STA ZP.TOPL                       functiondeclaration.asm:214
0xC1E4  0xAD 0xA1 0x0B  LDA 0x0BA1              // LDA (Statement.stmtNamePtr + 1)   functiondeclaration.asm:215
0xC1E7  0x85 0x12       STA 0x12                // STA ZP.TOPH                       functiondeclaration.asm:216
0xC1E9  0x64 0x16       STZ 0x16                // STZ ZP.NEXTL    Arguments list head = null
0xC1EB  0x64 0x17       STZ 0x17                // STZ ZP.NEXTH                      functiondeclaration.asm:220
0xC1ED  0x64 0x1D       STZ 0x1D                // STZ ZP.IDYL     Function body tokens = null (will be set later)
0xC1EF  0x64 0x1E       STZ 0x1E                // STZ ZP.IDYH                       functiondeclaration.asm:222
0xC1F1  0x20 0x5F 0xA7  JSR 0xA75F              // Functions.Declare();    Input: ZP.TOP = name, ZP.NEXT = args head, ZP.IDY = body tokens
0xC1F4  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:226
0xC1F7  0x90 0x2D       BCC 0xC226 (+45)        // if (NC) { break; }                functiondeclaration.asm:227
0xC1F9  0x20 0x28 0xC1  JSR 0xC128              // IDXtoStmtObjectPtr();             functiondeclaration.asm:230
0xC1FC  0x20 0x27 0xC2  JSR 0xC227              // parseParameterList();             functiondeclaration.asm:233
0xC1FF  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:234
0xC202  0x90 0x22       BCC 0xC226 (+34)        // if (NC) { break; }                functiondeclaration.asm:235
0xC204  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:238
0xC206  0xC9 0xE5       CMP # 0xE5              // CMP #Token.RPAREN                 functiondeclaration.asm:239
0xC208  0xF0 0x03       BEQ 0xC20D (+3)         // if (NZ)                           functiondeclaration.asm:240
0xC20A  0x4C 0x38 0x8C  JMP 0x8C38              // Error.ExpectedRightParen(); BIT ZP.EmulatorPCL
0xC20D  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:247
0xC210  0x90 0x14       BCC 0xC226 (+20)        // if (NC) { break; }                functiondeclaration.asm:248
0xC212  0x20 0x1F 0xC1  JSR 0xC11F              // illegalCommentCheck(); if (NC) {  BIT ZP.EmulatorPCL break; }
0xC215  0x90 0x0F       BCC 0xC226 (+15)
0xC217  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    functiondeclaration.asm:255
0xC219  0xD0 0x02       BNE 0xC21D (+2)         // if (Z)                            functiondeclaration.asm:256
0xC21B  0x38            SEC                     // SEC    Success - incomplete function ready for capture
0xC21C  0x60            RTS                     // break;                            functiondeclaration.asm:261
0xC21D  0x20 0xBD 0xC2  JSR 0xC2BD              // captureFunctionBody();            functiondeclaration.asm:265
0xC220  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:266
0xC223  0x90 0x01       BCC 0xC226 (+1)         // if (NC) { break; }                functiondeclaration.asm:267
0xC225  0x38            SEC                     // SEC    Success                    functiondeclaration.asm:269
0xC226  0x60            RTS                     // }                                 functiondeclaration.asm:276

// /source/projects/6502sbc/hopperbasic/functiondeclaration.asm:285
// ####  FunctionDeclaration.parseParameterList()  ####                         0x01EB

0xC227  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:293
0xC22A  0xB0 0x01       BCS 0xC22D (+1)         // if (NC) { break; }                functiondeclaration.asm:294
0xC22C  0x60            RTS
0xC22D  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:297
0xC22F  0xC9 0xE5       CMP # 0xE5              // CMP #Token.RPAREN                 functiondeclaration.asm:298
0xC231  0xD0 0x02       BNE 0xC235 (+2)         // if (Z)                            functiondeclaration.asm:299
0xC233  0x38            SEC                     // SEC    Success - empty parameter list
0xC234  0x60            RTS                     // break;                            functiondeclaration.asm:302
0xC235  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:309
0xC237  0xC9 0xDA       CMP # 0xDA              // CMP #Token.IDENTIFIER             functiondeclaration.asm:310
0xC239  0xF0 0x03       BEQ 0xC23E (+3)         // if (NZ)                           functiondeclaration.asm:311
0xC23B  0x4C 0x7B 0x8B  JMP 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xC23E  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();    Result in ZP.TOP
0xC241  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:319
0xC244  0x90 0x2A       BCC 0xC270 (+42)        // if (NC) { break; }                functiondeclaration.asm:320
0xC246  0x20 0x14 0xC1  JSR 0xC114              // stmtObjectPtrToIDX();             functiondeclaration.asm:324
0xC249  0xA9 0x40       LDA # 0x40              // LDA #SymbolType.ARGUMENT          functiondeclaration.asm:326
0xC24B  0x09 0x10       ORA # 0x10              // ORA #BASICType.VAR                functiondeclaration.asm:327
0xC24D  0x85 0x40       STA 0x40                // STA ZP.SymbolType    argument for Locals.Add()
0xC24F  0x20 0x98 0xA4  JSR 0xA498              // Locals.Add();    Input: ZP.IDX = function node, ZP.TOP = argument name
0xC252  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:331
0xC255  0x90 0x19       BCC 0xC270 (+25)        // if (NC) { break; }                functiondeclaration.asm:332
0xC257  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:335
0xC25A  0x90 0x14       BCC 0xC270 (+20)        // if (NC) { break; }                functiondeclaration.asm:336
0xC25C  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:339
0xC25E  0xC9 0xE5       CMP # 0xE5              // CMP #Token.RPAREN                 functiondeclaration.asm:340
0xC260  0xD0 0x02       BNE 0xC264 (+2)         // if (Z)                            functiondeclaration.asm:341
0xC262  0x38            SEC                     // SEC    Success - end of parameter list
0xC263  0x60            RTS                     // break;                            functiondeclaration.asm:344
0xC264  0xC9 0xDF       CMP # 0xDF              // CMP #Token.COMMA                  functiondeclaration.asm:348
0xC266  0xF0 0x03       BEQ 0xC26B (+3)         // if (NZ)                           functiondeclaration.asm:349
0xC268  0x4C 0x7B 0x8B  JMP 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xC26B  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:356
0xC26E  0xB0 0xC5       BCS 0xC235 (-59)        // if (NC) { break; }                functiondeclaration.asm:357
0xC270  0x60            RTS                     // break;    Exit outer loop         functiondeclaration.asm:362

// /source/projects/6502sbc/hopperbasic/functiondeclaration.asm:378
// ####  FunctionDeclaration.captureBeginBody()  ####                           0x01EC

0xC271  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              functiondeclaration.asm:386
0xC273  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            functiondeclaration.asm:387
0xC275  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              functiondeclaration.asm:388
0xC277  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            functiondeclaration.asm:389
0xC279  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:394
0xC27B  0xC9 0xDB       CMP # 0xDB              // CMP #Token.EOF                    functiondeclaration.asm:395
0xC27D  0xD0 0x05       BNE 0xC284 (+5)         // if (Z)                            functiondeclaration.asm:396
0xC27F  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xC282  0x80 0x14       BRA 0xC298 (+20)        // break;                            functiondeclaration.asm:400
0xC284  0xC9 0xA9       CMP # 0xA9              // CMP #Token.END                    functiondeclaration.asm:403
0xC286  0xD0 0x0B       BNE 0xC293 (+11)        // if (Z)                            functiondeclaration.asm:404
0xC288  0x20 0x25 0xBE  JSR 0xBE25              // Tokenizer.PeekToken();    next token -> A
0xC28B  0x20 0x1F 0xC1  JSR 0xC11F              // illegalCommentCheck(); if (NC) { BIT ZP.EmulatorPCL break; }
0xC28E  0x90 0x08       BCC 0xC298 (+8)
0xC290  0x38            SEC                     // SEC                               functiondeclaration.asm:411
0xC291  0x80 0x05       BRA 0xC298 (+5)         // break;                            functiondeclaration.asm:412
0xC293  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:416
0xC296  0xB0 0xE1       BCS 0xC279 (-31)        // if (NC) { break; }                functiondeclaration.asm:417
0xC298  0x90 0x22       BCC 0xC2BC (+34)        // if (NC) { break; }    Error during scanning
0xC29A  0x20 0x01 0xDD  JSR 0xDD01              // Statement.calculateTokensLength();
0xC29D  0x20 0x91 0x93  JSR 0x9391              // DecSOURCEADDRESS();               functiondeclaration.asm:427
0xC2A0  0x20 0x38 0x96  JSR 0x9638              // Tools.CreateTokenStream();    captureBeginBody() : Munts: A, ZP.IDY, ZP.ACC, ZP.FLENGTH, ZP.FSOURCEADDRESS, ZP.FDESTINATIONADDRESS, -> ZP.IDY
0xC2A3  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:431
0xC2A6  0x90 0x14       BCC 0xC2BC (+20)        // if (NC) { break; }                functiondeclaration.asm:432
0xC2A8  0x20 0x14 0xC1  JSR 0xC114              // stmtObjectPtrToIDX();             functiondeclaration.asm:435
0xC2AB  0x20 0x6C 0xA8  JSR 0xA86C              // Functions.SetBody();    Input: ZP.IDX = function node, ZP.IDY = body tokens
0xC2AE  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:438
0xC2B1  0x90 0x09       BCC 0xC2BC (+9)         // if (NC) { break; }                functiondeclaration.asm:439
0xC2B3  0x20 0xA7 0xA8  JSR 0xA8A7              // Functions.FreeAllOpCodes();    compiled FUNCs potentially stale now
0xC2B6  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:444
0xC2B9  0x90 0x01       BCC 0xC2BC (+1)         // if (NC) { break; }                functiondeclaration.asm:445
0xC2BB  0x38            SEC                     // SEC    Success                    functiondeclaration.asm:447
0xC2BC  0x60            RTS                     // }                                 functiondeclaration.asm:454

// /source/projects/6502sbc/hopperbasic/functiondeclaration.asm:464
// ####  FunctionDeclaration.captureFunctionBody()  ####                        0x01ED

0xC2BD  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              functiondeclaration.asm:472
0xC2BF  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            functiondeclaration.asm:473
0xC2C1  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              functiondeclaration.asm:474
0xC2C3  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            functiondeclaration.asm:475
0xC2C5  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:480
0xC2C7  0xC9 0xDB       CMP # 0xDB              // CMP #Token.EOF                    functiondeclaration.asm:481
0xC2C9  0xD0 0x05       BNE 0xC2D0 (+5)         // if (Z)                            functiondeclaration.asm:482
0xC2CB  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xC2CE  0x80 0x15       BRA 0xC2E5 (+21)        // break;                            functiondeclaration.asm:486
0xC2D0  0xC9 0xA6       CMP # 0xA6              // CMP #Token.ENDFUNC                functiondeclaration.asm:489
0xC2D2  0xD0 0x0B       BNE 0xC2DF (+11)        // if (Z)                            functiondeclaration.asm:490
0xC2D4  0x20 0x25 0xBE  JSR 0xBE25              // Tokenizer.PeekToken();    next token -> A
0xC2D7  0x20 0x1F 0xC1  JSR 0xC11F              // illegalCommentCheck(); if (NC) { BIT ZP.EmulatorPCL break; }
0xC2DA  0x90 0x09       BCC 0xC2E5 (+9)
0xC2DC  0x38            SEC                     // SEC                               functiondeclaration.asm:497
0xC2DD  0x80 0x06       BRA 0xC2E5 (+6)         // break;                            functiondeclaration.asm:498
0xC2DF  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:502
0xC2E2  0xB0 0xE1       BCS 0xC2C5 (-31)        // if (NC)                           functiondeclaration.asm:503
0xC2E4  0x18            CLC                     // CLC                               functiondeclaration.asm:505
0xC2E5  0x90 0x22       BCC 0xC309 (+34)        // if (NC) { break; }    Error during scanning
0xC2E7  0x20 0x01 0xDD  JSR 0xDD01              // Statement.calculateTokensLength();
0xC2EA  0x20 0x91 0x93  JSR 0x9391              // DecSOURCEADDRESS();               functiondeclaration.asm:518
0xC2ED  0x20 0x38 0x96  JSR 0x9638              // Tools.CreateTokenStream();    captureFunctionBody(): Munts: A, ZP.IDY, ZP.ACC, ZP.FLENGTH, ZP.FSOURCEADDRESS, ZP.FDESTINATIONADDRESS, -> ZP.IDY
0xC2F0  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:522
0xC2F3  0x90 0x14       BCC 0xC309 (+20)        // if (NC) { break; }                functiondeclaration.asm:523
0xC2F5  0x20 0x14 0xC1  JSR 0xC114              // stmtObjectPtrToIDX();             functiondeclaration.asm:527
0xC2F8  0x20 0x6C 0xA8  JSR 0xA86C              // Functions.SetBody();    Input: ZP.IDX = function node, ZP.IDY = body tokens
0xC2FB  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:530
0xC2FE  0x90 0x09       BCC 0xC309 (+9)         // if (NC) { break; }                functiondeclaration.asm:531
0xC300  0x20 0xA7 0xA8  JSR 0xA8A7              // Functions.FreeAllOpCodes();    compiled FUNCs potentially stale now
0xC303  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:536
0xC306  0x90 0x01       BCC 0xC309 (+1)         // if (NC) { break; }                functiondeclaration.asm:537
0xC308  0x38            SEC                     // SEC    Success                    functiondeclaration.asm:539
0xC309  0x60            RTS                     // }                                 functiondeclaration.asm:546

// /source/projects/6502sbc/hopperbasic/functiondeclaration.asm:555
// ####  FunctionDeclaration.CompletePartialFunction()  ####                    0x01EE

0xC30A  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL              functiondeclaration.asm:563
0xC30C  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              functiondeclaration.asm:564
0xC30E  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();    Gets FIRST token (should be FUNC)
0xC311  0xB0 0x01       BCS 0xC314 (+1)         // if (NC) { break; }                functiondeclaration.asm:568
0xC313  0x60            RTS
0xC314  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:570
0xC316  0xC9 0xA5       CMP # 0xA5              // CMP #Token.FUNC                   functiondeclaration.asm:571
0xC318  0xD0 0x34       BNE 0xC34E (+52)        // if (Z)                            functiondeclaration.asm:572
0xC31A  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();    Gets SECOND token (should be function name)
0xC31D  0xB0 0x01       BCS 0xC320 (+1)         // if (NC) { break; }                functiondeclaration.asm:576
0xC31F  0x60            RTS
0xC320  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:578
0xC322  0xC9 0xDA       CMP # 0xDA              // CMP #Token.IDENTIFIER             functiondeclaration.asm:579
0xC324  0xF0 0x03       BEQ 0xC329 (+3)         // if (NZ)                           functiondeclaration.asm:580
0xC326  0x4C 0x7B 0x8B  JMP 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xC329  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();    Result in ZP.TOP
0xC32C  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:588
0xC32F  0xB0 0x01       BCS 0xC332 (+1)         // if (NC) { break; }                functiondeclaration.asm:589
0xC331  0x60            RTS
0xC332  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:594
0xC335  0x90 0x14       BCC 0xC34B (+20)        // if (NC) { break; }                functiondeclaration.asm:595
0xC337  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:597
0xC339  0xC9 0xE5       CMP # 0xE5              // CMP #Token.RPAREN                 functiondeclaration.asm:598
0xC33B  0xD0 0x07       BNE 0xC344 (+7)         // if (Z)                            functiondeclaration.asm:599
0xC33D  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();    Move past RPAREN to start of body
0xC340  0x90 0x09       BCC 0xC34B (+9)         // if (NC) { break; }                functiondeclaration.asm:602
0xC342  0x80 0x07       BRA 0xC34B (+7)
0xC344  0xC9 0xDB       CMP # 0xDB              // CMP #Token.EOF                    functiondeclaration.asm:606
0xC346  0xD0 0xEA       BNE 0xC332 (-22)        // if (Z)                            functiondeclaration.asm:607
0xC348  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xC34B  0xB0 0x11       BCS 0xC35E (+17)        // if (NC) { break; }                functiondeclaration.asm:613
0xC34D  0x60            RTS
0xC34E  0xC9 0xA8       CMP # 0xA8              // CMP #Token.BEGIN                  functiondeclaration.asm:617
0xC350  0xF0 0x03       BEQ 0xC355 (+3)         // if (NZ)                           functiondeclaration.asm:618
0xC352  0x4C 0xCA 0x8B  JMP 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0xC355  0x20 0x16 0x86  JSR 0x8616              // Messages.Main();    point ZP.TOP -> "$MAIN"
0xC358  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:627
0xC35B  0xB0 0x01       BCS 0xC35E (+1)         // if (NC) { break; }                functiondeclaration.asm:628
0xC35D  0x60            RTS
0xC35E  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:632
0xC360  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    functiondeclaration.asm:633
0xC362  0xF0 0x06       BEQ 0xC36A (+6)         // if (NZ)                           functiondeclaration.asm:634
0xC364  0xC6 0x2B       DEC 0x2B                // DEC ZP.TokenizerPosL              functiondeclaration.asm:637
0xC366  0xD0 0x02       BNE 0xC36A (+2)         // if (Z)                            functiondeclaration.asm:638
0xC368  0xC6 0x2C       DEC 0x2C                // DEC ZP.TokenizerPosH              functiondeclaration.asm:640
0xC36A  0x20 0x99 0xA7  JSR 0xA799              // Functions.Find();    Input: ZP.TOP = name, Output: ZP.IDX = function node
0xC36D  0xB0 0x03       BCS 0xC372 (+3)         // if (NC)                           functiondeclaration.asm:647
0xC36F  0x4C 0x8F 0x8B  JMP 0x8B8F              // Error.UndefinedIdentifierTOP(); BIT ZP.EmulatorPCL
0xC372  0x20 0x28 0xC1  JSR 0xC128              // IDXtoStmtObjectPtr();             functiondeclaration.asm:654
0xC375  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              functiondeclaration.asm:656
0xC377  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            functiondeclaration.asm:657
0xC379  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              functiondeclaration.asm:658
0xC37B  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            functiondeclaration.asm:659
0xC37D  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              functiondeclaration.asm:665
0xC37F  0x8D 0xBB 0x0B  STA 0x0BBB              // STA Statement.stmtTemp0           functiondeclaration.asm:666
0xC382  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              functiondeclaration.asm:667
0xC384  0x8D 0xBC 0x0B  STA 0x0BBC              // STA Statement.stmtTemp1           functiondeclaration.asm:668
0xC387  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       functiondeclaration.asm:670
0xC38A  0x90 0x25       BCC 0xC3B1 (+37)        // if (NC)                           functiondeclaration.asm:671
0xC38C  0xC9 0xDB       CMP # 0xDB              // CMP #Token.EOF                    functiondeclaration.asm:675
0xC38E  0xD0 0x05       BNE 0xC395 (+5)         // if (Z)                            functiondeclaration.asm:676
0xC390  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xC393  0x80 0x1C       BRA 0xC3B1 (+28)        // break;                            functiondeclaration.asm:679
0xC395  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               functiondeclaration.asm:682
0xC397  0xC9 0xA6       CMP # 0xA6              // CMP #Token.ENDFUNC                functiondeclaration.asm:683
0xC399  0xF0 0x04       BEQ 0xC39F (+4)         // if (NZ)                           functiondeclaration.asm:684
0xC39B  0xC9 0xA9       CMP # 0xA9              // CMP #Token.END                    functiondeclaration.asm:686
0xC39D  0xD0 0xDE       BNE 0xC37D (-34)        // if (NZ)                           functiondeclaration.asm:687
0xC39F  0x20 0x25 0xBE  JSR 0xBE25              // Tokenizer.PeekToken();    next token -> A
0xC3A2  0x20 0x1F 0xC1  JSR 0xC11F              // illegalCommentCheck(); if (NC) { BIT ZP.EmulatorPCL break; }
0xC3A5  0x90 0x0A       BCC 0xC3B1 (+10)
0xC3A7  0xAD 0xBC 0x0B  LDA 0x0BBC              // LDA Statement.stmtTemp1           functiondeclaration.asm:699
0xC3AA  0x85 0x2C       STA 0x2C                // STA ZP.TokenizerPosH              functiondeclaration.asm:700
0xC3AC  0xAD 0xBB 0x0B  LDA 0x0BBB              // LDA Statement.stmtTemp0           functiondeclaration.asm:701
0xC3AF  0x85 0x2B       STA 0x2B                // STA ZP.TokenizerPosL              functiondeclaration.asm:702
0xC3B1  0x90 0x1A       BCC 0xC3CD (+26)        // if (NC) { break; }                functiondeclaration.asm:706
0xC3B3  0x20 0x01 0xDD  JSR 0xDD01              // Statement.calculateTokensLength();
0xC3B6  0x20 0x38 0x96  JSR 0x9638              // Tools.CreateTokenStream();    CompletePartialFunction(): Munts: A, ZP.IDY, ZP.ACC, ZP.FLENGTH, ZP.FSOURCEADDRESS, ZP.FDESTINATIONADDRESS, -> ZP.IDY
0xC3B9  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:713
0xC3BC  0x90 0x0F       BCC 0xC3CD (+15)        // if (NC) { break; }                functiondeclaration.asm:714
0xC3BE  0x20 0x14 0xC1  JSR 0xC114              // stmtObjectPtrToIDX();             functiondeclaration.asm:717
0xC3C1  0x20 0x6C 0xA8  JSR 0xA86C              // Functions.SetBody();    Input: ZP.IDX = function node, ZP.IDY = body tokens
0xC3C4  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     functiondeclaration.asm:720
0xC3C7  0x90 0x04       BCC 0xC3CD (+4)         // if (NC) { break; }                functiondeclaration.asm:721
0xC3C9  0x20 0xA7 0xA8  JSR 0xA8A7              // Functions.FreeAllOpCodes();    compiled FUNCs potentially stale now
0xC3CC  0x38            SEC                     // SEC    Success                    functiondeclaration.asm:725
0xC3CD  0x60            RTS                     // }                                 functiondeclaration.asm:732

// /source/projects/6502sbc/hopperbasic/emit.asm:5
// ####  Emit.RuntimeErrorCheck()  ####                                         0x01EF

0xC3CE  0x7F 0x02 0x13  BBR7 0x02, 0xC3E4 (+19) // if (BBS7, ZP.FLAGS)    compiling to find error location?
0xC3D1  0xA5 0x7F       LDA 0x7F                // LDA ZP.XPCH                       emit.asm:14
0xC3D3  0xC5 0x01       CMP 0x01                // CMP ZP.PCH                        emit.asm:15
0xC3D5  0xD0 0x04       BNE 0xC3DB (+4)         // if (Z)                            emit.asm:16
0xC3D7  0xA5 0x7E       LDA 0x7E                // LDA ZP.XPCL                       emit.asm:18
0xC3D9  0xC5 0x00       CMP 0x00                // CMP ZP.PCL                        emit.asm:19
0xC3DB  0x90 0x07       BCC 0xC3E4 (+7)         // if (C)   C set if XPC >= PC       emit.asm:21
0xC3DD  0xA5 0xA8       LDA 0xA8                // LDA ZP.RuntimeError               emit.asm:24
0xC3DF  0x85 0x2D       STA 0x2D                // STA ZP.LastError                  emit.asm:25
0xC3E1  0x4C 0x59 0x8C  JMP 0x8C59              // CheckError();                     emit.asm:27
0xC3E4  0x38            SEC                     // SEC                               emit.asm:31
0xC3E5  0x60            RTS                     // break;                            emit.asm:32

// /source/projects/6502sbc/hopperbasic/emit.asm:41
// ####  Emit.OpCode()  ####                                                    0x01F0

0xC3E6  0x48            PHA                     // PHA    relied on: see compileMultiplicative()
0xC3E7  0x8D 0x82 0x0B  STA 0x0B82              // STA Compiler.compilerOpCode       emit.asm:45
0xC3EA  0xA9 0x01       LDA # 1                 // LDA #1                            emit.asm:48
0xC3EC  0x20 0x8D 0xD0  JSR 0xD08D              // CheckBufferSpace();               emit.asm:49
0xC3EF  0xB0 0x05       BCS 0xC3F6 (+5)         // if (NC)                           emit.asm:50
0xC3F1  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     emit.asm:52
0xC3F4  0x80 0x17       BRA 0xC40D (+23)        // break;                            emit.asm:53
0xC3F6  0x20 0xCE 0xC3  JSR 0xC3CE              // RuntimeErrorCheck(); if (NC) { break; }
0xC3F9  0x90 0x12       BCC 0xC40D (+18)
0xC3FB  0xAD 0x82 0x0B  LDA 0x0B82              // LDA Compiler.compilerOpCode       emit.asm:59
0xC3FE  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      emit.asm:60
0xC400  0x8D 0x86 0x0B  STA 0x0B86              // STA Compiler.compilerLastOpCode   emit.asm:61
0xC403  0xE6 0x7E       INC 0x7E                // INC ZP.XPCL                       emit.asm:64
0xC405  0xD0 0x02       BNE 0xC409 (+2)         // if (Z)                            emit.asm:65
0xC407  0xE6 0x7F       INC 0x7F                // INC ZP.XPCH                       emit.asm:67
0xC409  0x20 0x44 0xCF  JSR 0xCF44              // Optimizer.Peep();    current opcode is in Compiler.compilerOpCode
0xC40C  0x38            SEC                     // SEC    Success                    emit.asm:73
0xC40D  0x68            PLA                     // PLA                               emit.asm:76
0xC40E  0x60            RTS                     // }                                 emit.asm:77

// /source/projects/6502sbc/hopperbasic/emit.asm:84
// ####  Emit.OpCodeWithByte()  ####                                            0x01F1

0xC40F  0x8D 0x82 0x0B  STA 0x0B82              // STA Compiler.compilerOpCode       emit.asm:87
0xC412  0xA9 0x02       LDA # 0x02              // LDA #2                            emit.asm:90
0xC414  0x20 0x8D 0xD0  JSR 0xD08D              // CheckBufferSpace();               emit.asm:91
0xC417  0x90 0x30       BCC 0xC449 (+48)        // if (NC)                           emit.asm:92
0xC419  0x20 0xCE 0xC3  JSR 0xC3CE              // RuntimeErrorCheck(); if (NC) { break; }
0xC41C  0x90 0x2B       BCC 0xC449 (+43)
0xC41E  0xAD 0x82 0x0B  LDA 0x0B82              // LDA Compiler.compilerOpCode       emit.asm:100
0xC421  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      emit.asm:101
0xC423  0x8D 0x86 0x0B  STA 0x0B86              // STA Compiler.compilerLastOpCode   emit.asm:102
0xC426  0xE6 0x7E       INC 0x7E                // INC ZP.XPCL                       emit.asm:105
0xC428  0xD0 0x02       BNE 0xC42C (+2)         // if (Z)                            emit.asm:106
0xC42A  0xE6 0x7F       INC 0x7F                // INC ZP.XPCH                       emit.asm:108
0xC42C  0xAD 0x83 0x0B  LDA 0x0B83              // LDA Compiler.compilerOperand1     emit.asm:112
0xC42F  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      emit.asm:113
0xC431  0xE6 0x7E       INC 0x7E                // INC ZP.XPCL                       emit.asm:116
0xC433  0xD0 0x02       BNE 0xC437 (+2)         // if (Z)                            emit.asm:117
0xC435  0xE6 0x7F       INC 0x7F                // INC ZP.XPCH                       emit.asm:119
0xC437  0x20 0x44 0xCF  JSR 0xCF44              // Optimizer.Peep();                 emit.asm:123
0xC43A  0xAD 0x82 0x0B  LDA 0x0B82              // LDA Compiler.compilerOpCode       emit.asm:124
0xC43D  0xC9 0x49       CMP # 0x49              // case OpCode.RETURN:               emit.asm:127
0xC43F  0xF0 0x04       BEQ 0xC445 (+4)
0xC441  0xC9 0x4A       CMP # 0x4A              // case OpCode.RETURNVAL:            emit.asm:128
0xC443  0xD0 0x03       BNE 0xC448 (+3)
0xC445  0x20 0x5E 0xCD  JSR 0xCD5E              // Optimizer.ClearPeeps();    RETURN and RETURNVAL (after optimization)
0xC448  0x38            SEC                     // SEC    Success                    emit.asm:135
0xC449  0x60            RTS                     // }                                 emit.asm:138

// /source/projects/6502sbc/hopperbasic/emit.asm:145
// ####  Emit.OpCodeWithWord()  ####                                            0x01F2

0xC44A  0x8D 0x82 0x0B  STA 0x0B82              // STA Compiler.compilerOpCode       emit.asm:148
0xC44D  0xA9 0x03       LDA # 0x03              // LDA #3                            emit.asm:151
0xC44F  0x20 0x8D 0xD0  JSR 0xD08D              // CheckBufferSpace();               emit.asm:152
0xC452  0x90 0x3D       BCC 0xC491 (+61)        // if (NC)                           emit.asm:153
0xC454  0x20 0xCE 0xC3  JSR 0xC3CE              // RuntimeErrorCheck(); if (NC) { break; }
0xC457  0x90 0x38       BCC 0xC491 (+56)
0xC459  0xAD 0x82 0x0B  LDA 0x0B82              // LDA Compiler.compilerOpCode       emit.asm:161
0xC45C  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      emit.asm:162
0xC45E  0x8D 0x86 0x0B  STA 0x0B86              // STA Compiler.compilerLastOpCode   emit.asm:163
0xC461  0xE6 0x7E       INC 0x7E                // INC ZP.XPCL                       emit.asm:166
0xC463  0xD0 0x02       BNE 0xC467 (+2)         // if (Z)                            emit.asm:167
0xC465  0xE6 0x7F       INC 0x7F                // INC ZP.XPCH                       emit.asm:169
0xC467  0xAD 0x83 0x0B  LDA 0x0B83              // LDA Compiler.compilerOperand1     emit.asm:173
0xC46A  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      emit.asm:174
0xC46C  0xE6 0x7E       INC 0x7E                // INC ZP.XPCL                       emit.asm:177
0xC46E  0xD0 0x02       BNE 0xC472 (+2)         // if (Z)                            emit.asm:178
0xC470  0xE6 0x7F       INC 0x7F                // INC ZP.XPCH                       emit.asm:180
0xC472  0xAD 0x84 0x0B  LDA 0x0B84              // LDA Compiler.compilerOperand2     emit.asm:184
0xC475  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      emit.asm:185
0xC477  0xE6 0x7E       INC 0x7E                // INC ZP.XPCL                       emit.asm:188
0xC479  0xD0 0x02       BNE 0xC47D (+2)         // if (Z)                            emit.asm:189
0xC47B  0xE6 0x7F       INC 0x7F                // INC ZP.XPCH                       emit.asm:191
0xC47D  0xAD 0x82 0x0B  LDA 0x0B82              // LDA Compiler.compilerOpCode       emit.asm:195
0xC480  0xC9 0x88       CMP # 0x88              // case OpCode.JUMPZW:               emit.asm:198
0xC482  0xF0 0x04       BEQ 0xC488 (+4)
0xC484  0xC9 0x87       CMP # 0x87              // case OpCode.JUMPW:                emit.asm:199
0xC486  0xD0 0x05       BNE 0xC48D (+5)
0xC488  0x20 0x5E 0xCD  JSR 0xCD5E              // Optimizer.ClearPeeps();    JUMPZW, JUMPW
0xC48B  0x80 0x03       BRA 0xC490 (+3)         // }                                 emit.asm:202
0xC48D  0x20 0x44 0xCF  JSR 0xCF44              // Optimizer.Peep();    current opcode is in Compiler.compilerOpCode
0xC490  0x38            SEC                     // SEC    Success                    emit.asm:210
0xC491  0x60            RTS                     // }                                 emit.asm:213

// /source/projects/6502sbc/hopperbasic/emit.asm:224
// ####  Emit.OpCodeWithThreeBytes()  ####                                      0x01F3

0xC492  0x8D 0x82 0x0B  STA 0x0B82              // STA Compiler.compilerOpCode       emit.asm:227
0xC495  0xA9 0x04       LDA # 0x04              // LDA #4                            emit.asm:229
0xC497  0x20 0x8D 0xD0  JSR 0xD08D              // CheckBufferSpace();               emit.asm:230
0xC49A  0xB0 0x01       BCS 0xC49D (+1)         // if (NC)                           emit.asm:231
0xC49C  0x60            RTS                     // break;                            emit.asm:233
0xC49D  0x20 0xCE 0xC3  JSR 0xC3CE              // RuntimeErrorCheck(); if (NC) { break; }
0xC4A0  0x90 0x47       BCC 0xC4E9 (+71)
0xC4A2  0xAD 0x82 0x0B  LDA 0x0B82              // LDA Compiler.compilerOpCode       emit.asm:239
0xC4A5  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      emit.asm:240
0xC4A7  0x8D 0x86 0x0B  STA 0x0B86              // STA Compiler.compilerLastOpCode   emit.asm:241
0xC4AA  0xE6 0x7E       INC 0x7E                // INC ZP.XPCL                       emit.asm:244
0xC4AC  0xD0 0x02       BNE 0xC4B0 (+2)         // if (Z)                            emit.asm:245
0xC4AE  0xE6 0x7F       INC 0x7F                // INC ZP.XPCH                       emit.asm:247
0xC4B0  0xAD 0x83 0x0B  LDA 0x0B83              // LDA Compiler.compilerOperand1     emit.asm:251
0xC4B3  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      emit.asm:252
0xC4B5  0xE6 0x7E       INC 0x7E                // INC ZP.XPCL                       emit.asm:255
0xC4B7  0xD0 0x02       BNE 0xC4BB (+2)         // if (Z)                            emit.asm:256
0xC4B9  0xE6 0x7F       INC 0x7F                // INC ZP.XPCH                       emit.asm:258
0xC4BB  0xAD 0x84 0x0B  LDA 0x0B84              // LDA Compiler.compilerOperand2     emit.asm:262
0xC4BE  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      emit.asm:263
0xC4C0  0xE6 0x7E       INC 0x7E                // INC ZP.XPCL                       emit.asm:266
0xC4C2  0xD0 0x02       BNE 0xC4C6 (+2)         // if (Z)                            emit.asm:267
0xC4C4  0xE6 0x7F       INC 0x7F                // INC ZP.XPCH                       emit.asm:269
0xC4C6  0xAD 0x85 0x0B  LDA 0x0B85              // LDA Compiler.compilerOperand3     emit.asm:273
0xC4C9  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      emit.asm:274
0xC4CB  0xE6 0x7E       INC 0x7E                // INC ZP.XPCL                       emit.asm:277
0xC4CD  0xD0 0x02       BNE 0xC4D1 (+2)         // if (Z)                            emit.asm:278
0xC4CF  0xE6 0x7F       INC 0x7F                // INC ZP.XPCH                       emit.asm:280
0xC4D1  0xAD 0x82 0x0B  LDA 0x0B82              // LDA Compiler.compilerOpCode       emit.asm:284
0xC4D4  0xC9 0xC1       CMP # 0xC1              // case OpCode.FORIT:                emit.asm:287
0xC4D6  0xF0 0x08       BEQ 0xC4E0 (+8)
0xC4D8  0xC9 0xC2       CMP # 0xC2              // case OpCode.FORITF:               emit.asm:288
0xC4DA  0xF0 0x04       BEQ 0xC4E0 (+4)
0xC4DC  0xC9 0xC0       CMP # 0xC0              // case OpCode.FORCHK:               emit.asm:289
0xC4DE  0xD0 0x05       BNE 0xC4E5 (+5)
0xC4E0  0x20 0x5E 0xCD  JSR 0xCD5E              // Optimizer.ClearPeeps();    FORIT, FORITF, FORCHK
0xC4E3  0x80 0x03       BRA 0xC4E8 (+3)         // }                                 emit.asm:292
0xC4E5  0x20 0x44 0xCF  JSR 0xCF44              // Optimizer.Peep();    current opcode is in Compiler.compilerOpCode
0xC4E8  0x38            SEC                     // SEC    Success                    emit.asm:299
0xC4E9  0x60            RTS                     // }                                 emit.asm:302

// /source/projects/6502sbc/hopperbasic/emit.asm:309
// ####  Emit.OptimizedConstant()  ####                                         0x01F4

0xC4EA  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       emit.asm:313
0xC4EC  0x29 0x0F       AND # 0x0F              // AND #BASICType.TYPEMASK           emit.asm:314
0xC4EE  0xC9 0x08       CMP # 0x08              // case BASICType.LONG:              emit.asm:317
0xC4F0  0xD0 0x22       BNE 0xC514 (+34)
0xC4F2  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       emit.asm:319
0xC4F4  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     emit.asm:320
0xC4F7  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       emit.asm:321
0xC4F9  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     emit.asm:322
0xC4FC  0xA9 0x04       LDA # 0x04              // LDA # BASICType.WORD              emit.asm:323
0xC4FE  0x85 0x15       STA 0x15                // STA ZP.TOPT                       emit.asm:324
0xC500  0x20 0xA3 0xC5  JSR 0xC5A3              // Emit.PushWord();                  emit.asm:325
0xC503  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       emit.asm:327
0xC505  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     emit.asm:328
0xC508  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       emit.asm:329
0xC50A  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     emit.asm:330
0xC50D  0xA9 0x08       LDA # 0x08              // LDA # BASICType.LONG              emit.asm:331
0xC50F  0x85 0x15       STA 0x15                // STA ZP.TOPT                       emit.asm:332
0xC511  0x4C 0xA3 0xC5  JMP 0xC5A3              // Emit.PushWord();                  emit.asm:333
0xC514  0xC9 0x02       CMP # 0x02              // case BASICType.INT:               emit.asm:338
0xC516  0xF0 0x04       BEQ 0xC51C (+4)
0xC518  0xC9 0x04       CMP # 0x04              // case BASICType.WORD:              emit.asm:339
0xC51A  0xD0 0x03       BNE 0xC51F (+3)
0xC51C  0x4C 0xCA 0x8B  JMP 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0xC51F  0xC9 0x03       CMP # 0x03              // case BASICType.BYTE:              emit.asm:352
0xC521  0xD0 0x03       BNE 0xC526 (+3)
0xC523  0x4C 0xCA 0x8B  JMP 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0xC526  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              emit.asm:360
0xC528  0xD0 0x05       BNE 0xC52F (+5)
0xC52A  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       emit.asm:362
0xC52C  0x4C 0x91 0xC5  JMP 0xC591              // Emit.PushChar();                  emit.asm:363
0xC52F  0xC9 0x06       CMP # 0x06              // case BASICType.BIT:               emit.asm:367
0xC531  0xD0 0x05       BNE 0xC538 (+5)
0xC533  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       emit.asm:369
0xC535  0x4C 0x68 0xC5  JMP 0xC568              // Emit.PushBit();                   emit.asm:370
0xC538  0x20 0xCA 0x8B  JSR 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0xC53B  0x38            SEC                     // SEC                               emit.asm:378
0xC53C  0x60            RTS                     // break;                            emit.asm:379

// /source/projects/6502sbc/hopperbasic/emit.asm:393
// ####  Emit.PushGlobal()  ####                                                0x01F5

0xC53D  0xDA            PHX                     // PHX                               emit.asm:394
0xC53E  0x5A            PHY                     // PHY                               emit.asm:395
0xC53F  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       emit.asm:400
0xC541  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     Index
0xC544  0xA9 0x4B       LDA # 0x4B              // LDA #OpCode.PUSHGLOBAL            emit.asm:404
0xC546  0x8D 0x82 0x0B  STA 0x0B82              // STA Compiler.compilerOpCode       emit.asm:405
0xC549  0x20 0x0F 0xC4  JSR 0xC40F              // Emit.OpCodeWithByte();            emit.asm:406
0xC54C  0x7A            PLY                     // PLY                               emit.asm:410
0xC54D  0xFA            PLX                     // PLX                               emit.asm:411
0xC54E  0x60            RTS                     // }                                 emit.asm:412

// /source/projects/6502sbc/hopperbasic/emit.asm:420
// ####  Emit.PopGlobal()  ####                                                 0x01F6

0xC54F  0xA9 0x40       LDA # 0x40              // LDA #SymbolType.VARIABLE          emit.asm:425
0xC551  0x85 0x47       STA 0x47                // STA ZP.SymbolIteratorFilter     Only variables (not constants)
0xC553  0x20 0x8E 0xA1  JSR 0xA18E              // Variables.Find();     Input: ZP.TOP = name
0xC556  0xB0 0x03       BCS 0xC55B (+3)         // if (NC)                           emit.asm:429
0xC558  0x4C 0x8F 0x8B  JMP 0x8B8F              // Error.UndefinedIdentifierTOP(); BIT ZP.EmulatorPCL
0xC55B  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       emit.asm:438
0xC55D  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     Index
0xC560  0xA9 0x4C       LDA # 0x4C              // LDA # OpCode.POPGLOBAL            emit.asm:442
0xC562  0x8D 0x82 0x0B  STA 0x0B82              // STA Compiler.compilerOpCode       emit.asm:443
0xC565  0x4C 0x0F 0xC4  JMP 0xC40F              // Emit.OpCodeWithByte();            emit.asm:444

// /source/projects/6502sbc/hopperbasic/emit.asm:457
// ####  Emit.PushBit()  ####                                                   0x01F7

0xC568  0xC9 0x02       CMP # 0x02              // CMP #2                            emit.asm:461
0xC56A  0x90 0x03       BCC 0xC56F (+3)         // if (C)    >= 2, invalid           emit.asm:462
0xC56C  0x4C 0x47 0x8C  JMP 0x8C47              // Error.InvalidBitValue(); BIT ZP.EmulatorPCL
0xC56F  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1             Store value as operand
0xC572  0xA9 0x40       LDA # 0x40              // LDA #OpCode.PUSHBIT               emit.asm:470
0xC574  0x4C 0x0F 0xC4  JMP 0xC40F              // Emit.OpCodeWithByte();            emit.asm:471

// /source/projects/6502sbc/hopperbasic/emit.asm:482
// ####  Emit.PushByte()  ####                                                  0x01F8

0xC577  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1             Store value as operand
0xC57A  0xC9 0x00       CMP # 0                 // case 0:                           emit.asm:487
0xC57C  0xD0 0x05       BNE 0xC583 (+5)
0xC57E  0xA9 0x15       LDA # 0x15              // LDA #OpCode.PUSH0                 emit.asm:489
0xC580  0x4C 0xE6 0xC3  JMP 0xC3E6              // Emit.OpCode();                    emit.asm:490
0xC583  0xC9 0x01       CMP # 1                 // case 1:                           emit.asm:492
0xC585  0xD0 0x05       BNE 0xC58C (+5)
0xC587  0xA9 0x16       LDA # 0x16              // LDA #OpCode.PUSH1                 emit.asm:494
0xC589  0x4C 0xE6 0xC3  JMP 0xC3E6              // Emit.OpCode();                    emit.asm:495
0xC58C  0xA9 0x41       LDA # 0x41              // LDA #OpCode.PUSHBYTE              emit.asm:499
0xC58E  0x4C 0x0F 0xC4  JMP 0xC40F              // Emit.OpCodeWithByte();            emit.asm:500

// /source/projects/6502sbc/hopperbasic/emit.asm:510
// ####  Emit.PushChar()  ####                                                  0x01F9

0xC591  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1             Store value as operand
0xC594  0xA9 0x42       LDA # 0x42              // LDA #OpCode.PUSHCHAR              emit.asm:513
0xC596  0x4C 0x0F 0xC4  JMP 0xC40F              // Emit.OpCodeWithByte();            emit.asm:514

// /source/projects/6502sbc/hopperbasic/emit.asm:522
// ####  Emit.PushVoid()  ####                                                  0x01FA

0xC599  0xA9 0x17       LDA # 0x17              // LDA #OpCode.PUSHVOID              emit.asm:523
0xC59B  0x4C 0xE6 0xC3  JMP 0xC3E6              // Emit.OpCode();                    emit.asm:524

// /source/projects/6502sbc/hopperbasic/emit.asm:532
// ####  Emit.PushEmptyVar()  ####                                              0x01FB

0xC59E  0xA9 0x1B       LDA # 0x1B              // LDA #OpCode.PUSHEMPTYVAR          emit.asm:533
0xC5A0  0x4C 0xE6 0xC3  JMP 0xC3E6              // Emit.OpCode();                    emit.asm:534

// /source/projects/6502sbc/hopperbasic/emit.asm:542
// ####  Emit.PushWord()  ####                                                  0x01FC

0xC5A3  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       emit.asm:546
0xC5A5  0xC9 0x02       CMP # 0x02              // CMP # BASICType.INT               emit.asm:547
0xC5A7  0xD0 0x05       BNE 0xC5AE (+5)         // if (Z)                            emit.asm:548
0xC5A9  0xA9 0x80       LDA # 0x80              // LDA #OpCode.PUSHINT               emit.asm:550
0xC5AB  0x4C 0x4A 0xC4  JMP 0xC44A              // Emit.OpCodeWithWord();            emit.asm:551
0xC5AE  0xC9 0x04       CMP # 0x04              // CMP #BASICType.WORD               emit.asm:555
0xC5B0  0xD0 0x05       BNE 0xC5B7 (+5)         // if (Z)                            emit.asm:556
0xC5B2  0xA9 0x81       LDA # 0x81              // LDA #OpCode.PUSHWORD              emit.asm:558
0xC5B4  0x4C 0x4A 0xC4  JMP 0xC44A              // Emit.OpCodeWithWord();            emit.asm:559
0xC5B7  0xC9 0x08       CMP # 0x08              // CMP #BASICType.LONG               emit.asm:562
0xC5B9  0xF0 0x03       BEQ 0xC5BE (+3)         // if (Z)                            emit.asm:563
0xC5BB  0x4C 0xED 0x8B  JMP 0x8BED
0xC5BE  0xAD 0x83 0x0B  LDA 0x0B83              // LDA Compiler.compilerOperand1     emit.asm:565
0xC5C1  0x0D 0x84 0x0B  ORA 0x0B84              // ORA Compiler.compilerOperand2     emit.asm:566
0xC5C4  0xD0 0x05       BNE 0xC5CB (+5)         // if (Z)                            emit.asm:567
0xC5C6  0xA9 0x18       LDA # 0x18              // LDA #OpCode.PUSHLONG0             emit.asm:569
0xC5C8  0x4C 0xE6 0xC3  JMP 0xC3E6              // Emit.OpCode();                    emit.asm:570
0xC5CB  0xA9 0x94       LDA # 0x94              // LDA #OpCode.PUSHLONG              emit.asm:574
0xC5CD  0x4C 0x4A 0xC4  JMP 0xC44A              // Emit.OpCodeWithWord();            emit.asm:575

// /source/projects/6502sbc/hopperbasic/emit.asm:592
// ####  Emit.Return()  ####                                                    0x01FD

0xC5D0  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1             Store cleanup count as operand
0xC5D3  0xA9 0x49       LDA # 0x49              // LDA #OpCode.RETURN                emit.asm:594
0xC5D5  0x4C 0x0F 0xC4  JMP 0xC40F              // Emit.OpCodeWithByte();            emit.asm:595

// /source/projects/6502sbc/hopperbasic/emit.asm:603
// ####  Emit.ReturnVal()  ####                                                 0x01FE

0xC5D8  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1             Store cleanup count as operand
0xC5DB  0xA9 0x4A       LDA # 0x4A              // LDA #OpCode.RETURNVAL             emit.asm:605
0xC5DD  0x4C 0x0F 0xC4  JMP 0xC40F              // Emit.OpCodeWithByte();            emit.asm:606

// /source/projects/6502sbc/hopperbasic/emit.asm:616
// ####  Emit.DecSp()  ####                                                     0x01FF

0xC5E0  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1      Store count as operand
0xC5E3  0xA9 0x4F       LDA # 0x4F              // LDA #OpCode.DECSP                 emit.asm:618
0xC5E5  0x4C 0x0F 0xC4  JMP 0xC40F              // Emit.OpCodeWithByte();             Changed from Emit.OpCode()

// /source/projects/6502sbc/hopperbasic/emit.asm:627
// ####  Emit.SysCall()  ####                                                   0x0200

0xC5E8  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1         Store ID as operand
0xC5EB  0xA9 0x48       LDA # 0x48              // LDA #OpCode.SYSCALL               emit.asm:629
0xC5ED  0x4C 0x0F 0xC4  JMP 0xC40F              // Emit.OpCodeWithByte();            emit.asm:630

// /source/projects/6502sbc/hopperbasic/emit.asm:635
// ####  Emit.VT100Escape()  ####                                               0x0201

0xC5F0  0xAA            TAX                     // TAX                               emit.asm:638
0xC5F1  0xA9 0x1B       LDA # 0x1B              // LDA #0x1B           ESC           emit.asm:639
0xC5F3  0x20 0x04 0xC6  JSR 0xC604              // Emit.PrintChar();                 emit.asm:640
0xC5F6  0x90 0x0B       BCC 0xC603 (+11)        // if (NC) { break; }                emit.asm:641
0xC5F8  0xA9 0x5B       LDA # 0x5B              // LDA #'['                          emit.asm:643
0xC5FA  0x20 0x04 0xC6  JSR 0xC604              // Emit.PrintChar();                 emit.asm:644
0xC5FD  0x90 0x04       BCC 0xC603 (+4)         // if (NC) { break; }                emit.asm:645
0xC5FF  0x8A            TXA                     // TXA                               emit.asm:647
0xC600  0x4C 0x04 0xC6  JMP 0xC604              // Emit.PrintChar();                 emit.asm:648
0xC603  0x60            RTS                     // }                                 emit.asm:651

// /source/projects/6502sbc/hopperbasic/emit.asm:657
// ####  Emit.PrintChar()  ####                                                 0x0202

0xC604  0x48            PHA                     // PHA     Save character            emit.asm:658
0xC605  0x20 0x91 0xC5  JSR 0xC591              // Emit.PushChar();     Uses A register
0xC608  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     emit.asm:664
0xC60B  0x90 0x0B       BCC 0xC618 (+11)        // if (NC) { break; }                emit.asm:665
0xC60D  0xA9 0x11       LDA # 0x11              // LDA #SysCallType.PrintChar        emit.asm:668
0xC60F  0x20 0xE8 0xC5  JSR 0xC5E8              // Emit.SysCall();                   emit.asm:669
0xC612  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     emit.asm:670
0xC615  0x90 0x01       BCC 0xC618 (+1)         // if (NC) { break; }                emit.asm:671
0xC617  0x38            SEC                     // SEC    Success                    emit.asm:673
0xC618  0x68            PLA                     // PLA     Restore character (for caller)
0xC619  0x60            RTS                     // }                                 emit.asm:678

// /source/projects/6502sbc/hopperbasic/emit.asm:682
// ####  Emit.PrintNewLine()  ####                                              0x0203

0xC61A  0xA9 0x0A       LDA # 0x0A              // LDA #'\n'                         emit.asm:683
0xC61C  0x4C 0x04 0xC6  JMP 0xC604              // Emit.PrintChar();                 emit.asm:684

// /source/projects/6502sbc/hopperbasic/emit.asm:689
// ####  Emit.PrintSpace()  ####                                                0x0204

0xC61F  0xA9 0x20       LDA # 0x20              // LDA #' '                          emit.asm:690
0xC621  0x4C 0x04 0xC6  JMP 0xC604              // Emit.PrintChar();                 emit.asm:691

// /source/projects/6502sbc/hopperbasic/emit.asm:696
// ####  Emit.PrintValue()  ####                                                0x0205

0xC624  0xA9 0x09       LDA # 0x09              // LDA #SysCallType.PrintValue       emit.asm:699
0xC626  0x20 0xE8 0xC5  JSR 0xC5E8              // SysCall();                        emit.asm:700
0xC629  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     emit.asm:701
0xC62C  0x90 0x01       BCC 0xC62F (+1)         // if (NC) { break; }                emit.asm:702
0xC62E  0x38            SEC                     // SEC    Success                    emit.asm:704
0xC62F  0x60            RTS                     // }                                 emit.asm:707

// /source/projects/6502sbc/hopperbasic/emit.asm:713
// ####  Emit.Halt()  ####                                                      0x0206

0xC630  0xA9 0x19       LDA # 0x19              // LDA #OpCode.HALT                  emit.asm:714
0xC632  0x4C 0xE6 0xC3  JMP 0xC3E6              // Emit.OpCode();                    emit.asm:715

// /source/projects/6502sbc/hopperbasic/emit.asm:724
// ####  Emit.Call()  ####                                                      0x0207

0xC635  0xDA            PHX                     // PHX                               emit.asm:725
0xC636  0x5A            PHY                     // PHY                               emit.asm:726
0xC637  0xA5 0x30       LDA 0x30                // LDA ZP.TokenLiteralPosL           emit.asm:730
0xC639  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     LSB
0xC63C  0xA5 0x31       LDA 0x31                // LDA ZP.TokenLiteralPosH           emit.asm:732
0xC63E  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     MSB
0xC641  0xA9 0x83       LDA # 0x83              // LDA # OpCode.CALL                 emit.asm:736
0xC643  0x20 0x4A 0xC4  JSR 0xC44A              // Emit.OpCodeWithWord();            emit.asm:737
0xC646  0x7A            PLY                     // PLY                               emit.asm:741
0xC647  0xFA            PLX                     // PLX                               emit.asm:742
0xC648  0x60            RTS                     // }                                 emit.asm:743

// /source/projects/6502sbc/hopperbasic/emit.asm:751
// ####  Emit.PushCString()  ####                                               0x0208

0xC649  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();    Result in ZP.TOP
0xC64C  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     emit.asm:756
0xC64F  0x90 0x05       BCC 0xC656 (+5)         // if (NC) { break; }                emit.asm:757
0xC651  0xA9 0x82       LDA # 0x82              // LDA #OpCode.PUSHCSTRING           emit.asm:760
0xC653  0x4C 0x4A 0xC4  JMP 0xC44A              // Emit.OpCodeWithWord();            emit.asm:761
0xC656  0x60            RTS                     // }                                 emit.asm:764

// /source/projects/6502sbc/hopperbasic/emit.asm:771
// ####  Emit.PushLocal()  ####                                                 0x0209

0xC657  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1         Store offset as operand
0xC65A  0xA9 0x43       LDA # 0x43              // LDA #OpCode.PUSHLOCAL             emit.asm:773
0xC65C  0x4C 0x0F 0xC4  JMP 0xC40F              // Emit.OpCodeWithByte();            emit.asm:774

// /source/projects/6502sbc/hopperbasic/emit.asm:782
// ####  Emit.PopLocal()  ####                                                  0x020A

0xC65F  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1         Store offset as operand
0xC662  0xA9 0x44       LDA # 0x44              // LDA #OpCode.POPLOCAL              emit.asm:784
0xC664  0x4C 0x0F 0xC4  JMP 0xC40F              // Emit.OpCodeWithByte();            emit.asm:785

// /source/projects/6502sbc/hopperbasic/emit.asm:796
// ####  Emit.ForCheck()  ####                                                  0x020B

0xC667  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1         Store iterator offset as first operand
0xC66A  0x8E 0x84 0x0B  STX 0x0B84              // STX Compiler.compilerOperand2         Store jump offset LSB
0xC66D  0x8C 0x85 0x0B  STY 0x0B85              // STY Compiler.compilerOperand3         Store jump offset MSB
0xC670  0xA9 0xC0       LDA # 0xC0              // LDA #OpCode.FORCHK                emit.asm:801
0xC672  0x4C 0x92 0xC4  JMP 0xC492              // Emit.OpCodeWithThreeBytes();      emit.asm:802

// /source/projects/6502sbc/hopperbasic/emit.asm:812
// ####  Emit.ForIterate()  ####                                                0x020C

0xC675  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1         Store iterator offset as first operand
0xC678  0x8E 0x84 0x0B  STX 0x0B84              // STX Compiler.compilerOperand2         Store jump offset LSB
0xC67B  0x8C 0x85 0x0B  STY 0x0B85              // STY Compiler.compilerOperand3         Store jump offset MSB
0xC67E  0xA9 0xC1       LDA # 0xC1              // LDA #OpCode.FORIT                 emit.asm:817
0xC680  0x4C 0x92 0xC4  JMP 0xC492              // Emit.OpCodeWithThreeBytes();      emit.asm:818

// /source/projects/6502sbc/hopperbasic/emit.asm:828
// ####  Emit.ForIterateFast()  ####                                            0x020D

0xC683  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1         Store iterator offset as first operand
0xC686  0x8E 0x84 0x0B  STX 0x0B84              // STX Compiler.compilerOperand2         Store jump offset LSB
0xC689  0x8C 0x85 0x0B  STY 0x0B85              // STY Compiler.compilerOperand3         Store jump offset MSB
0xC68C  0xA9 0xC2       LDA # 0xC2              // LDA #OpCode.FORITF                emit.asm:833
0xC68E  0x4C 0x92 0xC4  JMP 0xC492              // Emit.OpCodeWithThreeBytes();      emit.asm:834

// /source/projects/6502sbc/hopperbasic/compilerflow.asm:8
// ####  CompilerFlow.saveCurrentPosition()  ####                               0x020E

0xC691  0xA5 0x32       LDA 0x32                // LDA ZP.OpCodeBufferContentLengthL compilerflow.asm:9
0xC693  0x85 0x11       STA 0x11                // STA ZP.TOPL                       compilerflow.asm:10
0xC695  0xA5 0x33       LDA 0x33                // LDA ZP.OpCodeBufferContentLengthH compilerflow.asm:11
0xC697  0x85 0x12       STA 0x12                // STA ZP.TOPH                       compilerflow.asm:12
0xC699  0xA9 0x04       LDA # 0x04              // LDA # BASICType.WORD              compilerflow.asm:13
0xC69B  0x4C 0xA1 0x94  JMP 0x94A1              // Stacks.PushTop();    type in A    compilerflow.asm:14

// /source/projects/6502sbc/hopperbasic/compilerflow.asm:23
// ####  CompilerFlow.calculateForwardOffset()  ####                            0x020F

0xC69E  0x38            SEC                     // SEC                               compilerflow.asm:25
0xC69F  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL       Target position LSB
0xC6A1  0xE5 0x1B       SBC 0x1B                // SBC ZP.IDXL       Subtract source position LSB
0xC6A3  0x85 0x16       STA 0x16                // STA ZP.NEXTL      Store forward offset LSB
0xC6A5  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH       Target position MSB
0xC6A7  0xE5 0x1C       SBC 0x1C                // SBC ZP.IDXH       Subtract source position MSB
0xC6A9  0x85 0x17       STA 0x17                // STA ZP.NEXTH      Store forward offset MSB
0xC6AB  0x60            RTS                     // }                                 compilerflow.asm:32

// /source/projects/6502sbc/hopperbasic/compilerflow.asm:41
// ####  CompilerFlow.patchWordOperand()  ####                                  0x0210

0xC6AC  0xA8            TAY                     // TAY     Save Y offset parameter   compilerflow.asm:42
0xC6AD  0x18            CLC                     // CLC                               compilerflow.asm:45
0xC6AE  0xA5 0x3A       LDA 0x3A                // LDA ZP.OpCodeBufferL              compilerflow.asm:46
0xC6B0  0x65 0x1B       ADC 0x1B                // ADC ZP.IDXL       Add relative position
0xC6B2  0x85 0x1B       STA 0x1B                // STA ZP.IDXL       Absolute patch address LSB
0xC6B4  0xA5 0x3B       LDA 0x3B                // LDA ZP.OpCodeBufferH              compilerflow.asm:49
0xC6B6  0x65 0x1C       ADC 0x1C                // ADC ZP.IDXH       Add relative position
0xC6B8  0x85 0x1C       STA 0x1C                // STA ZP.IDXH       Absolute patch address MSB
0xC6BA  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL      Forward offset LSB
0xC6BC  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y      Patch LSB    compilerflow.asm:55
0xC6BE  0xC8            INY                     // INY                               compilerflow.asm:56
0xC6BF  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH      Forward offset MSB
0xC6C1  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y      Patch MSB    compilerflow.asm:58
0xC6C3  0x60            RTS                     // }                                 compilerflow.asm:59

// /source/projects/6502sbc/hopperbasic/compilerflow.asm:67
// ####  CompilerFlow.calculateBackwardOffset()  ####                           0x0211

0xC6C4  0x38            SEC                     // SEC                               compilerflow.asm:70
0xC6C5  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL       Loop start position LSB
0xC6C7  0xE5 0x1D       SBC 0x1D                // SBC ZP.IDYL       Subtract current position LSB
0xC6C9  0x85 0x11       STA 0x11                // STA ZP.TOPL       Store backward offset LSB
0xC6CB  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH       Loop start position MSB
0xC6CD  0xE5 0x1E       SBC 0x1E                // SBC ZP.IDYH       Subtract current position MSB
0xC6CF  0x85 0x12       STA 0x12                // STA ZP.TOPH       Store backward offset MSB
0xC6D1  0x60            RTS                     // }                                 compilerflow.asm:77

// /source/projects/6502sbc/hopperbasic/compilerflow.asm:84
// ####  CompilerFlow.addInstructionSizeToPosition()  ####                      0x0212

0xC6D2  0x18            CLC                     // CLC                               compilerflow.asm:86
0xC6D3  0x65 0x1D       ADC 0x1D                // ADC ZP.IDYL           Add instruction size to LSB
0xC6D5  0x85 0x1D       STA 0x1D                // STA ZP.IDYL           Store updated position LSB
0xC6D7  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH           Get MSB     compilerflow.asm:89
0xC6D9  0x69 0x00       ADC # 0                 // ADC #0                Add carry   compilerflow.asm:90
0xC6DB  0x85 0x1E       STA 0x1E                // STA ZP.IDYH           Store updated position MSB
0xC6DD  0x60            RTS                     // }                                 compilerflow.asm:92

// /source/projects/6502sbc/hopperbasic/compilerflow.asm:99
// ####  CompilerFlow.subtractInstructionSizeFromOffset()  ####                 0x0213

0xC6DE  0x85 0x0E       STA 0x0E                // STA ZP.ACCL           Store instruction size temporarily
0xC6E0  0x38            SEC                     // SEC                               compilerflow.asm:102
0xC6E1  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL          Get raw offset LSB
0xC6E3  0xE5 0x0E       SBC 0x0E                // SBC ZP.ACCL           Subtract instruction size
0xC6E5  0x85 0x16       STA 0x16                // STA ZP.NEXTL          Store adjusted offset LSB
0xC6E7  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH          Get raw offset MSB
0xC6E9  0xE9 0x00       SBC # 0                 // SBC #0                Subtract borrow
0xC6EB  0x85 0x17       STA 0x17                // STA ZP.NEXTH          Store adjusted offset MSB
0xC6ED  0x60            RTS                     // }                                 compilerflow.asm:109

// /source/projects/6502sbc/hopperbasic/compilerflow.asm:115
// ####  CompilerFlow.loadCurrentPosition()  ####                               0x0214

0xC6EE  0xA5 0x32       LDA 0x32                // LDA ZP.OpCodeBufferContentLengthL compilerflow.asm:116
0xC6F0  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       compilerflow.asm:117
0xC6F2  0xA5 0x33       LDA 0x33                // LDA ZP.OpCodeBufferContentLengthH compilerflow.asm:118
0xC6F4  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       compilerflow.asm:119
0xC6F6  0x60            RTS                     // }                                 compilerflow.asm:120

// /source/projects/6502sbc/hopperbasic/compilerflow.asm:132
// ####  CompilerFlow.CompileIfStatement()  ####                                0x0215

0xC6F7  0xA5 0x03       LDA 0x03                // LDA ZP.SP                         compilerflow.asm:138
0xC6F9  0x48            PHA                     // PHA                               compilerflow.asm:139
0xC6FA  0xAD 0x90 0x0B  LDA 0x0B90              // LDA Compiler.compilerIfClauses    compilerflow.asm:142
0xC6FD  0x48            PHA                     // PHA                               compilerflow.asm:143
0xC6FE  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xC701  0xB0 0x03       BCS 0xC706 (+3)         // if (NC) { break; }                compilerflow.asm:149
0xC703  0x4C 0x2D 0xC8  JMP 0xC82D
0xC706  0x20 0xA3 0xD0  JSR 0xD0A3              // Compiler.CompileFoldedExpressionTree();    IF <expression>
0xC709  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:153
0xC70C  0xB0 0x03       BCS 0xC711 (+3)         // if (NC) { break; }                compilerflow.asm:154
0xC70E  0x4C 0x2D 0xC8  JMP 0xC82D
0xC711  0x0F 0x36 0x0E  BBR0 0x36, 0xC722 (+14) // if (BBS0, ZP.CompilerFlags)       compilerflow.asm:156
0xC714  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       compilerflow.asm:158
0xC716  0xC9 0x06       CMP # 0x06              // CMP # BASICType.BIT               compilerflow.asm:159
0xC718  0xF0 0x08       BEQ 0xC722 (+8)         // if (NZ)                           compilerflow.asm:160
0xC71A  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xC71D  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:163
0xC71F  0x4C 0x2D 0xC8  JMP 0xC82D              // break;                            compilerflow.asm:164
0xC722  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:169
0xC724  0xC9 0xA2       CMP # 0xA2              // CMP #Token.THEN                   compilerflow.asm:170
0xC726  0xF0 0x0A       BEQ 0xC732 (+10)        // if (NZ)                           compilerflow.asm:171
0xC728  0xA9 0x17       LDA # 0x17              // Error.ExpectedThen(); BIT ZP.EmulatorPCL
0xC72A  0x20 0x5F 0x8B  JSR 0x8B5F
0xC72D  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:174
0xC72F  0x4C 0x2D 0xC8  JMP 0xC82D              // break;                            compilerflow.asm:175
0xC732  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xC735  0xB0 0x03       BCS 0xC73A (+3)         // if (NC) { break; }                compilerflow.asm:179
0xC737  0x4C 0x2D 0xC8  JMP 0xC82D
0xC73A  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:182
0xC73C  0xC9 0xDC       CMP # 0xDC              // case Token.EOL:                   compilerflow.asm:185
0xC73E  0xF0 0x04       BEQ 0xC744 (+4)
0xC740  0xC9 0x95       CMP # 0x95              // case Token.COMMENT:               compilerflow.asm:186
0xC742  0xD0 0x10       BNE 0xC754 (+16)
0xC744  0xAD 0x90 0x0B  LDA 0x0B90              // LDA Compiler.compilerIfClauses    compilerflow.asm:189
0xC747  0x29 0xFE       AND # 0xFE              // AND #0xFE     Clear BIT0 for multi-line
0xC749  0x8D 0x90 0x0B  STA 0x0B90              // STA Compiler.compilerIfClauses    compilerflow.asm:191
0xC74C  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();     Skip the EOL/comment
0xC74F  0xB0 0x0B       BCS 0xC75C (+11)        // if (NC) { break; }                compilerflow.asm:194
0xC751  0x4C 0x2D 0xC8  JMP 0xC82D
0xC754  0xAD 0x90 0x0B  LDA 0x0B90              // LDA Compiler.compilerIfClauses    compilerflow.asm:199
0xC757  0x09 0x01       ORA # 1                 // ORA #0x01     Set BIT0 for single-line
0xC759  0x8D 0x90 0x0B  STA 0x0B90              // STA Compiler.compilerIfClauses    compilerflow.asm:201
0xC75C  0x20 0x91 0xC6  JSR 0xC691              // saveCurrentPosition();            compilerflow.asm:206
0xC75F  0x9C 0x83 0x0B  STZ 0x0B83              // STZ Compiler.compilerOperand1     Placeholder LSB (will be patched)
0xC762  0x9C 0x84 0x0B  STZ 0x0B84              // STZ Compiler.compilerOperand2     Placeholder MSB (will be patched)
0xC765  0xA9 0x88       LDA # 0x88              // LDA #OpCode.JUMPZW                compilerflow.asm:212
0xC767  0x20 0x4A 0xC4  JSR 0xC44A              // Emit.OpCodeWithWord();            compilerflow.asm:213
0xC76A  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:214
0xC76D  0xB0 0x03       BCS 0xC772 (+3)         // if (NC) { break; }                compilerflow.asm:215
0xC76F  0x4C 0x2D 0xC8  JMP 0xC82D
0xC772  0xAD 0x90 0x0B  LDA 0x0B90              // LDA Compiler.compilerIfClauses    compilerflow.asm:219
0xC775  0x29 0x01       AND # 1                 // AND #0x01     Test single-line mode
0xC777  0xF0 0x0B       BEQ 0xC784 (+11)        // if (NZ)       Single-line mode (BIT0 = 1)?
0xC779  0x20 0x87 0xD9  JSR 0xD987              // CompileStatement();               compilerflow.asm:224
0xC77C  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:225
0xC77F  0xB0 0x0B       BCS 0xC78C (+11)        // if (NC) { break; }                compilerflow.asm:226
0xC781  0x4C 0x2D 0xC8  JMP 0xC82D
0xC784  0x20 0x06 0xD8  JSR 0xD806              // CompileStatementBlock();          compilerflow.asm:231
0xC787  0xB0 0x03       BCS 0xC78C (+3)         // if (NC) { break; }                compilerflow.asm:232
0xC789  0x4C 0x2D 0xC8  JMP 0xC82D
0xC78C  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:237
0xC78E  0xC9 0xA3       CMP # 0xA3              // CMP #Token.ELSE                   compilerflow.asm:238
0xC790  0xD0 0x71       BNE 0xC803 (+113)       // if (Z)                            compilerflow.asm:239
0xC792  0x20 0x91 0xC6  JSR 0xC691              // saveCurrentPosition();            compilerflow.asm:244
0xC795  0x9C 0x83 0x0B  STZ 0x0B83              // STZ Compiler.compilerOperand1     Placeholder LSB (will be patched)
0xC798  0x9C 0x84 0x0B  STZ 0x0B84              // STZ Compiler.compilerOperand2     Placeholder MSB (will be patched)
0xC79B  0xA9 0x87       LDA # 0x87              // LDA #OpCode.JUMPW                 compilerflow.asm:249
0xC79D  0x20 0x4A 0xC4  JSR 0xC44A              // Emit.OpCodeWithWord();            compilerflow.asm:250
0xC7A0  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:251
0xC7A3  0xB0 0x03       BCS 0xC7A8 (+3)         // if (NC) { break; }                compilerflow.asm:252
0xC7A5  0x4C 0x2D 0xC8  JMP 0xC82D
0xC7A8  0x20 0xEE 0xC6  JSR 0xC6EE              // loadCurrentPosition();            compilerflow.asm:257
0xC7AB  0x20 0x79 0x94  JSR 0x9479              // Stacks.PopTop();     Pop JUMPW position (save it)
0xC7AE  0x20 0xF5 0x94  JSR 0x94F5              // Stacks.PopIDX();     Pop JUMPZW position into ZP.IDX
0xC7B1  0x20 0xA1 0x94  JSR 0x94A1              // Stacks.PushTop();    Push JUMPW position back
0xC7B4  0x20 0x9E 0xC6  JSR 0xC69E              // calculateForwardOffset();         compilerflow.asm:265
0xC7B7  0xA9 0x03       LDA # 0x03              // LDA #3     JUMPZW instruction size
0xC7B9  0x20 0xDE 0xC6  JSR 0xC6DE              // subtractInstructionSizeFromOffset();
0xC7BC  0xA9 0x01       LDA # 1                 // LDA #1     Skip opcode byte to get to operand
0xC7BE  0x20 0xAC 0xC6  JSR 0xC6AC              // patchWordOperand();               compilerflow.asm:273
0xC7C1  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xC7C4  0x90 0x67       BCC 0xC82D (+103)       // if (NC) { break; }                compilerflow.asm:277
0xC7C6  0xAD 0x90 0x0B  LDA 0x0B90              // LDA Compiler.compilerIfClauses    compilerflow.asm:281
0xC7C9  0x29 0x01       AND # 1                 // AND #0x01     Test single-line mode
0xC7CB  0xF0 0x0A       BEQ 0xC7D7 (+10)        // if (NZ)       Single-line mode (BIT0 = 1)?
0xC7CD  0x20 0x87 0xD9  JSR 0xD987              // CompileStatement();               compilerflow.asm:286
0xC7D0  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:287
0xC7D3  0x90 0x58       BCC 0xC82D (+88)        // if (NC) { break; }                compilerflow.asm:288
0xC7D5  0x80 0x05       BRA 0xC7DC (+5)
0xC7D7  0x20 0x06 0xD8  JSR 0xD806              // CompileStatementBlock();          compilerflow.asm:293
0xC7DA  0x90 0x51       BCC 0xC82D (+81)        // if (NC) { break; }                compilerflow.asm:294
0xC7DC  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:298
0xC7DE  0xC9 0xA4       CMP # 0xA4              // CMP #Token.ENDIF                  compilerflow.asm:299
0xC7E0  0xF0 0x07       BEQ 0xC7E9 (+7)         // if (NZ)                           compilerflow.asm:300
0xC7E2  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL     Expected ENDIF
0xC7E5  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:303
0xC7E7  0x80 0x44       BRA 0xC82D (+68)        // break;                            compilerflow.asm:304
0xC7E9  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xC7EC  0x90 0x3F       BCC 0xC82D (+63)        // if (NC) { break; }                compilerflow.asm:309
0xC7EE  0x20 0xEE 0xC6  JSR 0xC6EE              // loadCurrentPosition();            compilerflow.asm:314
0xC7F1  0x20 0xF5 0x94  JSR 0x94F5              // Stacks.PopIDX();                  compilerflow.asm:317
0xC7F4  0x20 0x9E 0xC6  JSR 0xC69E              // calculateForwardOffset();         compilerflow.asm:320
0xC7F7  0xA9 0x03       LDA # 0x03              // LDA #3     JUMPW instruction size compilerflow.asm:323
0xC7F9  0x20 0xDE 0xC6  JSR 0xC6DE              // subtractInstructionSizeFromOffset();
0xC7FC  0xA9 0x01       LDA # 1                 // LDA #1     Skip opcode byte to get to operand
0xC7FE  0x20 0xAC 0xC6  JSR 0xC6AC              // patchWordOperand();               compilerflow.asm:328
0xC801  0x80 0x27       BRA 0xC82A (+39)        // }                                 compilerflow.asm:329
0xC803  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:335
0xC805  0xC9 0xA4       CMP # 0xA4              // CMP #Token.ENDIF                  compilerflow.asm:336
0xC807  0xF0 0x09       BEQ 0xC812 (+9)         // if (NZ)                           compilerflow.asm:337
0xC809  0xA9 0x18       LDA # 0x18              // Error.ExpectedEndif(); BIT ZP.EmulatorPCL     Expected ENDIF
0xC80B  0x20 0x5F 0x8B  JSR 0x8B5F
0xC80E  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:340
0xC810  0x80 0x1B       BRA 0xC82D (+27)        // break;                            compilerflow.asm:341
0xC812  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xC815  0x90 0x16       BCC 0xC82D (+22)        // if (NC) { break; }                compilerflow.asm:346
0xC817  0x20 0xEE 0xC6  JSR 0xC6EE              // loadCurrentPosition();            compilerflow.asm:351
0xC81A  0x20 0xF5 0x94  JSR 0x94F5              // Stacks.PopIDX();                  compilerflow.asm:354
0xC81D  0x20 0x9E 0xC6  JSR 0xC69E              // calculateForwardOffset();         compilerflow.asm:357
0xC820  0xA9 0x03       LDA # 0x03              // LDA #3     JUMPZW instruction size
0xC822  0x20 0xDE 0xC6  JSR 0xC6DE              // subtractInstructionSizeFromOffset();
0xC825  0xA9 0x01       LDA # 1                 // LDA #1     Skip opcode byte to get to operand
0xC827  0x20 0xAC 0xC6  JSR 0xC6AC              // patchWordOperand();               compilerflow.asm:365
0xC82A  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();              compilerflow.asm:368
0xC82D  0x68            PLA                     // PLA                               compilerflow.asm:373
0xC82E  0x8D 0x90 0x0B  STA 0x0B90              // STA Compiler.compilerIfClauses    compilerflow.asm:374
0xC831  0x68            PLA                     // PLA                               compilerflow.asm:377
0xC832  0x85 0x03       STA 0x03                // STA ZP.SP                         compilerflow.asm:378
0xC834  0x60            RTS                     // }                                 compilerflow.asm:383

// /source/projects/6502sbc/hopperbasic/compilerflow.asm:390
// ####  CompilerFlow.CompileWhileStatement()  ####                             0x0216

0xC835  0xA5 0x03       LDA 0x03                // LDA ZP.SP                         compilerflow.asm:395
0xC837  0x48            PHA                     // PHA                               compilerflow.asm:396
0xC838  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();     Skip WHILE token
0xC83B  0x90 0x78       BCC 0xC8B5 (+120)       // if (NC) { break; }                compilerflow.asm:402
0xC83D  0x20 0x91 0xC6  JSR 0xC691              // saveCurrentPosition();            compilerflow.asm:405
0xC840  0x20 0xA3 0xD0  JSR 0xD0A3              // Compiler.CompileFoldedExpressionTree();    WHILE <expression>
0xC843  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:409
0xC846  0x90 0x6D       BCC 0xC8B5 (+109)       // if (NC) { break; }                compilerflow.asm:410
0xC848  0x0F 0x36 0x0D  BBR0 0x36, 0xC858 (+13) // if (BBS0, ZP.CompilerFlags)       compilerflow.asm:412
0xC84B  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       compilerflow.asm:414
0xC84D  0xC9 0x06       CMP # 0x06              // CMP # BASICType.BIT               compilerflow.asm:415
0xC84F  0xF0 0x07       BEQ 0xC858 (+7)         // if (NZ)                           compilerflow.asm:416
0xC851  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xC854  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:419
0xC856  0x80 0x5D       BRA 0xC8B5 (+93)        // break;                            compilerflow.asm:420
0xC858  0x20 0x91 0xC6  JSR 0xC691              // saveCurrentPosition();            compilerflow.asm:426
0xC85B  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:429
0xC85E  0x90 0x55       BCC 0xC8B5 (+85)        // if (NC) { break; }                compilerflow.asm:430
0xC860  0x9C 0x83 0x0B  STZ 0x0B83              // STZ Compiler.compilerOperand1     Placeholder LSB (will be patched)
0xC863  0x9C 0x84 0x0B  STZ 0x0B84              // STZ Compiler.compilerOperand2     Placeholder MSB (will be patched)
0xC866  0xA9 0x88       LDA # 0x88              // LDA # OpCode.JUMPZW               compilerflow.asm:436
0xC868  0x20 0x4A 0xC4  JSR 0xC44A              // Emit.OpCodeWithWord();            compilerflow.asm:437
0xC86B  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:438
0xC86E  0x90 0x45       BCC 0xC8B5 (+69)        // if (NC) { break; }                compilerflow.asm:439
0xC870  0x20 0x06 0xD8  JSR 0xD806              // CompileStatementBlock();          compilerflow.asm:441
0xC873  0x90 0x40       BCC 0xC8B5 (+64)        // if (NC) { break; }                compilerflow.asm:442
0xC875  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:445
0xC877  0xC9 0xAF       CMP # 0xAF              // CMP #Token.WEND                   compilerflow.asm:446
0xC879  0xF0 0x05       BEQ 0xC880 (+5)         // if (NZ)                           compilerflow.asm:447
0xC87B  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xC87E  0x80 0x35       BRA 0xC8B5 (+53)        // break;                            compilerflow.asm:450
0xC880  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xC883  0x90 0x30       BCC 0xC8B5 (+48)        // if (NC) { break; }                compilerflow.asm:453
0xC885  0x20 0xF5 0x94  JSR 0x94F5              // Stacks.PopIDX();                  compilerflow.asm:459
0xC888  0x20 0x79 0x94  JSR 0x9479              // Stacks.PopTop();                  compilerflow.asm:462
0xC88B  0x20 0xEE 0xC6  JSR 0xC6EE              // loadCurrentPosition();            compilerflow.asm:465
0xC88E  0x20 0x9E 0xC6  JSR 0xC69E              // calculateForwardOffset();         compilerflow.asm:470
0xC891  0xA9 0x03       LDA # 0x03              // LDA #3     JUMPW instruction size compilerflow.asm:475
0xC893  0x20 0xD2 0xC6  JSR 0xC6D2              // addInstructionSizeToPosition();   compilerflow.asm:476
0xC896  0x20 0xC4 0xC6  JSR 0xC6C4              // calculateBackwardOffset();        compilerflow.asm:481
0xC899  0xA9 0x01       LDA # 1                 // LDA #1     Skip opcode byte       compilerflow.asm:485
0xC89B  0x20 0xAC 0xC6  JSR 0xC6AC              // patchWordOperand();               compilerflow.asm:486
0xC89E  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL       Backward offset LSB
0xC8A0  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compilerflow.asm:495
0xC8A3  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH       Backward offset MSB
0xC8A5  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     compilerflow.asm:497
0xC8A8  0xA9 0x87       LDA # 0x87              // LDA #OpCode.JUMPW                 compilerflow.asm:498
0xC8AA  0x20 0x4A 0xC4  JSR 0xC44A              // Emit.OpCodeWithWord();            compilerflow.asm:499
0xC8AD  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:502
0xC8B0  0x90 0x03       BCC 0xC8B5 (+3)         // if (NC) { break; }                compilerflow.asm:503
0xC8B2  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();              compilerflow.asm:505
0xC8B5  0x68            PLA                     // PLA                               compilerflow.asm:510
0xC8B6  0x85 0x03       STA 0x03                // STA ZP.SP                         compilerflow.asm:511
0xC8B8  0x60            RTS                     // }                                 compilerflow.asm:516

// /source/projects/6502sbc/hopperbasic/compilerflow.asm:523
// ####  CompilerFlow.CompileDoUntilStatement()  ####                           0x0217

0xC8B9  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xC8BC  0x90 0x62       BCC 0xC920 (+98)        // if (NC) { break; }                compilerflow.asm:532
0xC8BE  0x20 0x91 0xC6  JSR 0xC691              // saveCurrentPosition();            compilerflow.asm:535
0xC8C1  0x20 0x06 0xD8  JSR 0xD806              // CompileStatementBlock();          compilerflow.asm:537
0xC8C4  0x90 0x5A       BCC 0xC920 (+90)        // if (NC) { break; }                compilerflow.asm:538
0xC8C6  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:541
0xC8C8  0xC9 0xB1       CMP # 0xB1              // CMP #Token.UNTIL                  compilerflow.asm:542
0xC8CA  0xF0 0x05       BEQ 0xC8D1 (+5)         // if (NZ)                           compilerflow.asm:543
0xC8CC  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xC8CF  0x80 0x4F       BRA 0xC920 (+79)        // break;                            compilerflow.asm:546
0xC8D1  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:550
0xC8D3  0xC9 0xB1       CMP # 0xB1              // CMP #Token.UNTIL                  compilerflow.asm:551
0xC8D5  0xF0 0x07       BEQ 0xC8DE (+7)         // if (NZ)                           compilerflow.asm:552
0xC8D7  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL     Expected UNTIL
0xC8DA  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:555
0xC8DC  0x80 0x42       BRA 0xC920 (+66)        // break;                            compilerflow.asm:556
0xC8DE  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xC8E1  0x90 0x3D       BCC 0xC920 (+61)        // if (NC) { break; }                compilerflow.asm:561
0xC8E3  0x20 0xA3 0xD0  JSR 0xD0A3              // Compiler.CompileFoldedExpressionTree();    UNTIL <expression>
0xC8E6  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:565
0xC8E9  0x90 0x35       BCC 0xC920 (+53)        // if (NC) { break; }                compilerflow.asm:566
0xC8EB  0x0F 0x36 0x0D  BBR0 0x36, 0xC8FB (+13) // if (BBS0, ZP.CompilerFlags)       compilerflow.asm:568
0xC8EE  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       compilerflow.asm:570
0xC8F0  0xC9 0x06       CMP # 0x06              // CMP # BASICType.BIT               compilerflow.asm:571
0xC8F2  0xF0 0x07       BEQ 0xC8FB (+7)         // if (NZ)                           compilerflow.asm:572
0xC8F4  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xC8F7  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:575
0xC8F9  0x80 0x25       BRA 0xC920 (+37)        // break;                            compilerflow.asm:576
0xC8FB  0x20 0x79 0x94  JSR 0x9479              // Stacks.PopTop();                  compilerflow.asm:582
0xC8FE  0x20 0xEE 0xC6  JSR 0xC6EE              // loadCurrentPosition();            compilerflow.asm:585
0xC901  0xA9 0x03       LDA # 0x03              // LDA #3     JUMPW instruction size compilerflow.asm:589
0xC903  0x20 0xD2 0xC6  JSR 0xC6D2              // addInstructionSizeToPosition();   compilerflow.asm:590
0xC906  0x20 0xC4 0xC6  JSR 0xC6C4              // calculateBackwardOffset();        compilerflow.asm:594
0xC909  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL     Backward offset LSB
0xC90B  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compilerflow.asm:600
0xC90E  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH     Backward offset MSB
0xC910  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     compilerflow.asm:602
0xC913  0xA9 0x88       LDA # 0x88              // LDA #OpCode.JUMPZW                compilerflow.asm:603
0xC915  0x20 0x4A 0xC4  JSR 0xC44A              // Emit.OpCodeWithWord();            compilerflow.asm:604
0xC918  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:605
0xC91B  0x90 0x03       BCC 0xC920 (+3)         // if (NC) { break; }                compilerflow.asm:606
0xC91D  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();              compilerflow.asm:608
0xC920  0x20 0xAE 0x89  JSR 0x89AE              // States.IsSuccess();               compilerflow.asm:612
0xC923  0x90 0x01       BCC 0xC926 (+1)         // if (NC)                           compilerflow.asm:613
0xC925  0x60            RTS
0xC926  0x4C 0x79 0x94  JMP 0x9479              // Stacks.PopTop();                  compilerflow.asm:616

// /source/projects/6502sbc/hopperbasic/compilerflow.asm:626
// ####  CompilerFlow.addForVar()  ####                                         0x0218

0xC929  0xA9 0x03       LDA # 0x03              // LDA #(Messages.ForVarName % 256)  compilerflow.asm:627
0xC92B  0x85 0x11       STA 0x11                // STA ZP.TOPL                       compilerflow.asm:628
0xC92D  0xA9 0x86       LDA # 0x86              // LDA #(Messages.ForVarName / 256)  compilerflow.asm:629
0xC92F  0x85 0x12       STA 0x12                // STA ZP.TOPH                       compilerflow.asm:630
0xC931  0x4C 0x98 0xA4  JMP 0xA498              // Locals.Add();                     compilerflow.asm:631

// /source/projects/6502sbc/hopperbasic/compilerflow.asm:639
// ####  CompilerFlow.CompileForStatement()  ####                               0x0219

0xC934  0xAD 0x8C 0x0B  LDA 0x0B8C              // LDA Compiler.compilerForIteratorOffset
0xC937  0x48            PHA                     // PHA                               compilerflow.asm:648
0xC938  0xAD 0x8D 0x0B  LDA 0x0B8D              // LDA Compiler.compilerForIteratorType
0xC93B  0x48            PHA                     // PHA                               compilerflow.asm:650
0xC93C  0xAD 0x8E 0x0B  LDA 0x0B8E              // LDA Compiler.compilerGlobalIteratorSlot
0xC93F  0x48            PHA                     // PHA                               compilerflow.asm:652
0xC940  0xAD 0x8F 0x0B  LDA 0x0B8F              // LDA Compiler.compilerForIteratorBP
0xC943  0x48            PHA                     // PHA                               compilerflow.asm:654
0xC944  0xA5 0x03       LDA 0x03                // LDA ZP.SP    JIT was called from a running process - preserve the stack
0xC946  0x48            PHA                     // PHA                               compilerflow.asm:656
0xC947  0xA5 0x36       LDA 0x36                // LDA ZP.CompilerFlags              compilerflow.asm:657
0xC949  0x48            PHA                     // PHA                               compilerflow.asm:658
0xC94A  0x64 0x36       STZ 0x36                // STZ  ZP.CompilerFlags             compilerflow.asm:669
0xC94C  0xB7 0x36       SMB3 0x36               // SMB3 ZP.CompilerFlags    assume we can optimize to use FORITF until proven otherwize
0xC94E  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xC951  0xB0 0x03       BCS 0xC956 (+3)         // if (NC) { break; }                compilerflow.asm:674
0xC953  0x4C 0x3E 0xCD  JMP 0xCD3E
0xC956  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:677
0xC958  0xC9 0xDA       CMP # 0xDA              // CMP #Token.IDENTIFIER             compilerflow.asm:678
0xC95A  0xF0 0x08       BEQ 0xC964 (+8)         // if (NZ)                           compilerflow.asm:679
0xC95C  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL     Expected iterator variable
0xC95F  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:682
0xC961  0x4C 0x3E 0xCD  JMP 0xCD3E              // break;                            compilerflow.asm:683
0xC964  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();    Result in ZP.TOP (name pointer)
0xC967  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:688
0xC96A  0xB0 0x03       BCS 0xC96F (+3)         // if (NC) { break; }                compilerflow.asm:689
0xC96C  0x4C 0x3E 0xCD  JMP 0xCD3E
0xC96F  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       compilerflow.asm:693
0xC971  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       compilerflow.asm:694
0xC973  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       compilerflow.asm:695
0xC975  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       compilerflow.asm:696
0xC977  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xC97A  0x20 0x11 0xA5  JSR 0xA511              // Locals.Find();    Input: ZP.IDX = function node, ZP.TOP = name, Output: C set if found, ZP.ACCL = BP offset
0xC97D  0x90 0x03       BCC 0xC982 (+3)         // if (NC)                           compilerflow.asm:703
0xC97F  0x4C 0x34 0xCA  JMP 0xCA34
0xC982  0x64 0x47       STZ 0x47                // STZ ZP.SymbolIteratorFilter     Look for variables
0xC984  0x20 0x8E 0xA1  JSR 0xA18E              // Variables.Find();     Check global variables
0xC987  0x90 0x72       BCC 0xC9FB (+114)       // if (C)                            compilerflow.asm:708
0xC989  0x97 0x36       SMB1 0x36               // SMB1 ZP.CompilerFlags     Set BIT1: we own the shadow local
0xC98B  0xA7 0x36       SMB2 0x36               // SMB2 ZP.CompilerFlags     Set BIT2: we used a global
0xC98D  0x20 0x9E 0xC5  JSR 0xC59E              // Emit.PushEmptyVar();              compilerflow.asm:715
0xC990  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:716
0xC993  0xB0 0x03       BCS 0xC998 (+3)         // if (NC) { break; }                compilerflow.asm:717
0xC995  0x4C 0x3E 0xCD  JMP 0xCD3E
0xC998  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL     The global slot from Find()
0xC99A  0x8D 0x8E 0x0B  STA 0x0B8E              // STA Compiler.compilerGlobalIteratorSlot    SAVE for NEXT name verification!
0xC99D  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compilerflow.asm:723
0xC9A0  0xA9 0x4B       LDA # 0x4B              // LDA #OpCode.PUSHGLOBAL            compilerflow.asm:724
0xC9A2  0x20 0x0F 0xC4  JSR 0xC40F              // Emit.OpCodeWithByte();            compilerflow.asm:725
0xC9A5  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:726
0xC9A8  0xB0 0x03       BCS 0xC9AD (+3)         // if (NC) { break; }                compilerflow.asm:727
0xC9AA  0x4C 0x3E 0xCD  JMP 0xCD3E
0xC9AD  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       compilerflow.asm:731
0xC9AF  0x85 0x43       STA 0x43                // STA ZP.SymbolNameL                compilerflow.asm:732
0xC9B1  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       compilerflow.asm:733
0xC9B3  0x85 0x44       STA 0x44                // STA ZP.SymbolNameH                compilerflow.asm:734
0xC9B5  0xA9 0x90       LDA # 0x90              // LDA #(SymbolType.LOCAL | BASICType.VAR)
0xC9B7  0x85 0x40       STA 0x40                // STA ZP.SymbolType                 compilerflow.asm:736
0xC9B9  0x8D 0x8D 0x0B  STA 0x0B8D              // STA Compiler.compilerForIteratorType
0xC9BC  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xC9BF  0x20 0x98 0xA4  JSR 0xA498              // Locals.Add();             Creates local
0xC9C2  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:743
0xC9C5  0xB0 0x03       BCS 0xC9CA (+3)         // if (NC) { break; }                compilerflow.asm:744
0xC9C7  0x4C 0x3E 0xCD  JMP 0xCD3E
0xC9CA  0x20 0x11 0xA5  JSR 0xA511              // Locals.Find();    Input: ZP.IDX = function node, ZP.TOP = name, Output: C set if found, ZP.ACCL = BP offset
0xC9CD  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:748
0xC9D0  0xB0 0x03       BCS 0xC9D5 (+3)         // if (NC) { break; }                compilerflow.asm:749
0xC9D2  0x4C 0x3E 0xCD  JMP 0xCD3E
0xC9D5  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL        Get the offset from Find()
0xC9D7  0x8D 0x8F 0x0B  STA 0x0B8F              // STA Compiler.compilerForIteratorBP    keep the actual offset for the NEXT check
0xC9DA  0xAD 0x88 0x0B  LDA 0x0B88              // LDA Compiler.compilerFuncLocals   compilerflow.asm:754
0xC9DD  0x8D 0x8C 0x0B  STA 0x0B8C              // STA Compiler.compilerForIteratorOffset     BP offset for our shadow puppet!
0xC9E0  0xAD 0x8C 0x0B  LDA 0x0B8C              // LDA Compiler.compilerForIteratorOffset
0xC9E3  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compilerflow.asm:759
0xC9E6  0xA9 0x44       LDA # 0x44              // LDA #OpCode.POPLOCAL              compilerflow.asm:760
0xC9E8  0x20 0x0F 0xC4  JSR 0xC40F              // Emit.OpCodeWithByte();            compilerflow.asm:761
0xC9EB  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:762
0xC9EE  0xB0 0x03       BCS 0xC9F3 (+3)         // if (NC) { break; }                compilerflow.asm:763
0xC9F0  0x4C 0x3E 0xCD  JMP 0xCD3E
0xC9F3  0xEE 0x88 0x0B  INC 0x0B88              // INC Compiler.compilerFuncLocals           Track new local
0xC9F6  0xAD 0x8C 0x0B  LDA 0x0B8C              // LDA Compiler.compilerForIteratorOffset    Offset != BP offset for shadow local
0xC9F9  0x80 0x41       BRA 0xCA3C (+65)        // }                                 compilerflow.asm:771
0xC9FB  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xC9FE  0x20 0x9E 0xC5  JSR 0xC59E              // Emit.PushEmptyVar();              compilerflow.asm:779
0xCA01  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:780
0xCA04  0xB0 0x03       BCS 0xCA09 (+3)         // if (NC) { break; }                compilerflow.asm:781
0xCA06  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCA09  0xA9 0x90       LDA # 0x90              // LDA #(SymbolType.LOCAL|BASICType.VAR)     LOCAL type (will be updated by FROM expression type)
0xCA0B  0x85 0x40       STA 0x40                // STA ZP.SymbolType         argument for Locals.Add()
0xCA0D  0x97 0x36       SMB1 0x36               // SMB1 ZP.CompilerFlags     we own the iterator
0xCA0F  0x20 0x98 0xA4  JSR 0xA498              // Locals.Add();                     compilerflow.asm:790
0xCA12  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:791
0xCA15  0xB0 0x03       BCS 0xCA1A (+3)         // if (NC) { break; }                compilerflow.asm:792
0xCA17  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCA1A  0xD7 0x36       SMB5 0x36               // SMB5 ZP.CompilerFlags    we created an implicit local that needs to be removed at the end of the function
0xCA1C  0x20 0x11 0xA5  JSR 0xA511              // Locals.Find();    Input: ZP.IDX = function node, ZP.TOP = name, Output: C set if found, ZP.ACCL = BP offset
0xCA1F  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:798
0xCA22  0xB0 0x03       BCS 0xCA27 (+3)         // if (NC) { break; }                compilerflow.asm:799
0xCA24  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCA27  0xEE 0x88 0x0B  INC 0x0B88              // INC Compiler.compilerFuncLocals     Track new local
0xCA2A  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL        Get the offset from Find()
0xCA2C  0x8D 0x8F 0x0B  STA 0x0B8F              // STA Compiler.compilerForIteratorBP         keep the actual offset for the NEXT check
0xCA2F  0x8D 0x8C 0x0B  STA 0x0B8C              // STA Compiler.compilerForIteratorOffset     Offset = BP offset for implicit local
0xCA32  0x80 0x08       BRA 0xCA3C (+8)         // }                                 compilerflow.asm:805
0xCA34  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                               Get the offset from Find()
0xCA36  0x8D 0x8F 0x0B  STA 0x0B8F              // STA Compiler.compilerForIteratorBP        keep the actual offset for the NEXT check
0xCA39  0x8D 0x8C 0x0B  STA 0x0B8C              // STA Compiler.compilerForIteratorOffset    Offset = BP offset for real local
0xCA3C  0x20 0x8D 0xA5  JSR 0xA58D              // Locals.GetType();                 compilerflow.asm:814
0xCA3F  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       compilerflow.asm:815
0xCA41  0x8D 0x8D 0x0B  STA 0x0B8D              // STA Compiler.compilerForIteratorType
0xCA44  0x9C 0x8B 0x0B  STZ 0x0B8B              // STZ Compiler.compilerCanDeclareLocals    no more locals after this
0xCA47  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xCA4A  0xB0 0x03       BCS 0xCA4F (+3)         // if (NC) { break; }                compilerflow.asm:822
0xCA4C  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCA4F  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:825
0xCA51  0xC9 0xE1       CMP # 0xE1              // CMP # Token.EQUALS                compilerflow.asm:826
0xCA53  0xF0 0x08       BEQ 0xCA5D (+8)         // if (NZ)                           compilerflow.asm:827
0xCA55  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL     Expected '='
0xCA58  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:830
0xCA5A  0x4C 0x3E 0xCD  JMP 0xCD3E              // break;                            compilerflow.asm:831
0xCA5D  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xCA60  0xB0 0x03       BCS 0xCA65 (+3)         // if (NC) { break; }                compilerflow.asm:836
0xCA62  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCA65  0x20 0xA3 0xD0  JSR 0xD0A3              // Compiler.CompileFoldedExpressionTree();     Compile FROM expression
0xCA68  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:839
0xCA6B  0xB0 0x03       BCS 0xCA70 (+3)         // if (NC) { break; }                compilerflow.asm:840
0xCA6D  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCA70  0x0F 0x36 0x0B  BBR0 0x36, 0xCA7E (+11) // if (BBS0, ZP.CompilerFlags)       compilerflow.asm:842
0xCA73  0xBF 0x15 0x08  BBS3 0x15, 0xCA7E (+8)  // if (BBR3, ZP.TOPT)    Bit 3 - LONG
0xCA76  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xCA79  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:847
0xCA7B  0x4C 0x3E 0xCD  JMP 0xCD3E              // break;                            compilerflow.asm:848
0xCA7E  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTopStrict();    FROM integral value
0xCA81  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTopStrict();             compilerflow.asm:854
0xCA84  0x8F 0x36 0x02  BBS0 0x36, 0xCA89 (+2)  // if (BBR0, ZP.CompilerFlags)       compilerflow.asm:855
0xCA87  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags    optimization to FORITF disqualified
0xCA89  0xAD 0x8C 0x0B  LDA 0x0B8C              // LDA Compiler.compilerForIteratorOffset
0xCA8C  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compilerflow.asm:862
0xCA8F  0xA9 0x44       LDA # 0x44              // LDA #OpCode.POPLOCAL              compilerflow.asm:863
0xCA91  0x20 0x0F 0xC4  JSR 0xC40F              // Emit.OpCodeWithByte();            compilerflow.asm:864
0xCA94  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:865
0xCA97  0xB0 0x03       BCS 0xCA9C (+3)         // if (NC) { break; }                compilerflow.asm:866
0xCA99  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCA9C  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:869
0xCA9E  0xC9 0xAB       CMP # 0xAB              // CMP #Token.TO                     compilerflow.asm:870
0xCAA0  0xF0 0x08       BEQ 0xCAAA (+8)         // if (NZ)                           compilerflow.asm:871
0xCAA2  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL     Expected TO
0xCAA5  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:874
0xCAA7  0x4C 0x3E 0xCD  JMP 0xCD3E              // break;                            compilerflow.asm:875
0xCAAA  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xCAAD  0xB0 0x03       BCS 0xCAB2 (+3)         // if (NC) { break; }                compilerflow.asm:880
0xCAAF  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCAB2  0x20 0xA3 0xD0  JSR 0xD0A3              // Compiler.CompileFoldedExpressionTree();     Compile TO expression (leaves on stack)
0xCAB5  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:883
0xCAB8  0xB0 0x03       BCS 0xCABD (+3)         // if (NC) { break; }                compilerflow.asm:884
0xCABA  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCABD  0x0F 0x36 0x0B  BBR0 0x36, 0xCACB (+11) // if (BBS0, ZP.CompilerFlags)       compilerflow.asm:886
0xCAC0  0xBF 0x15 0x08  BBS3 0x15, 0xCACB (+8)  // if (BBR3, ZP.TOPT)    Bit 3 - LONG
0xCAC3  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xCAC6  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:891
0xCAC8  0x4C 0x3E 0xCD  JMP 0xCD3E              // break;                            compilerflow.asm:892
0xCACB  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       compilerflow.asm:896
0xCACD  0x48            PHA                     // PHA                               compilerflow.asm:897
0xCACE  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       compilerflow.asm:898
0xCAD0  0x48            PHA                     // PHA                               compilerflow.asm:899
0xCAD1  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       compilerflow.asm:900
0xCAD3  0x48            PHA                     // PHA                               compilerflow.asm:901
0xCAD4  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       compilerflow.asm:902
0xCAD6  0x48            PHA                     // PHA                               compilerflow.asm:903
0xCAD7  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       compilerflow.asm:904
0xCAD9  0x48            PHA                     // PHA                               compilerflow.asm:905
0xCADA  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xCADD  0x20 0x29 0xC9  JSR 0xC929              // addForVar();    Locals.Add() a variable called "$F"
0xCAE0  0x68            PLA                     // PLA                               compilerflow.asm:911
0xCAE1  0x85 0x14       STA 0x14                // STA ZP.TOP3                       compilerflow.asm:912
0xCAE3  0x68            PLA                     // PLA                               compilerflow.asm:913
0xCAE4  0x85 0x13       STA 0x13                // STA ZP.TOP2                       compilerflow.asm:914
0xCAE6  0x68            PLA                     // PLA                               compilerflow.asm:915
0xCAE7  0x85 0x12       STA 0x12                // STA ZP.TOP1                       compilerflow.asm:916
0xCAE9  0x68            PLA                     // PLA                               compilerflow.asm:917
0xCAEA  0x85 0x11       STA 0x11                // STA ZP.TOP0                       compilerflow.asm:918
0xCAEC  0x68            PLA                     // PLA                               compilerflow.asm:919
0xCAED  0x85 0x15       STA 0x15                // STA ZP.TOPT                       compilerflow.asm:920
0xCAEF  0xEE 0x88 0x0B  INC 0x0B88              // INC Compiler.compilerFuncLocals      consider a RETURN from within the loop needing to clean the stack
0xCAF2  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:923
0xCAF5  0xB0 0x03       BCS 0xCAFA (+3)         // if (NC) { break; }                compilerflow.asm:924
0xCAF7  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCAFA  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       compilerflow.asm:926
0xCAFC  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTopStrict();    TO integeral value
0xCAFF  0x8F 0x36 0x02  BBS0 0x36, 0xCB04 (+2)  // if (BBR0, ZP.CompilerFlags)    TO is not constant expression
0xCB02  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags    optimization to FORITF disqualified
0xCB04  0x3F 0x15 0x08  BBR3 0x15, 0xCB0F (+8)  // if (BBS3, ZP.TOPT)    LONG not ok compilerflow.asm:934
0xCB07  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       compilerflow.asm:936
0xCB09  0x05 0x14       ORA 0x14                // ORA ZP.TOP3    x2                 compilerflow.asm:937
0xCB0B  0xF0 0x02       BEQ 0xCB0F (+2)         // if (NZ)                           compilerflow.asm:938
0xCB0D  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags    optimization to FORITF disqualified
0xCB0F  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:945
0xCB11  0xC9 0xAC       CMP # 0xAC              // CMP #Token.STEP                   compilerflow.asm:946
0xCB13  0xD0 0x5E       BNE 0xCB73 (+94)        // if (Z)                            compilerflow.asm:947
0xCB15  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xCB18  0xB0 0x03       BCS 0xCB1D (+3)         // if (NC) { break; }                compilerflow.asm:951
0xCB1A  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCB1D  0x20 0xA3 0xD0  JSR 0xD0A3              // Compiler.CompileFoldedExpressionTree();     Compile STEP expression (leaves on stack)
0xCB20  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:954
0xCB23  0xB0 0x03       BCS 0xCB28 (+3)         // if (NC) { break; }                compilerflow.asm:955
0xCB25  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCB28  0x0F 0x36 0x1A  BBR0 0x36, 0xCB45 (+26) // if (BBS0, ZP.CompilerFlags)       compilerflow.asm:957
0xCB2B  0xBF 0x15 0x08  BBS3 0x15, 0xCB36 (+8)  // if (BBR3, ZP.TOPT)    Bit 3 - LONG
0xCB2E  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xCB31  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:962
0xCB33  0x4C 0x3E 0xCD  JMP 0xCD3E              // break;                            compilerflow.asm:963
0xCB36  0x20 0xAD 0x97  JSR 0x97AD              // Long.ZeroCheckTop();              compilerflow.asm:965
0xCB39  0xD0 0x0A       BNE 0xCB45 (+10)        // if (Z)                            compilerflow.asm:966
0xCB3B  0xA9 0x3E       LDA # 0x3E              // Error.BadStep(); BIT ZP.EmulatorPCL
0xCB3D  0x20 0x5F 0x8B  JSR 0x8B5F
0xCB40  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:969
0xCB42  0x4C 0x3E 0xCD  JMP 0xCD3E              // break;                            compilerflow.asm:970
0xCB45  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xCB48  0x20 0x29 0xC9  JSR 0xC929              // addForVar();    Locals.Add() a variable called "$F"
0xCB4B  0xEE 0x88 0x0B  INC 0x0B88              // INC Compiler.compilerFuncLocals      consider a RETURN from within the loop needing to clean the stack
0xCB4E  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:978
0xCB51  0xB0 0x03       BCS 0xCB56 (+3)         // if (NC) { break; }                compilerflow.asm:979
0xCB53  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCB56  0x8F 0x36 0x04  BBS0 0x36, 0xCB5D (+4)  // if (BBR0, ZP.CompilerFlags)    STEP is NOT constant expression
0xCB59  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags    optimization to FORITF disqualified
0xCB5B  0x80 0x2C       BRA 0xCB89 (+44)        // }                                 compilerflow.asm:984
0xCB5D  0xA9 0x01       LDA # 1                 // LDA #1                            compilerflow.asm:988
0xCB5F  0xC5 0x11       CMP 0x11                // CMP ZP.TOP0                       compilerflow.asm:989
0xCB61  0xF0 0x04       BEQ 0xCB67 (+4)         // if (NZ)                           compilerflow.asm:990
0xCB63  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags    STEP != 1, optimization to FORITF disqualified
0xCB65  0x80 0x22       BRA 0xCB89 (+34)        // }                                 compilerflow.asm:993
0xCB67  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       compilerflow.asm:996
0xCB69  0x05 0x13       ORA 0x13                // ORA ZP.TOP2                       compilerflow.asm:997
0xCB6B  0x05 0x14       ORA 0x14                // ORA ZP.TOP3    x3                 compilerflow.asm:998
0xCB6D  0xF0 0x1A       BEQ 0xCB89 (+26)        // if (NZ)                           compilerflow.asm:999
0xCB6F  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags    STEP != 1, optimization to FORITF disqualified
0xCB71  0x80 0x16       BRA 0xCB89 (+22)        // }                                 compilerflow.asm:1005
0xCB73  0xA9 0x16       LDA # 0x16              // LDA #OpCode.PUSH1                 compilerflow.asm:1009
0xCB75  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compilerflow.asm:1010
0xCB78  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:1011
0xCB7B  0xB0 0x03       BCS 0xCB80 (+3)         // if (NC) { break; }                compilerflow.asm:1012
0xCB7D  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCB80  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xCB83  0x20 0x29 0xC9  JSR 0xC929              // addForVar();    Locals.Add() a variable called "$F"
0xCB86  0xEE 0x88 0x0B  INC 0x0B88              // INC Compiler.compilerFuncLocals      consider a RETURN from within the loop needing to clean the stack
0xCB89  0x3F 0x36 0x74  BBR3 0x36, 0xCC00 (+116)// if (BBS3, ZP.CompilerFlags)       compilerflow.asm:1019
0xCB8C  0xAD 0x8D 0x0B  LDA 0x0B8D              // LDA Compiler.compilerForIteratorType
0xCB8F  0x29 0x10       AND # 0x10              // AND # BASICType.VAR               compilerflow.asm:1026
0xCB91  0xD0 0x4C       BNE 0xCBDF (+76)        // if (Z)                            compilerflow.asm:1027
0xCB93  0xAD 0x8D 0x0B  LDA 0x0B8D              // LDA Compiler.compilerForIteratorType
0xCB96  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          compilerflow.asm:1033
0xCB98  0xC9 0x03       CMP # 0x03              // case BASICType.BYTE:              compilerflow.asm:1036
0xCB9A  0xF0 0x43       BEQ 0xCBDF (+67)
0xCB9C  0xC9 0x02       CMP # 0x02              // case BASICType.INT:               compilerflow.asm:1037
0xCB9E  0xF0 0x3F       BEQ 0xCBDF (+63)
0xCBA0  0xC9 0x04       CMP # 0x04              // case BASICType.WORD:              compilerflow.asm:1038
0xCBA2  0xF0 0x3B       BEQ 0xCBDF (+59)
0xCBA4  0xC9 0x08       CMP # 0x08              // case BASICType.LONG:              compilerflow.asm:1044
0xCBA6  0xD0 0x2A       BNE 0xCBD2 (+42)
0xCBA8  0xA9 0xFF       LDA # 0xFF              // LDA #0xFF                         compilerflow.asm:1047
0xCBAA  0x20 0xCB 0x98  JSR 0x98CB              // Long.GetStackTopSP();    TO: [SP-1] -> TOP
0xCBAD  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       compilerflow.asm:1049
0xCBAF  0x10 0x04       BPL 0xCBB5 (+4)         // if (MI)                           compilerflow.asm:1050
0xCBB1  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags     -ve LONG, optimization to FORITF disqualified
0xCBB3  0x80 0x2A       BRA 0xCBDF (+42)        // }                                 compilerflow.asm:1053
0xCBB5  0x05 0x13       ORA 0x13                // ORA ZP.TOP2                       compilerflow.asm:1056
0xCBB7  0xF0 0x04       BEQ 0xCBBD (+4)         // if (NZ)                           compilerflow.asm:1057
0xCBB9  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags    > 65535, optimization to FORITF disqualified
0xCBBB  0x80 0x22       BRA 0xCBDF (+34)        // }                                 compilerflow.asm:1060
0xCBBD  0xA9 0xFE       LDA # 0xFE              // LDA #0xFE                         compilerflow.asm:1063
0xCBBF  0x20 0xCB 0x98  JSR 0x98CB              // Long.GetStackTopSP();    FROM: [SP-2] -> TOP
0xCBC2  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       compilerflow.asm:1065
0xCBC4  0x10 0x04       BPL 0xCBCA (+4)         // if (MI)                           compilerflow.asm:1066
0xCBC6  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags     -ve LONG, , optimization to FORITF disqualified
0xCBC8  0x80 0x15       BRA 0xCBDF (+21)        // }                                 compilerflow.asm:1069
0xCBCA  0x05 0x13       ORA 0x13                // ORA ZP.TOP2                       compilerflow.asm:1072
0xCBCC  0xF0 0x11       BEQ 0xCBDF (+17)        // if (NZ)                           compilerflow.asm:1073
0xCBCE  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags    > 65535, optimization to FORITF disqualified
0xCBD0  0x80 0x0D       BRA 0xCBDF (+13)        // }                                 compilerflow.asm:1080
0xCBD2  0xC9 0x00       CMP # 0                 // case BASICType.VOID:              compilerflow.asm:1081
0xCBD4  0xD0 0x07       BNE 0xCBDD (+7)
0xCBD6  0x9F 0x36 0x06  BBS1 0x36, 0xCBDF (+6)  // }                                 compilerflow.asm:1086
0xCBD9  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags     Disqualify FORITF
0xCBDB  0x80 0x02       BRA 0xCBDF (+2)         // }                                 compilerflow.asm:1092
0xCBDD  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags     Disqualify FORITF
0xCBDF  0x20 0xE9 0xE1  JSR 0xE1E9              // ComparisonInstructions.LessThan();    FROM <= TO   3 - pops 2, + pushes 1 = 2
0xCBE2  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();                                     2 - pop 1 = 1
0xCBE5  0xD0 0x07       BNE 0xCBEE (+7)         // if (Z)                            compilerflow.asm:1105
0xCBE7  0x20 0x79 0x94  JSR 0x9479              // Stacks.PopTop();    1 - pop 1 = 0 compilerflow.asm:1107
0xCBEA  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags    FROM == TO, requires FORCHK, optimization to FORITF disqualified
0xCBEC  0x80 0x1B       BRA 0xCC09 (+27)        // }                                 compilerflow.asm:1109
0xCBEE  0x20 0x95 0x97  JSR 0x9795              // Long.ZeroTop();                   compilerflow.asm:1112
0xCBF1  0x20 0x89 0x97  JSR 0x9789              // Long.PushTopStrictLONG();     sets TOPT = LONG, 1 + push 1 = 2
0xCBF4  0x20 0x91 0xE2  JSR 0xE291              // ComparisonInstructions.GreaterEqual();     FROM >= 0   2 - pops 2, + pushes 1 = 1
0xCBF7  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();                                         1 - pop 1 = 0
0xCBFA  0xD0 0x0D       BNE 0xCC09 (+13)        // if (Z)                            compilerflow.asm:1118
0xCBFC  0x37 0x36       RMB3 0x36               // RMB3 ZP.CompilerFlags    TO >= FROM, optimization to FORITF disqualified
0xCBFE  0x80 0x09       BRA 0xCC09 (+9)         // }                                 compilerflow.asm:1123
0xCC00  0x20 0x79 0x94  JSR 0x9479              // Stacks.PopTop();    3 - pops 3 = 0
0xCC03  0x20 0x79 0x94  JSR 0x9479              // Stacks.PopTop();                  compilerflow.asm:1127
0xCC06  0x20 0x79 0x94  JSR 0x9479              // Stacks.PopTop();                  compilerflow.asm:1128
0xCC09  0xBF 0x36 0x22  BBS3 0x36, 0xCC2E (+34) // if (BBR3, ZP.CompilerFlags)       compilerflow.asm:1131
0xCC0C  0xA5 0x32       LDA 0x32                // LDA ZP.OpCodeBufferContentLengthL compilerflow.asm:1135
0xCC0E  0x18            CLC                     // CLC                               compilerflow.asm:1136
0xCC0F  0x69 0x02       ADC # 0x02              // ADC #2     Skip opcode and iterator offset to get operand position
0xCC11  0x85 0x11       STA 0x11                // STA ZP.TOPL                       compilerflow.asm:1138
0xCC13  0xA5 0x33       LDA 0x33                // LDA ZP.OpCodeBufferContentLengthH compilerflow.asm:1139
0xCC15  0x69 0x00       ADC # 0                 // ADC #0                            compilerflow.asm:1140
0xCC17  0x85 0x12       STA 0x12                // STA ZP.TOPH                       compilerflow.asm:1141
0xCC19  0x20 0xA1 0x94  JSR 0x94A1              // Stacks.PushTop();     Push FORCHK operand position
0xCC1C  0xAD 0x8C 0x0B  LDA 0x0B8C              // LDA Compiler.compilerForIteratorOffset
0xCC1F  0xA2 0x00       LDX # 0                 // LDX #0x00     Placeholder forward offset LSB
0xCC21  0xA0 0x00       LDY # 0                 // LDY #0x00     Placeholder forward offset MSB
0xCC23  0x20 0x67 0xC6  JSR 0xC667              // Emit.ForCheck();                  compilerflow.asm:1149
0xCC26  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:1150
0xCC29  0xB0 0x03       BCS 0xCC2E (+3)         // if (NC) { break; }                compilerflow.asm:1151
0xCC2B  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCC2E  0x20 0x91 0xC6  JSR 0xC691              // saveCurrentPosition();     Push loop body start position
0xCC31  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:1160
0xCC33  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    compilerflow.asm:1161
0xCC35  0xD0 0x05       BNE 0xCC3C (+5)         // if (NZ) { break; }                compilerflow.asm:1162
0xCC37  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xCC3A  0xB0 0xF5       BCS 0xCC31 (-11)        // if (NC) { break; }                compilerflow.asm:1165
0xCC3C  0x20 0x06 0xD8  JSR 0xD806              // CompileStatementBlock();          compilerflow.asm:1169
0xCC3F  0xB0 0x03       BCS 0xCC44 (+3)         // if (NC) { break; }                compilerflow.asm:1170
0xCC41  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCC44  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:1173
0xCC46  0xC9 0xAD       CMP # 0xAD              // CMP #Token.NEXT                   compilerflow.asm:1174
0xCC48  0xF0 0x06       BEQ 0xCC50 (+6)         // if (NZ)                           compilerflow.asm:1175
0xCC4A  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xCC4D  0x4C 0x3E 0xCD  JMP 0xCD3E              // break;                            compilerflow.asm:1178
0xCC50  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:1182
0xCC53  0xB0 0x03       BCS 0xCC58 (+3)         // if (NC) { break; }                compilerflow.asm:1183
0xCC55  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCC58  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:1186
0xCC5A  0xC9 0xAD       CMP # 0xAD              // CMP #Token.NEXT                   compilerflow.asm:1187
0xCC5C  0xF0 0x08       BEQ 0xCC66 (+8)         // if (NZ)                           compilerflow.asm:1188
0xCC5E  0x20 0x01 0x8C  JSR 0x8C01              // Error.MissingNext(); BIT ZP.EmulatorPCL     Expected NEXT
0xCC61  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:1191
0xCC63  0x4C 0x3E 0xCD  JMP 0xCD3E              // break;                            compilerflow.asm:1192
0xCC66  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xCC69  0xB0 0x03       BCS 0xCC6E (+3)         // if (NC) { break; }                compilerflow.asm:1197
0xCC6B  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCC6E  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compilerflow.asm:1200
0xCC70  0xC9 0xDA       CMP # 0xDA              // CMP #Token.IDENTIFIER             compilerflow.asm:1201
0xCC72  0xF0 0x08       BEQ 0xCC7C (+8)         // if (NZ)                           compilerflow.asm:1202
0xCC74  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL     Expected iterator after NEXT
0xCC77  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:1205
0xCC79  0x4C 0x3E 0xCD  JMP 0xCD3E              // break;                            compilerflow.asm:1206
0xCC7C  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();    Result in ZP.TOP (name pointer)
0xCC7F  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:1211
0xCC82  0xB0 0x03       BCS 0xCC87 (+3)         // if (NC) { break; }                compilerflow.asm:1212
0xCC84  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCC87  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xCC8A  0x20 0x11 0xA5  JSR 0xA511              // Locals.Find();    Input: ZP.IDX = function node, ZP.TOP = name, Output: C set if found, ZP.ACCL = BP offset
0xCC8D  0xB0 0x08       BCS 0xCC97 (+8)         // if (NC)                           compilerflow.asm:1219
0xCC8F  0x20 0x8F 0x8B  JSR 0x8B8F              // Error.UndefinedIdentifierTOP(); BIT ZP.EmulatorPCL     Iterator not found
0xCC92  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:1222
0xCC94  0x4C 0x3E 0xCD  JMP 0xCD3E              // break;                            compilerflow.asm:1223
0xCC97  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       compilerflow.asm:1228
0xCC99  0xCD 0x8F 0x0B  CMP 0x0B8F              // CMP Compiler.compilerForIteratorBP
0xCC9C  0xF0 0x08       BEQ 0xCCA6 (+8)         // if (NZ)                           compilerflow.asm:1230
0xCC9E  0x20 0x06 0x8C  JSR 0x8C06              // Error.NextMismatch(); BIT ZP.EmulatorPCL     NEXT variable doesn't match FOR
0xCCA1  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compilerflow.asm:1233
0xCCA3  0x4C 0x3E 0xCD  JMP 0xCD3E              // break;                            compilerflow.asm:1234
0xCCA6  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xCCA9  0xB0 0x03       BCS 0xCCAE (+3)         // if (NC) { break; }                compilerflow.asm:1241
0xCCAB  0x4C 0x3E 0xCD  JMP 0xCD3E
0xCCAE  0x20 0x79 0x94  JSR 0x9479              // Stacks.PopTop();     Get loop body start in ZP.TOP
0xCCB1  0x20 0xEE 0xC6  JSR 0xC6EE              // loadCurrentPosition();            compilerflow.asm:1249
0xCCB4  0xA9 0x04       LDA # 0x04              // LDA #4     FORIT instruction size compilerflow.asm:1250
0xCCB6  0x20 0xD2 0xC6  JSR 0xC6D2              // addInstructionSizeToPosition();   compilerflow.asm:1251
0xCCB9  0x20 0xC4 0xC6  JSR 0xC6C4              // calculateBackwardOffset();        compilerflow.asm:1254
0xCCBC  0xA6 0x11       LDX 0x11                // LDX ZP.TOPL     Backward offset LSB
0xCCBE  0xA4 0x12       LDY 0x12                // LDY ZP.TOPH     Backward offset MSB
0xCCC0  0x3F 0x36 0x08  BBR3 0x36, 0xCCCB (+8)  // if (BBS3, ZP.CompilerFlags)    Optimized for FORITF
0xCCC3  0xAD 0x8C 0x0B  LDA 0x0B8C              // LDA Compiler.compilerForIteratorOffset
0xCCC6  0x20 0x83 0xC6  JSR 0xC683              // Emit.ForIterateFast();     Use FORITF
0xCCC9  0x80 0x1E       BRA 0xCCE9 (+30)        // }                                 compilerflow.asm:1263
0xCCCB  0xAD 0x8C 0x0B  LDA 0x0B8C              // LDA Compiler.compilerForIteratorOffset
0xCCCE  0x20 0x75 0xC6  JSR 0xC675              // Emit.ForIterate();                compilerflow.asm:1268
0xCCD1  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:1269
0xCCD4  0x90 0x68       BCC 0xCD3E (+104)       // if (NC) { break; }                compilerflow.asm:1270
0xCCD6  0x20 0xF5 0x94  JSR 0x94F5              // Stacks.PopIDX();     Get FORCHK operand position in ZP.IDX
0xCCD9  0x20 0xEE 0xC6  JSR 0xC6EE              // loadCurrentPosition();            compilerflow.asm:1279
0xCCDC  0x20 0x9E 0xC6  JSR 0xC69E              // calculateForwardOffset();         compilerflow.asm:1282
0xCCDF  0xA9 0x02       LDA # 0x02              // LDA #2     JUMPZW instruction size
0xCCE1  0x20 0xDE 0xC6  JSR 0xC6DE              // subtractInstructionSizeFromOffset();
0xCCE4  0xA9 0x00       LDA # 0                 // LDA #0     ZP.IDX already points to operand position
0xCCE6  0x20 0xAC 0xC6  JSR 0xC6AC              // patchWordOperand();               compilerflow.asm:1290
0xCCE9  0xA9 0x02       LDA # 0x02              // LDA #0x02     Decrement by 2 positions
0xCCEB  0x20 0xE0 0xC5  JSR 0xC5E0              // Emit.DecSp();                     compilerflow.asm:1296
0xCCEE  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:1297
0xCCF1  0x90 0x4B       BCC 0xCD3E (+75)        // if (NC) { break; }                compilerflow.asm:1298
0xCCF3  0xCE 0x88 0x0B  DEC 0x0B88              // DEC Compiler.compilerFuncLocals   compilerflow.asm:1300
0xCCF6  0xCE 0x88 0x0B  DEC 0x0B88              // DEC Compiler.compilerFuncLocals     Decrement twice since we're removing 2 locals
0xCCF9  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xCCFC  0x20 0xF4 0xA6  JSR 0xA6F4              // Locals.RemoveLast();              compilerflow.asm:1304
0xCCFF  0x20 0xF4 0xA6  JSR 0xA6F4              // Locals.RemoveLast();              compilerflow.asm:1305
0xCD02  0x2F 0x36 0x20  BBR2 0x36, 0xCD25 (+32) // if (BBS2, ZP.CompilerFlags)       compilerflow.asm:1309
0xCD05  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();    Get iterator name in ZP.TOP
0xCD08  0x64 0x47       STZ 0x47                // STZ ZP.SymbolIteratorFilter     Accept both variables and constants
0xCD0A  0x20 0x8E 0xA1  JSR 0xA18E              // Variables.Find();     Returns index in ZP.IDY
0xCD0D  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL     The global slot from Find()
0xCD0F  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compilerflow.asm:1320
0xCD12  0xA9 0x4C       LDA # 0x4C              // LDA #OpCode.POPGLOBAL             compilerflow.asm:1321
0xCD14  0x20 0x0F 0xC4  JSR 0xC40F              // Emit.OpCodeWithByte();            compilerflow.asm:1322
0xCD17  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:1323
0xCD1A  0x90 0x22       BCC 0xCD3E (+34)        // if (NC) { break; }                compilerflow.asm:1324
0xCD1C  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xCD1F  0x20 0xF4 0xA6  JSR 0xA6F4              // Locals.RemoveLast();              compilerflow.asm:1327
0xCD22  0xCE 0x88 0x0B  DEC 0x0B88              // DEC Compiler.compilerFuncLocals   compilerflow.asm:1328
0xCD25  0x5F 0x36 0x13  BBR5 0x36, 0xCD3B (+19) // if (BBS5, ZP.CompilerFlags)    IMPLICIT SCOPE : we own it
0xCD28  0xA9 0x01       LDA # 1                 // LDA #0x01     Decrement by 1 position
0xCD2A  0x20 0xE0 0xC5  JSR 0xC5E0              // Emit.DecSp();                     compilerflow.asm:1335
0xCD2D  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compilerflow.asm:1336
0xCD30  0x90 0x0C       BCC 0xCD3E (+12)        // if (NC) { break; }                compilerflow.asm:1337
0xCD32  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xCD35  0x20 0xF4 0xA6  JSR 0xA6F4              // Locals.RemoveLast();              compilerflow.asm:1340
0xCD38  0xCE 0x88 0x0B  DEC 0x0B88              // DEC Compiler.compilerFuncLocals   compilerflow.asm:1341
0xCD3B  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();              compilerflow.asm:1343
0xCD3E  0x68            PLA                     // PLA                               compilerflow.asm:1350
0xCD3F  0x5F 0x36 0x06  BBR5 0x36, 0xCD48 (+6)  // if (BBS5, ZP.CompilerFlags)       compilerflow.asm:1351
0xCD42  0x85 0x36       STA 0x36                // STA ZP.CompilerFlags              compilerflow.asm:1353
0xCD44  0xD7 0x36       SMB5 0x36               // SMB5 ZP.CompilerFlags    persist the reminder to function to remove implicit local at the end
0xCD46  0x80 0x02       BRA 0xCD4A (+2)         // }                                 compilerflow.asm:1355
0xCD48  0x85 0x36       STA 0x36                // STA ZP.CompilerFlags              compilerflow.asm:1358
0xCD4A  0x68            PLA                     // PLA                               compilerflow.asm:1360
0xCD4B  0x85 0x03       STA 0x03                // STA ZP.SP                         compilerflow.asm:1361
0xCD4D  0x68            PLA                     // PLA                               compilerflow.asm:1362
0xCD4E  0x8D 0x8F 0x0B  STA 0x0B8F              // STA Compiler.compilerForIteratorBP
0xCD51  0x68            PLA                     // PLA                               compilerflow.asm:1364
0xCD52  0x8D 0x8E 0x0B  STA 0x0B8E              // STA Compiler.compilerGlobalIteratorSlot
0xCD55  0x68            PLA                     // PLA                               compilerflow.asm:1366
0xCD56  0x8D 0x8D 0x0B  STA 0x0B8D              // STA Compiler.compilerForIteratorType
0xCD59  0x68            PLA                     // PLA                               compilerflow.asm:1368
0xCD5A  0x8D 0x8C 0x0B  STA 0x0B8C              // STA Compiler.compilerForIteratorOffset
0xCD5D  0x60            RTS                     // }                                 compilerflow.asm:1375

// /source/projects/6502sbc/hopperbasic/optimizer.asm:70
// ####  Optimizer.ClearPeeps()  ####                                           0x021A

0xCD5E  0x64 0x87       STZ 0x87                // STZ ZP.PEEP3                      optimizer.asm:72
0xCD60  0x64 0x86       STZ 0x86                // STZ ZP.PEEP2                      optimizer.asm:73
0xCD62  0x64 0x85       STZ 0x85                // STZ ZP.PEEP1                      optimizer.asm:74
0xCD64  0x64 0x84       STZ 0x84                // STZ ZP.PEEP0                      optimizer.asm:75
0xCD66  0x60            RTS                     // }                                 optimizer.asm:76

// /source/projects/6502sbc/hopperbasic/optimizer.asm:191
// ####  Optimizer.stepBack()  ####                                             0x021C

0xCD67  0x48            PHA                     // PHA    preserve the opcode        optimizer.asm:192
0xCD68  0x4A            LSR A                   // LSR A LSR A LSR A LSR A LSR A LSR A    divide by 64
0xCD69  0x4A            LSR A
0xCD6A  0x4A            LSR A
0xCD6B  0x4A            LSR A
0xCD6C  0x4A            LSR A
0xCD6D  0x4A            LSR A
0xCD6E  0x1A            INC A                   // INC                               optimizer.asm:194
0xCD6F  0xA8            TAY                     // TAY                               optimizer.asm:195
0xCD70  0x20 0x58 0x93  JSR 0x9358              // DecIDY();                         optimizer.asm:198
0xCD73  0x88            DEY                     // DEY                               optimizer.asm:199
0xCD74  0xD0 0xFA       BNE 0xCD70 (-6)         // if (Z) { break; }                 optimizer.asm:200
0xCD76  0x68            PLA                     // PLA                               optimizer.asm:202
0xCD77  0x60            RTS                     // }                                 optimizer.asm:203

// /source/projects/6502sbc/hopperbasic/optimizer.asm:205
// ####  Optimizer.stepBackXPC()  ####                                          0x021D

0xCD78  0x4A            LSR A                   // LSR A LSR A LSR A LSR A LSR A LSR A    divide by 64
0xCD79  0x4A            LSR A
0xCD7A  0x4A            LSR A
0xCD7B  0x4A            LSR A
0xCD7C  0x4A            LSR A
0xCD7D  0x4A            LSR A
0xCD7E  0x1A            INC A                   // INC                               optimizer.asm:207
0xCD7F  0xA8            TAY                     // TAY                               optimizer.asm:208
0xCD80  0xA5 0x7E       LDA 0x7E                // LDA ZP.XPCL                       optimizer.asm:211
0xCD82  0xD0 0x02       BNE 0xCD86 (+2)         // if (Z)                            optimizer.asm:212
0xCD84  0xC6 0x7F       DEC 0x7F                // DEC ZP.XPCH                       optimizer.asm:214
0xCD86  0xC6 0x7E       DEC 0x7E                // DEC ZP.XPCL                       optimizer.asm:216
0xCD88  0xA5 0x32       LDA 0x32                // LDA OpCodeBufferContentLengthL    optimizer.asm:218
0xCD8A  0xD0 0x02       BNE 0xCD8E (+2)         // if (Z)                            optimizer.asm:219
0xCD8C  0xC6 0x33       DEC 0x33                // DEC OpCodeBufferContentLengthH    optimizer.asm:221
0xCD8E  0xC6 0x32       DEC 0x32                // DEC OpCodeBufferContentLengthL    optimizer.asm:223
0xCD90  0x88            DEY                     // DEY                               optimizer.asm:225
0xCD91  0xD0 0xED       BNE 0xCD80 (-19)        // if (Z) { break; }                 optimizer.asm:226
0xCD93  0x60            RTS                     // }                                 optimizer.asm:228

// /source/projects/6502sbc/hopperbasic/optimizer.asm:230
// ####  Optimizer.incXPC()  ####                                               0x021E

0xCD94  0xE6 0x7E       INC 0x7E                // INC ZP.XPCL                       optimizer.asm:232
0xCD96  0xD0 0x02       BNE 0xCD9A (+2)         // if (Z)                            optimizer.asm:233
0xCD98  0xE6 0x7F       INC 0x7F                // INC ZP.XPCH                       optimizer.asm:235
0xCD9A  0xE6 0x32       INC 0x32                // INC OpCodeBufferContentLengthL    optimizer.asm:237
0xCD9C  0xF0 0x01       BEQ 0xCD9F (+1)         // if (Z)                            optimizer.asm:238
0xCD9E  0x60            RTS
0xCD9F  0xE6 0x33       INC 0x33                // INC OpCodeBufferContentLengthH    optimizer.asm:240
0xCDA1  0x60            RTS                     // }                                 optimizer.asm:242

// /source/projects/6502sbc/hopperbasic/optimizer.asm:245
// ####  Optimizer.SetItemPrep()  ####                                          0x021F

0xCDA2  0x38            SEC                     // SEC                               optimizer.asm:247
0xCDA3  0xA5 0x7E       LDA 0x7E                // LDA ZP.XPCL                       optimizer.asm:248
0xCDA5  0xE9 0x04       SBC # 0x04              // SBC #4                            optimizer.asm:249
0xCDA7  0x85 0x7E       STA 0x7E                // STA ZP.XPCL                       optimizer.asm:250
0xCDA9  0xA5 0x7F       LDA 0x7F                // LDA ZP.XPCH                       optimizer.asm:251
0xCDAB  0xE9 0x00       SBC # 0                 // SBC #0                            optimizer.asm:252
0xCDAD  0x85 0x7F       STA 0x7F                // STA ZP.XPCH                       optimizer.asm:253
0xCDAF  0x38            SEC                     // SEC                               optimizer.asm:255
0xCDB0  0xA5 0x32       LDA 0x32                // LDA OpCodeBufferContentLengthL    optimizer.asm:256
0xCDB2  0xE9 0x04       SBC # 0x04              // SBC #4                            optimizer.asm:257
0xCDB4  0x85 0x32       STA 0x32                // STA OpCodeBufferContentLengthL    optimizer.asm:258
0xCDB6  0xA5 0x33       LDA 0x33                // LDA OpCodeBufferContentLengthH    optimizer.asm:259
0xCDB8  0xE9 0x00       SBC # 0                 // SBC #0                            optimizer.asm:260
0xCDBA  0x85 0x33       STA 0x33                // STA OpCodeBufferContentLengthH    optimizer.asm:261
0xCDBC  0xA0 0x01       LDY # 1                 // LDY #1                            optimizer.asm:263
0xCDBE  0xB1 0x7E       LDA [0x7E],Y            // LDA [ZP.XPC], Y                   optimizer.asm:264
0xCDC0  0x8D 0x93 0x0B  STA 0x0B93              // STA Compiler.compilerSetItemObjOffset
0xCDC3  0xA0 0x03       LDY # 0x03              // LDY #3                            optimizer.asm:266
0xCDC5  0xB1 0x7E       LDA [0x7E],Y            // LDA [ZP.XPC], Y                   optimizer.asm:267
0xCDC7  0x8D 0x95 0x0B  STA 0x0B95              // STA Compiler.compilerSetItemIndexOffset
0xCDCA  0x60            RTS                     // }                                 optimizer.asm:269

// /source/projects/6502sbc/hopperbasic/optimizer.asm:273
// ####  Optimizer.pushPeepOp()  ####                                           0x0220

0xCDCB  0xA5 0x86       LDA 0x86                // LDA ZP.PEEP2                      optimizer.asm:274
0xCDCD  0x85 0x87       STA 0x87                // STA ZP.PEEP3                      optimizer.asm:275
0xCDCF  0xA5 0x85       LDA 0x85                // LDA ZP.PEEP1                      optimizer.asm:277
0xCDD1  0x85 0x86       STA 0x86                // STA ZP.PEEP2                      optimizer.asm:278
0xCDD3  0xA5 0x84       LDA 0x84                // LDA ZP.PEEP0                      optimizer.asm:280
0xCDD5  0x85 0x85       STA 0x85                // STA ZP.PEEP1                      optimizer.asm:281
0xCDD7  0xAD 0x82 0x0B  LDA 0x0B82              // LDA Compiler.compilerOpCode       optimizer.asm:283
0xCDDA  0x85 0x84       STA 0x84                // STA ZP.PEEP0                      optimizer.asm:284
0xCDDC  0x60            RTS                     // }                                 optimizer.asm:285

// /source/projects/6502sbc/hopperbasic/optimizer.asm:289
// ####  Optimizer.popPeepOp()  ####                                            0x0221

0xCDDD  0xA5 0x85       LDA 0x85                // LDA ZP.PEEP1                      optimizer.asm:290
0xCDDF  0x85 0x84       STA 0x84                // STA ZP.PEEP0                      optimizer.asm:291
0xCDE1  0xA5 0x86       LDA 0x86                // LDA ZP.PEEP2                      optimizer.asm:292
0xCDE3  0x85 0x85       STA 0x85                // STA ZP.PEEP1                      optimizer.asm:293
0xCDE5  0xA5 0x87       LDA 0x87                // LDA ZP.PEEP3                      optimizer.asm:294
0xCDE7  0x85 0x86       STA 0x86                // STA ZP.PEEP2                      optimizer.asm:295
0xCDE9  0xA9 0x00       LDA # 0                 // LDA # OpCode.INVALID              optimizer.asm:296
0xCDEB  0x85 0x87       STA 0x87                // STA ZP.PEEP3                      optimizer.asm:297
0xCDED  0x60            RTS                     // }                                 optimizer.asm:298

// /source/projects/6502sbc/hopperbasic/optimizer.asm:305
// ####  Optimizer.loadPeepOperand()  ####                                      0x0222

0xCDEE  0x74 0x50       STZ 0x50,X              // STZ ZP.PEEPOP0, X                 optimizer.asm:307
0xCDF0  0x74 0x54       STZ 0x54,X              // STZ ZP.PEEPOP0H, X                optimizer.asm:308
0xCDF2  0xB5 0x84       LDA 0x84,X              // LDA ZP.PEEP0, X     Load PEEP[X] opcode
0xCDF4  0xD0 0x01       BNE 0xCDF7 (+1)         // if (Z) { return; }     Skip invalid opcodes
0xCDF6  0x60            RTS
0xCDF7  0x20 0x67 0xCD  JSR 0xCD67              // stepBack();    munts Y, decrements IDY, preserves A
0xCDFA  0xA0 0x01       LDY # 1                 // LDY #1                            optimizer.asm:319
0xCDFC  0x29 0xC0       AND # 0xC0              // AND #0xC0                         optimizer.asm:320
0xCDFE  0xC9 0x40       CMP # 0x40              // CMP #0x40                         optimizer.asm:321
0xCE00  0xD0 0x05       BNE 0xCE07 (+5)         // if (Z)    Single byte operand     optimizer.asm:322
0xCE02  0xB1 0x1D       LDA [0x1D],Y            // LDA [ZP.IDY], Y                   optimizer.asm:324
0xCE04  0x95 0x50       STA 0x50,X              // STA ZP.PEEPOP0, X                 optimizer.asm:325
0xCE06  0x60            RTS                     // }                                 optimizer.asm:326
0xCE07  0xC9 0x80       CMP # 0x80              // CMP #0x80                         optimizer.asm:329
0xCE09  0xF0 0x01       BEQ 0xCE0C (+1)         // if (Z)    Two byte operand        optimizer.asm:330
0xCE0B  0x60            RTS
0xCE0C  0xB1 0x1D       LDA [0x1D],Y            // LDA [ZP.IDY], Y                   optimizer.asm:332
0xCE0E  0x95 0x50       STA 0x50,X              // STA ZP.PEEPOP0, X       Word LSB  optimizer.asm:333
0xCE10  0xC8            INY                     // INY                               optimizer.asm:334
0xCE11  0xB1 0x1D       LDA [0x1D],Y            // LDA [ZP.IDY], Y                   optimizer.asm:335
0xCE13  0x95 0x54       STA 0x54,X              // STA ZP.PEEPOP0H, X      Word MSB  optimizer.asm:336
0xCE15  0x60            RTS                     // }                                 optimizer.asm:339

// /source/projects/6502sbc/hopperbasic/optimizer.asm:345
// ####  Optimizer.tryOptimize()  ####                                          0x0223

0xCE16  0xA9 0xA0       LDA # 0xA0              // LDA #((peepPatterns-7) % 256)     optimizer.asm:347
0xCE18  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       optimizer.asm:348
0xCE1A  0xA9 0x85       LDA # 0x85              // LDA #((peepPatterns-7) / 256)     optimizer.asm:349
0xCE1C  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       optimizer.asm:350
0xCE1E  0x18            CLC                     // CLC                               optimizer.asm:355
0xCE1F  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       optimizer.asm:356
0xCE21  0x69 0x07       ADC # 0x07              // ADC #7                            optimizer.asm:357
0xCE23  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       optimizer.asm:358
0xCE25  0x90 0x02       BCC 0xCE29 (+2)         // if (C)                            optimizer.asm:359
0xCE27  0xE6 0x1C       INC 0x1C                // INC ZP.IDXH                       optimizer.asm:361
0xCE29  0xA0 0x00       LDY # 0                 // LDY #0                            optimizer.asm:365
0xCE2B  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y    Y = 0          optimizer.asm:366
0xCE2D  0xD0 0x02       BNE 0xCE31 (+2)         // if (Z) { CLC break; }    Found OpCode.INVALID - no more patterns
0xCE2F  0x18            CLC
0xCE30  0x60            RTS
0xCE31  0xC5 0x84       CMP 0x84                // CMP ZP.PEEP0                      optimizer.asm:370
0xCE33  0xD0 0xE9       BNE 0xCE1E (-23)        // if (NZ) { continue; }             optimizer.asm:371
0xCE35  0xC8            INY                     // INY                               optimizer.asm:374
0xCE36  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y    Y = 1          optimizer.asm:375
0xCE38  0xC5 0x85       CMP 0x85                // CMP ZP.PEEP1                      optimizer.asm:376
0xCE3A  0xD0 0xE2       BNE 0xCE1E (-30)        // if (NZ) { continue; }             optimizer.asm:377
0xCE3C  0xC8            INY                     // INY                               optimizer.asm:380
0xCE3D  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y    Y = 2          optimizer.asm:381
0xCE3F  0xC9 0xFF       CMP # 0xFF              // CMP # OpCode.DONTCARE             optimizer.asm:382
0xCE41  0xF0 0x10       BEQ 0xCE53 (+16)        // if (NZ)    do we have a 3rd instruction in the pattern?
0xCE43  0xC5 0x86       CMP 0x86                // CMP ZP.PEEP2                      optimizer.asm:385
0xCE45  0xD0 0xD7       BNE 0xCE1E (-41)        // if (NZ) { continue; }    does PEEP3 match the pattern?
0xCE47  0xC8            INY                     // INY                               optimizer.asm:389
0xCE48  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y    Y = 3          optimizer.asm:390
0xCE4A  0xC9 0xFF       CMP # 0xFF              // CMP # OpCode.DONTCARE             optimizer.asm:391
0xCE4C  0xF0 0x05       BEQ 0xCE53 (+5)         // if (NZ)    do we have a 4th instruction in the pattern?
0xCE4E  0xC5 0x87       CMP 0x87                // CMP ZP.PEEP3                      optimizer.asm:394
0xCE50  0xD0 0xCC       BNE 0xCE1E (-52)        // if (NZ) { continue; }    does PEEP3 match the pattern?
0xCE52  0xC8            INY                     // INY    Y = 4                      optimizer.asm:397
0xCE53  0x84 0x58       STY 0x58                // STY ZP.PEEPOPS                    optimizer.asm:404
0xCE55  0xA0 0x04       LDY # 0x04              // LDY #4                            optimizer.asm:407
0xCE57  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   optimizer.asm:408
0xCE59  0x85 0x59       STA 0x59                // STA ZP.PEEPCONSTRAINTS            optimizer.asm:409
0xCE5B  0xA0 0x05       LDY # 0x05              // LDY #5                            optimizer.asm:412
0xCE5D  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   optimizer.asm:413
0xCE5F  0x85 0x5B       STA 0x5B                // STA ZP.PEEPOPERANDS               optimizer.asm:414
0xCE61  0xA0 0x06       LDY # 0x06              // LDY #6                            optimizer.asm:417
0xCE63  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   optimizer.asm:418
0xCE65  0x85 0x5A       STA 0x5A                // STA ZP.PEEPREPLACE                optimizer.asm:419
0xCE67  0xA5 0x7E       LDA 0x7E                // LDA ZP.XPCL                       optimizer.asm:422
0xCE69  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       optimizer.asm:423
0xCE6B  0xA5 0x7F       LDA 0x7F                // LDA ZP.XPCH                       optimizer.asm:424
0xCE6D  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       optimizer.asm:425
0xCE6F  0xA2 0x00       LDX # 0                 // LDX #0                            optimizer.asm:428
0xCE71  0x20 0xEE 0xCD  JSR 0xCDEE              // loadPeepOperand();                optimizer.asm:429
0xCE74  0xA2 0x01       LDX # 1                 // LDX #1                            optimizer.asm:432
0xCE76  0x20 0xEE 0xCD  JSR 0xCDEE              // loadPeepOperand();                optimizer.asm:433
0xCE79  0xA5 0x58       LDA 0x58                // LDA ZP.PEEPOPS                    optimizer.asm:435
0xCE7B  0xC9 0x02       CMP # 0x02              // CMP #2                            optimizer.asm:436
0xCE7D  0xF0 0x05       BEQ 0xCE84 (+5)         // if (NZ)    must be 3 or 4         optimizer.asm:437
0xCE7F  0xA2 0x02       LDX # 0x02              // LDX #2                            optimizer.asm:440
0xCE81  0x20 0xEE 0xCD  JSR 0xCDEE              // loadPeepOperand();                optimizer.asm:441
0xCE84  0xA5 0x58       LDA 0x58                // LDA ZP.PEEPOPS                    optimizer.asm:443
0xCE86  0xC9 0x04       CMP # 0x04              // CMP #4                            optimizer.asm:444
0xCE88  0xD0 0x05       BNE 0xCE8F (+5)         // if (Z)                            optimizer.asm:445
0xCE8A  0xA2 0x03       LDX # 0x03              // LDX #3                            optimizer.asm:448
0xCE8C  0x20 0xEE 0xCD  JSR 0xCDEE              // loadPeepOperand();                optimizer.asm:449
0xCE8F  0xA5 0x59       LDA 0x59                // LDA ZP.PEEPCONSTRAINTS            optimizer.asm:453
0xCE91  0x29 0x01       AND # 1                 // AND #PeepConstraint.EqualOperands0and3
0xCE93  0xF0 0x06       BEQ 0xCE9B (+6)         // if (NZ)                           optimizer.asm:455
0xCE95  0xA5 0x50       LDA 0x50                // LDA ZP.PEEPOP0                    optimizer.asm:457
0xCE97  0xC5 0x53       CMP 0x53                // CMP ZP.PEEPOP3                    optimizer.asm:458
0xCE99  0xD0 0x83       BNE 0xCE1E (-125)       // continue;                         optimizer.asm:462
0xCE9B  0xA5 0x59       LDA 0x59                // LDA ZP.PEEPCONSTRAINTS            optimizer.asm:466
0xCE9D  0x29 0x02       AND # 0x02              // AND #PeepConstraint.EqualOperands0and2
0xCE9F  0xF0 0x0A       BEQ 0xCEAB (+10)        // if (NZ)                           optimizer.asm:468
0xCEA1  0xA5 0x50       LDA 0x50                // LDA ZP.PEEPOP0                    optimizer.asm:470
0xCEA3  0xC5 0x52       CMP 0x52                // CMP ZP.PEEPOP2                    optimizer.asm:471
0xCEA5  0xF0 0x04       BEQ 0xCEAB (+4)         // if (NZ)                           optimizer.asm:472
0xCEA7  0x18            CLC                     // CLC                               optimizer.asm:475
0xCEA8  0x4C 0x1E 0xCE  JMP 0xCE1E              // continue;                         optimizer.asm:476
0xCEAB  0xA5 0x59       LDA 0x59                // LDA ZP.PEEPCONSTRAINTS            optimizer.asm:480
0xCEAD  0x29 0x04       AND # 0x04              // AND #PeepConstraint.EqualOperands0and1
0xCEAF  0xF0 0x09       BEQ 0xCEBA (+9)         // if (NZ)                           optimizer.asm:482
0xCEB1  0xA5 0x50       LDA 0x50                // LDA ZP.PEEPOP0                    optimizer.asm:484
0xCEB3  0xC5 0x51       CMP 0x51                // CMP ZP.PEEPOP1                    optimizer.asm:485
0xCEB5  0xF0 0x03       BEQ 0xCEBA (+3)         // if (NZ)                           optimizer.asm:486
0xCEB7  0x4C 0x1E 0xCE  JMP 0xCE1E              // continue;                         optimizer.asm:489
0xCEBA  0xA6 0x58       LDX 0x58                // LDX ZP.PEEPOPS                    optimizer.asm:499
0xCEBC  0xA5 0x84       LDA 0x84                // LDA ZP.PEEP0                      optimizer.asm:502
0xCEBE  0x20 0x78 0xCD  JSR 0xCD78              // stepBackXPC();    munts A, Y      optimizer.asm:503
0xCEC1  0x20 0xDD 0xCD  JSR 0xCDDD              // popPeepOp();                      optimizer.asm:504
0xCEC4  0xCA            DEX                     // DEX                               optimizer.asm:505
0xCEC5  0xD0 0xF5       BNE 0xCEBC (-11)        // if (Z) { break; }                 optimizer.asm:506
0xCEC7  0xA5 0x5A       LDA 0x5A                // LDA ZP.PEEPREPLACE                optimizer.asm:511
0xCEC9  0x8D 0x82 0x0B  STA 0x0B82              // STA Compiler.compilerOpCode       optimizer.asm:512
0xCECC  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      optimizer.asm:513
0xCECE  0x8D 0x86 0x0B  STA 0x0B86              // STA Compiler.compilerLastOpCode   optimizer.asm:514
0xCED1  0x20 0x94 0xCD  JSR 0xCD94              // incXPC();                         optimizer.asm:519
0xCED4  0x20 0xCB 0xCD  JSR 0xCDCB              // pushPeepOp();    Compiler.compilerOpCode is the new PEEP0
0xCED7  0xA5 0x5B       LDA 0x5B                // LDA ZP.PEEPOPERANDS               optimizer.asm:524
0xCED9  0xC9 0x01       CMP # 1                 // case NewOperands.Operand0:        optimizer.asm:527
0xCEDB  0xD0 0x09       BNE 0xCEE6 (+9)
0xCEDD  0xA5 0x50       LDA 0x50                // LDA ZP.PEEPOP0                    optimizer.asm:529
0xCEDF  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      optimizer.asm:530
0xCEE1  0x20 0x94 0xCD  JSR 0xCD94              // incXPC();                         optimizer.asm:531
0xCEE4  0x80 0x5C       BRA 0xCF42 (+92)        // }                                 optimizer.asm:532
0xCEE6  0xC9 0x06       CMP # 0x06              // case NewOperands.IncrementOperand1:
0xCEE8  0xD0 0x0A       BNE 0xCEF4 (+10)
0xCEEA  0xA5 0x51       LDA 0x51                // LDA ZP.PEEPOP1                    optimizer.asm:535
0xCEEC  0x1A            INC A                   // INC                               optimizer.asm:536
0xCEED  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      optimizer.asm:537
0xCEEF  0x20 0x94 0xCD  JSR 0xCD94              // incXPC();                         optimizer.asm:538
0xCEF2  0x80 0x4E       BRA 0xCF42 (+78)        // }                                 optimizer.asm:539
0xCEF4  0xC9 0x02       CMP # 0x02              // case NewOperands.Operand1W:       optimizer.asm:540
0xCEF6  0xD0 0x10       BNE 0xCF08 (+16)
0xCEF8  0xA5 0x51       LDA 0x51                // LDA ZP.PEEPOP1         Word LSB   optimizer.asm:542
0xCEFA  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      optimizer.asm:543
0xCEFC  0x20 0x94 0xCD  JSR 0xCD94              // incXPC();                         optimizer.asm:544
0xCEFF  0xA5 0x55       LDA 0x55                // LDA ZP.PEEPOP1H        Word MSB   optimizer.asm:546
0xCF01  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      optimizer.asm:547
0xCF03  0x20 0x94 0xCD  JSR 0xCD94              // incXPC();                         optimizer.asm:548
0xCF06  0x80 0x3A       BRA 0xCF42 (+58)        // }                                 optimizer.asm:549
0xCF08  0xC9 0x03       CMP # 0x03              // case NewOperands.Operand0AndOperand2:
0xCF0A  0xD0 0x10       BNE 0xCF1C (+16)
0xCF0C  0xA5 0x50       LDA 0x50                // LDA ZP.PEEPOP0                    optimizer.asm:552
0xCF0E  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      optimizer.asm:553
0xCF10  0x20 0x94 0xCD  JSR 0xCD94              // incXPC();                         optimizer.asm:554
0xCF13  0xA5 0x52       LDA 0x52                // LDA ZP.PEEPOP2                    optimizer.asm:556
0xCF15  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      optimizer.asm:557
0xCF17  0x20 0x94 0xCD  JSR 0xCD94              // incXPC();                         optimizer.asm:558
0xCF1A  0x80 0x26       BRA 0xCF42 (+38)        // }                                 optimizer.asm:559
0xCF1C  0xC9 0x04       CMP # 0x04              // case NewOperands.Operand0AndOperand3:
0xCF1E  0xD0 0x10       BNE 0xCF30 (+16)
0xCF20  0xA5 0x50       LDA 0x50                // LDA ZP.PEEPOP0                    optimizer.asm:562
0xCF22  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      optimizer.asm:563
0xCF24  0x20 0x94 0xCD  JSR 0xCD94              // incXPC();                         optimizer.asm:564
0xCF27  0xA5 0x53       LDA 0x53                // LDA ZP.PEEPOP3                    optimizer.asm:566
0xCF29  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      optimizer.asm:567
0xCF2B  0x20 0x94 0xCD  JSR 0xCD94              // incXPC();                         optimizer.asm:568
0xCF2E  0x80 0x12       BRA 0xCF42 (+18)        // }                                 optimizer.asm:569
0xCF30  0xC9 0x05       CMP # 0x05              // case NewOperands.Operand2AndOperand1:
0xCF32  0xD0 0x0E       BNE 0xCF42 (+14)
0xCF34  0xA5 0x52       LDA 0x52                // LDA ZP.PEEPOP2                    optimizer.asm:572
0xCF36  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      optimizer.asm:573
0xCF38  0x20 0x94 0xCD  JSR 0xCD94              // incXPC();                         optimizer.asm:574
0xCF3B  0xA5 0x51       LDA 0x51                // LDA ZP.PEEPOP1                    optimizer.asm:576
0xCF3D  0x92 0x7E       STA [0x7E]              // STA [ZP.XPC]                      optimizer.asm:577
0xCF3F  0x20 0x94 0xCD  JSR 0xCD94              // incXPC();                         optimizer.asm:578
0xCF42  0x38            SEC                     // SEC    success                    optimizer.asm:626
0xCF43  0x60            RTS                     // break;    Exit after applying optimization

// /source/projects/6502sbc/hopperbasic/optimizer.asm:634
// ####  Optimizer.Peep()  ####                                                 0x0224

0xCF44  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       optimizer.asm:635
0xCF46  0x48            PHA                     // PHA                               optimizer.asm:636
0xCF47  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       optimizer.asm:637
0xCF49  0x48            PHA                     // PHA                               optimizer.asm:638
0xCF4A  0x20 0xCB 0xCD  JSR 0xCDCB              // pushPeepOp();    Compiler.compilerOpCode is the new PEEP0
0xCF4D  0x20 0x16 0xCE  JSR 0xCE16              // tryOptimize();                    optimizer.asm:643
0xCF50  0xB0 0xFB       BCS 0xCF4D (-5)         // if (C)                            optimizer.asm:644
0xCF52  0x68            PLA                     // PLA                               optimizer.asm:651
0xCF53  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       optimizer.asm:652
0xCF55  0x68            PLA                     // PLA                               optimizer.asm:653
0xCF56  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       optimizer.asm:654
0xCF58  0x60            RTS                     // }                                 optimizer.asm:655

// /source/projects/6502sbc/hopperbasic/optimizer.asm:667
// ####  Optimizer.IsSimpleIntegralConstant()  ####                             0x0225

0xCF59  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       optimizer.asm:674
0xCF5B  0x48            PHA                     // PHA                               optimizer.asm:675
0xCF5C  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       optimizer.asm:676
0xCF5E  0x48            PHA                     // PHA                               optimizer.asm:677
0xCF5F  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       optimizer.asm:678
0xCF61  0x48            PHA                     // PHA                               optimizer.asm:679
0xCF62  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       optimizer.asm:680
0xCF64  0x48            PHA                     // PHA                               optimizer.asm:681
0xCF65  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       optimizer.asm:682
0xCF67  0x48            PHA                     // PHA                               optimizer.asm:683
0xCF68  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       optimizer.asm:684
0xCF6A  0x48            PHA                     // PHA                               optimizer.asm:685
0xCF6B  0x20 0xA9 0xA2  JSR 0xA2A9              // Variables.GetType();    Output: ZP.ACCT = packed type
0xCF6E  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       optimizer.asm:691
0xCF70  0x29 0x80       AND # 0x80              // AND #SymbolType.CONSTANT          optimizer.asm:692
0xCF72  0xD0 0x04       BNE 0xCF78 (+4)         // if (Z)                            optimizer.asm:693
0xCF74  0x18            CLC                     // CLC    Not a constant             optimizer.asm:695
0xCF75  0x4C 0x25 0xD0  JMP 0xD025              // break;                            optimizer.asm:696
0xCF78  0x20 0xD9 0xA2  JSR 0xA2D9              // Variables.GetTokens();    Output: ZP.ACC = token stream pointer
0xCF7B  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      optimizer.asm:701
0xCF7D  0x05 0x17       ORA 0x17                // ORA ZP.NEXTH                      optimizer.asm:702
0xCF7F  0xD0 0x04       BNE 0xCF85 (+4)         // if (Z)                            optimizer.asm:703
0xCF81  0x18            CLC                     // CLC    No initialization tokens   optimizer.asm:705
0xCF82  0x4C 0x25 0xD0  JMP 0xD025              // break;                            optimizer.asm:706
0xCF85  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              optimizer.asm:710
0xCF87  0x48            PHA                     // PHA                               optimizer.asm:711
0xCF88  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              optimizer.asm:712
0xCF8A  0x48            PHA                     // PHA                               optimizer.asm:713
0xCF8B  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               optimizer.asm:714
0xCF8D  0x48            PHA                     // PHA                               optimizer.asm:715
0xCF8E  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               optimizer.asm:716
0xCF90  0x48            PHA                     // PHA                               optimizer.asm:717
0xCF91  0xA5 0x29       LDA 0x29                // LDA ZP.TokenBufferContentLengthL  optimizer.asm:718
0xCF93  0x48            PHA                     // PHA                               optimizer.asm:719
0xCF94  0xA5 0x2A       LDA 0x2A                // LDA ZP.TokenBufferContentLengthH  optimizer.asm:720
0xCF96  0x48            PHA                     // PHA                               optimizer.asm:721
0xCF97  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               optimizer.asm:722
0xCF99  0x48            PHA                     // PHA                               optimizer.asm:723
0xCF9A  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      optimizer.asm:728
0xCF9C  0x85 0x38       STA 0x38                // STA ZP.TokenBufferL               optimizer.asm:729
0xCF9E  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      optimizer.asm:730
0xCFA0  0x85 0x39       STA 0x39                // STA ZP.TokenBufferH               optimizer.asm:731
0xCFA2  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL       Start at beginning
0xCFA4  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              optimizer.asm:733
0xCFA6  0xA9 0xFF       LDA # 0xFF              // LDA #0xFF                         optimizer.asm:736
0xCFA8  0x85 0x29       STA 0x29                // STA ZP.TokenBufferContentLengthL  optimizer.asm:737
0xCFAA  0x64 0x2A       STZ 0x2A                // STZ ZP.TokenBufferContentLengthH     255 bytes - way more than needed
0xCFAC  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       optimizer.asm:742
0xCFAF  0xB0 0x03       BCS 0xCFB4 (+3)         // if (NC) { CLC break; }            optimizer.asm:743
0xCFB1  0x18            CLC
0xCFB2  0x80 0x5C       BRA 0xD010 (+92)
0xCFB4  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               optimizer.asm:746
0xCFB6  0xC9 0xDC       CMP # 0xDC              // case Token.EOL:                   optimizer.asm:749
0xCFB8  0xF0 0x04       BEQ 0xCFBE (+4)
0xCFBA  0xC9 0xDB       CMP # 0xDB              // case Token.EOF:                   optimizer.asm:750
0xCFBC  0xD0 0x03       BNE 0xCFC1 (+3)
0xCFBE  0x18            CLC                     // CLC    tokenizer failed?          optimizer.asm:752
0xCFBF  0x80 0x4F       BRA 0xD010 (+79)        // break;                            optimizer.asm:753
0xCFC1  0xC9 0xD7       CMP # 0xD7              // case Token.NUMBER:                optimizer.asm:755
0xCFC3  0xD0 0x12       BNE 0xCFD7 (+18)
0xCFC5  0x20 0x41 0xBE  JSR 0xBE41              // Tokenizer.GetTokenNumber();    Output: ZP.TOP = value, ZP.TOPT = type
0xCFC8  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no      optimizer.asm:761
0xCFCB  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               optimizer.asm:762
0xCFCD  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    optimizer.asm:763
0xCFCF  0xD0 0x03       BNE 0xCFD4 (+3)         // if (Z)                            optimizer.asm:764
0xCFD1  0x38            SEC                     // SEC    Success - simple number constant
0xCFD2  0x80 0x3C       BRA 0xD010 (+60)        // break;                            optimizer.asm:767
0xCFD4  0x18            CLC                     // CLC    Not just a number          optimizer.asm:769
0xCFD5  0x80 0x39       BRA 0xD010 (+57)        // break;                            optimizer.asm:770
0xCFD7  0xC9 0xBC       CMP # 0xBC              // case Token.TRUE:                  optimizer.asm:772
0xCFD9  0xD0 0x19       BNE 0xCFF4 (+25)
0xCFDB  0xA9 0x01       LDA # 1                 // LDA #1                            optimizer.asm:775
0xCFDD  0x85 0x11       STA 0x11                // STA ZP.TOPL                       optimizer.asm:776
0xCFDF  0x64 0x12       STZ 0x12                // STZ ZP.TOPH                       optimizer.asm:777
0xCFE1  0xA9 0x06       LDA # 0x06              // LDA #BASICType.BIT                optimizer.asm:778
0xCFE3  0x85 0x15       STA 0x15                // STA ZP.TOPT                       optimizer.asm:779
0xCFE5  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no      optimizer.asm:782
0xCFE8  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               optimizer.asm:783
0xCFEA  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    optimizer.asm:784
0xCFEC  0xD0 0x03       BNE 0xCFF1 (+3)         // if (Z)                            optimizer.asm:785
0xCFEE  0x38            SEC                     // SEC    Success - simple TRUE      optimizer.asm:787
0xCFEF  0x80 0x1F       BRA 0xD010 (+31)        // break;                            optimizer.asm:788
0xCFF1  0x18            CLC                     // CLC    Not just TRUE              optimizer.asm:790
0xCFF2  0x80 0x1C       BRA 0xD010 (+28)        // break;                            optimizer.asm:791
0xCFF4  0xC9 0xBD       CMP # 0xBD              // case Token.FALSE:                 optimizer.asm:793
0xCFF6  0xD0 0x17       BNE 0xD00F (+23)
0xCFF8  0x64 0x11       STZ 0x11                // STZ ZP.TOPL                       optimizer.asm:796
0xCFFA  0x64 0x12       STZ 0x12                // STZ ZP.TOPH                       optimizer.asm:797
0xCFFC  0xA9 0x06       LDA # 0x06              // LDA #BASICType.BIT                optimizer.asm:798
0xCFFE  0x85 0x15       STA 0x15                // STA ZP.TOPT                       optimizer.asm:799
0xD000  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no      optimizer.asm:802
0xD003  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               optimizer.asm:803
0xD005  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    optimizer.asm:804
0xD007  0xD0 0x03       BNE 0xD00C (+3)         // if (Z)                            optimizer.asm:805
0xD009  0x38            SEC                     // SEC    Success - simple FALSE     optimizer.asm:807
0xD00A  0x80 0x04       BRA 0xD010 (+4)         // break;                            optimizer.asm:808
0xD00C  0x18            CLC                     // CLC    Not just FALSE             optimizer.asm:810
0xD00D  0x80 0x01       BRA 0xD010 (+1)         // break;                            optimizer.asm:811
0xD00F  0x18            CLC                     // CLC                               optimizer.asm:816
0xD010  0x68            PLA                     // PLA STA ZP.CurrentToken           optimizer.asm:823
0xD011  0x85 0x2F       STA 0x2F
0xD013  0x68            PLA                     // PLA STA ZP.TokenBufferContentLengthH
0xD014  0x85 0x2A       STA 0x2A
0xD016  0x68            PLA                     // PLA STA ZP.TokenBufferContentLengthL
0xD017  0x85 0x29       STA 0x29
0xD019  0x68            PLA                     // PLA STA ZP.TokenBufferH           optimizer.asm:826
0xD01A  0x85 0x39       STA 0x39
0xD01C  0x68            PLA                     // PLA STA ZP.TokenBufferL           optimizer.asm:827
0xD01D  0x85 0x38       STA 0x38
0xD01F  0x68            PLA                     // PLA STA ZP.TokenizerPosH          optimizer.asm:828
0xD020  0x85 0x2C       STA 0x2C
0xD022  0x68            PLA                     // PLA STA ZP.TokenizerPosL          optimizer.asm:829
0xD023  0x85 0x2B       STA 0x2B
0xD025  0x90 0x04       BCC 0xD02B (+4)         // if (C)                            optimizer.asm:835
0xD027  0x68            PLA                     // PLA PLA                           optimizer.asm:837
0xD028  0x68            PLA
0xD029  0x80 0x06       BRA 0xD031 (+6)         // }                                 optimizer.asm:838
0xD02B  0x68            PLA                     // PLA STA ZP.TOPH                   optimizer.asm:842
0xD02C  0x85 0x12       STA 0x12
0xD02E  0x68            PLA                     // PLA STA ZP.TOPL                   optimizer.asm:843
0xD02F  0x85 0x11       STA 0x11
0xD031  0x68            PLA                     // PLA                               optimizer.asm:845
0xD032  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       optimizer.asm:846
0xD034  0x68            PLA                     // PLA                               optimizer.asm:847
0xD035  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       optimizer.asm:848
0xD037  0x68            PLA                     // PLA                               optimizer.asm:849
0xD038  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       optimizer.asm:850
0xD03A  0x68            PLA                     // PLA                               optimizer.asm:851
0xD03B  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       optimizer.asm:852
0xD03D  0x60            RTS                     // }                                 optimizer.asm:859

// /source/projects/6502sbc/hopperbasic/compiler.asm:44
// ####  Compiler.moveSavedNodeAddrToIDX()  ####                                0x0226

0xD03E  0xAD 0x89 0x0B  LDA 0x0B89              // LDA Compiler.compilerSavedNodeAddrL
0xD041  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       compiler.asm:46
0xD043  0xAD 0x8A 0x0B  LDA 0x0B8A              // LDA Compiler.compilerSavedNodeAddrH
0xD046  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       compiler.asm:48
0xD048  0x60            RTS                     // }                                 compiler.asm:49

// /source/projects/6502sbc/hopperbasic/compiler.asm:57
// ####  Compiler.InitOpCodeBuffer()  ####                                      0x0227

0xD049  0x64 0x32       STZ 0x32                // STZ ZP.OpCodeBufferContentLengthL compiler.asm:63
0xD04B  0x64 0x33       STZ 0x33                // STZ ZP.OpCodeBufferContentLengthH compiler.asm:64
0xD04D  0xA5 0x3A       LDA 0x3A                // LDA ZP.OpCodeBufferL              compiler.asm:67
0xD04F  0x85 0x7E       STA 0x7E                // STA ZP.XPCL                       compiler.asm:68
0xD051  0xA5 0x3B       LDA 0x3B                // LDA ZP.OpCodeBufferH              compiler.asm:69
0xD053  0x85 0x7F       STA 0x7F                // STA ZP.XPCH                       compiler.asm:70
0xD055  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              compiler.asm:73
0xD057  0x85 0x34       STA 0x34                // STA ZP.CompilerTokenPosL          compiler.asm:74
0xD059  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              compiler.asm:75
0xD05B  0x85 0x35       STA 0x35                // STA ZP.CompilerTokenPosH          compiler.asm:76
0xD05D  0x64 0x36       STZ 0x36                // STZ ZP.CompilerFlags              compiler.asm:79
0xD05F  0x9C 0x89 0x0B  STZ 0x0B89              // STZ Compiler.compilerSavedNodeAddrL
0xD062  0x9C 0x8A 0x0B  STZ 0x0B8A              // STZ Compiler.compilerSavedNodeAddrH
0xD065  0xA9 0x00       LDA # 0                 // LDA # OpCode.INVALID              compiler.asm:93
0xD067  0x8D 0x86 0x0B  STA 0x0B86              // STA compilerLastOpCode            compiler.asm:94
0xD06A  0x20 0x5E 0xCD  JSR 0xCD5E              // Optimizer.ClearPeeps();    Initialize
0xD06D  0x38            SEC                     // SEC    Success                    compiler.asm:98
0xD06E  0x60            RTS                     // }                                 compiler.asm:103

// /source/projects/6502sbc/hopperbasic/compiler.asm:107
// ####  Compiler.SetLiteralBase()  ####                                        0x0228

0xD06F  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               compiler.asm:112
0xD071  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       compiler.asm:113
0xD073  0x85 0x80       STA 0x80                // STA ZP.XIDL                       compiler.asm:114
0xD075  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               compiler.asm:115
0xD077  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       compiler.asm:116
0xD079  0x85 0x81       STA 0x81                // STA ZP.XIDH                       compiler.asm:117
0xD07B  0x60            RTS                     // }                                 compiler.asm:122

// /source/projects/6502sbc/hopperbasic/compiler.asm:130
// ####  Compiler.checkLastOpCodeIsReturn()  ####                               0x0229

0xD07C  0xAD 0x86 0x0B  LDA 0x0B86              // LDA compilerLastOpCode            compiler.asm:136
0xD07F  0xC9 0x49       CMP # 0x49              // CMP #OpCode.RETURN                compiler.asm:139
0xD081  0xD0 0x02       BNE 0xD085 (+2)         // if (Z)                            compiler.asm:140
0xD083  0x38            SEC                     // SEC    Found RETURN               compiler.asm:142
0xD084  0x60            RTS                     // break;                            compiler.asm:143
0xD085  0xC9 0x4A       CMP # 0x4A              // CMP #OpCode.RETURNVAL             compiler.asm:146
0xD087  0xD0 0x02       BNE 0xD08B (+2)         // if (Z)                            compiler.asm:147
0xD089  0x38            SEC                     // SEC    Found RETURNVAL            compiler.asm:149
0xD08A  0x60            RTS                     // break;                            compiler.asm:150
0xD08B  0x18            CLC                     // CLC    Not a RETURN opcode        compiler.asm:153
0xD08C  0x60            RTS                     // break;                            compiler.asm:154

// /source/projects/6502sbc/hopperbasic/compiler.asm:168
// ####  Compiler.CheckBufferSpace()  ####                                      0x022A

0xD08D  0x18            CLC                     // CLC                               compiler.asm:175
0xD08E  0x65 0x32       ADC 0x32                // ADC ZP.OpCodeBufferContentLengthL compiler.asm:176
0xD090  0x85 0x32       STA 0x32                // STA ZP.OpCodeBufferContentLengthL compiler.asm:177
0xD092  0xA5 0x33       LDA 0x33                // LDA ZP.OpCodeBufferContentLengthH compiler.asm:178
0xD094  0x69 0x00       ADC # 0                 // ADC #0                            compiler.asm:179
0xD096  0x85 0x33       STA 0x33                // STA ZP.OpCodeBufferContentLengthH compiler.asm:180
0xD098  0xA5 0x33       LDA 0x33                // LDA ZP.OpCodeBufferContentLengthH compiler.asm:183
0xD09A  0xC9 0x02       CMP # 0x02              // CMP #0x02                         compiler.asm:184
0xD09C  0x90 0x03       BCC 0xD0A1 (+3)         // if (C)    >= 0x0200, overflow     compiler.asm:185
0xD09E  0x4C 0xA2 0x8B  JMP 0x8BA2              // Error.FunctionTooBig(); BIT ZP.EmulatorPCL
0xD0A1  0x38            SEC                     // SEC    Success - space available  compiler.asm:191
0xD0A2  0x60            RTS                     // break;                            compiler.asm:192

// /source/projects/6502sbc/hopperbasic/compiler.asm:234
// ####  Compiler.CompileFoldedExpressionTree()  ####                           0x022C

0xD0A3  0x87 0x36       SMB0 0x36               // SMB0 ZP.CompilerFlags    constant expression = TRUE
0xD0A5  0xA5 0x03       LDA 0x03                // LDA ZP.SP                         compiler.asm:240
0xD0A7  0x48            PHA                     // PHA                               compiler.asm:241
0xD0A8  0xA5 0x32       LDA 0x32                // LDA ZP.OpCodeBufferContentLengthL compiler.asm:246
0xD0AA  0x48            PHA                     // PHA                               compiler.asm:247
0xD0AB  0xA5 0x33       LDA 0x33                // LDA ZP.OpCodeBufferContentLengthH compiler.asm:248
0xD0AD  0x48            PHA                     // PHA                               compiler.asm:249
0xD0AE  0xA5 0x7E       LDA 0x7E                // LDA ZP.XPCL                       compiler.asm:250
0xD0B0  0x48            PHA                     // PHA                               compiler.asm:251
0xD0B1  0xA5 0x7F       LDA 0x7F                // LDA ZP.XPCH                       compiler.asm:252
0xD0B3  0x48            PHA                     // PHA                               compiler.asm:253
0xD0B4  0x20 0xDB 0xD0  JSR 0xD0DB              // compileExpressionTree();          compiler.asm:255
0xD0B7  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:256
0xD0BA  0x90 0x17       BCC 0xD0D3 (+23)        // if (C)                            compiler.asm:257
0xD0BC  0x0F 0x36 0x14  BBR0 0x36, 0xD0D3 (+20) // if (BBS0, ZP.CompilerFlags)    constant expression:  was constant expression, the folded value is on VM stack
0xD0BF  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();    Get the constant value into ZP.TOP/TOPT
0xD0C2  0x68            PLA                     // PLA                               compiler.asm:264
0xD0C3  0x85 0x7F       STA 0x7F                // STA ZP.XPCH                       compiler.asm:265
0xD0C5  0x68            PLA                     // PLA                               compiler.asm:266
0xD0C6  0x85 0x7E       STA 0x7E                // STA ZP.XPCL                       compiler.asm:267
0xD0C8  0x68            PLA                     // PLA                               compiler.asm:268
0xD0C9  0x85 0x33       STA 0x33                // STA ZP.OpCodeBufferContentLengthH compiler.asm:269
0xD0CB  0x68            PLA                     // PLA                               compiler.asm:270
0xD0CC  0x85 0x32       STA 0x32                // STA ZP.OpCodeBufferContentLengthL compiler.asm:271
0xD0CE  0x20 0xEA 0xC4  JSR 0xC4EA              // Emit.OptimizedConstant();         compiler.asm:274
0xD0D1  0x80 0x04       BRA 0xD0D7 (+4)         // break;                            compiler.asm:276
0xD0D3  0x68            PLA                     // PLA PLA PLA PLA                   compiler.asm:281
0xD0D4  0x68            PLA
0xD0D5  0x68            PLA
0xD0D6  0x68            PLA
0xD0D7  0x68            PLA                     // PLA                               compiler.asm:284
0xD0D8  0x85 0x03       STA 0x03                // STA ZP.SP                         compiler.asm:285
0xD0DA  0x60            RTS                     // }                                 compiler.asm:290

// /source/projects/6502sbc/hopperbasic/compiler.asm:299
// ####  Compiler.compileExpressionTree()  ####                                 0x022D

0xD0DB  0x20 0x2A 0xD1  JSR 0xD12A              // compileLogicalAnd();              compiler.asm:307
0xD0DE  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:308
0xD0E1  0x90 0x1F       BCC 0xD102 (+31)        // if (NC) { break; }                compiler.asm:309
0xD0E3  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:313
0xD0E5  0xC9 0xB9       CMP # 0xB9              // CMP #Token.OR                     compiler.asm:314
0xD0E7  0xD0 0x19       BNE 0xD102 (+25)        // if (NZ) { break; }                compiler.asm:315
0xD0E9  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: BIT: not an integral constant expression
0xD0EB  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:320
0xD0EE  0x90 0x12       BCC 0xD102 (+18)        // if (NC) { break; }                compiler.asm:321
0xD0F0  0x20 0x2A 0xD1  JSR 0xD12A              // compileLogicalAnd();              compiler.asm:324
0xD0F3  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:325
0xD0F6  0x90 0x0A       BCC 0xD102 (+10)        // if (NC) { break; }                compiler.asm:326
0xD0F8  0xA9 0x0B       LDA # 0x0B              // LDA # OpCode.LOGICAL_OR           compiler.asm:329
0xD0FA  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:330
0xD0FD  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:331
0xD100  0xB0 0xE1       BCS 0xD0E3 (-31)        // if (NC) { break; }                compiler.asm:332
0xD102  0x60            RTS                     // }                                 compiler.asm:340

// /source/projects/6502sbc/hopperbasic/compiler.asm:348
// ####  Compiler.compileLogicalNot()  ####                                     0x022E

0xD103  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:355
0xD105  0xC9 0xBA       CMP # 0xBA              // CMP #Token.NOT                    compiler.asm:356
0xD107  0xD0 0x1A       BNE 0xD123 (+26)        // if (Z)                            compiler.asm:357
0xD109  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: BIT: not an integral constant expression
0xD10B  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:362
0xD10E  0x90 0x19       BCC 0xD129 (+25)        // if (NC) { break; }                compiler.asm:363
0xD110  0x20 0x03 0xD1  JSR 0xD103              // compileLogicalNot();              compiler.asm:366
0xD113  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:367
0xD116  0x90 0x11       BCC 0xD129 (+17)        // if (NC) { break; }                compiler.asm:368
0xD118  0xA9 0x0C       LDA # 0x0C              // LDA # OpCode.LOGICAL_NOT          compiler.asm:371
0xD11A  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:372
0xD11D  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:373
0xD120  0x90 0x07       BCC 0xD129 (+7)         // if (NC) { break; }                compiler.asm:374
0xD122  0x60            RTS
0xD123  0x20 0x52 0xD1  JSR 0xD152              // compileComparison();              compiler.asm:379
0xD126  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:380
0xD129  0x60            RTS                     // }                                 compiler.asm:389

// /source/projects/6502sbc/hopperbasic/compiler.asm:397
// ####  Compiler.compileLogicalAnd()  ####                                     0x022F

0xD12A  0x20 0x03 0xD1  JSR 0xD103              // compileLogicalNot();              compiler.asm:406
0xD12D  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:407
0xD130  0x90 0x1F       BCC 0xD151 (+31)        // if (NC) { break; }                compiler.asm:408
0xD132  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:412
0xD134  0xC9 0xB8       CMP # 0xB8              // CMP #Token.AND                    compiler.asm:413
0xD136  0xD0 0x19       BNE 0xD151 (+25)        // if (NZ) { break; }                compiler.asm:414
0xD138  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: BIT: not an integral constant expression
0xD13A  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:419
0xD13D  0x90 0x12       BCC 0xD151 (+18)        // if (NC) { break; }                compiler.asm:420
0xD13F  0x20 0x03 0xD1  JSR 0xD103              // compileLogicalNot();              compiler.asm:423
0xD142  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:424
0xD145  0x90 0x0A       BCC 0xD151 (+10)        // if (NC) { break; }                compiler.asm:425
0xD147  0xA9 0x0A       LDA # 0x0A              // LDA # OpCode.LOGICAL_AND          compiler.asm:428
0xD149  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:429
0xD14C  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:430
0xD14F  0xB0 0xE1       BCS 0xD132 (-31)        // if (NC) { break; }                compiler.asm:431
0xD151  0x60            RTS                     // }                                 compiler.asm:440

// /source/projects/6502sbc/hopperbasic/compiler.asm:448
// ####  Compiler.compileComparison()  ####                                     0x0230

0xD152  0x20 0x13 0xD2  JSR 0xD213              // compileAdditive();                compiler.asm:457
0xD155  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:458
0xD158  0xB0 0x01       BCS 0xD15B (+1)         // if (NC) { break; }                compiler.asm:459
0xD15A  0x60            RTS
0xD15B  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:463
0xD15D  0xC9 0xE1       CMP # 0xE1              // case Token.EQUALS:                compiler.asm:466
0xD15F  0xF0 0x15       BEQ 0xD176 (+21)
0xD161  0xC9 0xE6       CMP # 0xE6              // case Token.NOTEQUAL:              compiler.asm:467
0xD163  0xF0 0x11       BEQ 0xD176 (+17)
0xD165  0xC9 0xE7       CMP # 0xE7              // case Token.LT:                    compiler.asm:468
0xD167  0xF0 0x0D       BEQ 0xD176 (+13)
0xD169  0xC9 0xE8       CMP # 0xE8              // case Token.GT:                    compiler.asm:469
0xD16B  0xF0 0x09       BEQ 0xD176 (+9)
0xD16D  0xC9 0xE9       CMP # 0xE9              // case Token.LE:                    compiler.asm:470
0xD16F  0xF0 0x05       BEQ 0xD176 (+5)
0xD171  0xC9 0xEA       CMP # 0xEA              // case Token.GE:                    compiler.asm:471
0xD173  0xF0 0x01       BEQ 0xD176 (+1)
0xD175  0x60            RTS
0xD176  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: BIT (comparison): not an integral constant expression
0xD178  0x48            PHA                     // PHA    Save operator on stack     compiler.asm:475
0xD179  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:478
0xD17C  0xB0 0x02       BCS 0xD180 (+2)         // if (NC)                           compiler.asm:479
0xD17E  0x68            PLA                     // PLA    Clean up stack             compiler.asm:481
0xD17F  0x60            RTS                     // break;                            compiler.asm:482
0xD180  0x20 0x13 0xD2  JSR 0xD213              // compileAdditive();                compiler.asm:486
0xD183  0x68            PLA                     // PLA    Retrieve operator          compiler.asm:487
0xD184  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:488
0xD187  0x90 0x36       BCC 0xD1BF (+54)        // if (NC)                           compiler.asm:489
0xD189  0xC9 0xE1       CMP # 0xE1              // case Token.EQUALS:   { LDA # OpCode.EQ }
0xD18B  0xD0 0x04       BNE 0xD191 (+4)
0xD18D  0xA9 0x0D       LDA # 0x0D
0xD18F  0x80 0x26       BRA 0xD1B7 (+38)
0xD191  0xC9 0xE6       CMP # 0xE6              // case Token.NOTEQUAL: { LDA # OpCode.NE }
0xD193  0xD0 0x04       BNE 0xD199 (+4)
0xD195  0xA9 0x0E       LDA # 0x0E
0xD197  0x80 0x1E       BRA 0xD1B7 (+30)
0xD199  0xC9 0xE7       CMP # 0xE7              // case Token.LT:       { LDA # OpCode.LT }
0xD19B  0xD0 0x04       BNE 0xD1A1 (+4)
0xD19D  0xA9 0x0F       LDA # 0x0F
0xD19F  0x80 0x16       BRA 0xD1B7 (+22)
0xD1A1  0xC9 0xE8       CMP # 0xE8              // case Token.GT:       { LDA # OpCode.GT }
0xD1A3  0xD0 0x04       BNE 0xD1A9 (+4)
0xD1A5  0xA9 0x10       LDA # 0x10
0xD1A7  0x80 0x0E       BRA 0xD1B7 (+14)
0xD1A9  0xC9 0xE9       CMP # 0xE9              // case Token.LE:       { LDA # OpCode.LE }
0xD1AB  0xD0 0x04       BNE 0xD1B1 (+4)
0xD1AD  0xA9 0x11       LDA # 0x11
0xD1AF  0x80 0x06       BRA 0xD1B7 (+6)
0xD1B1  0xC9 0xEA       CMP # 0xEA              // case Token.GE:       { LDA # OpCode.GE }
0xD1B3  0xD0 0x02       BNE 0xD1B7 (+2)
0xD1B5  0xA9 0x12       LDA # 0x12
0xD1B7  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:504
0xD1BA  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:505
0xD1BD  0xB0 0x9C       BCS 0xD15B (-100)       // continue;    Check for more comparisons
0xD1BF  0x60            RTS                     // break;                            compiler.asm:518

// /source/projects/6502sbc/hopperbasic/compiler.asm:533
// ####  Compiler.compileBitwiseAnd()  ####                                     0x0231

0xD1C0  0x20 0x72 0xD2  JSR 0xD272              // compileMultiplicative();          compiler.asm:541
0xD1C3  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:542
0xD1C6  0x90 0x22       BCC 0xD1EA (+34)        // if (NC) { break; }                compiler.asm:543
0xD1C8  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:547
0xD1CA  0xC9 0xED       CMP # 0xED              // CMP #Token.BITWISE_AND            compiler.asm:548
0xD1CC  0xD0 0x1C       BNE 0xD1EA (+28)        // if (NZ) { break; }                compiler.asm:549
0xD1CE  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: TODO: expand constant folding
0xD1D0  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:554
0xD1D3  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:555
0xD1D6  0x90 0x12       BCC 0xD1EA (+18)        // if (NC) { break; }                compiler.asm:556
0xD1D8  0x20 0x72 0xD2  JSR 0xD272              // compileMultiplicative();          compiler.asm:559
0xD1DB  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:560
0xD1DE  0x90 0x0A       BCC 0xD1EA (+10)        // if (NC) { break; }                compiler.asm:561
0xD1E0  0xA9 0x07       LDA # 0x07              // LDA # OpCode.BITWISE_AND          compiler.asm:564
0xD1E2  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:565
0xD1E5  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:566
0xD1E8  0xB0 0xDE       BCS 0xD1C8 (-34)        // if (NC) { break; }                compiler.asm:567
0xD1EA  0x60            RTS                     // }                                 compiler.asm:576

// /source/projects/6502sbc/hopperbasic/compiler.asm:584
// ####  Compiler.compileBitwiseOr()  ####                                      0x0232

0xD1EB  0x20 0xC0 0xD1  JSR 0xD1C0              // compileBitwiseAnd();              compiler.asm:593
0xD1EE  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:594
0xD1F1  0x90 0x1F       BCC 0xD212 (+31)        // if (NC) { break; }                compiler.asm:595
0xD1F3  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:599
0xD1F5  0xC9 0xEE       CMP # 0xEE              // CMP #Token.BITWISE_OR             compiler.asm:600
0xD1F7  0xD0 0x19       BNE 0xD212 (+25)        // if (NZ) { break; }                compiler.asm:601
0xD1F9  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: TODO: expand constant folding
0xD1FB  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:606
0xD1FE  0x90 0x12       BCC 0xD212 (+18)        // if (NC) { break; }                compiler.asm:607
0xD200  0x20 0xC0 0xD1  JSR 0xD1C0              // compileBitwiseAnd();              compiler.asm:610
0xD203  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:611
0xD206  0x90 0x0A       BCC 0xD212 (+10)        // if (NC) { break; }                compiler.asm:612
0xD208  0xA9 0x08       LDA # 0x08              // LDA # OpCode.BITWISE_OR           compiler.asm:615
0xD20A  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:616
0xD20D  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:617
0xD210  0xB0 0xE1       BCS 0xD1F3 (-31)        // if (NC) { break; }                compiler.asm:618
0xD212  0x60            RTS                     // }                                 compiler.asm:627

// /source/projects/6502sbc/hopperbasic/compiler.asm:635
// ####  Compiler.compileAdditive()  ####                                       0x0233

0xD213  0x20 0xEB 0xD1  JSR 0xD1EB              // compileBitwiseOr();               compiler.asm:643
0xD216  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:644
0xD219  0xB0 0x01       BCS 0xD21C (+1)         // if (NC) { break; }                compiler.asm:645
0xD21B  0x60            RTS
0xD21C  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:649
0xD21E  0xC9 0xE2       CMP # 0xE2              // CMP #Token.PLUS                   compiler.asm:650
0xD220  0xD0 0x28       BNE 0xD24A (+40)        // if (Z)                            compiler.asm:651
0xD222  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:654
0xD225  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:655
0xD228  0xB0 0x01       BCS 0xD22B (+1)         // if (NC) { break; }                compiler.asm:656
0xD22A  0x60            RTS
0xD22B  0x20 0xEB 0xD1  JSR 0xD1EB              // compileBitwiseOr();               compiler.asm:659
0xD22E  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:660
0xD231  0x90 0x3E       BCC 0xD271 (+62)        // if (NC) { break; }                compiler.asm:661
0xD233  0xA9 0x01       LDA # 1                 // LDA # OpCode.ADD                  compiler.asm:665
0xD235  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:666
0xD238  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:667
0xD23B  0x90 0x34       BCC 0xD271 (+52)        // if (NC) { break; }                compiler.asm:668
0xD23D  0x0F 0x36 0xDC  BBR0 0x36, 0xD21C (-36) // if (BBS0, ZP.CompilerFlags)    constant expression:  ADD: both sides are still constant
0xD240  0x20 0x77 0xBF  JSR 0xBF77              // Instructions.Addition();    Pop Pop + Push
0xD243  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:672
0xD246  0x90 0x29       BCC 0xD271 (+41)        // if (NC) { break; }                compiler.asm:673
0xD248  0x80 0xD2       BRA 0xD21C (-46)
0xD24A  0xC9 0xE3       CMP # 0xE3              // CMP #Token.MINUS                  compiler.asm:679
0xD24C  0xF0 0x01       BEQ 0xD24F (+1)         // if (Z)                            compiler.asm:680
0xD24E  0x60            RTS
0xD24F  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:683
0xD252  0x90 0x1D       BCC 0xD271 (+29)        // if (NC) { break; }                compiler.asm:684
0xD254  0x20 0x72 0xD2  JSR 0xD272              // compileMultiplicative();          compiler.asm:687
0xD257  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:688
0xD25A  0x90 0x15       BCC 0xD271 (+21)        // if (NC) { break; }                compiler.asm:690
0xD25C  0xA9 0x02       LDA # 0x02              // LDA # OpCode.SUB                  compiler.asm:693
0xD25E  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:694
0xD261  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:695
0xD264  0x90 0x0B       BCC 0xD271 (+11)        // if (NC) { break; }                compiler.asm:696
0xD266  0x0F 0x36 0xB3  BBR0 0x36, 0xD21C (-77) // if (BBS0, ZP.CompilerFlags)    constant expression:  SUB: both sides are still constant
0xD269  0x20 0xA2 0xBF  JSR 0xBFA2              // Instructions.Subtraction();    Pop Pop + Push
0xD26C  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:700
0xD26F  0xB0 0xAB       BCS 0xD21C (-85)        // if (NC) { break; }                compiler.asm:701
0xD271  0x60            RTS                     // break;                            compiler.asm:709

// /source/projects/6502sbc/hopperbasic/compiler.asm:728
// ####  Compiler.compileMultiplicative()  ####                                 0x0235

0xD272  0x20 0xDC 0xD2  JSR 0xD2DC              // compileExponential();             compiler.asm:737
0xD275  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:738
0xD278  0xB0 0x01       BCS 0xD27B (+1)         // if (NC) { break; }                compiler.asm:739
0xD27A  0x60            RTS
0xD27B  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:743
0xD27D  0xC9 0xEB       CMP # 0xEB              // case Token.MULTIPLY:              compiler.asm:746
0xD27F  0xF0 0x09       BEQ 0xD28A (+9)
0xD281  0xC9 0xEC       CMP # 0xEC              // case Token.DIVIDE:                compiler.asm:747
0xD283  0xF0 0x05       BEQ 0xD28A (+5)
0xD285  0xC9 0xBB       CMP # 0xBB              // case Token.MOD:                   compiler.asm:748
0xD287  0xF0 0x01       BEQ 0xD28A (+1)
0xD289  0x60            RTS
0xD28A  0x48            PHA                     // PHA    Save operator on stack     compiler.asm:750
0xD28B  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:753
0xD28E  0xB0 0x02       BCS 0xD292 (+2)         // if (NC)                           compiler.asm:754
0xD290  0x68            PLA                     // PLA    Clean up stack             compiler.asm:756
0xD291  0x60            RTS                     // break;                            compiler.asm:757
0xD292  0x20 0xDC 0xD2  JSR 0xD2DC              // compileExponential();             compiler.asm:761
0xD295  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:762
0xD298  0x68            PLA                     // PLA    Retrieve operator          compiler.asm:763
0xD299  0xB0 0x01       BCS 0xD29C (+1)         // if (NC)                           compiler.asm:764
0xD29B  0x60            RTS                     // break;                            compiler.asm:766
0xD29C  0xC9 0xEB       CMP # 0xEB              // case Token.MULTIPLY: { LDA # OpCode.MUL }
0xD29E  0xD0 0x04       BNE 0xD2A4 (+4)
0xD2A0  0xA9 0x03       LDA # 0x03
0xD2A2  0x80 0x0E       BRA 0xD2B2 (+14)
0xD2A4  0xC9 0xEC       CMP # 0xEC              // case Token.DIVIDE:   { LDA # OpCode.DIV }
0xD2A6  0xD0 0x04       BNE 0xD2AC (+4)
0xD2A8  0xA9 0x04       LDA # 0x04
0xD2AA  0x80 0x06       BRA 0xD2B2 (+6)
0xD2AC  0xC9 0xBB       CMP # 0xBB              // case Token.MOD:      { LDA # OpCode.MOD }
0xD2AE  0xD0 0x02       BNE 0xD2B2 (+2)
0xD2B0  0xA9 0x05       LDA # 0x05
0xD2B2  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:776
0xD2B5  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:777
0xD2B8  0x90 0x21       BCC 0xD2DB (+33)        // if (NC) { break; }                compiler.asm:779
0xD2BA  0x0F 0x36 0xBE  BBR0 0x36, 0xD27B (-66) // if (BBS0, ZP.CompilerFlags)    constant expression:  ADD: both sides are still constant
0xD2BD  0xC9 0x03       CMP # 0x03              // case OpCode.MUL:                  compiler.asm:784
0xD2BF  0xD0 0x05       BNE 0xD2C6 (+5)
0xD2C1  0x20 0x04 0xC0  JSR 0xC004              // Instructions.Multiply();    Pop Pop + Push
0xD2C4  0x80 0x10       BRA 0xD2D6 (+16)        // }                                 compiler.asm:787
0xD2C6  0xC9 0x04       CMP # 0x04              // case OpCode.DIV:                  compiler.asm:788
0xD2C8  0xD0 0x05       BNE 0xD2CF (+5)
0xD2CA  0x20 0x16 0xC0  JSR 0xC016              // Instructions.Divide();    Pop Pop + Push
0xD2CD  0x80 0x07       BRA 0xD2D6 (+7)         // }                                 compiler.asm:791
0xD2CF  0xC9 0x05       CMP # 0x05              // case OpCode.MOD:                  compiler.asm:792
0xD2D1  0xD0 0x03       BNE 0xD2D6 (+3)
0xD2D3  0x20 0x28 0xC0  JSR 0xC028              // Instructions.Modulo();    Pop Pop + Push
0xD2D6  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:797
0xD2D9  0xB0 0xA0       BCS 0xD27B (-96)        // if (NC) { break; }                compiler.asm:798
0xD2DB  0x60            RTS                     // break;                            compiler.asm:811

// /source/projects/6502sbc/hopperbasic/compiler.asm:825
// ####  Compiler.compileUnary()  ####                                          0x0236

0xD2DC  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:833
0xD2DE  0xC9 0xE3       CMP # 0xE3              // case Token.MINUS:                 compiler.asm:836
0xD2E0  0xD0 0x16       BNE 0xD2F8 (+22)
0xD2E2  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: TODO: expand constant folding
0xD2E4  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:841
0xD2E7  0xB0 0x01       BCS 0xD2EA (+1)         // if (NC) { break; }                compiler.asm:842
0xD2E9  0x60            RTS
0xD2EA  0x20 0x4E 0xD5  JSR 0xD54E              // compilePrimary();                 compiler.asm:845
0xD2ED  0xB0 0x01       BCS 0xD2F0 (+1)         // if (NC) { break; }                compiler.asm:846
0xD2EF  0x60            RTS
0xD2F0  0xA9 0x06       LDA # 0x06              // LDA # OpCode.NEG                  compiler.asm:849
0xD2F2  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:850
0xD2F5  0x4C 0x59 0x8C  JMP 0x8C59              // CheckError();                     compiler.asm:851
0xD2F8  0xC9 0xEF       CMP # 0xEF              // case Token.BITWISE_NOT:           compiler.asm:854
0xD2FA  0xD0 0x18       BNE 0xD314 (+24)
0xD2FC  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: TODO: expand constant folding
0xD2FE  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:859
0xD301  0xB0 0x01       BCS 0xD304 (+1)         // if (NC) { break; }                compiler.asm:860
0xD303  0x60            RTS
0xD304  0x20 0x4E 0xD5  JSR 0xD54E              // compilePrimary();                 compiler.asm:863
0xD307  0x90 0x3B       BCC 0xD344 (+59)        // if (NC) { break; }                compiler.asm:864
0xD309  0xA9 0x09       LDA # 0x09              // LDA # OpCode.BITWISE_NOT          compiler.asm:867
0xD30B  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:868
0xD30E  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:869
0xD311  0x90 0x31       BCC 0xD344 (+49)        // if (NC) { break; }                compiler.asm:870
0xD313  0x60            RTS
0xD314  0x20 0x4E 0xD5  JSR 0xD54E              // compilePrimary();                 compiler.asm:875
0xD317  0x90 0x2B       BCC 0xD344 (+43)        // if (NC) { break; }                compiler.asm:876
0xD319  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:881
0xD31B  0xC9 0xF0       CMP # 0xF0              // CMP #Token.LBRACKET               compiler.asm:882
0xD31D  0xD0 0x25       BNE 0xD344 (+37)        // if (NZ) { break; }     No indexing
0xD31F  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: LBRACKET not a constant expression
0xD321  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:889
0xD324  0x90 0x1E       BCC 0xD344 (+30)        // if (NC) { break; }                compiler.asm:890
0xD326  0x20 0xDB 0xD0  JSR 0xD0DB              // compileExpressionTree();     Full expression for the index
0xD329  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:894
0xD32C  0x90 0x16       BCC 0xD344 (+22)        // if (NC) { break; }                compiler.asm:895
0xD32E  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:898
0xD330  0xC9 0xF1       CMP # 0xF1              // CMP #Token.RBRACKET               compiler.asm:899
0xD332  0xF0 0x03       BEQ 0xD337 (+3)         // if (NZ)                           compiler.asm:900
0xD334  0x4C 0xCF 0x8B  JMP 0x8BCF              // Error.ExpectedRightBracket(); BIT ZP.EmulatorPCL
0xD337  0xA9 0x1C       LDA # 0x1C              // LDA #OpCode.GETITEM               compiler.asm:907
0xD339  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:908
0xD33C  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:909
0xD33F  0x90 0x03       BCC 0xD344 (+3)         // if (NC) { break; }                compiler.asm:910
0xD341  0x4C 0xC3 0xBD  JMP 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:913
0xD344  0x60            RTS                     // }                                 compiler.asm:924

// /source/projects/6502sbc/hopperbasic/compiler.asm:933
// ####  Compiler.compileVariableOrArgument()  ####                             0x0237

0xD345  0xDA            PHX                     // PHX                               compiler.asm:934
0xD346  0x5A            PHY                     // PHY                               compiler.asm:935
0xD347  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();     Result in ZP.TOP
0xD34A  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:945
0xD34D  0xB0 0x03       BCS 0xD352 (+3)         // if (NC) { break; }                compiler.asm:946
0xD34F  0x4C 0x55 0xD4  JMP 0xD455
0xD352  0x20 0xD5 0xDC  JSR 0xDCD5              // InFunction();        Are we in a function?
0xD355  0x90 0x1B       BCC 0xD372 (+27)        // if (C)                            compiler.asm:950
0xD357  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xD35A  0x20 0x11 0xA5  JSR 0xA511              // Locals.Find();     Input: ZP.IDX = function, ZP.TOP = name
0xD35D  0x90 0x13       BCC 0xD372 (+19)        // if (C)     Found as argument or local
0xD35F  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       compiler.asm:961
0xD361  0x20 0x57 0xC6  JSR 0xC657              // Emit.PushLocal();     A contains signed BP offset
0xD364  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:965
0xD367  0xB0 0x03       BCS 0xD36C (+3)         // if (NC) { break; }                compiler.asm:966
0xD369  0x4C 0x55 0xD4  JMP 0xD455
0xD36C  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: PUSHLOCAL not an integral constant expression
0xD36E  0x38            SEC                     // SEC     Success                   compiler.asm:970
0xD36F  0x4C 0x55 0xD4  JMP 0xD455              // break;     Exit - we handled it   compiler.asm:971
0xD372  0x38            SEC                     // SEC                               compiler.asm:976
0xD373  0xAD 0x89 0x0B  LDA 0x0B89              // LDA (Compiler.compilerSavedNodeAddrL + 0)
0xD376  0x0D 0x8A 0x0B  ORA 0x0B8A              // ORA (Compiler.compilerSavedNodeAddrH + 0)
0xD379  0xD0 0x1E       BNE 0xD399 (+30)        // if (Z)                            compiler.asm:980
0xD37B  0x64 0x47       STZ 0x47                // STZ ZP.SymbolIteratorFilter    variables and constants
0xD37D  0x20 0x8E 0xA1  JSR 0xA18E              // Variables.Find();    ZP.TOP = name, -> ZP.IDX = symbol node address, ZP.IDY is node index
0xD380  0xB0 0x06       BCS 0xD388 (+6)         // if (NC)                           compiler.asm:987
0xD382  0x20 0x8F 0x8B  JSR 0x8B8F              // Error.UndefinedIdentifierTOP(); BIT ZP.EmulatorPCL break;
0xD385  0x4C 0x55 0xD4  JMP 0xD455
0xD388  0x20 0x3D 0xC5  JSR 0xC53D              // Emit.PushGlobal();                compiler.asm:991
0xD38B  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:992
0xD38E  0xB0 0x03       BCS 0xD393 (+3)         // if (NC) { break; }                compiler.asm:993
0xD390  0x4C 0x55 0xD4  JMP 0xD455
0xD393  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: PUSHGLOBAL not an integral constant expression
0xD395  0x38            SEC                     // SEC    Success                    compiler.asm:996
0xD396  0x4C 0x55 0xD4  JMP 0xD455              // }    REPL scope                   compiler.asm:997
0xD399  0x64 0x47       STZ 0x47                // STZ ZP.SymbolIteratorFilter    variables and constants
0xD39B  0x20 0x8E 0xA1  JSR 0xA18E              // Variables.Find();    ZP.TOP = name, -> ZP.IDX = symbol node address, ZP.IDY is node index
0xD39E  0xB0 0x03       BCS 0xD3A3 (+3)         // if (C)                            compiler.asm:1005
0xD3A0  0x4C 0x46 0xD4  JMP 0xD446
0xD3A3  0x20 0x59 0xCF  JSR 0xCF59              // Optimizer.IsSimpleIntegralConstant();
0xD3A6  0xB0 0x03       BCS 0xD3AB (+3)         // if (C)                            compiler.asm:1009
0xD3A8  0x4C 0x39 0xD4  JMP 0xD439
0xD3AB  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       compiler.asm:1012
0xD3AD  0x29 0x3F       AND # 0x3F              // AND #BASICType.MASK               compiler.asm:1013
0xD3AF  0xC9 0x08       CMP # 0x08              // case BASICType.LONG:              compiler.asm:1016
0xD3B1  0xD0 0x24       BNE 0xD3D7 (+36)
0xD3B3  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       compiler.asm:1019
0xD3B5  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compiler.asm:1020
0xD3B8  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       compiler.asm:1021
0xD3BA  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     compiler.asm:1022
0xD3BD  0xA9 0x04       LDA # 0x04              // LDA # BASICType.WORD              compiler.asm:1023
0xD3BF  0x85 0x15       STA 0x15                // STA ZP.TOPT                       compiler.asm:1024
0xD3C1  0x20 0xA3 0xC5  JSR 0xC5A3              // Emit.PushWord();                  compiler.asm:1025
0xD3C4  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       compiler.asm:1027
0xD3C6  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compiler.asm:1028
0xD3C9  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       compiler.asm:1029
0xD3CB  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     compiler.asm:1030
0xD3CE  0xA9 0x08       LDA # 0x08              // LDA # BASICType.LONG              compiler.asm:1031
0xD3D0  0x85 0x15       STA 0x15                // STA ZP.TOPT                       compiler.asm:1032
0xD3D2  0x20 0xA3 0xC5  JSR 0xC5A3              // Emit.PushWord();                  compiler.asm:1033
0xD3D5  0x80 0x56       BRA 0xD42D (+86)        // }                                 compiler.asm:1034
0xD3D7  0xC9 0x06       CMP # 0x06              // case BASICType.BIT:               compiler.asm:1035
0xD3D9  0xD0 0x07       BNE 0xD3E2 (+7)
0xD3DB  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       compiler.asm:1037
0xD3DD  0x20 0x68 0xC5  JSR 0xC568              // Emit.PushBit();                   compiler.asm:1038
0xD3E0  0x80 0x4B       BRA 0xD42D (+75)        // }                                 compiler.asm:1039
0xD3E2  0xC9 0x03       CMP # 0x03              // case BASICType.BYTE:              compiler.asm:1040
0xD3E4  0xD0 0x0A       BNE 0xD3F0 (+10)
0xD3E6  0x20 0x9A 0x97  JSR 0x979A              // Long.ZeroTop3();    needed?       compiler.asm:1042
0xD3E9  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       compiler.asm:1043
0xD3EB  0x20 0x77 0xC5  JSR 0xC577              // Emit.PushByte();                  compiler.asm:1044
0xD3EE  0x80 0x3D       BRA 0xD42D (+61)        // }                                 compiler.asm:1045
0xD3F0  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              compiler.asm:1046
0xD3F2  0xD0 0x07       BNE 0xD3FB (+7)
0xD3F4  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       compiler.asm:1049
0xD3F6  0x20 0x91 0xC5  JSR 0xC591              // Emit.PushChar();                  compiler.asm:1050
0xD3F9  0x80 0x32       BRA 0xD42D (+50)        // }                                 compiler.asm:1051
0xD3FB  0xC9 0x02       CMP # 0x02              // case BASICType.INT:               compiler.asm:1052
0xD3FD  0xD0 0x1D       BNE 0xD41C (+29)
0xD3FF  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       compiler.asm:1055
0xD401  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compiler.asm:1056
0xD404  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       compiler.asm:1057
0xD406  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     compiler.asm:1058
0xD409  0x10 0x08       BPL 0xD413 (+8)         // if (MI)                           compiler.asm:1060
0xD40B  0xA9 0xFF       LDA # 0xFF              // LDA #0xFF                         compiler.asm:1062
0xD40D  0x85 0x13       STA 0x13                // STA ZP.TOP2                       compiler.asm:1063
0xD40F  0x85 0x14       STA 0x14                // STA ZP.TOP3                       compiler.asm:1064
0xD411  0x80 0x04       BRA 0xD417 (+4)         // }                                 compiler.asm:1065
0xD413  0x64 0x13       STZ 0x13                // STZ ZP.TOP2                       compiler.asm:1068
0xD415  0x64 0x14       STZ 0x14                // STZ ZP.TOP3    x2                 compiler.asm:1069
0xD417  0x20 0xA3 0xC5  JSR 0xC5A3              // Emit.PushWord();                  compiler.asm:1071
0xD41A  0x80 0x11       BRA 0xD42D (+17)        // }                                 compiler.asm:1072
0xD41C  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       compiler.asm:1075
0xD41E  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compiler.asm:1076
0xD421  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       compiler.asm:1077
0xD423  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     compiler.asm:1078
0xD426  0x64 0x13       STZ 0x13                // STZ ZP.TOP2                       compiler.asm:1079
0xD428  0x64 0x14       STZ 0x14                // STZ ZP.TOP3    x2                 compiler.asm:1080
0xD42A  0x20 0xA3 0xC5  JSR 0xC5A3              // Emit.PushWord();                  compiler.asm:1081
0xD42D  0x0F 0x36 0x0E  BBR0 0x36, 0xD43E (+14) // if (BBS0, ZP.CompilerFlags)    constant expression:  PUSH constant value
0xD430  0xA9 0x08       LDA # 0x08              // LDA #BASICType.LONG               compiler.asm:1086
0xD432  0x85 0x15       STA 0x15                // STA ZP.TOPT                       compiler.asm:1087
0xD434  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();                   compiler.asm:1088
0xD437  0x80 0x05       BRA 0xD43E (+5)         // }    simple integral constant     compiler.asm:1090
0xD439  0x20 0x3D 0xC5  JSR 0xC53D              // Emit.PushGlobal();                compiler.asm:1094
0xD43C  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: PUSHGLOBAL: not an integral constant expression
0xD43E  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:1097
0xD441  0x90 0x12       BCC 0xD455 (+18)        // if (NC) { break; }                compiler.asm:1098
0xD443  0x38            SEC                     // SEC    Success                    compiler.asm:1099
0xD444  0x80 0x0F       BRA 0xD455 (+15)        // }    found                        compiler.asm:1100
0xD446  0x20 0x99 0xA7  JSR 0xA799              // Functions.Find();     Input: ZP.TOP = name pointer, Output: ZP.IDX = function node
0xD449  0x90 0x05       BCC 0xD450 (+5)         // if (C)                            compiler.asm:1105
0xD44B  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError();    function with no ()
0xD44E  0x80 0x03       BRA 0xD453 (+3)         // }                                 compiler.asm:1108
0xD450  0x20 0x8F 0x8B  JSR 0x8B8F              // Error.UndefinedIdentifierTOP();   compiler.asm:1112
0xD453  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compiler.asm:1115
0xD455  0x7A            PLY                     // PLY                               compiler.asm:1125
0xD456  0xFA            PLX                     // PLX                               compiler.asm:1126
0xD457  0x60            RTS                     // }                                 compiler.asm:1127

// /source/projects/6502sbc/hopperbasic/compiler.asm:1132
// ####  Compiler.compileFunctionCallOrVariable()  ####                         0x0238

0xD458  0xDA            PHX                     // PHX                               compiler.asm:1133
0xD459  0x5A            PHY                     // PHY                               compiler.asm:1134
0xD45A  0xAD 0x91 0x0B  LDA 0x0B91              // LDA compilerCurrentArgCount       compiler.asm:1142
0xD45D  0x48            PHA                     // PHA                               compiler.asm:1143
0xD45E  0xA5 0x30       LDA 0x30                // LDA ZP.TokenLiteralPosL           compiler.asm:1149
0xD460  0x85 0x11       STA 0x11                // STA ZP.TOPL                       compiler.asm:1150
0xD462  0xA5 0x31       LDA 0x31                // LDA ZP.TokenLiteralPosH           compiler.asm:1151
0xD464  0x85 0x12       STA 0x12                // STA ZP.TOPH                       compiler.asm:1152
0xD466  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       compiler.asm:1153
0xD468  0x20 0xA1 0x94  JSR 0x94A1              // Stacks.PushTop();                 compiler.asm:1154
0xD46B  0x20 0x25 0xBE  JSR 0xBE25              // Tokenizer.PeekToken();    peek next -> A
0xD46E  0xC9 0xE4       CMP # 0xE4              // CMP #Token.LPAREN                 compiler.asm:1156
0xD470  0xF0 0x03       BEQ 0xD475 (+3)         // if (Z)                            compiler.asm:1157
0xD472  0x4C 0x21 0xD5  JMP 0xD521
0xD475  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: LPAREN: not an integral constant expression
0xD477  0x9C 0x91 0x0B  STZ 0x0B91              // STZ compilerCurrentArgCount       compiler.asm:1161
0xD47A  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();    consume LPAREN
0xD47D  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:1164
0xD480  0xB0 0x06       BCS 0xD488 (+6)         // if (NC)                           compiler.asm:1165
0xD482  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();    clean up VM stack slot
0xD485  0x4C 0x47 0xD5  JMP 0xD547              // break;                            compiler.asm:1168
0xD488  0x5F 0x02 0x04  BBR5 0x02, 0xD48F (+4)  // if (BBS5, ZP.FLAGS)               compiler.asm:1171
0xD48B  0x57 0x02       RMB5 0x02               // RMB5 ZP.FLAGS    subsequent function calls need RETURN slots
0xD48D  0x80 0x0E       BRA 0xD49D (+14)        // }                                 compiler.asm:1174
0xD48F  0x20 0x99 0xC5  JSR 0xC599              // Emit.PushVoid();                  compiler.asm:1177
0xD492  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:1178
0xD495  0xB0 0x06       BCS 0xD49D (+6)         // if (NC)                           compiler.asm:1179
0xD497  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();    clean up VM stack slot
0xD49A  0x4C 0x47 0xD5  JMP 0xD547              // break;                            compiler.asm:1182
0xD49D  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:1186
0xD4A0  0xB0 0x06       BCS 0xD4A8 (+6)         // if (NC)                           compiler.asm:1187
0xD4A2  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();    clean up VM stack slot
0xD4A5  0x4C 0x47 0xD5  JMP 0xD547              // break;                            compiler.asm:1190
0xD4A8  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:1194
0xD4AA  0xC9 0xE5       CMP # 0xE5              // CMP #Token.RPAREN                 compiler.asm:1195
0xD4AC  0xF0 0x34       BEQ 0xD4E2 (+52)        // if (NZ)                           compiler.asm:1196
0xD4AE  0xEE 0x91 0x0B  INC 0x0B91              // INC compilerCurrentArgCount       compiler.asm:1201
0xD4B1  0x20 0xDB 0xD0  JSR 0xD0DB              // compileExpressionTree();          compiler.asm:1203
0xD4B4  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:1204
0xD4B7  0xB0 0x05       BCS 0xD4BE (+5)         // if (NC)                           compiler.asm:1205
0xD4B9  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();    clean up VM stack slot
0xD4BC  0x80 0x1A       BRA 0xD4D8 (+26)        // break;                            compiler.asm:1208
0xD4BE  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:1212
0xD4C0  0xC9 0xE5       CMP # 0xE5              // CMP #Token.RPAREN                 compiler.asm:1213
0xD4C2  0xF0 0x14       BEQ 0xD4D8 (+20)        // if (Z)                            compiler.asm:1214
0xD4C4  0xC9 0xDF       CMP # 0xDF              // CMP #Token.COMMA                  compiler.asm:1221
0xD4C6  0xF0 0x08       BEQ 0xD4D0 (+8)         // if (NZ)                           compiler.asm:1222
0xD4C8  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xD4CB  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();    clean up VM stack slot
0xD4CE  0x80 0x08       BRA 0xD4D8 (+8)         // break;                            compiler.asm:1226
0xD4D0  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:1230
0xD4D3  0xB0 0xD9       BCS 0xD4AE (-39)        // if (NC)                           compiler.asm:1231
0xD4D5  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();    clean up VM stack slot
0xD4D8  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:1240
0xD4DB  0xB0 0x05       BCS 0xD4E2 (+5)         // if (NC)                           compiler.asm:1241
0xD4DD  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();    clean up VM stack slot
0xD4E0  0x80 0x65       BRA 0xD547 (+101)       // break;                            compiler.asm:1244
0xD4E2  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:1249
0xD4E4  0xC9 0xE5       CMP # 0xE5              // CMP #Token.RPAREN                 compiler.asm:1250
0xD4E6  0xF0 0x08       BEQ 0xD4F0 (+8)         // if (NZ)                           compiler.asm:1251
0xD4E8  0x20 0x38 0x8C  JSR 0x8C38              // Error.ExpectedRightParen(); BIT ZP.EmulatorPCL
0xD4EB  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();    clean up VM stack slot
0xD4EE  0x80 0x57       BRA 0xD547 (+87)        // break;                            compiler.asm:1255
0xD4F0  0x20 0x79 0x94  JSR 0x9479              // Stacks.PopTop();                  compiler.asm:1259
0xD4F3  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       compiler.asm:1261
0xD4F5  0x85 0x31       STA 0x31                // STA ZP.TokenLiteralPosH           compiler.asm:1262
0xD4F7  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       compiler.asm:1263
0xD4F9  0x85 0x30       STA 0x30                // STA ZP.TokenLiteralPosL           compiler.asm:1264
0xD4FB  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();    name -> TOP
0xD4FE  0x20 0x99 0xA7  JSR 0xA799              // Functions.Find();     Input: ZP.TOP = name pointer, Output: ZP.IDX = function node
0xD501  0x90 0x0F       BCC 0xD512 (+15)        // if (C)    Function found          compiler.asm:1268
0xD503  0x20 0xE1 0xA5  JSR 0xA5E1              // Locals.GetArgumentsCount();    Input: ZP.IDX = function node, Output: A = argument count
0xD506  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       compiler.asm:1272
0xD508  0xCD 0x91 0x0B  CMP 0x0B91              // CMP compilerCurrentArgCount       compiler.asm:1273
0xD50B  0xF0 0x05       BEQ 0xD512 (+5)         // if (NZ)                           compiler.asm:1274
0xD50D  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xD510  0x80 0x35       BRA 0xD547 (+53)        // break;                            compiler.asm:1277
0xD512  0x20 0x35 0xC6  JSR 0xC635              // Emit.Call();                      compiler.asm:1282
0xD515  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:1283
0xD518  0x90 0x2D       BCC 0xD547 (+45)        // if (NC) { break; }                compiler.asm:1284
0xD51A  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:1287
0xD51D  0x90 0x28       BCC 0xD547 (+40)        // if (NC) { break; }                compiler.asm:1288
0xD51F  0x80 0x25       BRA 0xD546 (+37)
0xD521  0x20 0x79 0x94  JSR 0x9479              // Stacks.PopTop();                  compiler.asm:1292
0xD524  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       compiler.asm:1294
0xD526  0x85 0x31       STA 0x31                // STA ZP.TokenLiteralPosH           compiler.asm:1295
0xD528  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       compiler.asm:1296
0xD52A  0x85 0x30       STA 0x30                // STA ZP.TokenLiteralPosL           compiler.asm:1297
0xD52C  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();    name -> TOP
0xD52F  0x20 0x99 0xA7  JSR 0xA799              // Functions.Find();     Input: ZP.TOP = name pointer, Output: ZP.IDX = function node
0xD532  0x90 0x05       BCC 0xD539 (+5)         // if (C)                            compiler.asm:1301
0xD534  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xD537  0x80 0x0E       BRA 0xD547 (+14)        // break;                            compiler.asm:1305
0xD539  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:1309
0xD53C  0x90 0x09       BCC 0xD547 (+9)         // if (NC) { break; }                compiler.asm:1310
0xD53E  0x20 0x45 0xD3  JSR 0xD345              // compileVariableOrArgument();      compiler.asm:1313
0xD541  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:1315
0xD544  0x90 0x01       BCC 0xD547 (+1)         // if (NC) { break; }                compiler.asm:1316
0xD546  0x38            SEC                     // SEC    Success                    compiler.asm:1319
0xD547  0x68            PLA                     // PLA                               compiler.asm:1329
0xD548  0x8D 0x91 0x0B  STA 0x0B91              // STA compilerCurrentArgCount       compiler.asm:1330
0xD54B  0x7A            PLY                     // PLY                               compiler.asm:1332
0xD54C  0xFA            PLX                     // PLX                               compiler.asm:1333
0xD54D  0x60            RTS                     // }                                 compiler.asm:1334

// /source/projects/6502sbc/hopperbasic/compiler.asm:1343
// ####  Compiler.compilePrimary()  ####                                        0x0239

0xD54E  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:1349
0xD550  0xC9 0xBC       CMP # 0xBC              // case Token.TRUE:                  compiler.asm:1352
0xD552  0xD0 0x20       BNE 0xD574 (+32)
0xD554  0xA9 0x01       LDA # 1                 // LDA #1                            compiler.asm:1355
0xD556  0x85 0x11       STA 0x11                // STA ZP.TOP0                       compiler.asm:1356
0xD558  0x20 0x68 0xC5  JSR 0xC568              // Emit.PushBit();                   compiler.asm:1357
0xD55B  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1358
0xD55E  0xB0 0x01       BCS 0xD561 (+1)         // if (NC)                           compiler.asm:1359
0xD560  0x60            RTS                     // return;                           compiler.asm:1364
0xD561  0x8F 0x36 0x03  BBS0 0x36, 0xD567 (+3)  // if (BBS0, ZP.CompilerFlags)    constant expression: FALSE
0xD564  0x4C 0xC9 0xBD  JMP 0xBDC9
0xD567  0x20 0x9A 0x97  JSR 0x979A              // Long.ZeroTop3();                  compiler.asm:1370
0xD56A  0xA9 0x06       LDA # 0x06              // LDA #BASICType.BIT                compiler.asm:1371
0xD56C  0x85 0x15       STA 0x15                // STA ZP.TOPT                       compiler.asm:1372
0xD56E  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();                   compiler.asm:1373
0xD571  0x4C 0xC9 0xBD  JMP 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xD574  0xC9 0xBD       CMP # 0xBD              // case Token.FALSE:                 compiler.asm:1384
0xD576  0xD0 0x20       BNE 0xD598 (+32)
0xD578  0xA9 0x00       LDA # 0                 // LDA #0                            compiler.asm:1387
0xD57A  0x85 0x11       STA 0x11                // STA ZP.TOP0                       compiler.asm:1388
0xD57C  0x20 0x68 0xC5  JSR 0xC568              // Emit.PushBit();                   compiler.asm:1389
0xD57F  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1390
0xD582  0xB0 0x01       BCS 0xD585 (+1)         // if (NC)                           compiler.asm:1391
0xD584  0x60            RTS                     // return;                           compiler.asm:1396
0xD585  0x8F 0x36 0x03  BBS0 0x36, 0xD58B (+3)  // if (BBS0, ZP.CompilerFlags)    constant expression: FALSE
0xD588  0x4C 0xC9 0xBD  JMP 0xBDC9
0xD58B  0x20 0x9A 0x97  JSR 0x979A              // Long.ZeroTop3();                  compiler.asm:1402
0xD58E  0xA9 0x06       LDA # 0x06              // LDA # BASICType.BIT               compiler.asm:1403
0xD590  0x85 0x15       STA 0x15                // STA ZP.TOPT                       compiler.asm:1404
0xD592  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();                   compiler.asm:1405
0xD595  0x4C 0xC9 0xBD  JMP 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xD598  0xC9 0xD7       CMP # 0xD7              // case Token.NUMBER:                compiler.asm:1415
0xD59A  0xF0 0x03       BEQ 0xD59F (+3)
0xD59C  0x4C 0x41 0xD6  JMP 0xD641
0xD59F  0x20 0x41 0xBE  JSR 0xBE41              // Tokenizer.GetTokenNumber();    Result in ZP.TOP, type in ZP.TOPT
0xD5A2  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1420
0xD5A5  0xB0 0x01       BCS 0xD5A8 (+1)         // if (NC)                           compiler.asm:1421
0xD5A7  0x60            RTS                     // return;                           compiler.asm:1426
0xD5A8  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       compiler.asm:1431
0xD5AA  0xC9 0x06       CMP # 0x06              // CMP #BASICType.BIT                compiler.asm:1432
0xD5AC  0xD0 0x0B       BNE 0xD5B9 (+11)        // if (Z)                            compiler.asm:1433
0xD5AE  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL    BIT values are single byte
0xD5B0  0x20 0x68 0xC5  JSR 0xC568              // Emit.PushBit();                   compiler.asm:1437
0xD5B3  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1438
0xD5B6  0xB0 0x79       BCS 0xD631 (+121)       // if (NC)                           compiler.asm:1439
0xD5B8  0x60            RTS                     // return;                           compiler.asm:1444
0xD5B9  0x3F 0x15 0x2E  BBR3 0x15, 0xD5EA (+46) // if (BBS3, ZP.TOPT)    Bit 3 - LONG
0xD5BC  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       compiler.asm:1452
0xD5BE  0x8D 0x83 0x0B  STA 0x0B83              // STA compilerOperand1     LSB      compiler.asm:1453
0xD5C1  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       compiler.asm:1454
0xD5C3  0x8D 0x84 0x0B  STA 0x0B84              // STA compilerOperand2     MSB      compiler.asm:1455
0xD5C6  0xA9 0x04       LDA # 0x04              // LDA # BASICType.WORD              compiler.asm:1457
0xD5C8  0x85 0x15       STA 0x15                // STA ZP.TOPT                       compiler.asm:1458
0xD5CA  0x20 0xA3 0xC5  JSR 0xC5A3              // Emit.PushWord();                  compiler.asm:1459
0xD5CD  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1460
0xD5D0  0xB0 0x01       BCS 0xD5D3 (+1)         // if (NC)                           compiler.asm:1461
0xD5D2  0x60            RTS                     // return;                           compiler.asm:1466
0xD5D3  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       compiler.asm:1470
0xD5D5  0x8D 0x83 0x0B  STA 0x0B83              // STA compilerOperand1     LSB      compiler.asm:1471
0xD5D8  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       compiler.asm:1472
0xD5DA  0x8D 0x84 0x0B  STA 0x0B84              // STA compilerOperand2     MSB      compiler.asm:1473
0xD5DD  0xA9 0x08       LDA # 0x08              // LDA # BASICType.LONG              compiler.asm:1475
0xD5DF  0x85 0x15       STA 0x15                // STA ZP.TOPT                       compiler.asm:1476
0xD5E1  0x20 0xA3 0xC5  JSR 0xC5A3              // Emit.PushWord();                  compiler.asm:1477
0xD5E4  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1478
0xD5E7  0xB0 0x48       BCS 0xD631 (+72)        // if (NC)                           compiler.asm:1479
0xD5E9  0x60            RTS                     // return;                           compiler.asm:1484
0xD5EA  0xC9 0x03       CMP # 0x03              // CMP #BASICType.BYTE               compiler.asm:1490
0xD5EC  0xD0 0x0E       BNE 0xD5FC (+14)        // if (Z)                            compiler.asm:1491
0xD5EE  0x20 0x9A 0x97  JSR 0x979A              // Long.ZeroTop3();    needed?       compiler.asm:1493
0xD5F1  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       compiler.asm:1494
0xD5F3  0x20 0x77 0xC5  JSR 0xC577              // Emit.PushByte();                  compiler.asm:1495
0xD5F6  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1496
0xD5F9  0xB0 0x36       BCS 0xD631 (+54)        // if (NC)                           compiler.asm:1497
0xD5FB  0x60            RTS                     // return;                           compiler.asm:1502
0xD5FC  0xC9 0x02       CMP # 0x02              // CMP #BASICType.INT                compiler.asm:1508
0xD5FE  0xD0 0x1A       BNE 0xD61A (+26)        // if (Z)    INT                     compiler.asm:1509
0xD600  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       compiler.asm:1511
0xD602  0x8D 0x83 0x0B  STA 0x0B83              // STA compilerOperand1     LSB      compiler.asm:1512
0xD605  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       compiler.asm:1513
0xD607  0x8D 0x84 0x0B  STA 0x0B84              // STA compilerOperand2     MSB      compiler.asm:1514
0xD60A  0x10 0x08       BPL 0xD614 (+8)         // if (MI)                           compiler.asm:1516
0xD60C  0xA9 0xFF       LDA # 0xFF              // LDA #0xFF                         compiler.asm:1518
0xD60E  0x85 0x13       STA 0x13                // STA ZP.TOP2                       compiler.asm:1519
0xD610  0x85 0x14       STA 0x14                // STA ZP.TOP3                       compiler.asm:1520
0xD612  0x80 0x14       BRA 0xD628 (+20)        // }                                 compiler.asm:1521
0xD614  0x64 0x13       STZ 0x13                // STZ ZP.TOP2                       compiler.asm:1524
0xD616  0x64 0x14       STZ 0x14                // STZ ZP.TOP3    x2                 compiler.asm:1525
0xD618  0x80 0x0E       BRA 0xD628 (+14)        // }                                 compiler.asm:1527
0xD61A  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       compiler.asm:1530
0xD61C  0x8D 0x83 0x0B  STA 0x0B83              // STA compilerOperand1     LSB      compiler.asm:1531
0xD61F  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       compiler.asm:1532
0xD621  0x8D 0x84 0x0B  STA 0x0B84              // STA compilerOperand2     MSB      compiler.asm:1533
0xD624  0x64 0x13       STZ 0x13                // STZ ZP.TOP2                       compiler.asm:1534
0xD626  0x64 0x14       STZ 0x14                // STZ ZP.TOP3    x2                 compiler.asm:1535
0xD628  0x20 0xA3 0xC5  JSR 0xC5A3              // Emit.PushWord();                  compiler.asm:1537
0xD62B  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1538
0xD62E  0xB0 0x01       BCS 0xD631 (+1)         // if (NC)                           compiler.asm:1539
0xD630  0x60            RTS                     // return;                           compiler.asm:1544
0xD631  0x8F 0x36 0x03  BBS0 0x36, 0xD637 (+3)  // if (BBS0, ZP.CompilerFlags)    constant expression: NUMBER: PUSH numeric literal
0xD634  0x4C 0xC9 0xBD  JMP 0xBDC9
0xD637  0xA9 0x08       LDA # 0x08              // LDA #BASICType.LONG               compiler.asm:1552
0xD639  0x85 0x15       STA 0x15                // STA ZP.TOPT                       compiler.asm:1553
0xD63B  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();                   compiler.asm:1554
0xD63E  0x4C 0xC9 0xBD  JMP 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xD641  0xC9 0xD8       CMP # 0xD8              // case Token.STRINGLIT:             compiler.asm:1565
0xD643  0xD0 0x18       BNE 0xD65D (+24)
0xD645  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: STRINGLIT: not an integral constant expression
0xD647  0xA5 0x30       LDA 0x30                // LDA ZP.TokenLiteralPosL           compiler.asm:1571
0xD649  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     LSB
0xD64C  0xA5 0x31       LDA 0x31                // LDA ZP.TokenLiteralPosH           compiler.asm:1573
0xD64E  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     MSB
0xD651  0x20 0x49 0xC6  JSR 0xC649              // Emit.PushCString();               compiler.asm:1576
0xD654  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1577
0xD657  0x90 0x03       BCC 0xD65C (+3)         // if (NC)                           compiler.asm:1578
0xD659  0x4C 0xC9 0xBD  JMP 0xBDC9
0xD65C  0x60            RTS                     // return;                           compiler.asm:1583
0xD65D  0xC9 0xD9       CMP # 0xD9              // case Token.CHARLIT:               compiler.asm:1595
0xD65F  0xD0 0x2F       BNE 0xD690 (+47)
0xD661  0x18            CLC                     // CLC                               compiler.asm:1600
0xD662  0xA5 0x38       LDA 0x38                // LDA ZP.TokenBufferL               compiler.asm:1601
0xD664  0x65 0x30       ADC 0x30                // ADC ZP.TokenLiteralPosL           compiler.asm:1602
0xD666  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       compiler.asm:1603
0xD668  0xA5 0x39       LDA 0x39                // LDA ZP.TokenBufferH               compiler.asm:1604
0xD66A  0x65 0x31       ADC 0x31                // ADC ZP.TokenLiteralPosH           compiler.asm:1605
0xD66C  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       compiler.asm:1606
0xD66E  0xA0 0x00       LDY # 0                 // LDY #0                            compiler.asm:1609
0xD670  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   compiler.asm:1610
0xD672  0x85 0x11       STA 0x11                // STA ZP.TOP0                       compiler.asm:1611
0xD674  0x20 0x91 0xC5  JSR 0xC591              // Emit.PushChar();                  compiler.asm:1613
0xD677  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1614
0xD67A  0xB0 0x01       BCS 0xD67D (+1)         // if (NC)                           compiler.asm:1615
0xD67C  0x60            RTS                     // return;                           compiler.asm:1620
0xD67D  0x8F 0x36 0x03  BBS0 0x36, 0xD683 (+3)  // if (BBS0, ZP.CompilerFlags)    constant expression: FALSE
0xD680  0x4C 0xC9 0xBD  JMP 0xBDC9
0xD683  0x20 0x9A 0x97  JSR 0x979A              // Long.ZeroTop3();                  compiler.asm:1626
0xD686  0xA9 0x01       LDA # 1                 // LDA # BASICType.CHAR              compiler.asm:1627
0xD688  0x85 0x15       STA 0x15                // STA ZP.TOPT                       compiler.asm:1628
0xD68A  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();                   compiler.asm:1629
0xD68D  0x4C 0xC9 0xBD  JMP 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xD690  0xC9 0xE4       CMP # 0xE4              // case Token.LPAREN:                compiler.asm:1642
0xD692  0xD0 0x1E       BNE 0xD6B2 (+30)
0xD694  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:1645
0xD697  0xB0 0x01       BCS 0xD69A (+1)         // if (NC)                           compiler.asm:1646
0xD699  0x60            RTS                     // return;                           compiler.asm:1651
0xD69A  0x20 0xDB 0xD0  JSR 0xD0DB              // compileExpressionTree();          compiler.asm:1656
0xD69D  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1657
0xD6A0  0xB0 0x01       BCS 0xD6A3 (+1)         // if (NC)                           compiler.asm:1658
0xD6A2  0x60            RTS                     // return;                           compiler.asm:1663
0xD6A3  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:1668
0xD6A5  0xC9 0xE5       CMP # 0xE5              // CMP #Token.RPAREN                 compiler.asm:1669
0xD6A7  0xD0 0x03       BNE 0xD6AC (+3)         // if (NZ)                           compiler.asm:1670
0xD6A9  0x4C 0xC9 0xBD  JMP 0xBDC9
0xD6AC  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xD6AF  0x4C 0x73 0x8C  JMP 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1673
0xD6B2  0xC9 0xD5       CMP # 0xD5              // case Token.IMPORT:                compiler.asm:1690
0xD6B4  0xD0 0x07       BNE 0xD6BD (+7)
0xD6B6  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    not a constant expression
0xD6B8  0xA9 0xBE       LDA # 0xBE              // LDA #SysCallType.Import           compiler.asm:1694
0xD6BA  0x4C 0x88 0xD7  JMP 0xD788              // compileSysCall();     handles '(' array ',' filename ')' syntax
0xD6BD  0xC9 0xCF       CMP # 0xCF              // case Token.I2CFIND:               compiler.asm:1703
0xD6BF  0xD0 0x07       BNE 0xD6C8 (+7)
0xD6C1  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: I2CFIND: not an integral constant expression
0xD6C3  0xA9 0x8D       LDA # 0x8D              // LDA #SysCallType.I2CFind          compiler.asm:1706
0xD6C5  0x4C 0x88 0xD7  JMP 0xD788              // compileSysCall();                 compiler.asm:1707
0xD6C8  0xC9 0xD2       CMP # 0xD2              // case Token.I2CEND:                compiler.asm:1714
0xD6CA  0xD0 0x07       BNE 0xD6D3 (+7)
0xD6CC  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: I2CEND: not an integral constant expression
0xD6CE  0xA9 0xA4       LDA # 0xA4              // LDA #SysCallType.I2CEnd           compiler.asm:1717
0xD6D0  0x4C 0x88 0xD7  JMP 0xD788              // compileSysCall();                 compiler.asm:1718
0xD6D3  0xC9 0xD3       CMP # 0xD3              // case Token.I2CGET:                compiler.asm:1725
0xD6D5  0xD0 0x07       BNE 0xD6DE (+7)
0xD6D7  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: I2CGET: not an integral constant expression
0xD6D9  0xA9 0xAE       LDA # 0xAE              // LDA #SysCallType.I2CGet           compiler.asm:1728
0xD6DB  0x4C 0x88 0xD7  JMP 0xD788              // compileSysCall();                 compiler.asm:1729
0xD6DE  0xC9 0xD4       CMP # 0xD4              // case Token.I2CNEXT:               compiler.asm:1736
0xD6E0  0xD0 0x07       BNE 0xD6E9 (+7)
0xD6E2  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: I2CNEXT: not an integral constant expression
0xD6E4  0xA9 0xB4       LDA # 0xB4              // LDA #SysCallType.I2CNext          compiler.asm:1739
0xD6E6  0x4C 0x88 0xD7  JMP 0xD788              // compileSysCall();                 compiler.asm:1740
0xD6E9  0xC9 0xC1       CMP # 0xC1              // case Token.MILLIS:                compiler.asm:1748
0xD6EB  0xD0 0x07       BNE 0xD6F4 (+7)
0xD6ED  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: MILLIS: not an integral constant expression
0xD6EF  0xA9 0x2C       LDA # 0x2C              // LDA #SysCallType.Millis           compiler.asm:1751
0xD6F1  0x4C 0x88 0xD7  JMP 0xD788              // compileSysCall();                 compiler.asm:1752
0xD6F4  0xC9 0xC5       CMP # 0xC5              // case Token.SECONDS:               compiler.asm:1759
0xD6F6  0xD0 0x07       BNE 0xD6FF (+7)
0xD6F8  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: SECONDS: not an integral constant expression
0xD6FA  0xA9 0x34       LDA # 0x34              // LDA #SysCallType.Seconds          compiler.asm:1762
0xD6FC  0x4C 0x88 0xD7  JMP 0xD788              // compileSysCall();                 compiler.asm:1763
0xD6FF  0xC9 0xC0       CMP # 0xC0              // case Token.ABS:                   compiler.asm:1770
0xD701  0xD0 0x07       BNE 0xD70A (+7)
0xD703  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: ABS: not an integral constant expression
0xD705  0xA9 0x1D       LDA # 0x1D              // LDA #SysCallType.Abs              compiler.asm:1773
0xD707  0x4C 0x88 0xD7  JMP 0xD788              // compileSysCall();                 compiler.asm:1774
0xD70A  0xC9 0xCE       CMP # 0xCE              // case Token.RND:                   compiler.asm:1781
0xD70C  0xD0 0x07       BNE 0xD715 (+7)
0xD70E  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: RND: not an integral constant expression
0xD710  0xA9 0x85       LDA # 0x85              // LDA #SysCallType.Rnd              compiler.asm:1784
0xD712  0x4C 0x88 0xD7  JMP 0xD788              // compileSysCall();                 compiler.asm:1785
0xD715  0xC9 0xC2       CMP # 0xC2              // case Token.PEEK:                  compiler.asm:1792
0xD717  0xD0 0x07       BNE 0xD720 (+7)
0xD719  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: PEEK: not an integral constant expression
0xD71B  0xA9 0x45       LDA # 0x45              // LDA #SysCallType.Peek             compiler.asm:1795
0xD71D  0x4C 0x88 0xD7  JMP 0xD788              // compileSysCall();                 compiler.asm:1796
0xD720  0xC9 0xCC       CMP # 0xCC              // case Token.READ:                  compiler.asm:1803
0xD722  0xD0 0x07       BNE 0xD72B (+7)
0xD724  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: READ: not an integral constant expression
0xD726  0xA9 0x5D       LDA # 0x5D              // LDA #SysCallType.Read             compiler.asm:1806
0xD728  0x4C 0x88 0xD7  JMP 0xD788              // compileSysCall();                 compiler.asm:1807
0xD72B  0xC9 0xC9       CMP # 0xC9              // case Token.CHR:                   compiler.asm:1814
0xD72D  0xD0 0x19       BNE 0xD748 (+25)
0xD72F  0xA9 0x6D       LDA # 0x6D              // LDA #SysCallType.Chr              compiler.asm:1816
0xD731  0x20 0x88 0xD7  JSR 0xD788              // compileSysCall();                 compiler.asm:1817
0xD734  0x8F 0x36 0x01  BBS0 0x36, 0xD738 (+1)  // if (BBS0, ZP.CompilerFlags)    constant expression: CHAR?
0xD737  0x60            RTS
0xD738  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();                    compiler.asm:1820
0xD73B  0xA9 0x01       LDA # 1                 // LDA # BASICType.CHAR              compiler.asm:1821
0xD73D  0x85 0x10       STA 0x10                // STA ZP.ACCT                       compiler.asm:1822
0xD73F  0x20 0x59 0x86  JSR 0x8659              // BASICTypes.Coerce();              compiler.asm:1824
0xD742  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1825
0xD745  0x4C 0x6A 0x97  JMP 0x976A              // Long.PushTop();                   compiler.asm:1826
0xD748  0xC9 0xC8       CMP # 0xC8              // case Token.ASC:                   compiler.asm:1835
0xD74A  0xD0 0x21       BNE 0xD76D (+33)
0xD74C  0xA9 0x75       LDA # 0x75              // LDA #SysCallType.Asc              compiler.asm:1837
0xD74E  0x20 0x88 0xD7  JSR 0xD788              // compileSysCall();                 compiler.asm:1838
0xD751  0x8F 0x36 0x01  BBS0 0x36, 0xD755 (+1)  // if (BBS0, ZP.CompilerFlags)    constant expression: CHAR?
0xD754  0x60            RTS
0xD755  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();                    compiler.asm:1841
0xD758  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       compiler.asm:1842
0xD75A  0xC9 0x01       CMP # 1                 // CMP # BASICType.CHAR              compiler.asm:1843
0xD75C  0xD0 0x06       BNE 0xD764 (+6)         // if (Z)                            compiler.asm:1844
0xD75E  0x20 0x9A 0x97  JSR 0x979A              // ZeroTop3();                       compiler.asm:1847
0xD761  0x4C 0x89 0x97  JMP 0x9789              // Long.PushTopStrictLONG();         compiler.asm:1848
0xD764  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();                   compiler.asm:1852
0xD767  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xD76A  0x4C 0x73 0x8C  JMP 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1854
0xD76D  0xC9 0xCA       CMP # 0xCA              // case Token.LEN:                   compiler.asm:1863
0xD76F  0xD0 0x07       BNE 0xD778 (+7)
0xD771  0x07 0x36       RMB0 0x36               // RMB0 ZP.CompilerFlags    constant expression: LEN: not an integral constant expression
0xD773  0xA9 0x7D       LDA # 0x7D              // LDA #SysCallType.Len              compiler.asm:1866
0xD775  0x4C 0x88 0xD7  JMP 0xD788              // compileSysCall();                 compiler.asm:1867
0xD778  0xC9 0xDA       CMP # 0xDA              // case Token.IDENTIFIER:            compiler.asm:1876
0xD77A  0xD0 0x06       BNE 0xD782 (+6)
0xD77C  0x20 0x58 0xD4  JSR 0xD458              // compileFunctionCallOrVariable();  compiler.asm:1878
0xD77F  0x4C 0x73 0x8C  JMP 0x8C73              // }                                 compiler.asm:1879
0xD782  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xD785  0x4C 0x73 0x8C  JMP 0x8C73              // }                                 compiler.asm:1884

// /source/projects/6502sbc/hopperbasic/compiler.asm:1903
// ####  Compiler.compileSysCall()  ####                                        0x023A

0xD788  0xAA            TAX                     // TAX                               compiler.asm:1904
0xD789  0xA5 0xA5       LDA 0xA5                // LDA ZP.CURRENTSYSCALL             compiler.asm:1907
0xD78B  0x48            PHA                     // PHA                               compiler.asm:1908
0xD78C  0x86 0xA5       STX 0xA5                // STX ZP.CURRENTSYSCALL             compiler.asm:1910
0xD78E  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:1921
0xD791  0x90 0x57       BCC 0xD7EA (+87)        // if (NC)                           compiler.asm:1922
0xD793  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:1927
0xD795  0xC9 0xE4       CMP # 0xE4              // CMP #Token.LPAREN                 compiler.asm:1928
0xD797  0xF0 0x08       BEQ 0xD7A1 (+8)         // if (NZ)                           compiler.asm:1929
0xD799  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xD79C  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1932
0xD79F  0x80 0x49       BRA 0xD7EA (+73)        // break;                            compiler.asm:1933
0xD7A1  0xA5 0xA5       LDA 0xA5                // LDA ZP.CURRENTSYSCALL             compiler.asm:1938
0xD7A3  0x29 0x03       AND # 0x03              // AND #0b00000011     Extract arg count bits
0xD7A5  0xAA            TAX                     // TAX     X = argument count        compiler.asm:1940
0xD7A6  0xD0 0x07       BNE 0xD7AF (+7)         // if (Z)                            compiler.asm:1944
0xD7A8  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xD7AB  0x90 0x3D       BCC 0xD7EA (+61)        // if (NC)                           compiler.asm:1948
0xD7AD  0x80 0x22       BRA 0xD7D1 (+34)
0xD7AF  0xDA            PHX                     // PHX     Save argument count       compiler.asm:1956
0xD7B0  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xD7B3  0x90 0x19       BCC 0xD7CE (+25)        // if (NC) { break; }     Exit argument loop on error
0xD7B5  0xDA            PHX                     // PHX                               compiler.asm:1964
0xD7B6  0x20 0xDB 0xD0  JSR 0xD0DB              // compileExpressionTree();          compiler.asm:1965
0xD7B9  0xFA            PLX                     // PLX                               compiler.asm:1966
0xD7BA  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1967
0xD7BD  0x90 0x0F       BCC 0xD7CE (+15)        // if (NC) { break; }     Exit argument loop on error
0xD7BF  0xCA            DEX                     // DEX     One less argument to process
0xD7C0  0xF0 0x0C       BEQ 0xD7CE (+12)        // if (Z) { break; }     Done with arguments
0xD7C2  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:1974
0xD7C4  0xC9 0xDF       CMP # 0xDF              // CMP #Token.COMMA                  compiler.asm:1975
0xD7C6  0xF0 0xE8       BEQ 0xD7B0 (-24)        // if (NZ)                           compiler.asm:1976
0xD7C8  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xD7CB  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:1979
0xD7CE  0xFA            PLX                     // PLX     Restore argument count (for debugging if needed)
0xD7CF  0x90 0x19       BCC 0xD7EA (+25)        // if (NC)                           compiler.asm:1987
0xD7D1  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:1995
0xD7D3  0xC9 0xE5       CMP # 0xE5              // CMP #Token.RPAREN                 compiler.asm:1996
0xD7D5  0xF0 0x08       BEQ 0xD7DF (+8)         // if (NZ)                           compiler.asm:1997
0xD7D7  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xD7DA  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2000
0xD7DD  0x80 0x0B       BRA 0xD7EA (+11)        // break;                            compiler.asm:2001
0xD7DF  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xD7E2  0x90 0x06       BCC 0xD7EA (+6)         // if (NC)                           compiler.asm:2006
0xD7E4  0xA5 0xA5       LDA 0xA5                // LDA ZP.CURRENTSYSCALL             compiler.asm:2012
0xD7E6  0x20 0xE8 0xC5  JSR 0xC5E8              // Emit.SysCall();     A = SysCallType
0xD7E9  0x38            SEC                     // SEC    Success                    compiler.asm:2015
0xD7EA  0x68            PLA                     // PLA                               compiler.asm:2020
0xD7EB  0x85 0xA5       STA 0xA5                // STA ZP.CURRENTSYSCALL             compiler.asm:2021
0xD7ED  0x60            RTS                     // }                                 compiler.asm:2028

// /source/projects/6502sbc/hopperbasic/compiler.asm:2039
// ####  Compiler.CompileExpression()  ####                                     0x023B

0xD7EE  0x20 0x95 0x96  JSR 0x9695              // BufferManager.UseREPLOpCodeBuffer();
0xD7F1  0x20 0x49 0xD0  JSR 0xD049              // InitOpCodeBuffer();               compiler.asm:2046
0xD7F4  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2048
0xD7F7  0xB0 0x01       BCS 0xD7FA (+1)         // if (NC) { return; }               compiler.asm:2049
0xD7F9  0x60            RTS
0xD7FA  0x20 0xA3 0xD0  JSR 0xD0A3              // CompileFoldedExpressionTree();    REPL expression
0xD7FD  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2053
0xD800  0x90 0x03       BCC 0xD805 (+3)         // if (NC) { return; }               compiler.asm:2054
0xD802  0x4C 0xBB 0x89  JMP 0x89BB
0xD805  0x60            RTS

// /source/projects/6502sbc/hopperbasic/compiler.asm:2072
// ####  Compiler.CompileStatementBlock()  ####                                 0x023C

0xD806  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2080
0xD808  0xC9 0xDB       CMP # 0xDB              // case Token.EOF:                   compiler.asm:2083
0xD80A  0xF0 0x14       BEQ 0xD820 (+20)
0xD80C  0xC9 0xAF       CMP # 0xAF              // case Token.WEND:                  compiler.asm:2084
0xD80E  0xF0 0x10       BEQ 0xD820 (+16)
0xD810  0xC9 0xAD       CMP # 0xAD              // case Token.NEXT:                  compiler.asm:2085
0xD812  0xF0 0x0C       BEQ 0xD820 (+12)
0xD814  0xC9 0xB1       CMP # 0xB1              // case Token.UNTIL:                 compiler.asm:2086
0xD816  0xF0 0x08       BEQ 0xD820 (+8)
0xD818  0xC9 0xA3       CMP # 0xA3              // case Token.ELSE:                  compiler.asm:2087
0xD81A  0xF0 0x04       BEQ 0xD820 (+4)
0xD81C  0xC9 0xA4       CMP # 0xA4              // case Token.ENDIF:                 compiler.asm:2088
0xD81E  0xD0 0x06       BNE 0xD826 (+6)
0xD820  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();              compiler.asm:2090
0xD823  0x4C 0x73 0x8C  JMP 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2091
0xD826  0xC9 0xDC       CMP # 0xDC              // case Token.EOL:                   compiler.asm:2095
0xD828  0xD0 0x07       BNE 0xD831 (+7)
0xD82A  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xD82D  0x90 0x15       BCC 0xD844 (+21)        // if (NC) { break; }                compiler.asm:2099
0xD82F  0x80 0xD5       BRA 0xD806 (-43)
0xD831  0x20 0x87 0xD9  JSR 0xD987              // CompileStatement();               compiler.asm:2106
0xD834  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2107
0xD837  0x90 0x0B       BCC 0xD844 (+11)        // if (NC) { break; }                compiler.asm:2108
0xD839  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2111
0xD83B  0xC9 0xDE       CMP # 0xDE              // CMP #Token.COLON                  compiler.asm:2112
0xD83D  0xD0 0xC7       BNE 0xD806 (-57)        // if (Z)                            compiler.asm:2113
0xD83F  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xD842  0xB0 0xC2       BCS 0xD806 (-62)        // if (NC) { break; }                compiler.asm:2116
0xD844  0x60            RTS                     // }                                 compiler.asm:2128

// /source/projects/6502sbc/hopperbasic/compiler.asm:2138
// ####  Compiler.CompileFunction()  ####                                       0x023D

0xD845  0x48            PHA                     // PHA                               compiler.asm:2139
0xD846  0xDA            PHX                     // PHX                               compiler.asm:2140
0xD847  0x5A            PHY                     // PHY                               compiler.asm:2141
0xD848  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       compiler.asm:2147
0xD84A  0x8D 0x87 0x0B  STA 0x0B87              // STA compilerFuncArgs              compiler.asm:2148
0xD84D  0xA9 0x01       LDA # 1                 // LDA #1                            compiler.asm:2150
0xD84F  0x8D 0x8B 0x0B  STA 0x0B8B              // STA compilerCanDeclareLocals    locals are allowed
0xD852  0x57 0x36       RMB5 0x36               // RMB5 ZP.CompilerFlags    track if an implict local was created in CompileForStatement
0xD854  0x20 0x49 0xD0  JSR 0xD049              // InitOpCodeBuffer();               compiler.asm:2158
0xD857  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2159
0xD85A  0x90 0x50       BCC 0xD8AC (+80)        // if (NC) { break; }                compiler.asm:2160
0xD85C  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       compiler.asm:2163
0xD85E  0x8D 0x89 0x0B  STA 0x0B89              // STA compilerSavedNodeAddrL        compiler.asm:2164
0xD861  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       compiler.asm:2165
0xD863  0x8D 0x8A 0x0B  STA 0x0B8A              // STA compilerSavedNodeAddrH        compiler.asm:2166
0xD866  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL              compiler.asm:2169
0xD868  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              compiler.asm:2170
0xD86A  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xD86D  0x90 0x3D       BCC 0xD8AC (+61)        // if (NC) { break; }                compiler.asm:2174
0xD86F  0xA9 0x50       LDA # 0x50              // LDA #OpCode.ENTER                 compiler.asm:2177
0xD871  0x9C 0x83 0x0B  STZ 0x0B83              // STZ Compiler.compilerOperand1    default to ENTER 0x00
0xD874  0x20 0x0F 0xC4  JSR 0xC40F              // Emit.OpCodeWithByte();            compiler.asm:2179
0xD877  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2180
0xD87A  0x90 0x30       BCC 0xD8AC (+48)        // if (NC) { break; }                compiler.asm:2181
0xD87C  0x9C 0x88 0x0B  STZ 0x0B88              // STZ compilerFuncLocals    no locals yet
0xD87F  0x20 0x06 0xD8  JSR 0xD806              // CompileStatementBlock();          compiler.asm:2186
0xD882  0x90 0x28       BCC 0xD8AC (+40)        // if (NC)                           compiler.asm:2187
0xD884  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2193
0xD886  0xC9 0xDB       CMP # 0xDB              // CMP #Token.EOF                    compiler.asm:2194
0xD888  0xF0 0x07       BEQ 0xD891 (+7)         // if (NZ)                           compiler.asm:2195
0xD88A  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xD88D  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compiler.asm:2198
0xD88F  0x80 0x1B       BRA 0xD8AC (+27)        // break;                            compiler.asm:2199
0xD891  0x20 0x7C 0xD0  JSR 0xD07C              // checkLastOpCodeIsReturn();        compiler.asm:2203
0xD894  0xB0 0x0B       BCS 0xD8A1 (+11)        // if (NC)    Last opcode was not RETURN
0xD896  0xAD 0x87 0x0B  LDA 0x0B87              // LDA compilerFuncArgs              compiler.asm:2207
0xD899  0x20 0xD0 0xC5  JSR 0xC5D0              // Emit.Return();     Pass total count
0xD89C  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2212
0xD89F  0x90 0x0B       BCC 0xD8AC (+11)        // if (NC) { break; }                compiler.asm:2213
0xD8A1  0x20 0x30 0xC6  JSR 0xC630              // Emit.Halt();     sentinel for ending opcode iteration
0xD8A4  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2216
0xD8A7  0x90 0x03       BCC 0xD8AC (+3)         // if (NC) { break; }                compiler.asm:2217
0xD8A9  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();    Success   compiler.asm:2219
0xD8AC  0x5F 0x36 0x06  BBR5 0x36, 0xD8B5 (+6)  // if (BBS5, ZP.CompilerFlags)    in CompileForStatement, we created an implicit local that needs to be removed at the end of the function
0xD8AF  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xD8B2  0x20 0xF4 0xA6  JSR 0xA6F4              // Locals.RemoveLast();              compiler.asm:2226
0xD8B5  0x9C 0x89 0x0B  STZ 0x0B89              // STZ Compiler.compilerSavedNodeAddrL
0xD8B8  0x9C 0x8A 0x0B  STZ 0x0B8A              // STZ Compiler.compilerSavedNodeAddrH
0xD8BB  0x7A            PLY                     // PLY                               compiler.asm:2238
0xD8BC  0xFA            PLX                     // PLX                               compiler.asm:2239
0xD8BD  0x68            PLA                     // PLA                               compiler.asm:2240
0xD8BE  0x60            RTS                     // }                                 compiler.asm:2241

// /source/projects/6502sbc/hopperbasic/compiler.asm:2244
// ####  Compiler.compileSysCallStatements()  ####                              0x023E

0xD8BF  0xC9 0xD0       CMP # 0xD0              // case Token.I2CBEGIN:              compiler.asm:2249
0xD8C1  0xD0 0x04       BNE 0xD8C7 (+4)
0xD8C3  0xA9 0x91       LDA # 0x91              // LDA #SysCallType.I2CBegin         compiler.asm:2251
0xD8C5  0x80 0x53       BRA 0xD91A (+83)        // }                                 compiler.asm:2252
0xD8C7  0xC9 0xD1       CMP # 0xD1              // case Token.I2CPUT:                compiler.asm:2253
0xD8C9  0xD0 0x04       BNE 0xD8CF (+4)
0xD8CB  0xA9 0x99       LDA # 0x99              // LDA #SysCallType.I2CPut           compiler.asm:2255
0xD8CD  0x80 0x4B       BRA 0xD91A (+75)        // }                                 compiler.asm:2256
0xD8CF  0xC9 0xD6       CMP # 0xD6              // case Token.EXPORT:                compiler.asm:2258
0xD8D1  0xD0 0x04       BNE 0xD8D7 (+4)
0xD8D3  0xA9 0xC2       LDA # 0xC2              // LDA #SysCallType.Export           compiler.asm:2260
0xD8D5  0x80 0x43       BRA 0xD91A (+67)        // }                                 compiler.asm:2261
0xD8D7  0xC9 0xD5       CMP # 0xD5              // case Token.IMPORT:                compiler.asm:2264
0xD8D9  0xD0 0x04       BNE 0xD8DF (+4)
0xD8DB  0xA9 0xBE       LDA # 0xBE              // LDA #SysCallType.Import           compiler.asm:2266
0xD8DD  0x80 0x3B       BRA 0xD91A (+59)        // }                                 compiler.asm:2267
0xD8DF  0xC9 0xD2       CMP # 0xD2              // case Token.I2CEND:                compiler.asm:2269
0xD8E1  0xD0 0x04       BNE 0xD8E7 (+4)
0xD8E3  0xA9 0xA4       LDA # 0xA4              // LDA #SysCallType.I2CEnd           compiler.asm:2271
0xD8E5  0x80 0x33       BRA 0xD91A (+51)        // }                                 compiler.asm:2272
0xD8E7  0xC9 0xD3       CMP # 0xD3              // case Token.I2CGET:                compiler.asm:2273
0xD8E9  0xD0 0x04       BNE 0xD8EF (+4)
0xD8EB  0xA9 0xAE       LDA # 0xAE              // LDA #SysCallType.I2CGet           compiler.asm:2275
0xD8ED  0x80 0x2B       BRA 0xD91A (+43)        // }                                 compiler.asm:2276
0xD8EF  0xC9 0xD4       CMP # 0xD4              // case Token.I2CNEXT:               compiler.asm:2277
0xD8F1  0xD0 0x04       BNE 0xD8F7 (+4)
0xD8F3  0xA9 0xB4       LDA # 0xB4              // LDA #SysCallType.I2CNext          compiler.asm:2279
0xD8F5  0x80 0x23       BRA 0xD91A (+35)        // }                                 compiler.asm:2280
0xD8F7  0xC9 0xC6       CMP # 0xC6              // case Token.DELAY:                 compiler.asm:2283
0xD8F9  0xD0 0x04       BNE 0xD8FF (+4)
0xD8FB  0xA9 0x39       LDA # 0x39              // LDA #SysCallType.Delay            compiler.asm:2285
0xD8FD  0x80 0x1B       BRA 0xD91A (+27)        // }                                 compiler.asm:2286
0xD8FF  0xC9 0xC3       CMP # 0xC3              // case Token.POKE:                  compiler.asm:2287
0xD901  0xD0 0x04       BNE 0xD907 (+4)
0xD903  0xA9 0x4A       LDA # 0x4A              // LDA #SysCallType.Poke             compiler.asm:2289
0xD905  0x80 0x13       BRA 0xD91A (+19)        // }                                 compiler.asm:2290
0xD907  0xC9 0xCD       CMP # 0xCD              // case Token.WRITE:                 compiler.asm:2291
0xD909  0xD0 0x04       BNE 0xD90F (+4)
0xD90B  0xA9 0x62       LDA # 0x62              // LDA #SysCallType.Write            compiler.asm:2293
0xD90D  0x80 0x0B       BRA 0xD91A (+11)        // }                                 compiler.asm:2294
0xD90F  0xC9 0xCB       CMP # 0xCB              // case Token.PINMODE:               compiler.asm:2295
0xD911  0xD0 0x04       BNE 0xD917 (+4)
0xD913  0xA9 0x52       LDA # 0x52              // LDA #SysCallType.PinMode          compiler.asm:2297
0xD915  0x80 0x03       BRA 0xD91A (+3)         // }                                 compiler.asm:2298
0xD917  0xA9 0x00       LDA # 0                 // LDA #0    not processed           compiler.asm:2301
0xD919  0x60            RTS                     // break;                            compiler.asm:2302
0xD91A  0x20 0x88 0xD7  JSR 0xD788              // compileSysCall();                 compiler.asm:2305
0xD91D  0xA9 0x01       LDA # 1                 // LDA #1    processed               compiler.asm:2306
0xD91F  0x60            RTS                     // break;                            compiler.asm:2307

// /source/projects/6502sbc/hopperbasic/compiler.asm:2311
// ####  Compiler.compileMinorStatements()  ####                                0x023F

0xD920  0xC9 0xAE       CMP # 0xAE              // case Token.WHILE:                 compiler.asm:2316
0xD922  0xD0 0x08       BNE 0xD92C (+8)
0xD924  0x9C 0x8B 0x0B  STZ 0x0B8B              // STZ compilerCanDeclareLocals    no more locals after this
0xD927  0x20 0x35 0xC8  JSR 0xC835              // CompilerFlow.CompileWhileStatement();
0xD92A  0x80 0x58       BRA 0xD984 (+88)        // }                                 compiler.asm:2320
0xD92C  0xC9 0xB0       CMP # 0xB0              // case Token.DO:                    compiler.asm:2321
0xD92E  0xD0 0x08       BNE 0xD938 (+8)
0xD930  0x9C 0x8B 0x0B  STZ 0x0B8B              // STZ compilerCanDeclareLocals    no more locals after this
0xD933  0x20 0xB9 0xC8  JSR 0xC8B9              // CompilerFlow.CompileDoUntilStatement();
0xD936  0x80 0x4C       BRA 0xD984 (+76)        // }                                 compiler.asm:2325
0xD938  0xC9 0xA7       CMP # 0xA7              // case Token.RETURN:                compiler.asm:2326
0xD93A  0xD0 0x08       BNE 0xD944 (+8)
0xD93C  0x9C 0x8B 0x0B  STZ 0x0B8B              // STZ compilerCanDeclareLocals    no more locals after this
0xD93F  0x20 0x80 0xDA  JSR 0xDA80              // compileReturnStatement();         compiler.asm:2329
0xD942  0x80 0x40       BRA 0xD984 (+64)        // }                                 compiler.asm:2330
0xD944  0xC9 0xA1       CMP # 0xA1              // case Token.IF:                    compiler.asm:2331
0xD946  0xD0 0x08       BNE 0xD950 (+8)
0xD948  0x9C 0x8B 0x0B  STZ 0x0B8B              // STZ compilerCanDeclareLocals    no more locals after this
0xD94B  0x20 0xF7 0xC6  JSR 0xC6F7              // CompilerFlow.CompileIfStatement();
0xD94E  0x80 0x34       BRA 0xD984 (+52)        // }                                 compiler.asm:2335
0xD950  0xC9 0x94       CMP # 0x94              // case Token.REM:                   compiler.asm:2336
0xD952  0xF0 0x04       BEQ 0xD958 (+4)
0xD954  0xC9 0x95       CMP # 0x95              // case Token.COMMENT:               compiler.asm:2337
0xD956  0xD0 0x05       BNE 0xD95D (+5)
0xD958  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    Skip comments - advance to next token
0xD95B  0x80 0x27       BRA 0xD984 (+39)        // }                                 compiler.asm:2340
0xD95D  0xC9 0xDA       CMP # 0xDA              // case Token.IDENTIFIER:            compiler.asm:2341
0xD95F  0xD0 0x05       BNE 0xD966 (+5)
0xD961  0x20 0x74 0xDC  JSR 0xDC74              // compileIdentifierStatement();      Could be assignment or function call
0xD964  0x80 0x1E       BRA 0xD984 (+30)        // }                                 compiler.asm:2344
0xD966  0xC9 0xAA       CMP # 0xAA              // case Token.FOR:                   compiler.asm:2345
0xD968  0xD0 0x05       BNE 0xD96F (+5)
0xD96A  0x20 0x34 0xC9  JSR 0xC934              // CompilerFlow.CompileForStatement();
0xD96D  0x80 0x15       BRA 0xD984 (+21)        // }                                 compiler.asm:2348
0xD96F  0xC9 0x9F       CMP # 0x9F              // case Token.PRINT:                 compiler.asm:2349
0xD971  0xD0 0x05       BNE 0xD978 (+5)
0xD973  0x20 0xF7 0xD9  JSR 0xD9F7              // compilePrintStatement();          compiler.asm:2351
0xD976  0x80 0x0C       BRA 0xD984 (+12)        // }                                 compiler.asm:2352
0xD978  0xC9 0xC7       CMP # 0xC7              // case Token.CLS:                   compiler.asm:2353
0xD97A  0xD0 0x05       BNE 0xD981 (+5)
0xD97C  0x20 0xE4 0xDC  JSR 0xDCE4              // compileCLSStatement();            compiler.asm:2355
0xD97F  0x80 0x03       BRA 0xD984 (+3)         // }                                 compiler.asm:2356
0xD981  0xA9 0x00       LDA # 0                 // LDA #0    not processed           compiler.asm:2359
0xD983  0x60            RTS                     // break;                            compiler.asm:2360
0xD984  0xA9 0x01       LDA # 1                 // LDA #1    processed               compiler.asm:2363
0xD986  0x60            RTS                     // break;                            compiler.asm:2364

// /source/projects/6502sbc/hopperbasic/compiler.asm:2375
// ####  Compiler.CompileStatement()  ####                                      0x0240

0xD987  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2382
0xD989  0x20 0x20 0xD9  JSR 0xD920              // compileMinorStatements();         compiler.asm:2383
0xD98C  0xD0 0x05       BNE 0xD993 (+5)         // if (Z)    not processed           compiler.asm:2384
0xD98E  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2386
0xD990  0x20 0xBF 0xD8  JSR 0xD8BF              // compileSysCallStatements();       compiler.asm:2387
0xD993  0xF0 0x09       BEQ 0xD99E (+9)         // if (NZ)    processed              compiler.asm:2389
0xD995  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2391
0xD998  0xB0 0x01       BCS 0xD99B (+1)         // if (C) { States.SetSuccess(); }   compiler.asm:2392
0xD99A  0x60            RTS
0xD99B  0x4C 0xBB 0x89  JMP 0x89BB
0xD99E  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2395
0xD9A0  0xC9 0x96       CMP # 0x96              // case Token.INT:                   compiler.asm:2398
0xD9A2  0xF0 0x18       BEQ 0xD9BC (+24)
0xD9A4  0xC9 0x97       CMP # 0x97              // case Token.WORD:                  compiler.asm:2399
0xD9A6  0xF0 0x14       BEQ 0xD9BC (+20)
0xD9A8  0xC9 0x99       CMP # 0x99              // case Token.BYTE:                  compiler.asm:2400
0xD9AA  0xF0 0x10       BEQ 0xD9BC (+16)
0xD9AC  0xC9 0x9C       CMP # 0x9C              // case Token.CHAR:                  compiler.asm:2401
0xD9AE  0xF0 0x0C       BEQ 0xD9BC (+12)
0xD9B0  0xC9 0x98       CMP # 0x98              // case Token.BIT:                   compiler.asm:2402
0xD9B2  0xF0 0x08       BEQ 0xD9BC (+8)
0xD9B4  0xC9 0x9B       CMP # 0x9B              // case Token.STRING:                compiler.asm:2403
0xD9B6  0xF0 0x04       BEQ 0xD9BC (+4)
0xD9B8  0xC9 0x9A       CMP # 0x9A              // case Token.LONG:                  compiler.asm:2404
0xD9BA  0xD0 0x06       BNE 0xD9C2 (+6)
0xD9BC  0x20 0x99 0x8B  JSR 0x8B99              // Error.IllegalType(); BIT ZP.EmulatorPCL    ZP.CurrentToken
0xD9BF  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compiler.asm:2407
0xD9C1  0x60            RTS                     // break;                            compiler.asm:2408
0xD9C2  0xC9 0x9D       CMP # 0x9D              // case Token.VAR:                   compiler.asm:2410
0xD9C4  0xD0 0x22       BNE 0xD9E8 (+34)
0xD9C6  0xAD 0x8B 0x0B  LDA 0x0B8B              // LDA compilerCanDeclareLocals      compiler.asm:2413
0xD9C9  0xD0 0x06       BNE 0xD9D1 (+6)         // if (Z)                            compiler.asm:2414
0xD9CB  0x20 0xE3 0x8B  JSR 0x8BE3              // Error.LateDeclaration(); BIT ZP.EmulatorPCL     "Declarations must come before statements"
0xD9CE  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compiler.asm:2417
0xD9D0  0x60            RTS                     // break;                            compiler.asm:2418
0xD9D1  0x20 0xB0 0xDA  JSR 0xDAB0              // compileLocalDeclaration();        compiler.asm:2422
0xD9D4  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:2423
0xD9D7  0x90 0x0C       BCC 0xD9E5 (+12)        // if (NC) { break; }                compiler.asm:2424
0xD9D9  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2427
0xD9DB  0xC9 0xDF       CMP # 0xDF              // CMP #Token.COMMA                  compiler.asm:2428
0xD9DD  0xD0 0x06       BNE 0xD9E5 (+6)         // if (NZ) { break; }    Done        compiler.asm:2429
0xD9DF  0xA9 0x9D       LDA # 0x9D              // LDA # Token.VAR                   compiler.asm:2432
0xD9E1  0x85 0x2F       STA 0x2F                // STA ZP.CurrentToken               compiler.asm:2433
0xD9E3  0x80 0xEC       BRA 0xD9D1 (-20)        // }                                 compiler.asm:2434
0xD9E5  0x90 0x0F       BCC 0xD9F6 (+15)        // if (NC) { break; }                compiler.asm:2435
0xD9E7  0x60            RTS
0xD9E8  0xC9 0x94       CMP # 0x94              // CMP # Token.afterConsoleCommands  compiler.asm:2443
0xD9EA  0x90 0x05       BCC 0xD9F1 (+5)         // if (C)                            compiler.asm:2444
0xD9EC  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xD9EF  0x80 0x03       BRA 0xD9F4 (+3)         // }                                 compiler.asm:2447
0xD9F1  0x20 0x85 0x8B  JSR 0x8B85              // Error.IllegalInFunction(); BIT ZP.EmulatorPCL    console command
0xD9F4  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compiler.asm:2452
0xD9F6  0x60            RTS                     // }                                 compiler.asm:2467

// /source/projects/6502sbc/hopperbasic/compiler.asm:2482
// ####  Compiler.compilePrintStatement()  ####                                 0x0241

0xD9F7  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xD9FA  0xB0 0x01       BCS 0xD9FD (+1)         // if (NC) { break; }                compiler.asm:2491
0xD9FC  0x60            RTS
0xD9FD  0x20 0x78 0x8A  JSR 0x8A78              // Tokens.IsEndOfPrintStatement();   compiler.asm:2494
0xDA00  0x90 0x0C       BCC 0xDA0E (+12)        // if (C)                            compiler.asm:2495
0xDA02  0x20 0x1A 0xC6  JSR 0xC61A              // Emit.PrintNewLine();              compiler.asm:2498
0xDA05  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2499
0xDA08  0x90 0x03       BCC 0xDA0D (+3)         // if (NC) { break; }                compiler.asm:2500
0xDA0A  0x4C 0xBB 0x89  JMP 0x89BB
0xDA0D  0x60            RTS
0xDA0E  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2506
0xDA10  0xC9 0xDF       CMP # 0xDF              // CMP #Token.COMMA                  compiler.asm:2507
0xDA12  0xD0 0x12       BNE 0xDA26 (+18)        // if (Z)                            compiler.asm:2508
0xDA14  0x20 0x1F 0xC6  JSR 0xC61F              // Emit.PrintSpace();                compiler.asm:2511
0xDA17  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2512
0xDA1A  0xB0 0x01       BCS 0xDA1D (+1)         // if (NC) { break; }                compiler.asm:2513
0xDA1C  0x60            RTS
0xDA1D  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xDA20  0x90 0x03       BCC 0xDA25 (+3)         // if (NC) { break; }                compiler.asm:2516
0xDA22  0x4C 0xBB 0x89  JMP 0x89BB
0xDA25  0x60            RTS
0xDA26  0xC9 0xE0       CMP # 0xE0              // CMP #Token.SEMICOLON              compiler.asm:2521
0xDA28  0xD0 0x09       BNE 0xDA33 (+9)         // if (Z)                            compiler.asm:2522
0xDA2A  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xDA2D  0x90 0x03       BCC 0xDA32 (+3)         // if (NC) { break; }                compiler.asm:2526
0xDA2F  0x4C 0xBB 0x89  JMP 0x89BB
0xDA32  0x60            RTS
0xDA33  0x20 0xA3 0xD0  JSR 0xD0A3              // CompileFoldedExpressionTree();    PRINT arguments, use full expression compilation
0xDA36  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2536
0xDA39  0xB0 0x01       BCS 0xDA3C (+1)         // if (NC) { break; }                compiler.asm:2537
0xDA3B  0x60            RTS
0xDA3C  0x20 0x24 0xC6  JSR 0xC624              // Emit.PrintValue();                compiler.asm:2540
0xDA3F  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2541
0xDA42  0x90 0x3B       BCC 0xDA7F (+59)        // if (NC) { break; }                compiler.asm:2542
0xDA44  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2545
0xDA46  0xC9 0xDF       CMP # 0xDF              // CMP #Token.COMMA                  compiler.asm:2546
0xDA48  0xD0 0x17       BNE 0xDA61 (+23)        // if (Z)                            compiler.asm:2547
0xDA4A  0x20 0x1F 0xC6  JSR 0xC61F              // Emit.PrintSpace();                compiler.asm:2550
0xDA4D  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2551
0xDA50  0x90 0x2D       BCC 0xDA7F (+45)        // if (NC) { break; }                compiler.asm:2552
0xDA52  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xDA55  0x90 0x28       BCC 0xDA7F (+40)        // if (NC) { break; }                compiler.asm:2556
0xDA57  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2559
0xDA59  0x20 0x78 0x8A  JSR 0x8A78              // Tokens.IsEndOfPrintStatement();   compiler.asm:2560
0xDA5C  0x90 0xD5       BCC 0xDA33 (-43)        // if (C)                            compiler.asm:2561
0xDA5E  0x4C 0xBB 0x89  JMP 0x89BB              // States.SetSuccess();              compiler.asm:2564
0xDA61  0xC9 0xE0       CMP # 0xE0              // CMP #Token.SEMICOLON              compiler.asm:2572
0xDA63  0xD0 0x0F       BNE 0xDA74 (+15)        // if (Z)                            compiler.asm:2573
0xDA65  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xDA68  0x90 0x15       BCC 0xDA7F (+21)        // if (NC) { break; }                compiler.asm:2578
0xDA6A  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2581
0xDA6C  0x20 0x78 0x8A  JSR 0x8A78              // Tokens.IsEndOfPrintStatement();   compiler.asm:2582
0xDA6F  0x90 0xC2       BCC 0xDA33 (-62)        // if (C)                            compiler.asm:2583
0xDA71  0x4C 0xBB 0x89  JMP 0x89BB              // States.SetSuccess();              compiler.asm:2586
0xDA74  0x20 0x1A 0xC6  JSR 0xC61A              // Emit.PrintNewLine();              compiler.asm:2596
0xDA77  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2597
0xDA7A  0x90 0x03       BCC 0xDA7F (+3)         // if (NC) { break; }                compiler.asm:2598
0xDA7C  0x4C 0xBB 0x89  JMP 0x89BB
0xDA7F  0x60            RTS                     // break;    Exit main loop          compiler.asm:2604

// /source/projects/6502sbc/hopperbasic/compiler.asm:2618
// ####  Compiler.compileReturnStatement()  ####                                0x0242

0xDA80  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xDA83  0x90 0x2A       BCC 0xDAAF (+42)        // if (NC) { break; }                compiler.asm:2627
0xDA85  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2630
0xDA87  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    compiler.asm:2631
0xDA89  0xD0 0x0E       BNE 0xDA99 (+14)        // if (Z)                            compiler.asm:2632
0xDA8B  0xAD 0x87 0x0B  LDA 0x0B87              // LDA compilerFuncArgs              compiler.asm:2635
0xDA8E  0x20 0xD0 0xC5  JSR 0xC5D0              // Emit.Return();     Pass total count
0xDA91  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2640
0xDA94  0x90 0x19       BCC 0xDAAF (+25)        // if (NC) { break; }                compiler.asm:2641
0xDA96  0x4C 0xBB 0x89  JMP 0x89BB
0xDA99  0x20 0xA3 0xD0  JSR 0xD0A3              // CompileFoldedExpressionTree();    RETURN <expression>
0xDA9C  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2648
0xDA9F  0x90 0x0E       BCC 0xDAAF (+14)        // if (NC) { break; }                compiler.asm:2649
0xDAA1  0xAD 0x87 0x0B  LDA 0x0B87              // LDA compilerFuncArgs              compiler.asm:2652
0xDAA4  0x20 0xD8 0xC5  JSR 0xC5D8              // Emit.ReturnVal();                 compiler.asm:2656
0xDAA7  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2657
0xDAAA  0x90 0x03       BCC 0xDAAF (+3)         // if (NC) { break; }                compiler.asm:2658
0xDAAC  0x4C 0xBB 0x89  JMP 0x89BB
0xDAAF  0x60            RTS                     // }                                 compiler.asm:2667

// /source/projects/6502sbc/hopperbasic/compiler.asm:2681
// ####  Compiler.compileLocalDeclaration()  ####                               0x0243

0xDAB0  0x48            PHA                     // PHA                               compiler.asm:2682
0xDAB1  0xDA            PHX                     // PHX                               compiler.asm:2683
0xDAB2  0x5A            PHY                     // PHY                               compiler.asm:2684
0xDAB3  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:2695
0xDAB6  0x90 0x65       BCC 0xDB1D (+101)       // if (NC) { break; }                compiler.asm:2696
0xDAB8  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2699
0xDABA  0xC9 0xDA       CMP # 0xDA              // CMP #Token.IDENTIFIER             compiler.asm:2700
0xDABC  0xF0 0x05       BEQ 0xDAC3 (+5)         // if (NZ)                           compiler.asm:2701
0xDABE  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xDAC1  0x80 0x5A       BRA 0xDB1D (+90)        // break;                            compiler.asm:2704
0xDAC3  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();     Result in ZP.TOP
0xDAC6  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:2709
0xDAC9  0x90 0x52       BCC 0xDB1D (+82)        // if (NC) { break; }                compiler.asm:2710
0xDACB  0x20 0x3E 0xD0  JSR 0xD03E              // Compiler.moveSavedNodeAddrToIDX();
0xDACE  0x20 0x11 0xA5  JSR 0xA511              // Locals.Find();     Uses existing Find with compareNames
0xDAD1  0x90 0x05       BCC 0xDAD8 (+5)         // if (C)     Found - duplicate      compiler.asm:2715
0xDAD3  0x20 0xFC 0x8B  JSR 0x8BFC              // Error.VariableExistsTOP(); BIT ZP.EmulatorPCL    name is in TOP
0xDAD6  0x80 0x45       BRA 0xDB1D (+69)        // break;                            compiler.asm:2718
0xDAD8  0x38            SEC                     // SEC                               compiler.asm:2720
0xDAD9  0xEE 0x88 0x0B  INC 0x0B88              // INC compilerFuncLocals            compiler.asm:2723
0xDADC  0x9C 0x83 0x0B  STZ 0x0B83              // STZ compilerOperand1              compiler.asm:2725
0xDADF  0x9C 0x84 0x0B  STZ 0x0B84              // STZ compilerOperand2              compiler.asm:2726
0xDAE2  0x20 0x9E 0xC5  JSR 0xC59E              // Emit.PushEmptyVar();    value zero, type with be (BASICType.LONG|BASICType.VAR) by default
0xDAE5  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:2730
0xDAE8  0x90 0x33       BCC 0xDB1D (+51)        // if (NC) { break; }                compiler.asm:2731
0xDAEA  0xA9 0x10       LDA # 0x10              // LDA #BASICType.VAR                compiler.asm:2735
0xDAEC  0x09 0x80       ORA # 0x80              // ORA # SymbolType.LOCAL     Combine with LOCAL
0xDAEE  0x85 0x40       STA 0x40                // STA ZP.SymbolType     argument for Locals.Add()
0xDAF0  0x20 0x98 0xA4  JSR 0xA498              // Locals.Add();     Reuse existing Add method
0xDAF3  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:2741
0xDAF6  0x90 0x25       BCC 0xDB1D (+37)        // if (NC) { break; }                compiler.asm:2742
0xDAF8  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:2745
0xDAFB  0x90 0x20       BCC 0xDB1D (+32)        // if (NC) { break; }                compiler.asm:2746
0xDAFD  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2749
0xDAFF  0xC9 0xE1       CMP # 0xE1              // CMP #Token.EQUALS                 compiler.asm:2750
0xDB01  0xD0 0x19       BNE 0xDB1C (+25)        // if (Z)                            compiler.asm:2751
0xDB03  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       compiler.asm:2754
0xDB06  0x90 0x15       BCC 0xDB1D (+21)        // if (NC) { break; }                compiler.asm:2755
0xDB08  0x20 0xA3 0xD0  JSR 0xD0A3              // CompileFoldedExpressionTree();    <type> LOCAL = <expression>
0xDB0B  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:2759
0xDB0E  0x90 0x0D       BCC 0xDB1D (+13)        // if (NC) { break; }                compiler.asm:2760
0xDB10  0xAD 0x88 0x0B  LDA 0x0B88              // LDA compilerFuncLocals     Positive BP offset (0-based)
0xDB13  0x3A            DEC A                   // DEC A                             compiler.asm:2764
0xDB14  0x20 0x5F 0xC6  JSR 0xC65F              // Emit.PopLocal();                  compiler.asm:2765
0xDB17  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     compiler.asm:2766
0xDB1A  0x90 0x01       BCC 0xDB1D (+1)         // if (NC) { break; }                compiler.asm:2767
0xDB1C  0x38            SEC                     // SEC     Success                   compiler.asm:2770
0xDB1D  0x7A            PLY                     // PLY                               compiler.asm:2780
0xDB1E  0xFA            PLX                     // PLX                               compiler.asm:2781
0xDB1F  0x68            PLA                     // PLA                               compiler.asm:2782
0xDB20  0x60            RTS                     // }                                 compiler.asm:2783

// /source/projects/6502sbc/hopperbasic/compiler.asm:2799
// ####  Compiler.compileAssignment()  ####                                     0x0244

0xDB21  0x48            PHA                     // PHA                               compiler.asm:2800
0xDB22  0xDA            PHX                     // PHX                               compiler.asm:2801
0xDB23  0x5A            PHY                     // PHY                               compiler.asm:2802
0xDB24  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT    (IdentifierType)   compiler.asm:2813
0xDB26  0x48            PHA                     // PHA                               compiler.asm:2814
0xDB27  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       compiler.asm:2817
0xDB29  0x48            PHA                     // PHA                               compiler.asm:2818
0xDB2A  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       compiler.asm:2819
0xDB2C  0x48            PHA                     // PHA                               compiler.asm:2820
0xDB2D  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       compiler.asm:2823
0xDB2F  0x48            PHA                     // PHA                               compiler.asm:2824
0xDB30  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2829
0xDB32  0xC9 0xDA       CMP # 0xDA              // CMP #Token.IDENTIFIER             compiler.asm:2830
0xDB34  0xD0 0x68       BNE 0xDB9E (+104)       // if (Z)                            compiler.asm:2831
0xDB36  0x20 0x25 0xBE  JSR 0xBE25              // Tokenizer.PeekToken();    -> A    compiler.asm:2835
0xDB39  0xC9 0xF0       CMP # 0xF0              // CMP #Token.LBRACKET               compiler.asm:2836
0xDB3B  0xD0 0x61       BNE 0xDB9E (+97)        // if (Z)                            compiler.asm:2837
0xDB3D  0xC7 0x36       SMB4 0x36               // SMB4 ZP.CompilerFlags     Set bit 4 as "array assignment" flag
0xDB3F  0x20 0x45 0xD3  JSR 0xD345              // compileVariableOrArgument();      compiler.asm:2844
0xDB42  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2845
0xDB45  0x90 0x74       BCC 0xDBBB (+116)       // if (NC) { break; }                compiler.asm:2846
0xDB47  0x9C 0x92 0x0B  STZ 0x0B92              // STZ Compiler.compilerSetItemObjInstr
0xDB4A  0xAD 0x86 0x0B  LDA 0x0B86              // LDA Compiler.compilerLastOpCode   compiler.asm:2849
0xDB4D  0xC9 0x43       CMP # 0x43              // CMP # OpCode.PUSHLOCAL            compiler.asm:2850
0xDB4F  0xD0 0x03       BNE 0xDB54 (+3)         // if (Z)                            compiler.asm:2851
0xDB51  0x8D 0x92 0x0B  STA 0x0B92              // STA Compiler.compilerSetItemObjInstr
0xDB54  0xC9 0x4B       CMP # 0x4B              // CMP # OpCode.PUSHGLOBAL           compiler.asm:2855
0xDB56  0xD0 0x03       BNE 0xDB5B (+3)         // if (Z)                            compiler.asm:2856
0xDB58  0x8D 0x92 0x0B  STA 0x0B92              // STA Compiler.compilerSetItemObjInstr
0xDB5B  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xDB5E  0x90 0x5B       BCC 0xDBBB (+91)        // if (NC) { break; }                compiler.asm:2863
0xDB60  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xDB63  0x90 0x56       BCC 0xDBBB (+86)        // if (NC) { break; }                compiler.asm:2866
0xDB65  0x20 0xA3 0xD0  JSR 0xD0A3              // CompileFoldedExpressionTree();    array[<expression>] =
0xDB68  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2870
0xDB6B  0x90 0x4E       BCC 0xDBBB (+78)        // if (NC) { break; }                compiler.asm:2871
0xDB6D  0x9C 0x94 0x0B  STZ 0x0B94              // STZ Compiler.compilerSetItemIndexInstr
0xDB70  0xAD 0x86 0x0B  LDA 0x0B86              // LDA Compiler.compilerLastOpCode   compiler.asm:2875
0xDB73  0xC9 0x43       CMP # 0x43              // CMP # OpCode.PUSHLOCAL            compiler.asm:2876
0xDB75  0xD0 0x0B       BNE 0xDB82 (+11)        // if (Z)                            compiler.asm:2877
0xDB77  0x8D 0x94 0x0B  STA 0x0B94              // STA Compiler.compilerSetItemIndexInstr
0xDB7A  0xAD 0x92 0x0B  LDA 0x0B92              // LDA Compiler.compilerSetItemObjInstr
0xDB7D  0xF0 0x03       BEQ 0xDB82 (+3)         // if (NZ)                           compiler.asm:2881
0xDB7F  0x20 0xA2 0xCD  JSR 0xCDA2              // Optimizer.SetItemPrep();          compiler.asm:2883
0xDB82  0xC9 0x4B       CMP # 0x4B              // CMP # OpCode.PUSHGLOBAL           compiler.asm:2886
0xDB84  0xD0 0x0B       BNE 0xDB91 (+11)        // if (Z)                            compiler.asm:2887
0xDB86  0x8D 0x94 0x0B  STA 0x0B94              // STA Compiler.compilerSetItemIndexInstr
0xDB89  0xAD 0x92 0x0B  LDA 0x0B92              // LDA Compiler.compilerSetItemObjInstr
0xDB8C  0xF0 0x03       BEQ 0xDB91 (+3)         // if (NZ)                           compiler.asm:2891
0xDB8E  0x20 0xA2 0xCD  JSR 0xCDA2              // Optimizer.SetItemPrep();          compiler.asm:2893
0xDB91  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2900
0xDB93  0xC9 0xF1       CMP # 0xF1              // CMP #Token.RBRACKET               compiler.asm:2901
0xDB95  0xF0 0x07       BEQ 0xDB9E (+7)         // if (NZ)                           compiler.asm:2902
0xDB97  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xDB9A  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compiler.asm:2905
0xDB9C  0x80 0x1D       BRA 0xDBBB (+29)        // break;                            compiler.asm:2906
0xDB9E  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xDBA1  0x90 0x18       BCC 0xDBBB (+24)        // if (NC) { break; }                compiler.asm:2915
0xDBA3  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               compiler.asm:2919
0xDBA5  0xC9 0xE1       CMP # 0xE1              // CMP #Token.EQUALS                 compiler.asm:2920
0xDBA7  0xF0 0x07       BEQ 0xDBB0 (+7)         // if (NZ)                           compiler.asm:2921
0xDBA9  0x20 0x33 0x8C  JSR 0x8C33              // Error.ExpectedEqual(); BIT ZP.EmulatorPCL
0xDBAC  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compiler.asm:2924
0xDBAE  0x80 0x0B       BRA 0xDBBB (+11)        // break;                            compiler.asm:2925
0xDBB0  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xDBB3  0x90 0x06       BCC 0xDBBB (+6)         // if (NC) { break; }                compiler.asm:2930
0xDBB5  0x20 0xA3 0xD0  JSR 0xD0A3              // CompileFoldedExpressionTree();    local = <expression>
0xDBB8  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:2934
0xDBBB  0x68            PLA                     // PLA     Restore BP offset         compiler.asm:2942
0xDBBC  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       compiler.asm:2943
0xDBBE  0x68            PLA                     // PLA     Restore IDXH              compiler.asm:2944
0xDBBF  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       compiler.asm:2945
0xDBC1  0x68            PLA                     // PLA     Restore IDXL              compiler.asm:2946
0xDBC2  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       compiler.asm:2947
0xDBC4  0x68            PLA                     // PLA     Restore IdentifierType    compiler.asm:2948
0xDBC5  0x85 0x10       STA 0x10                // STA ZP.ACCT                       compiler.asm:2949
0xDBC7  0x20 0x96 0x89  JSR 0x8996              // CanContinue();                    compiler.asm:2951
0xDBCA  0xB0 0x03       BCS 0xDBCF (+3)         // if (NC)                           compiler.asm:2952
0xDBCC  0x4C 0x70 0xDC  JMP 0xDC70              // break;                            compiler.asm:2954
0xDBCF  0x4F 0x36 0x7B  BBR4 0x36, 0xDC4D (+123)// if (BBS4, ZP.CompilerFlags)     Check array assignment flag
0xDBD2  0x47 0x36       RMB4 0x36               // RMB4 ZP.CompilerFlags     Clear flag
0xDBD4  0xAD 0x92 0x0B  LDA 0x0B92              // LDA Compiler.compilerSetItemObjInstr
0xDBD7  0xC9 0x4B       CMP # 0x4B              // CMP # OpCode.PUSHGLOBAL           compiler.asm:2966
0xDBD9  0xD0 0x31       BNE 0xDC0C (+49)        // if (Z)                            compiler.asm:2967
0xDBDB  0xAD 0x94 0x0B  LDA 0x0B94              // LDA Compiler.compilerSetItemIndexInstr
0xDBDE  0xC9 0x4B       CMP # 0x4B              // CMP # OpCode.PUSHGLOBAL           compiler.asm:2970
0xDBE0  0xD0 0x13       BNE 0xDBF5 (+19)        // if (Z)                            compiler.asm:2971
0xDBE2  0xAD 0x93 0x0B  LDA 0x0B93              // LDA Compiler.compilerSetItemObjOffset
0xDBE5  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compiler.asm:2975
0xDBE8  0xAD 0x95 0x0B  LDA 0x0B95              // LDA Compiler.compilerSetItemIndexOffset
0xDBEB  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     compiler.asm:2977
0xDBEE  0xA9 0x90       LDA # 0x90              // LDA #OpCode.SETITEMGG             compiler.asm:2978
0xDBF0  0x20 0x4A 0xC4  JSR 0xC44A              // Emit.OpCodeWithWord();            compiler.asm:2979
0xDBF3  0x80 0x51       BRA 0xDC46 (+81)        // break;                            compiler.asm:2980
0xDBF5  0xC9 0x43       CMP # 0x43              // CMP # OpCode.PUSHLOCAL            compiler.asm:2982
0xDBF7  0xD0 0x13       BNE 0xDC0C (+19)        // if (Z)                            compiler.asm:2983
0xDBF9  0xAD 0x93 0x0B  LDA 0x0B93              // LDA Compiler.compilerSetItemObjOffset
0xDBFC  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compiler.asm:2987
0xDBFF  0xAD 0x95 0x0B  LDA 0x0B95              // LDA Compiler.compilerSetItemIndexOffset
0xDC02  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     compiler.asm:2989
0xDC05  0xA9 0x91       LDA # 0x91              // LDA #OpCode.SETITEMGL             compiler.asm:2990
0xDC07  0x20 0x4A 0xC4  JSR 0xC44A              // Emit.OpCodeWithWord();            compiler.asm:2991
0xDC0A  0x80 0x3A       BRA 0xDC46 (+58)        // break;                            compiler.asm:2992
0xDC0C  0xC9 0x43       CMP # 0x43              // CMP # OpCode.PUSHLOCAL            compiler.asm:2995
0xDC0E  0xD0 0x31       BNE 0xDC41 (+49)        // if (Z)                            compiler.asm:2996
0xDC10  0xAD 0x94 0x0B  LDA 0x0B94              // LDA Compiler.compilerSetItemIndexInstr
0xDC13  0xC9 0x4B       CMP # 0x4B              // CMP # OpCode.PUSHGLOBAL           compiler.asm:2999
0xDC15  0xD0 0x13       BNE 0xDC2A (+19)        // if (Z)                            compiler.asm:3000
0xDC17  0xAD 0x93 0x0B  LDA 0x0B93              // LDA Compiler.compilerSetItemObjOffset
0xDC1A  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compiler.asm:3004
0xDC1D  0xAD 0x95 0x0B  LDA 0x0B95              // LDA Compiler.compilerSetItemIndexOffset
0xDC20  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     compiler.asm:3006
0xDC23  0xA9 0x92       LDA # 0x92              // LDA #OpCode.SETITEMLG             compiler.asm:3007
0xDC25  0x20 0x4A 0xC4  JSR 0xC44A              // Emit.OpCodeWithWord();            compiler.asm:3008
0xDC28  0x80 0x1C       BRA 0xDC46 (+28)        // break;                            compiler.asm:3009
0xDC2A  0xC9 0x43       CMP # 0x43              // CMP # OpCode.PUSHLOCAL            compiler.asm:3011
0xDC2C  0xD0 0x13       BNE 0xDC41 (+19)        // if (Z)                            compiler.asm:3012
0xDC2E  0xAD 0x93 0x0B  LDA 0x0B93              // LDA Compiler.compilerSetItemObjOffset
0xDC31  0x8D 0x83 0x0B  STA 0x0B83              // STA Compiler.compilerOperand1     compiler.asm:3016
0xDC34  0xAD 0x95 0x0B  LDA 0x0B95              // LDA Compiler.compilerSetItemIndexOffset
0xDC37  0x8D 0x84 0x0B  STA 0x0B84              // STA Compiler.compilerOperand2     compiler.asm:3018
0xDC3A  0xA9 0x93       LDA # 0x93              // LDA #OpCode.SETITEMLL             compiler.asm:3019
0xDC3C  0x20 0x4A 0xC4  JSR 0xC44A              // Emit.OpCodeWithWord();            compiler.asm:3020
0xDC3F  0x80 0x05       BRA 0xDC46 (+5)         // break;                            compiler.asm:3021
0xDC41  0xA9 0x1D       LDA # 0x1D              // LDA #OpCode.SETITEM               compiler.asm:3027
0xDC43  0x20 0xE6 0xC3  JSR 0xC3E6              // Emit.OpCode();                    compiler.asm:3028
0xDC46  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:3031
0xDC49  0x90 0x25       BCC 0xDC70 (+37)        // if (NC) { break; }                compiler.asm:3032
0xDC4B  0x80 0x20       BRA 0xDC6D (+32)
0xDC4D  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       compiler.asm:3037
0xDC4F  0xC9 0x04       CMP # 0x04              // CMP #IdentifierType.Local         compiler.asm:3038
0xDC51  0xD0 0x0C       BNE 0xDC5F (+12)        // if (Z)                            compiler.asm:3039
0xDC53  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL     BP offset (signed)
0xDC55  0x20 0x5F 0xC6  JSR 0xC65F              // Emit.PopLocal();                  compiler.asm:3043
0xDC58  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:3044
0xDC5B  0x90 0x13       BCC 0xDC70 (+19)        // if (NC) { break; }                compiler.asm:3045
0xDC5D  0x80 0x0E       BRA 0xDC6D (+14)
0xDC5F  0x20 0xC9 0xA2  JSR 0xA2C9              // Variables.GetName();     Returns name in ZP.STR
0xDC62  0x20 0x55 0xF6  JSR 0xF655              // MoveSTRtoTOP();                   compiler.asm:3054
0xDC65  0x20 0x4F 0xC5  JSR 0xC54F              // Emit.PopGlobal();                 compiler.asm:3057
0xDC68  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:3058
0xDC6B  0x90 0x03       BCC 0xDC70 (+3)         // if (NC) { break; }                compiler.asm:3059
0xDC6D  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();              compiler.asm:3062
0xDC70  0x7A            PLY                     // PLY                               compiler.asm:3072
0xDC71  0xFA            PLX                     // PLX                               compiler.asm:3073
0xDC72  0x68            PLA                     // PLA                               compiler.asm:3074
0xDC73  0x60            RTS                     // }                                 compiler.asm:3075

// /source/projects/6502sbc/hopperbasic/compiler.asm:3082
// ####  Compiler.compileIdentifierStatement()  ####                            0x0245

0xDC74  0x20 0x21 0xDD  JSR 0xDD21              // Statement.ResolveIdentifier();    Uses same logic as REPL
0xDC77  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:3092
0xDC7A  0xB0 0x01       BCS 0xDC7D (+1)         // if (NC) { break; }                compiler.asm:3093
0xDC7C  0x60            RTS
0xDC7D  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       compiler.asm:3095
0xDC7F  0xC9 0x03       CMP # 0x03              // case IdentifierType.Function:     compiler.asm:3098
0xDC81  0xD0 0x17       BNE 0xDC9A (+23)
0xDC83  0x20 0x58 0xD4  JSR 0xD458              // compileFunctionCallOrVariable();  compiler.asm:3101
0xDC86  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:3102
0xDC89  0xB0 0x01       BCS 0xDC8C (+1)         // if (NC) { break; }                compiler.asm:3103
0xDC8B  0x60            RTS
0xDC8C  0xA9 0x01       LDA # 1                 // LDA #0x01     Decrement by 1 position
0xDC8E  0x20 0xE0 0xC5  JSR 0xC5E0              // Emit.DecSp();                     compiler.asm:3107
0xDC91  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:3108
0xDC94  0x90 0x03       BCC 0xDC99 (+3)         // if (NC) { break; }                compiler.asm:3109
0xDC96  0x4C 0xBB 0x89  JMP 0x89BB
0xDC99  0x60            RTS
0xDC9A  0xC9 0x01       CMP # 1                 // case IdentifierType.Global:       compiler.asm:3114
0xDC9C  0xF0 0x04       BEQ 0xDCA2 (+4)
0xDC9E  0xC9 0x04       CMP # 0x04              // case IdentifierType.Local:     Add this case
0xDCA0  0xD0 0x0B       BNE 0xDCAD (+11)
0xDCA2  0x20 0x21 0xDB  JSR 0xDB21              // compileAssignment();              compiler.asm:3117
0xDCA5  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:3118
0xDCA8  0x90 0x2A       BCC 0xDCD4 (+42)        // if (NC) { break; }                compiler.asm:3119
0xDCAA  0x4C 0xBB 0x89  JMP 0x89BB
0xDCAD  0xC9 0x02       CMP # 0x02              // case IdentifierType.Constant:     compiler.asm:3124
0xDCAF  0xD0 0x14       BNE 0xDCC5 (+20)
0xDCB1  0x5F 0x02 0x0B  BBR5 0x02, 0xDCBF (+11) // if (BBS5, ZP.FLAGS)               compiler.asm:3126
0xDCB4  0x20 0x21 0xDB  JSR 0xDB21              // compileAssignment();              compiler.asm:3129
0xDCB7  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:3130
0xDCBA  0x90 0x18       BCC 0xDCD4 (+24)        // if (NC) { break; }                compiler.asm:3131
0xDCBC  0x4C 0xBB 0x89  JMP 0x89BB
0xDCBF  0x20 0x24 0x8C  JSR 0x8C24              // Error.IllegalAssignment(); BIT ZP.EmulatorPCL
0xDCC2  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compiler.asm:3138
0xDCC4  0x60            RTS                     // break;                            compiler.asm:3140
0xDCC5  0xC9 0x05       CMP # 0x05              // case IdentifierType.Keyword:      compiler.asm:3142
0xDCC7  0xD0 0x06       BNE 0xDCCF (+6)
0xDCC9  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xDCCC  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compiler.asm:3146
0xDCCE  0x60            RTS                     // break;                            compiler.asm:3147
0xDCCF  0x20 0x8F 0x8B  JSR 0x8B8F              // Error.UndefinedIdentifierTOP(); BIT ZP.EmulatorPCL    if ResolveIdentifier failed, TOP
0xDCD2  0x64 0x4E       STZ 0x4E                // States.SetFailure();              compiler.asm:3153
0xDCD4  0x60            RTS                     // }                                 compiler.asm:3165

// /source/projects/6502sbc/hopperbasic/compiler.asm:3173
// ####  Compiler.InFunction()  ####                                            0x0246

0xDCD5  0x48            PHA                     // PHA                               compiler.asm:3174
0xDCD6  0xAD 0x89 0x0B  LDA 0x0B89              // LDA compilerSavedNodeAddrL        compiler.asm:3177
0xDCD9  0x0D 0x8A 0x0B  ORA 0x0B8A              // ORA compilerSavedNodeAddrH        compiler.asm:3178
0xDCDC  0xF0 0x03       BEQ 0xDCE1 (+3)         // if (NZ)                           compiler.asm:3179
0xDCDE  0x38            SEC                     // SEC     We're in a function context
0xDCDF  0x80 0x01       BRA 0xDCE2 (+1)         // }                                 compiler.asm:3182
0xDCE1  0x18            CLC                     // CLC     Not in a function context compiler.asm:3185
0xDCE2  0x68            PLA                     // PLA                               compiler.asm:3188
0xDCE3  0x60            RTS                     // }                                 compiler.asm:3189

// /source/projects/6502sbc/hopperbasic/compiler.asm:3198
// ####  Compiler.compileCLSStatement()  ####                                   0x0247

0xDCE4  0x20 0xC9 0xBD  JSR 0xBDC9              // Tokenizer.NextTokenCheckSetFailure();
0xDCE7  0x90 0x17       BCC 0xDD00 (+23)        // if (NC) { break; }                compiler.asm:3207
0xDCE9  0xA9 0x48       LDA # 0x48              // LDA #'H'    "ESC[H" : move cursor to (1,1)
0xDCEB  0x20 0xF0 0xC5  JSR 0xC5F0              // Emit.VT100Escape();               compiler.asm:3212
0xDCEE  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:3213
0xDCF1  0x90 0x0D       BCC 0xDD00 (+13)        // if (NC) { break; }                compiler.asm:3214
0xDCF3  0xA9 0x4A       LDA # 0x4A              // LDA #'J'    "ESC[J" : clear from cursor to end of screen
0xDCF5  0x20 0xF0 0xC5  JSR 0xC5F0              // Emit.VT100Escape();               compiler.asm:3216
0xDCF8  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        compiler.asm:3217
0xDCFB  0x90 0x03       BCC 0xDD00 (+3)         // if (NC) { break; }                compiler.asm:3218
0xDCFD  0x4C 0xBB 0x89  JMP 0x89BB
0xDD00  0x60            RTS                     // }                                 compiler.asm:3227

// /source/projects/6502sbc/hopperbasic/statement.asm:41
// ####  Statement.calculateTokensLength()  ####                                0x0248

0xDD01  0x38            SEC                     // SEC                               statement.asm:42
0xDD02  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              statement.asm:43
0xDD04  0xE5 0x61       SBC 0x61                // SBC ZP.FSOURCEADDRESSL            statement.asm:44
0xDD06  0x85 0x65       STA 0x65                // STA ZP.FLENGTHL     Length low    statement.asm:45
0xDD08  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              statement.asm:46
0xDD0A  0xE5 0x62       SBC 0x62                // SBC ZP.FSOURCEADDRESSH            statement.asm:47
0xDD0C  0x85 0x66       STA 0x66                // STA ZP.FLENGTHH     Length high   statement.asm:48
0xDD0E  0x60            RTS                     // }                                 statement.asm:49

// /source/projects/6502sbc/hopperbasic/statement.asm:67
// ####  Statement.IsCaptureModeOff()  ####                                     0x024A

0xDD0F  0xAD 0xB3 0x0B  LDA 0x0BB3              // LDA funcCaptureMode               statement.asm:68
0xDD12  0xD0 0x02       BNE 0xDD16 (+2)         // if (Z)                            statement.asm:70
0xDD14  0x38            SEC                     // SEC    C = CaptureMode.Off        statement.asm:72
0xDD15  0x60            RTS                     // }                                 statement.asm:73
0xDD16  0x18            CLC                     // CLC    NC = not CaptureMode.Off   statement.asm:76
0xDD17  0x60            RTS                     // }                                 statement.asm:78

// /source/projects/6502sbc/hopperbasic/statement.asm:80
// ####  Statement.IsCaptureModeOn()  ####                                      0x024B

0xDD18  0xAD 0xB3 0x0B  LDA 0x0BB3              // LDA funcCaptureMode               statement.asm:81
0xDD1B  0xD0 0x02       BNE 0xDD1F (+2)         // if (Z)                            statement.asm:83
0xDD1D  0x18            CLC                     // CLC    NC = CaptureMode.Off       statement.asm:85
0xDD1E  0x60            RTS                     // }                                 statement.asm:86
0xDD1F  0x38            SEC                     // SEC    C = not CaptureMode.Off    statement.asm:89
0xDD20  0x60            RTS                     // }                                 statement.asm:91

// /source/projects/6502sbc/hopperbasic/statement.asm:148
// ####  Statement.ResolveIdentifier()  ####                                    0x0251

0xDD21  0x48            PHA                     // PHA                               statement.asm:149
0xDD22  0xDA            PHX                     // PHX                               statement.asm:150
0xDD23  0x5A            PHY                     // PHY                               statement.asm:151
0xDD24  0x20 0x6A 0x8A  JSR 0x8A6A              // Tokens.IsKeyword();    Input: A = token value to check
0xDD27  0x90 0x06       BCC 0xDD2F (+6)         // if (C)                            statement.asm:163
0xDD29  0xA9 0x05       LDA # 0x05              // LDA #IdentifierType.Keyword       statement.asm:165
0xDD2B  0x85 0x10       STA 0x10                // STA ZP.ACCT                       statement.asm:166
0xDD2D  0x80 0x20       BRA 0xDD4F (+32)        // break;    success                 statement.asm:167
0xDD2F  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();     Result in ZP.TOP
0xDD32  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     statement.asm:172
0xDD35  0x90 0x18       BCC 0xDD4F (+24)        // if (NC) { break; }                statement.asm:173
0xDD37  0x20 0xC6 0xA6  JSR 0xA6C6              // Locals.Resolve();    Input: ZP.TOP = name, Output: C = found, ZP.IDX = node, ACCT = type
0xDD3A  0xB0 0x13       BCS 0xDD4F (+19)        // if (C)                            statement.asm:177
0xDD3C  0x20 0x5A 0xA4  JSR 0xA45A              // Variables.Resolve();    Input: ZP.TOP = name, Output: C = found, ACCT = type, ZP.IDX = node
0xDD3F  0xB0 0x0E       BCS 0xDD4F (+14)        // if (C)                            statement.asm:184
0xDD41  0x20 0x99 0xA7  JSR 0xA799              // Functions.Find();    Input: ZP.TOP = name, Output: C = found, ZP.IDX = node, ZP.ACCL = signed one byte BP offset
0xDD44  0x90 0x06       BCC 0xDD4C (+6)         // if (C)                            statement.asm:192
0xDD46  0xA9 0x03       LDA # 0x03              // LDA # IdentifierType.Function     statement.asm:194
0xDD48  0x85 0x10       STA 0x10                // STA ZP.ACCT                       statement.asm:195
0xDD4A  0x80 0x03       BRA 0xDD4F (+3)         // break;    success                 statement.asm:196
0xDD4C  0xA9 0x00       LDA # 0                 // LDA #IdentifierType.Undefined     statement.asm:200
0xDD4E  0x18            CLC                     // CLC                               statement.asm:201
0xDD4F  0x7A            PLY                     // PLY                               statement.asm:209
0xDD50  0xFA            PLX                     // PLX                               statement.asm:210
0xDD51  0x68            PLA                     // PLA                               statement.asm:211
0xDD52  0x60            RTS                     // }                                 statement.asm:212

// /source/projects/6502sbc/hopperbasic/statement.asm:223
// ####  Statement.EvaluateExpression()  ####                                   0x0252

0xDD53  0x20 0x6F 0xD0  JSR 0xD06F              // Compiler.SetLiteralBase();        statement.asm:230
0xDD56  0x20 0xEE 0xD7  JSR 0xD7EE              // Compiler.CompileExpression();     statement.asm:231
0xDD59  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        statement.asm:232
0xDD5C  0x90 0x2B       BCC 0xDD89 (+43)        // if (NC) { break; }                statement.asm:233
0xDD5E  0x0F 0x36 0x06  BBR0 0x36, 0xDD67 (+6)  // if (BBS0, ZP.CompilerFlags)       statement.asm:235
0xDD61  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();                   statement.asm:238
0xDD64  0x4C 0xBB 0x89  JMP 0x89BB              // States.SetSuccess();              statement.asm:239
0xDD67  0x20 0x30 0xC6  JSR 0xC630              // Emit.Halt();                      statement.asm:244
0xDD6A  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        statement.asm:245
0xDD6D  0x90 0x1A       BCC 0xDD89 (+26)        // if (NC) { break; }                statement.asm:246
0xDD6F  0xA5 0x32       LDA 0x32                // LDA ZP.OpCodeBufferContentLengthL statement.asm:249
0xDD71  0x48            PHA                     // PHA                               statement.asm:250
0xDD72  0xA5 0x33       LDA 0x33                // LDA ZP.OpCodeBufferContentLengthH statement.asm:251
0xDD74  0x48            PHA                     // PHA                               statement.asm:252
0xDD75  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();    clear     statement.asm:254
0xDD78  0x20 0xF3 0xE7  JSR 0xE7F3              // Executor.ExecuteOpCodes();        statement.asm:257
0xDD7B  0x68            PLA                     // PLA                               statement.asm:260
0xDD7C  0x85 0x33       STA 0x33                // STA ZP.OpCodeBufferContentLengthH statement.asm:261
0xDD7E  0x68            PLA                     // PLA                               statement.asm:262
0xDD7F  0x85 0x32       STA 0x32                // STA ZP.OpCodeBufferContentLengthL statement.asm:263
0xDD81  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        statement.asm:265
0xDD84  0x90 0x03       BCC 0xDD89 (+3)         // if (NC) { break; }                statement.asm:266
0xDD86  0x4C 0xBB 0x89  JMP 0x89BB
0xDD89  0x60            RTS                     // }                                 statement.asm:276

// /source/projects/6502sbc/hopperbasic/statement.asm:290
// ####  Statement.ExecuteStatement()  ####                                     0x0253

0xDD8A  0x20 0x6F 0xD0  JSR 0xD06F              // Compiler.SetLiteralBase();        statement.asm:298
0xDD8D  0x20 0x95 0x96  JSR 0x9695              // BufferManager.UseREPLOpCodeBuffer();
0xDD90  0x20 0x49 0xD0  JSR 0xD049              // Compiler.InitOpCodeBuffer();      statement.asm:302
0xDD93  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        statement.asm:303
0xDD96  0x90 0x2D       BCC 0xDDC5 (+45)        // if (NC) { break; }                statement.asm:304
0xDD98  0x20 0x87 0xD9  JSR 0xD987              // Compiler.CompileStatement();      statement.asm:307
0xDD9B  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        statement.asm:308
0xDD9E  0x90 0x25       BCC 0xDDC5 (+37)        // if (NC) { break; }                statement.asm:309
0xDDA0  0x20 0x30 0xC6  JSR 0xC630              // Emit.Halt();                      statement.asm:312
0xDDA3  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        statement.asm:313
0xDDA6  0x90 0x1D       BCC 0xDDC5 (+29)        // if (NC) { break; }                statement.asm:314
0xDDA8  0xA5 0x32       LDA 0x32                // LDA ZP.OpCodeBufferContentLengthL statement.asm:317
0xDDAA  0x48            PHA                     // PHA                               statement.asm:318
0xDDAB  0xA5 0x33       LDA 0x33                // LDA ZP.OpCodeBufferContentLengthH statement.asm:319
0xDDAD  0x48            PHA                     // PHA                               statement.asm:320
0xDDAE  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();    Clear state
0xDDB1  0x20 0xF3 0xE7  JSR 0xE7F3              // Executor.ExecuteOpCodes();        statement.asm:325
0xDDB4  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     statement.asm:326
0xDDB7  0x68            PLA                     // PLA                               statement.asm:329
0xDDB8  0x85 0x33       STA 0x33                // STA ZP.OpCodeBufferContentLengthH statement.asm:330
0xDDBA  0x68            PLA                     // PLA                               statement.asm:331
0xDDBB  0x85 0x32       STA 0x32                // STA ZP.OpCodeBufferContentLengthL statement.asm:332
0xDDBD  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        statement.asm:334
0xDDC0  0x90 0x03       BCC 0xDDC5 (+3)         // if (NC) { break; }                statement.asm:335
0xDDC2  0x4C 0xBB 0x89  JMP 0x89BB
0xDDC5  0x60            RTS                     // }                                 statement.asm:344

// /source/projects/6502sbc/hopperbasic/statement.asm:355
// ####  Statement.Execute()  ####                                              0x0254

0xDDC6  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               statement.asm:360
0xDDC8  0xC9 0x94       CMP # 0x94              // case Token.REM:                   statement.asm:364
0xDDCA  0xF0 0x04       BEQ 0xDDD0 (+4)
0xDDCC  0xC9 0x95       CMP # 0x95              // case Token.COMMENT:               statement.asm:365
0xDDCE  0xD0 0x06       BNE 0xDDD6 (+6)
0xDDD0  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no      statement.asm:368
0xDDD3  0x38            SEC                     // SEC     Success                   statement.asm:369
0xDDD4  0x80 0x75       BRA 0xDE4B (+117)       // }                                 statement.asm:370
0xDDD6  0xC9 0xA5       CMP # 0xA5              // case Token.FUNC:                  statement.asm:371
0xDDD8  0xD0 0x05       BNE 0xDDDF (+5)
0xDDDA  0x20 0x70 0xC1  JSR 0xC170              // FunctionDeclaration.ExecuteFunctionDeclaration();
0xDDDD  0x80 0x6C       BRA 0xDE4B (+108)       // }                                 statement.asm:374
0xDDDF  0xC9 0xA8       CMP # 0xA8              // case Token.BEGIN:                 statement.asm:375
0xDDE1  0xD0 0x05       BNE 0xDDE8 (+5)
0xDDE3  0x20 0x33 0xC1  JSR 0xC133              // FunctionDeclaration.ExecuteBeginDeclaration();
0xDDE6  0x80 0x63       BRA 0xDE4B (+99)        // }                                 statement.asm:378
0xDDE8  0xC9 0xCD       CMP # 0xCD              // case Token.WRITE:                 statement.asm:380
0xDDEA  0xF0 0x20       BEQ 0xDE0C (+32)
0xDDEC  0xC9 0xC3       CMP # 0xC3              // case Token.POKE:                  statement.asm:381
0xDDEE  0xF0 0x1C       BEQ 0xDE0C (+28)
0xDDF0  0xC9 0xC6       CMP # 0xC6              // case Token.DELAY:                 statement.asm:382
0xDDF2  0xF0 0x18       BEQ 0xDE0C (+24)
0xDDF4  0xC9 0xCB       CMP # 0xCB              // case Token.PINMODE:               statement.asm:383
0xDDF6  0xF0 0x14       BEQ 0xDE0C (+20)
0xDDF8  0xC9 0xD6       CMP # 0xD6              // case Token.EXPORT:                statement.asm:385
0xDDFA  0xF0 0x10       BEQ 0xDE0C (+16)
0xDDFC  0xC9 0xD5       CMP # 0xD5              // case Token.IMPORT:                statement.asm:386
0xDDFE  0xF0 0x0C       BEQ 0xDE0C (+12)
0xDE00  0xC9 0x9F       CMP # 0x9F              // case Token.PRINT:                 statement.asm:388
0xDE02  0xF0 0x08       BEQ 0xDE0C (+8)
0xDE04  0xC9 0xC7       CMP # 0xC7              // case Token.CLS:                   statement.asm:389
0xDE06  0xF0 0x04       BEQ 0xDE0C (+4)
0xDE08  0xC9 0xDA       CMP # 0xDA              // case Token.IDENTIFIER:    Could be assignment or function call
0xDE0A  0xD0 0x09       BNE 0xDE15 (+9)
0xDE0C  0xC7 0x02       SMB4 0x02               // SMB4 ZP.FLAGS    Bit 4 - initialization mode: Load and Save globals to stack (ExecuteOpCodes)
0xDE0E  0xD7 0x02       SMB5 0x02               // SMB5 ZP.FLAGS    Bit 5 - initialization mode: do not create a RETURN slot for REPL calls (in compileFunctionCallOrVariable)
0xDE10  0x20 0x8A 0xDD  JSR 0xDD8A              // Statement.ExecuteStatement();    EXECUTION: IDENTIFIER, IDENTIFIER(), PRINT, CLS - GLOBAL LOAD SAVE
0xDE13  0x80 0x36       BRA 0xDE4B (+54)        // }                                 statement.asm:395
0xDE15  0xC9 0x9E       CMP # 0x9E              // case Token.CONST:                 statement.asm:397
0xDE17  0xD0 0x05       BNE 0xDE1E (+5)
0xDE19  0x20 0x5F 0xDE  JSR 0xDE5F              // executeConstantDeclaration();     statement.asm:399
0xDE1C  0x80 0x2D       BRA 0xDE4B (+45)        // }                                 statement.asm:400
0xDE1E  0xC9 0x96       CMP # 0x96              // case Token.INT:                   statement.asm:403
0xDE20  0xF0 0x14       BEQ 0xDE36 (+20)
0xDE22  0xC9 0x97       CMP # 0x97              // case Token.WORD:                  statement.asm:404
0xDE24  0xF0 0x10       BEQ 0xDE36 (+16)
0xDE26  0xC9 0x99       CMP # 0x99              // case Token.BYTE:                  statement.asm:405
0xDE28  0xF0 0x0C       BEQ 0xDE36 (+12)
0xDE2A  0xC9 0x98       CMP # 0x98              // case Token.BIT:                   statement.asm:406
0xDE2C  0xF0 0x08       BEQ 0xDE36 (+8)
0xDE2E  0xC9 0x9C       CMP # 0x9C              // case Token.CHAR:                  statement.asm:407
0xDE30  0xF0 0x04       BEQ 0xDE36 (+4)
0xDE32  0xC9 0x9D       CMP # 0x9D              // case Token.VAR:                   statement.asm:410
0xDE34  0xD0 0x05       BNE 0xDE3B (+5)
0xDE36  0x20 0x78 0xDE  JSR 0xDE78              // executeVariableDeclaration();     statement.asm:412
0xDE39  0x80 0x10       BRA 0xDE4B (+16)        // }                                 statement.asm:413
0xDE3B  0xC9 0x9B       CMP # 0x9B              // case Token.STRING:                statement.asm:415
0xDE3D  0xF0 0x04       BEQ 0xDE43 (+4)
0xDE3F  0xC9 0x9A       CMP # 0x9A              // case Token.LONG:                  statement.asm:416
0xDE41  0xD0 0x05       BNE 0xDE48 (+5)
0xDE43  0x20 0x99 0x8B  JSR 0x8B99              // Error.IllegalType(); BIT ZP.EmulatorPCL     ZP.CurrentToken
0xDE46  0x80 0x03       BRA 0xDE4B (+3)         // }                                 statement.asm:419
0xDE48  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xDE4B  0xB0 0x01       BCS 0xDE4E (+1)         // if (C)    Only if statement executed successfully
0xDE4D  0x60            RTS
0xDE4E  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               statement.asm:430
0xDE50  0xC9 0x94       CMP # 0x94              // CMP #Token.REM                    statement.asm:431
0xDE52  0xD0 0x03       BNE 0xDE57 (+3)         // if (Z)                            statement.asm:432
0xDE54  0x4C 0xD2 0xBD  JMP 0xBDD2              // Tokenizer.NextToken();    no, Skip REM and consume comment text
0xDE57  0xC9 0x95       CMP # 0x95              // CMP #Token.COMMENT                statement.asm:438
0xDE59  0xF0 0x01       BEQ 0xDE5C (+1)         // if (Z)                            statement.asm:439
0xDE5B  0x60            RTS
0xDE5C  0x4C 0xD2 0xBD  JMP 0xBDD2              // Tokenizer.NextToken();    no, Skip COMMENT and consume comment text

// /source/projects/6502sbc/hopperbasic/statement.asm:461
// ####  Statement.executeConstantDeclaration()  ####                           0x0255

0xDE5F  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no, consume 'CONST'
0xDE62  0xB0 0x03       BCS 0xDE67 (+3)         // if (NC)                           statement.asm:468
0xDE64  0x4C 0x7B 0x8B  JMP 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xDE67  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               statement.asm:475
0xDE69  0xC9 0x9D       CMP # 0x9D              // CMP #Token.VAR                    statement.asm:476
0xDE6B  0xD0 0x03       BNE 0xDE70 (+3)         // if (Z)                            statement.asm:477
0xDE6D  0x4C 0x7B 0x8B  JMP 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xDE70  0xA9 0x80       LDA # 0x80              // LDA #SymbolType.CONSTANT          statement.asm:484
0xDE72  0x8D 0xAC 0x0B  STA 0x0BAC              // STA stmtSymbol                    statement.asm:485
0xDE75  0x4C 0x90 0xDE  JMP 0xDE90              // processSingleSymbolDeclaration(); statement.asm:486

// /source/projects/6502sbc/hopperbasic/statement.asm:504
// ####  Statement.executeVariableDeclaration()  ####                           0x0256

0xDE78  0xA9 0x40       LDA # 0x40              // LDA #SymbolType.VARIABLE          statement.asm:509
0xDE7A  0x8D 0xAC 0x0B  STA 0x0BAC              // STA stmtSymbol                    statement.asm:510
0xDE7D  0x20 0x90 0xDE  JSR 0xDE90              // processSingleSymbolDeclaration();    Consumes VAR, processes variable
0xDE80  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     statement.asm:515
0xDE83  0x90 0x0A       BCC 0xDE8F (+10)        // if (NC) { break; }                statement.asm:516
0xDE85  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               statement.asm:519
0xDE87  0xC9 0xDF       CMP # 0xDF              // CMP #Token.COMMA                  statement.asm:520
0xDE89  0xD0 0x04       BNE 0xDE8F (+4)         // if (NZ) { break; }                statement.asm:521
0xDE8B  0xA2 0x9D       LDX # 0x9D              // LDX #Token.VAR                    statement.asm:524
0xDE8D  0x80 0xEE       BRA 0xDE7D (-18)        // }                                 statement.asm:525
0xDE8F  0x60            RTS                     // }                                 statement.asm:530

// /source/projects/6502sbc/hopperbasic/statement.asm:535
// ####  Statement.processSingleSymbolDeclaration()  ####                       0x0257

0xDE90  0x9C 0xB1 0x0B  STZ 0x0BB1              // STZ (stmtStringPtr + 0)           statement.asm:543
0xDE93  0x9C 0xB2 0x0B  STZ 0x0BB2              // STZ (stmtStringPtr + 1)           statement.asm:544
0xDE96  0x9C 0xAD 0x0B  STZ 0x0BAD              // STZ stmtType                      statement.asm:550
0xDE99  0x20 0x00 0x88  JSR 0x8800              // BASICTypes.FromToken();    X -> A statement.asm:553
0xDE9C  0x90 0x1B       BCC 0xDEB9 (+27)        // if (C)                            statement.asm:554
0xDE9E  0xC9 0x10       CMP # 0x10              // CMP # BASICType.VAR               statement.asm:556
0xDEA0  0xD0 0x02       BNE 0xDEA4 (+2)         // if (Z)                            statement.asm:557
0xDEA2  0x09 0x08       ORA # 0x08              // ORA # BASICType.LONG    good default until assignment says otherwise
0xDEA4  0x8D 0xAD 0x0B  STA 0x0BAD              // STA stmtType    LHS type          statement.asm:566
0xDEA7  0xAD 0xAC 0x0B  LDA 0x0BAC              // LDA stmtSymbol                    statement.asm:567
0xDEAA  0xC9 0x80       CMP # 0x80              // CMP #SymbolType.CONSTANT          statement.asm:568
0xDEAC  0xD0 0x03       BNE 0xDEB1 (+3)         // if (Z)                            statement.asm:569
0xDEAE  0x20 0xC5 0x8B  JSR 0x8BC5              // Error.IllegalIdentifier(); BIT ZP.EmulatorPCL
0xDEB1  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       statement.asm:575
0xDEB4  0xB0 0x03       BCS 0xDEB9 (+3)         // if (NC) { break; }    error exit  statement.asm:576
0xDEB6  0x4C 0x74 0xE0  JMP 0xE074
0xDEB9  0xA6 0x2F       LDX 0x2F                // LDX ZP.CurrentToken    IDENTIFIER token?
0xDEBB  0xE0 0xDA       CPX # 0xDA              // CPX # Token.IDENTIFIER            statement.asm:582
0xDEBD  0xF0 0x12       BEQ 0xDED1 (+18)        // if (NZ)                           statement.asm:583
0xDEBF  0x8A            TXA                     // TXA                               statement.asm:585
0xDEC0  0x20 0x6A 0x8A  JSR 0x8A6A              // Tokens.IsKeyword();               statement.asm:586
0xDEC3  0x90 0x05       BCC 0xDECA (+5)         // if (C)                            statement.asm:587
0xDEC5  0x20 0x99 0x8B  JSR 0x8B99              // Error.IllegalType(); BIT ZP.EmulatorPCL    ZP.CurrentToken
0xDEC8  0x80 0x03       BRA 0xDECD (+3)         // }                                 statement.asm:590
0xDECA  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xDECD  0x18            CLC                     // CLC                               statement.asm:595
0xDECE  0x4C 0x74 0xE0  JMP 0xE074              // break;    error exit              statement.asm:596
0xDED1  0x20 0x2C 0xBF  JSR 0xBF2C              // Tokenizer.GetTokenString();     Returns pointer in ZP.TOP
0xDED4  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       statement.asm:605
0xDED6  0x48            PHA                     // PHA                               statement.asm:606
0xDED7  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       statement.asm:607
0xDED9  0x48            PHA                     // PHA                               statement.asm:608
0xDEDA  0xA2 0x3E       LDX # 0x3E              // LDX #ZP.FunctionsList             statement.asm:611
0xDEDC  0x20 0x4F 0x9F  JSR 0x9F4F              // Objects.Find();    ZP.IDX = symbol node address
0xDEDF  0x90 0x07       BCC 0xDEE8 (+7)         // if (C)                            statement.asm:613
0xDEE1  0x20 0xF2 0x8B  JSR 0x8BF2              // Error.FunctionExistsTOP(); BIT ZP.EmulatorPCL    name is in ZP.TOP
0xDEE4  0x18            CLC                     // CLC     Error                     statement.asm:616
0xDEE5  0x4C 0x6E 0xE0  JMP 0xE06E              // break;                            statement.asm:617
0xDEE8  0x64 0x47       STZ 0x47                // STZ ZP.SymbolIteratorFilter    constant or variable
0xDEEA  0x20 0x8E 0xA1  JSR 0xA18E              // Variables.Find();    ZP.IDX = symbol node address
0xDEED  0x90 0x32       BCC 0xDF21 (+50)        // if (C)                            statement.asm:622
0xDEEF  0x20 0xA9 0xA2  JSR 0xA2A9              // Variables.GetType();    Input: ZP.IDX, Output: ZP.ACCT = symbolType|dataType
0xDEF2  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     statement.asm:626
0xDEF5  0xB0 0x03       BCS 0xDEFA (+3)         // if (NC) { break; }                statement.asm:627
0xDEF7  0x4C 0x6E 0xE0  JMP 0xE06E
0xDEFA  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       statement.asm:629
0xDEFC  0x29 0xC0       AND # 0xC0              // AND # SymbolType.MASK     Extract existing symbol type
0xDEFE  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT              Temporarily store existing type
0xDF00  0xAD 0xAC 0x0B  LDA 0x0BAC              // LDA stmtSymbol    New symbol type (VARIABLE or CONSTANT)
0xDF03  0xC5 0x1A       CMP 0x1A                // CMP ZP.NEXTT                      statement.asm:635
0xDF05  0xF0 0x12       BEQ 0xDF19 (+18)        // if (NZ)                           statement.asm:636
0xDF07  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      statement.asm:639
0xDF09  0xC9 0x80       CMP # 0x80              // CMP # SymbolType.CONSTANT         statement.asm:640
0xDF0B  0xD0 0x05       BNE 0xDF12 (+5)         // if (Z)                            statement.asm:641
0xDF0D  0x20 0xF7 0x8B  JSR 0x8BF7              // Error.ConstantExistsTOP(); BIT ZP.EmulatorPCL    name is in ZP.TOP
0xDF10  0x80 0x03       BRA 0xDF15 (+3)         // }                                 statement.asm:644
0xDF12  0x20 0xFC 0x8B  JSR 0x8BFC              // Error.VariableExistsTOP(); BIT ZP.EmulatorPCL    name is in ZP.TOP
0xDF15  0x18            CLC                     // CLC                               statement.asm:649
0xDF16  0x4C 0x6E 0xE0  JMP 0xE06E              // break;                            statement.asm:650
0xDF19  0x20 0xF2 0xA2  JSR 0xA2F2              // Variables.Remove();    delete it (name ptr in TOP)
0xDF1C  0xB0 0x03       BCS 0xDF21 (+3)         // if (NC) { break; }                statement.asm:655
0xDF1E  0x4C 0x6E 0xE0  JMP 0xE06E
0xDF21  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       statement.asm:658
0xDF24  0xB0 0x03       BCS 0xDF29 (+3)         // if (NC) { break; }    error exit  statement.asm:659
0xDF26  0x4C 0x6E 0xE0  JMP 0xE06E
0xDF29  0x9C 0xBA 0x0B  STZ 0x0BBA              // STZ declInitializer    no initializer
0xDF2C  0xA6 0x2F       LDX 0x2F                // LDX ZP.CurrentToken               statement.asm:665
0xDF2E  0xE0 0xF0       CPX # 0xF0              // case Token.LBRACKET:              statement.asm:669
0xDF30  0xF0 0x03       BEQ 0xDF35 (+3)
0xDF32  0x4C 0xB3 0xDF  JMP 0xDFB3
0xDF35  0xAD 0xAD 0x0B  LDA 0x0BAD              // LDA stmtType                      statement.asm:673
0xDF38  0x09 0x20       ORA # 0x20              // ORA # BASICType.ARRAY             statement.asm:674
0xDF3A  0x8D 0xAD 0x0B  STA 0x0BAD              // STA stmtType                      statement.asm:675
0xDF3D  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              statement.asm:678
0xDF3F  0x48            PHA                     // PHA                               statement.asm:679
0xDF40  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              statement.asm:680
0xDF42  0x48            PHA                     // PHA                               statement.asm:681
0xDF43  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       statement.asm:684
0xDF46  0x90 0x0A       BCC 0xDF52 (+10)        // if (C)                            statement.asm:685
0xDF48  0xC7 0x02       SMB4 0x02               // SMB4 ZP.FLAGS    Bit 4 - initialization mode: Load and Save globals to stack (ExecuteOpCodes)
0xDF4A  0xD7 0x02       SMB5 0x02               // SMB5 ZP.FLAGS    Bit 5 - initialization mode: do not create a RETURN slot for REPL calls (in compileFunctionCallOrVariable)
0xDF4C  0x20 0x53 0xDD  JSR 0xDD53              // Statement.EvaluateExpression();    EXECUTION: initialize ARRAY (size expression)- GLOBAL LOAD SAVE (our current variable does not exist yet)
0xDF4F  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     statement.asm:690
0xDF52  0x68            PLA                     // PLA                               statement.asm:694
0xDF53  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            statement.asm:695
0xDF55  0x68            PLA                     // PLA                               statement.asm:696
0xDF56  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            statement.asm:697
0xDF58  0xB0 0x03       BCS 0xDF5D (+3)         // if (NC) { break; }    error exit  statement.asm:699
0xDF5A  0x4C 0x6E 0xE0  JMP 0xE06E
0xDF5D  0x20 0x01 0xDD  JSR 0xDD01              // calculateTokensLength();          statement.asm:702
0xDF60  0xA5 0x65       LDA 0x65                // LDA ZP.FLENGTHL                   statement.asm:705
0xDF62  0xD0 0x02       BNE 0xDF66 (+2)         // if (Z)                            statement.asm:706
0xDF64  0xC6 0x66       DEC 0x66                // DEC ZP.FLENGTHH                   statement.asm:708
0xDF66  0xC6 0x65       DEC 0x65                // DEC ZP.FLENGTHL                   statement.asm:710
0xDF68  0x20 0x38 0x96  JSR 0x9638              // Tools.CreateTokenStream();    Munts: A, ZP.IDY, ZP.ACC, ZP.FLENGTH, ZP.FSOURCEADDRESS, ZP.FDESTINATIONADDRESS, -> ZP.IDY
0xDF6B  0xB0 0x03       BCS 0xDF70 (+3)         // if (NC) { break; }    error exit  statement.asm:713
0xDF6D  0x4C 0x6E 0xE0  JMP 0xE06E
0xDF70  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       statement.asm:716
0xDF72  0x8D 0xA4 0x0B  STA 0x0BA4              // STA (stmtTokensPtr + 0)           statement.asm:717
0xDF75  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       statement.asm:718
0xDF77  0x8D 0xA5 0x0B  STA 0x0BA5              // STA (stmtTokensPtr + 1)           statement.asm:719
0xDF7A  0x20 0x0D 0x99  JSR 0x990D              // Long.PopNext();     Result in ZP.NEXT, type in ZP.NEXTT,  modifies X
0xDF7D  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      statement.asm:724
0xDF7F  0xC9 0x08       CMP # 0x08              // CMP # BASICType.LONG              statement.asm:725
0xDF81  0xD0 0x0D       BNE 0xDF90 (+13)        // if (Z)                            statement.asm:726
0xDF83  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      statement.asm:728
0xDF85  0x05 0x19       ORA 0x19                // ORA ZP.NEXT3    x2                statement.asm:729
0xDF87  0xF0 0x0E       BEQ 0xDF97 (+14)        // if (NZ)                           statement.asm:730
0xDF89  0x20 0x15 0x8C  JSR 0x8C15              // Error.BadIndex(); BIT ZP.EmulatorPCL
0xDF8C  0x18            CLC                     // CLC                               statement.asm:733
0xDF8D  0x4C 0x6E 0xE0  JMP 0xE06E              // break;                            statement.asm:734
0xDF90  0x20 0x15 0x8C  JSR 0x8C15              // Error.BadIndex(); BIT ZP.EmulatorPCL
0xDF93  0x18            CLC                     // CLC                               statement.asm:741
0xDF94  0x4C 0x6E 0xE0  JMP 0xE06E              // break;                            statement.asm:742
0xDF97  0xEE 0xBA 0x0B  INC 0x0BBA              // INC declInitializer               statement.asm:745
0xDF9A  0x38            SEC                     // SEC                               statement.asm:746
0xDF9B  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               statement.asm:749
0xDF9D  0xC9 0xF1       CMP # 0xF1              // CMP #Token.RBRACKET               statement.asm:750
0xDF9F  0xF0 0x07       BEQ 0xDFA8 (+7)         // if (NZ)                           statement.asm:751
0xDFA1  0x20 0xCF 0x8B  JSR 0x8BCF              // Error.ExpectedRightBracket(); BIT ZP.EmulatorPCL
0xDFA4  0x18            CLC                     // CLC                               statement.asm:754
0xDFA5  0x4C 0x6E 0xE0  JMP 0xE06E              // break;                            statement.asm:755
0xDFA8  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       statement.asm:759
0xDFAB  0xB0 0x03       BCS 0xDFB0 (+3)         // if (NC) { break; }                statement.asm:760
0xDFAD  0x4C 0x6E 0xE0  JMP 0xE06E
0xDFB0  0x4C 0x6D 0xE0  JMP 0xE06D              // }                                 statement.asm:761
0xDFB3  0xE0 0xE1       CPX # 0xE1              // case Token.EQUALS:                statement.asm:762
0xDFB5  0xD0 0x6B       BNE 0xE022 (+107)
0xDFB7  0xAD 0xAD 0x0B  LDA 0x0BAD              // LDA stmtType                      statement.asm:764
0xDFBA  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          statement.asm:765
0xDFBC  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              statement.asm:768
0xDFBE  0xF0 0x0C       BEQ 0xDFCC (+12)
0xDFC0  0xC9 0x03       CMP # 0x03              // case BASICType.BYTE:              statement.asm:769
0xDFC2  0xF0 0x08       BEQ 0xDFCC (+8)
0xDFC4  0xC9 0x02       CMP # 0x02              // case BASICType.INT:               statement.asm:770
0xDFC6  0xF0 0x04       BEQ 0xDFCC (+4)
0xDFC8  0xC9 0x04       CMP # 0x04              // case BASICType.WORD:              statement.asm:771
0xDFCA  0xD0 0x06       BNE 0xDFD2 (+6)
0xDFCC  0x20 0xC5 0x8B  JSR 0x8BC5              // Error.IllegalIdentifier(); BIT ZP.EmulatorPCL    not an ARRAY anymore
0xDFCF  0x4C 0x6E 0xE0  JMP 0xE06E              // break;                            statement.asm:774
0xDFD2  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              statement.asm:779
0xDFD4  0x48            PHA                     // PHA                               statement.asm:780
0xDFD5  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              statement.asm:781
0xDFD7  0x48            PHA                     // PHA                               statement.asm:782
0xDFD8  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();       statement.asm:785
0xDFDB  0x90 0x0A       BCC 0xDFE7 (+10)        // if (C)                            statement.asm:786
0xDFDD  0xC7 0x02       SMB4 0x02               // SMB4 ZP.FLAGS    Bit 4 - initialization mode: Load and Save globals to stack (ExecuteOpCodes)
0xDFDF  0xD7 0x02       SMB5 0x02               // SMB5 ZP.FLAGS    Bit 5 - initialization mode: do not create a RETURN slot for REPL calls (in compileFunctionCallOrVariable)
0xDFE1  0x20 0x53 0xDD  JSR 0xDD53              // Statement.EvaluateExpression();    EXECUTION: initialize global variable (RHS expression) - GLOBAL LOAD SAVE (our current variable does not exist yet)
0xDFE4  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     statement.asm:791
0xDFE7  0x68            PLA                     // PLA                               statement.asm:795
0xDFE8  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            statement.asm:796
0xDFEA  0x68            PLA                     // PLA                               statement.asm:797
0xDFEB  0x85 0x61       STA 0x61                // STA ZP.FSOURCEADDRESSL            statement.asm:798
0xDFED  0xB0 0x03       BCS 0xDFF2 (+3)         // if (NC) { break; }    error exit  statement.asm:800
0xDFEF  0x4C 0x6E 0xE0  JMP 0xE06E
0xDFF2  0x20 0x01 0xDD  JSR 0xDD01              // calculateTokensLength();          statement.asm:803
0xDFF5  0x20 0x38 0x96  JSR 0x9638              // Tools.CreateTokenStream();    Munts: A, ZP.IDY, ZP.ACC, ZP.FLENGTH, ZP.FSOURCEADDRESS, ZP.FDESTINATIONADDRESS, -> ZP.IDY
0xDFF8  0x90 0x74       BCC 0xE06E (+116)       // if (NC) { break; }    error exit  statement.asm:806
0xDFFA  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       statement.asm:809
0xDFFC  0x8D 0xA4 0x0B  STA 0x0BA4              // STA (stmtTokensPtr + 0)           statement.asm:810
0xDFFF  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       statement.asm:811
0xE001  0x8D 0xA5 0x0B  STA 0x0BA5              // STA (stmtTokensPtr + 1)           statement.asm:812
0xE004  0x20 0x0D 0x99  JSR 0x990D              // Long.PopNext();     Result in ZP.NEXT, type in ZP.NEXTT,  modifies X
0xE007  0x8F 0x36 0x12  BBS0 0x36, 0xE01C (+18) // if (BBR0, ZP.CompilerFlags)    constant expression:  was constant expression, the folded value is on VM stack
0xE00A  0xAD 0xAC 0x0B  LDA 0x0BAC              // LDA stmtSymbol                    statement.asm:818
0xE00D  0xC9 0x80       CMP # 0x80              // CMP #SymbolType.CONSTANT          statement.asm:819
0xE00F  0xD0 0x0B       BNE 0xE01C (+11)        // if (Z)                            statement.asm:820
0xE011  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      statement.asm:822
0xE013  0xC9 0x05       CMP # 0x05              // CMP #BASICType.STRING    constant expression of sorts
0xE015  0xF0 0x05       BEQ 0xE01C (+5)         // if (NZ)                           statement.asm:824
0xE017  0x20 0x1A 0x8C  JSR 0x8C1A              // Error.ConstantExpressionExpected(); BIT ZP.EmulatorPCL
0xE01A  0x80 0x52       BRA 0xE06E (+82)        // break;    error exit              statement.asm:827
0xE01C  0xEE 0xBA 0x0B  INC 0x0BBA              // INC declInitializer               statement.asm:833
0xE01F  0x38            SEC                     // SEC                               statement.asm:834
0xE020  0x80 0x4B       BRA 0xE06D (+75)        // }                                 statement.asm:835
0xE022  0xE0 0x95       CPX # 0x95              // case Token.COMMENT:               statement.asm:836
0xE024  0xF0 0x0C       BEQ 0xE032 (+12)
0xE026  0xE0 0xDC       CPX # 0xDC              // case Token.EOL:                   statement.asm:837
0xE028  0xF0 0x08       BEQ 0xE032 (+8)
0xE02A  0xE0 0xDE       CPX # 0xDE              // case Token.COLON:                 statement.asm:838
0xE02C  0xF0 0x04       BEQ 0xE032 (+4)
0xE02E  0xE0 0xDF       CPX # 0xDF              // case Token.COMMA:                 statement.asm:839
0xE030  0xD0 0x35       BNE 0xE067 (+53)
0xE032  0xAD 0xAC 0x0B  LDA 0x0BAC              // LDA stmtSymbol                    statement.asm:841
0xE035  0xC9 0x80       CMP # 0x80              // CMP #SymbolType.CONSTANT          statement.asm:842
0xE037  0xD0 0x06       BNE 0xE03F (+6)         // if (Z)                            statement.asm:843
0xE039  0x20 0x1A 0x8C  JSR 0x8C1A              // Error.ConstantExpressionExpected(); BIT ZP.EmulatorPCL
0xE03C  0x18            CLC                     // CLC                               statement.asm:847
0xE03D  0x80 0x2F       BRA 0xE06E (+47)        // break;    error exit              statement.asm:848
0xE03F  0xAD 0xAD 0x0B  LDA 0x0BAD              // LDA stmtType                      statement.asm:851
0xE042  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          statement.asm:852
0xE044  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              statement.asm:855
0xE046  0xF0 0x0C       BEQ 0xE054 (+12)
0xE048  0xC9 0x03       CMP # 0x03              // case BASICType.BYTE:              statement.asm:856
0xE04A  0xF0 0x08       BEQ 0xE054 (+8)
0xE04C  0xC9 0x02       CMP # 0x02              // case BASICType.INT:               statement.asm:857
0xE04E  0xF0 0x04       BEQ 0xE054 (+4)
0xE050  0xC9 0x04       CMP # 0x04              // case BASICType.WORD:              statement.asm:858
0xE052  0xD0 0x05       BNE 0xE059 (+5)
0xE054  0x20 0xC5 0x8B  JSR 0x8BC5              // Error.IllegalIdentifier(); BIT ZP.EmulatorPCL    not an ARRAY anymore
0xE057  0x80 0x15       BRA 0xE06E (+21)        // break;                            statement.asm:861
0xE059  0x20 0xA1 0x97  JSR 0x97A1              // Long.ZeroNext();                  statement.asm:866
0xE05C  0xA9 0x08       LDA # 0x08              // LDA #BASICType.LONG               statement.asm:869
0xE05E  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT                      statement.asm:870
0xE060  0x64 0x1C       STZ 0x1C                // STZ ZP.IDXH                       statement.asm:873
0xE062  0x64 0x1B       STZ 0x1B                // STZ ZP.IDXL                       statement.asm:874
0xE064  0x38            SEC                     // SEC     Success                   statement.asm:876
0xE065  0x80 0x06       BRA 0xE06D (+6)         // }                                 statement.asm:877
0xE067  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xE06A  0x18            CLC                     // CLC                               statement.asm:881
0xE06B  0x80 0x01       BRA 0xE06E (+1)         // break;    error exit              statement.asm:882
0xE06D  0x38            SEC                     // SEC     Success                   statement.asm:886
0xE06E  0x68            PLA                     // PLA                               statement.asm:890
0xE06F  0x85 0x12       STA 0x12                // STA ZP.TOP1                       statement.asm:891
0xE071  0x68            PLA                     // PLA                               statement.asm:892
0xE072  0x85 0x11       STA 0x11                // STA ZP.TOP0                       statement.asm:893
0xE074  0x90 0x46       BCC 0xE0BC (+70)        // if (NC)                           statement.asm:899
0xE076  0xAD 0xBA 0x0B  LDA 0x0BBA              // LDA declInitializer    did we have "= <expression>"?
0xE079  0xF0 0x0F       BEQ 0xE08A (+15)        // if (NZ)                           statement.asm:905
0xE07B  0xAD 0xAC 0x0B  LDA 0x0BAC              // LDA stmtSymbol                    statement.asm:910
0xE07E  0x29 0x80       AND # 0x80              // AND # SymbolType.CONSTANT         statement.asm:911
0xE080  0xF0 0x05       BEQ 0xE087 (+5)         // if (NZ)                           statement.asm:912
0xE082  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      statement.asm:915
0xE084  0x8D 0xAD 0x0B  STA 0x0BAD              // STA stmtType                      statement.asm:916
0xE087  0x38            SEC                     // SEC                               statement.asm:918
0xE088  0x80 0x01       BRA 0xE08B (+1)         // }                                 statement.asm:919
0xE08A  0x38            SEC                     // SEC    absent RHS is ok, default to INT -> 0, BIT -> FALSE, STRING -> empty
0xE08B  0xAD 0xAD 0x0B  LDA 0x0BAD              // LDA stmtType                      statement.asm:926
0xE08E  0x29 0x10       AND # 0x10              // AND # BASICType.VAR               statement.asm:927
0xE090  0xF0 0x07       BEQ 0xE099 (+7)         // if (NZ)     VAR variable          statement.asm:928
0xE092  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT     RHS type from expression
0xE094  0x09 0x10       ORA # 0x10              // ORA #BASICType.VAR     Keep VAR bit
0xE096  0x8D 0xAD 0x0B  STA 0x0BAD              // STA stmtType                      statement.asm:933
0xE099  0xAD 0xAD 0x0B  LDA 0x0BAD              // LDA stmtType     dataType (bottom 6 bits)
0xE09C  0x0D 0xAC 0x0B  ORA 0x0BAC              // ORA stmtSymbol    SymbolType (top 2 bits)
0xE09F  0x85 0x10       STA 0x10                // STA ZP.ACCT                       statement.asm:940
0xE0A1  0xAD 0xA4 0x0B  LDA 0x0BA4              // LDA (stmtTokensPtr+0)             statement.asm:942
0xE0A4  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       statement.asm:943
0xE0A6  0xAD 0xA5 0x0B  LDA 0x0BA5              // LDA (stmtTokensPtr+1)             statement.asm:944
0xE0A9  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       statement.asm:945
0xE0AB  0x20 0xF5 0xA0  JSR 0xA0F5              // Variables.Declare();              statement.asm:950
0xE0AE  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     statement.asm:951
0xE0B1  0x90 0x06       BCC 0xE0B9 (+6)         // if (C)                            statement.asm:952
0xE0B3  0x9C 0xA4 0x0B  STZ 0x0BA4              // STZ (stmtTokensPtr+0)             statement.asm:955
0xE0B6  0x9C 0xA5 0x0B  STZ 0x0BA5              // STZ (stmtTokensPtr+1)             statement.asm:956
0xE0B9  0x20 0xA7 0xA8  JSR 0xA8A7              // Functions.FreeAllOpCodes();    compiled FUNCs potentially stale now
0xE0BC  0xAD 0xA4 0x0B  LDA 0x0BA4              // LDA (stmtTokensPtr+0)             statement.asm:962
0xE0BF  0x0D 0xA5 0x0B  ORA 0x0BA5              // ORA (stmtTokensPtr+1)             statement.asm:963
0xE0C2  0xF0 0x0D       BEQ 0xE0D1 (+13)        // if (NZ)                           statement.asm:964
0xE0C4  0xAD 0xA4 0x0B  LDA 0x0BA4              // LDA (stmtTokensPtr+0)             statement.asm:966
0xE0C7  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       statement.asm:967
0xE0C9  0xAD 0xA5 0x0B  LDA 0x0BA5              // LDA (stmtTokensPtr+1)             statement.asm:968
0xE0CC  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       statement.asm:969
0xE0CE  0x20 0xB8 0x92  JSR 0x92B8              // Memory.Free();    Input: ZP.IDX, Munts: A, ZP.IDX, ZP.M* -> C on success
0xE0D1  0xAD 0xB1 0x0B  LDA 0x0BB1              // LDA (stmtStringPtr+0)             statement.asm:972
0xE0D4  0x0D 0xB2 0x0B  ORA 0x0BB2              // ORA (stmtStringPtr+1)             statement.asm:973
0xE0D7  0xD0 0x01       BNE 0xE0DA (+1)         // if (NZ)                           statement.asm:974
0xE0D9  0x60            RTS
0xE0DA  0xAD 0xB1 0x0B  LDA 0x0BB1              // LDA (stmtStringPtr+0)             statement.asm:976
0xE0DD  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       statement.asm:977
0xE0DF  0xAD 0xB2 0x0B  LDA 0x0BB2              // LDA (stmtStringPtr+1)             statement.asm:978
0xE0E2  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       statement.asm:979
0xE0E4  0x4C 0xB8 0x92  JMP 0x92B8              // Memory.Free();    Input: ZP.IDX, Munts: A, ZP.IDX, ZP.M* -> C on success

// /source/projects/6502sbc/hopperbasic/gpio.asm:14
// ####  GPIO.PinMode()  ####                                                   0x0258

0xE0E7  0xC9 0x08       CMP # 0x08              // CMP #8                            gpio.asm:16
0xE0E9  0x90 0x16       BCC 0xE101 (+22)        // if (C)                            gpio.asm:17
0xE0EB  0x38            SEC                     // SEC                               gpio.asm:20
0xE0EC  0xE9 0x08       SBC # 0x08              // SBC #8                           Convert to 0-7 range
0xE0EE  0xA8            TAY                     // TAY                              Use as index
0xE0EF  0xB9 0x98 0x85  LDA 0x8598,Y            // LDA BASICArray.BitMasks, Y      Load mask directly from table
0xE0F2  0xE0 0x00       CPX # 0                 // CPX #PINMODE.INPUT                gpio.asm:26
0xE0F4  0xD0 0x06       BNE 0xE0FC (+6)         // if (Z)                            gpio.asm:27
0xE0F6  0x49 0xFF       EOR # 0xFF              // EOR #0xFF           Invert mask   gpio.asm:30
0xE0F8  0x25 0xF2       AND 0xF2                // AND ZP.DDRB                       gpio.asm:31
0xE0FA  0x80 0x02       BRA 0xE0FE (+2)         // }                                 gpio.asm:32
0xE0FC  0x05 0xF2       ORA 0xF2                // ORA ZP.DDRB                       gpio.asm:36
0xE0FE  0x85 0xF2       STA 0xF2                // STA ZP.DDRB                       gpio.asm:38
0xE100  0x60            RTS                     // }                                 gpio.asm:39
0xE101  0xA8            TAY                     // TAY                              Use as index
0xE102  0xB9 0x98 0x85  LDA 0x8598,Y            // LDA BASICArray.BitMasks, Y      Load mask directly from table
0xE105  0xE0 0x00       CPX # 0                 // CPX #PINMODE.INPUT                gpio.asm:47
0xE107  0xD0 0x06       BNE 0xE10F (+6)         // if (Z)                            gpio.asm:48
0xE109  0x49 0xFF       EOR # 0xFF              // EOR #0xFF           Invert mask   gpio.asm:51
0xE10B  0x25 0xF3       AND 0xF3                // AND ZP.DDRA                       gpio.asm:52
0xE10D  0x80 0x02       BRA 0xE111 (+2)         // }                                 gpio.asm:53
0xE10F  0x05 0xF3       ORA 0xF3                // ORA ZP.DDRA                       gpio.asm:57
0xE111  0x85 0xF3       STA 0xF3                // STA ZP.DDRA                       gpio.asm:59
0xE113  0x60            RTS                     // }                                 gpio.asm:61

// /source/projects/6502sbc/hopperbasic/gpio.asm:68
// ####  GPIO.PinWrite()  ####                                                  0x0259

0xE114  0xC9 0x08       CMP # 0x08              // CMP #8                            gpio.asm:70
0xE116  0x90 0x16       BCC 0xE12E (+22)        // if (C)                            gpio.asm:71
0xE118  0x38            SEC                     // SEC                               gpio.asm:74
0xE119  0xE9 0x08       SBC # 0x08              // SBC #8                           Convert to 0-7 range
0xE11B  0xA8            TAY                     // TAY                              Use as index
0xE11C  0xB9 0x98 0x85  LDA 0x8598,Y            // LDA BASICArray.BitMasks, Y      Load mask directly from table
0xE11F  0xE0 0x00       CPX # 0                 // CPX #0                            gpio.asm:80
0xE121  0xD0 0x06       BNE 0xE129 (+6)         // if (Z)                            gpio.asm:81
0xE123  0x49 0xFF       EOR # 0xFF              // EOR #0xFF           Invert mask   gpio.asm:84
0xE125  0x25 0xF0       AND 0xF0                // AND ZP.PORTB                      gpio.asm:85
0xE127  0x80 0x02       BRA 0xE12B (+2)         // }                                 gpio.asm:86
0xE129  0x05 0xF0       ORA 0xF0                // ORA ZP.PORTB                      gpio.asm:90
0xE12B  0x85 0xF0       STA 0xF0                // STA ZP.PORTB                      gpio.asm:92
0xE12D  0x60            RTS                     // }                                 gpio.asm:93
0xE12E  0xA8            TAY                     // TAY                              Use as index
0xE12F  0xB9 0x98 0x85  LDA 0x8598,Y            // LDA BASICArray.BitMasks, Y      Load mask directly from table
0xE132  0xE0 0x00       CPX # 0                 // CPX #0                            gpio.asm:101
0xE134  0xD0 0x06       BNE 0xE13C (+6)         // if (Z)                            gpio.asm:102
0xE136  0x49 0xFF       EOR # 0xFF              // EOR #0xFF           Invert mask   gpio.asm:105
0xE138  0x25 0xF1       AND 0xF1                // AND ZP.PORTA                      gpio.asm:106
0xE13A  0x80 0x02       BRA 0xE13E (+2)         // }                                 gpio.asm:107
0xE13C  0x05 0xF1       ORA 0xF1                // ORA ZP.PORTA                      gpio.asm:111
0xE13E  0x85 0xF1       STA 0xF1                // STA ZP.PORTA                      gpio.asm:113
0xE140  0x60            RTS                     // }                                 gpio.asm:115

// /source/projects/6502sbc/hopperbasic/gpio.asm:122
// ####  GPIO.PinRead()  ####                                                   0x025A

0xE141  0xC9 0x08       CMP # 0x08              // CMP #8                            gpio.asm:124
0xE143  0x90 0x11       BCC 0xE156 (+17)        // if (C)                            gpio.asm:125
0xE145  0x38            SEC                     // SEC                               gpio.asm:128
0xE146  0xE9 0x08       SBC # 0x08              // SBC #8                           Convert to 0-7 range
0xE148  0xA8            TAY                     // TAY                              Use as index
0xE149  0xB9 0x98 0x85  LDA 0x8598,Y            // LDA BASICArray.BitMasks, Y      Load mask directly from table
0xE14C  0x25 0xF0       AND 0xF0                // AND ZP.PORTB                      gpio.asm:134
0xE14E  0xD0 0x03       BNE 0xE153 (+3)         // if (Z)                            gpio.asm:135
0xE150  0xA9 0x00       LDA # 0                 // LDA #0          Return 0 for LOW  gpio.asm:137
0xE152  0x60            RTS                     // }                                 gpio.asm:138
0xE153  0xA9 0x01       LDA # 1                 // LDA #1          Return 1 for HIGH gpio.asm:141
0xE155  0x60            RTS                     // }                                 gpio.asm:143
0xE156  0xA8            TAY                     // TAY                              Use as index
0xE157  0xB9 0x98 0x85  LDA 0x8598,Y            // LDA BASICArray.BitMasks, Y      Load mask directly from table
0xE15A  0x25 0xF1       AND 0xF1                // AND ZP.PORTA                      gpio.asm:151
0xE15C  0xD0 0x03       BNE 0xE161 (+3)         // if (Z)                            gpio.asm:152
0xE15E  0xA9 0x00       LDA # 0                 // LDA #0          Return 0 for LOW  gpio.asm:154
0xE160  0x60            RTS                     // }                                 gpio.asm:155
0xE161  0xA9 0x01       LDA # 1                 // LDA #1          Return 1 for HIGH gpio.asm:158
0xE163  0x60            RTS                     // }                                 gpio.asm:162

// /source/projects/6502sbc/hopperbasic/comparisoninstructions.asm:11
// ####  ComparisonInstructions.Equal()  ####                                   0x025B

0xE164  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNext();                comparisoninstructions.asm:15
0xE167  0x90 0x3D       BCC 0xE1A6 (+61)        // if (NC) { break; }                comparisoninstructions.asm:16
0xE169  0x3F 0x15 0x05  BBR3 0x15, 0xE171 (+5)  // if (BBS3, ZP.TOPT)    if either is LONG, both will be long
0xE16C  0x20 0xF2 0x99  JSR 0x99F2              // Long.EQ();                        comparisoninstructions.asm:19
0xE16F  0x38            SEC                     // SEC                               comparisoninstructions.asm:20
0xE170  0x60            RTS                     // break;                            comparisoninstructions.asm:21
0xE171  0xA2 0x00       LDX # 0                 // LDX #0             Assume false (not equal)
0xE173  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      comparisoninstructions.asm:25
0xE175  0xC5 0x15       CMP 0x15                // CMP ZP.TOPT                       comparisoninstructions.asm:26
0xE177  0xF0 0x05       BEQ 0xE17E (+5)         // if (NZ)                           comparisoninstructions.asm:27
0xE179  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE17C  0x18            CLC                     // CLC                               comparisoninstructions.asm:30
0xE17D  0x60            RTS                     // break;                            comparisoninstructions.asm:31
0xE17E  0xC9 0x05       CMP # 0x05              // case BASICType.STRING:            comparisoninstructions.asm:35
0xE180  0xD0 0x09       BNE 0xE18B (+9)
0xE182  0x20 0x0F 0x96  JSR 0x960F              // Tools.StringCompare();    Includes pointer equality optimization
0xE185  0x90 0x1B       BCC 0xE1A2 (+27)        // if (C)                            comparisoninstructions.asm:39
0xE187  0xA2 0x01       LDX # 1                 // LDX #1    Strings are equal       comparisoninstructions.asm:41
0xE189  0x80 0x17       BRA 0xE1A2 (+23)        // }                                 comparisoninstructions.asm:43
0xE18B  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              comparisoninstructions.asm:44
0xE18D  0xF0 0x04       BEQ 0xE193 (+4)
0xE18F  0xC9 0x06       CMP # 0x06              // case BASICType.BIT:               comparisoninstructions.asm:45
0xE191  0xD0 0x0A       BNE 0xE19D (+10)
0xE193  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       comparisoninstructions.asm:47
0xE195  0xC5 0x16       CMP 0x16                // CMP ZP.NEXT0                      comparisoninstructions.asm:48
0xE197  0xD0 0x09       BNE 0xE1A2 (+9)         // if (Z)                            comparisoninstructions.asm:49
0xE199  0xA2 0x01       LDX # 1                 // LDX #1    Values are equal        comparisoninstructions.asm:51
0xE19B  0x80 0x05       BRA 0xE1A2 (+5)         // }                                 comparisoninstructions.asm:53
0xE19D  0x20 0xCA 0x8B  JSR 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0xE1A0  0x18            CLC                     // CLC                               comparisoninstructions.asm:57
0xE1A1  0x60            RTS                     // break;                            comparisoninstructions.asm:58
0xE1A2  0x20 0xEA 0x94  JSR 0x94EA              // Stacks.PushX();                   comparisoninstructions.asm:62
0xE1A5  0x38            SEC                     // SEC                               comparisoninstructions.asm:63
0xE1A6  0x60            RTS                     // }                                 comparisoninstructions.asm:66

// /source/projects/6502sbc/hopperbasic/comparisoninstructions.asm:73
// ####  ComparisonInstructions.NotEqual()  ####                                0x025C

0xE1A7  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNext();                comparisoninstructions.asm:77
0xE1AA  0x90 0x3C       BCC 0xE1E8 (+60)        // if (NC) { break; }                comparisoninstructions.asm:78
0xE1AC  0x3F 0x15 0x05  BBR3 0x15, 0xE1B4 (+5)  // if (BBS3, ZP.TOPT)    if either is LONG, both will be long
0xE1AF  0x20 0xF8 0x99  JSR 0x99F8              // Long.NE();                        comparisoninstructions.asm:81
0xE1B2  0x38            SEC                     // SEC                               comparisoninstructions.asm:82
0xE1B3  0x60            RTS                     // break;                            comparisoninstructions.asm:83
0xE1B4  0xA2 0x01       LDX # 1                 // LDX #1             Assume true (not equal)
0xE1B6  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      comparisoninstructions.asm:87
0xE1B8  0xC5 0x15       CMP 0x15                // CMP ZP.TOPT                       comparisoninstructions.asm:88
0xE1BA  0xF0 0x04       BEQ 0xE1C0 (+4)         // if (NZ)                           comparisoninstructions.asm:89
0xE1BC  0x18            CLC                     // CLC                               comparisoninstructions.asm:91
0xE1BD  0x4C 0xED 0x8B  JMP 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE1C0  0xC9 0x05       CMP # 0x05              // case BASICType.STRING:            comparisoninstructions.asm:97
0xE1C2  0xD0 0x09       BNE 0xE1CD (+9)
0xE1C4  0x20 0x0F 0x96  JSR 0x960F              // Tools.StringCompare();    Includes pointer equality optimization
0xE1C7  0x90 0x1B       BCC 0xE1E4 (+27)        // if (C)                            comparisoninstructions.asm:101
0xE1C9  0xA2 0x00       LDX # 0                 // LDX #0    Strings are equal       comparisoninstructions.asm:103
0xE1CB  0x80 0x17       BRA 0xE1E4 (+23)        // }                                 comparisoninstructions.asm:105
0xE1CD  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              comparisoninstructions.asm:106
0xE1CF  0xF0 0x04       BEQ 0xE1D5 (+4)
0xE1D1  0xC9 0x06       CMP # 0x06              // case BASICType.BIT:               comparisoninstructions.asm:107
0xE1D3  0xD0 0x0A       BNE 0xE1DF (+10)
0xE1D5  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       comparisoninstructions.asm:109
0xE1D7  0xC5 0x16       CMP 0x16                // CMP ZP.NEXT0                      comparisoninstructions.asm:110
0xE1D9  0xD0 0x09       BNE 0xE1E4 (+9)         // if (Z)                            comparisoninstructions.asm:111
0xE1DB  0xA2 0x00       LDX # 0                 // LDX #0    Values are equal        comparisoninstructions.asm:113
0xE1DD  0x80 0x05       BRA 0xE1E4 (+5)         // }                                 comparisoninstructions.asm:115
0xE1DF  0x20 0xCA 0x8B  JSR 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0xE1E2  0x18            CLC                     // CLC                               comparisoninstructions.asm:119
0xE1E3  0x60            RTS                     // break;                            comparisoninstructions.asm:120
0xE1E4  0x20 0xEA 0x94  JSR 0x94EA              // Stacks.PushX();                   comparisoninstructions.asm:124
0xE1E7  0x38            SEC                     // SEC                               comparisoninstructions.asm:125
0xE1E8  0x60            RTS                     // }                                 comparisoninstructions.asm:128

// /source/projects/6502sbc/hopperbasic/comparisoninstructions.asm:135
// ####  ComparisonInstructions.LessThan()  ####                                0x025D

0xE1E9  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNext();                comparisoninstructions.asm:139
0xE1EC  0x90 0x32       BCC 0xE220 (+50)        // if (NC) { break; }                comparisoninstructions.asm:140
0xE1EE  0x3F 0x15 0x05  BBR3 0x15, 0xE1F6 (+5)  // if (BBS3, ZP.TOPT)    if either is LONG, both will be long
0xE1F1  0x20 0xE3 0x99  JSR 0x99E3              // Long.LT();                        comparisoninstructions.asm:143
0xE1F4  0x38            SEC                     // SEC                               comparisoninstructions.asm:144
0xE1F5  0x60            RTS                     // break;                            comparisoninstructions.asm:145
0xE1F6  0xA2 0x00       LDX # 0                 // LDX #0    false                   comparisoninstructions.asm:148
0xE1F8  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      comparisoninstructions.asm:150
0xE1FA  0xC5 0x15       CMP 0x15                // CMP ZP.TOPT                       comparisoninstructions.asm:151
0xE1FC  0xF0 0x05       BEQ 0xE203 (+5)         // if (NZ)                           comparisoninstructions.asm:152
0xE1FE  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE201  0x18            CLC                     // CLC                               comparisoninstructions.asm:155
0xE202  0x60            RTS                     // break;    BIT type mismatch       comparisoninstructions.asm:156
0xE203  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              comparisoninstructions.asm:160
0xE205  0xF0 0x03       BEQ 0xE20A (+3)
0xE207  0x4C 0x29 0x8C  JMP 0x8C29
0xE20A  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      comparisoninstructions.asm:162
0xE20C  0xC5 0x11       CMP 0x11                // CMP ZP.TOP0                       comparisoninstructions.asm:163
0xE20E  0xD0 0x04       BNE 0xE214 (+4)         // if (Z)                            comparisoninstructions.asm:164
0xE210  0xA2 0x00       LDX # 0                 // LDX #0         NEXT == TOP        comparisoninstructions.asm:166
0xE212  0x80 0x08       BRA 0xE21C (+8)         // }                                 comparisoninstructions.asm:167
0xE214  0x90 0x04       BCC 0xE21A (+4)         // else if (C)                       comparisoninstructions.asm:168
0xE216  0xA2 0x00       LDX # 0                 // LDX #0         NEXT > TOP         comparisoninstructions.asm:170
0xE218  0x80 0x02       BRA 0xE21C (+2)         // }                                 comparisoninstructions.asm:171
0xE21A  0xA2 0x01       LDX # 1                 // LDX #1         NEXT < TOP         comparisoninstructions.asm:174
0xE21C  0x20 0xEA 0x94  JSR 0x94EA              // Stacks.PushX();                   comparisoninstructions.asm:184
0xE21F  0x38            SEC                     // SEC                               comparisoninstructions.asm:185
0xE220  0x60            RTS                     // }                                 comparisoninstructions.asm:188

// /source/projects/6502sbc/hopperbasic/comparisoninstructions.asm:195
// ####  ComparisonInstructions.GreaterThan()  ####                             0x025E

0xE221  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNext();                comparisoninstructions.asm:199
0xE224  0x90 0x32       BCC 0xE258 (+50)        // if (NC) { break; }                comparisoninstructions.asm:200
0xE226  0x3F 0x15 0x05  BBR3 0x15, 0xE22E (+5)  // if (BBS3, ZP.TOPT)    if either is LONG, both will be long
0xE229  0x20 0xE9 0x99  JSR 0x99E9              // Long.GT();                        comparisoninstructions.asm:203
0xE22C  0x38            SEC                     // SEC                               comparisoninstructions.asm:204
0xE22D  0x60            RTS                     // break;                            comparisoninstructions.asm:205
0xE22E  0xA2 0x00       LDX # 0                 // LDX #0    false                   comparisoninstructions.asm:208
0xE230  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      comparisoninstructions.asm:210
0xE232  0xC5 0x15       CMP 0x15                // CMP ZP.TOPT                       comparisoninstructions.asm:211
0xE234  0xF0 0x05       BEQ 0xE23B (+5)         // if (NZ)                           comparisoninstructions.asm:212
0xE236  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE239  0x18            CLC                     // CLC                               comparisoninstructions.asm:215
0xE23A  0x60            RTS                     // break;    BIT type mismatch       comparisoninstructions.asm:216
0xE23B  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              comparisoninstructions.asm:220
0xE23D  0xF0 0x03       BEQ 0xE242 (+3)
0xE23F  0x4C 0x29 0x8C  JMP 0x8C29
0xE242  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      comparisoninstructions.asm:222
0xE244  0xC5 0x11       CMP 0x11                // CMP ZP.TOP0                       comparisoninstructions.asm:223
0xE246  0xD0 0x04       BNE 0xE24C (+4)         // if (Z)                            comparisoninstructions.asm:224
0xE248  0xA2 0x00       LDX # 0                 // LDX #0         NEXT == TOP        comparisoninstructions.asm:226
0xE24A  0x80 0x08       BRA 0xE254 (+8)         // }                                 comparisoninstructions.asm:227
0xE24C  0x90 0x04       BCC 0xE252 (+4)         // else if (C)                       comparisoninstructions.asm:228
0xE24E  0xA2 0x01       LDX # 1                 // LDX #1         NEXT > TOP         comparisoninstructions.asm:230
0xE250  0x80 0x02       BRA 0xE254 (+2)         // }                                 comparisoninstructions.asm:231
0xE252  0xA2 0x00       LDX # 0                 // LDX #0         NEXT < TOP         comparisoninstructions.asm:234
0xE254  0x20 0xEA 0x94  JSR 0x94EA              // Stacks.PushX();                   comparisoninstructions.asm:244
0xE257  0x38            SEC                     // SEC                               comparisoninstructions.asm:245
0xE258  0x60            RTS                     // }                                 comparisoninstructions.asm:248

// /source/projects/6502sbc/hopperbasic/comparisoninstructions.asm:255
// ####  ComparisonInstructions.LessEqual()  ####                               0x025F

0xE259  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNext();                comparisoninstructions.asm:259
0xE25C  0x90 0x32       BCC 0xE290 (+50)        // if (NC) { break; }                comparisoninstructions.asm:260
0xE25E  0x3F 0x15 0x05  BBR3 0x15, 0xE266 (+5)  // if (BBS3, ZP.TOPT)    if either is LONG, both will be long
0xE261  0x20 0x09 0x9A  JSR 0x9A09              // Long.LE();                        comparisoninstructions.asm:263
0xE264  0x38            SEC                     // SEC                               comparisoninstructions.asm:264
0xE265  0x60            RTS                     // break;                            comparisoninstructions.asm:265
0xE266  0xA2 0x00       LDX # 0                 // LDX #0    false                   comparisoninstructions.asm:269
0xE268  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      comparisoninstructions.asm:271
0xE26A  0xC5 0x15       CMP 0x15                // CMP ZP.TOPT                       comparisoninstructions.asm:272
0xE26C  0xF0 0x05       BEQ 0xE273 (+5)         // if (NZ)                           comparisoninstructions.asm:273
0xE26E  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE271  0x18            CLC                     // CLC                               comparisoninstructions.asm:276
0xE272  0x60            RTS                     // break;    BIT type mismatch       comparisoninstructions.asm:277
0xE273  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              comparisoninstructions.asm:281
0xE275  0xF0 0x03       BEQ 0xE27A (+3)
0xE277  0x4C 0x29 0x8C  JMP 0x8C29
0xE27A  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      comparisoninstructions.asm:283
0xE27C  0xC5 0x11       CMP 0x11                // CMP ZP.TOP0                       comparisoninstructions.asm:284
0xE27E  0xD0 0x04       BNE 0xE284 (+4)         // if (Z)                            comparisoninstructions.asm:285
0xE280  0xA2 0x01       LDX # 1                 // LDX #1         NEXT == TOP        comparisoninstructions.asm:287
0xE282  0x80 0x08       BRA 0xE28C (+8)         // }                                 comparisoninstructions.asm:288
0xE284  0x90 0x04       BCC 0xE28A (+4)         // else if (C)                       comparisoninstructions.asm:289
0xE286  0xA2 0x00       LDX # 0                 // LDX #0         NEXT > TOP         comparisoninstructions.asm:291
0xE288  0x80 0x02       BRA 0xE28C (+2)         // }                                 comparisoninstructions.asm:292
0xE28A  0xA2 0x01       LDX # 1                 // LDX #1         NEXT < TOP         comparisoninstructions.asm:295
0xE28C  0x20 0xEA 0x94  JSR 0x94EA              // Stacks.PushX();                   comparisoninstructions.asm:305
0xE28F  0x38            SEC                     // SEC                               comparisoninstructions.asm:306
0xE290  0x60            RTS                     // }                                 comparisoninstructions.asm:309

// /source/projects/6502sbc/hopperbasic/comparisoninstructions.asm:316
// ####  ComparisonInstructions.GreaterEqual()  ####                            0x0260

0xE291  0x20 0x7D 0x98  JSR 0x987D              // Long.PopTopNext();                comparisoninstructions.asm:320
0xE294  0x90 0x32       BCC 0xE2C8 (+50)        // if (NC) { break; }                comparisoninstructions.asm:321
0xE296  0x3F 0x15 0x05  BBR3 0x15, 0xE29E (+5)  // if (BBS3, ZP.TOPT)    if either is LONG, both will be long
0xE299  0x20 0x19 0x9A  JSR 0x9A19              // Long.GE();                        comparisoninstructions.asm:324
0xE29C  0x38            SEC                     // SEC                               comparisoninstructions.asm:325
0xE29D  0x60            RTS                     // break;                            comparisoninstructions.asm:326
0xE29E  0xA2 0x00       LDX # 0                 // LDX #0    false                   comparisoninstructions.asm:329
0xE2A0  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      comparisoninstructions.asm:331
0xE2A2  0xC5 0x15       CMP 0x15                // CMP ZP.TOPT                       comparisoninstructions.asm:332
0xE2A4  0xF0 0x05       BEQ 0xE2AB (+5)         // if (NZ)                           comparisoninstructions.asm:333
0xE2A6  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE2A9  0x18            CLC                     // CLC                               comparisoninstructions.asm:336
0xE2AA  0x60            RTS                     // break;    BIT type mismatch       comparisoninstructions.asm:337
0xE2AB  0xC9 0x01       CMP # 1                 // case BASICType.CHAR:              comparisoninstructions.asm:341
0xE2AD  0xF0 0x03       BEQ 0xE2B2 (+3)
0xE2AF  0x4C 0x29 0x8C  JMP 0x8C29
0xE2B2  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      comparisoninstructions.asm:343
0xE2B4  0xC5 0x11       CMP 0x11                // CMP ZP.TOP0                       comparisoninstructions.asm:344
0xE2B6  0xD0 0x04       BNE 0xE2BC (+4)         // if (Z)                            comparisoninstructions.asm:345
0xE2B8  0xA2 0x01       LDX # 1                 // LDX #1         NEXT == TOP        comparisoninstructions.asm:347
0xE2BA  0x80 0x08       BRA 0xE2C4 (+8)         // }                                 comparisoninstructions.asm:348
0xE2BC  0x90 0x04       BCC 0xE2C2 (+4)         // else if (C)                       comparisoninstructions.asm:349
0xE2BE  0xA2 0x01       LDX # 1                 // LDX #1         NEXT > TOP         comparisoninstructions.asm:351
0xE2C0  0x80 0x02       BRA 0xE2C4 (+2)         // }                                 comparisoninstructions.asm:352
0xE2C2  0xA2 0x00       LDX # 0                 // LDX #0         NEXT < TOP         comparisoninstructions.asm:355
0xE2C4  0x20 0xEA 0x94  JSR 0x94EA              // Stacks.PushX();                   comparisoninstructions.asm:365
0xE2C7  0x38            SEC                     // SEC                               comparisoninstructions.asm:366
0xE2C8  0x60            RTS                     // }                                 comparisoninstructions.asm:369

// /source/projects/6502sbc/hopperbasic/basicsyscalls.asm:184
// ####  BASICSysCalls.updateRandomSeed()  ####                                 0x0261

0xE2C9  0xA5 0xA3       LDA 0xA3                // LDA ZP.RANDOMSEEDL                basicsyscalls.asm:186
0xE2CB  0x05 0xA4       ORA 0xA4                // ORA ZP.RANDOMSEEDH                basicsyscalls.asm:187
0xE2CD  0xD0 0x04       BNE 0xE2D3 (+4)         // if (Z)                            basicsyscalls.asm:188
0xE2CF  0xA9 0x01       LDA # 1                 // LDA #0x01     Use 1 as default seed if zero
0xE2D1  0x85 0xA3       STA 0xA3                // STA ZP.RANDOMSEEDL                basicsyscalls.asm:191
0xE2D3  0xA5 0xA3       LDA 0xA3                // LDA ZP.RANDOMSEEDL                basicsyscalls.asm:195
0xE2D5  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       basicsyscalls.asm:196
0xE2D7  0xA5 0xA4       LDA 0xA4                // LDA ZP.RANDOMSEEDH                basicsyscalls.asm:197
0xE2D9  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       basicsyscalls.asm:198
0xE2DB  0x06 0xA3       ASL 0xA3                // ASL ZP.RANDOMSEEDL     *2         basicsyscalls.asm:201
0xE2DD  0x26 0xA4       ROL 0xA4                // ROL ZP.RANDOMSEEDH                basicsyscalls.asm:202
0xE2DF  0x06 0xA3       ASL 0xA3                // ASL ZP.RANDOMSEEDL     *4         basicsyscalls.asm:203
0xE2E1  0x26 0xA4       ROL 0xA4                // ROL ZP.RANDOMSEEDH                basicsyscalls.asm:204
0xE2E3  0x06 0xA3       ASL 0xA3                // ASL ZP.RANDOMSEEDL     *8         basicsyscalls.asm:205
0xE2E5  0x26 0xA4       ROL 0xA4                // ROL ZP.RANDOMSEEDH                basicsyscalls.asm:206
0xE2E7  0x06 0xA3       ASL 0xA3                // ASL ZP.RANDOMSEEDL     *16        basicsyscalls.asm:207
0xE2E9  0x26 0xA4       ROL 0xA4                // ROL ZP.RANDOMSEEDH                basicsyscalls.asm:208
0xE2EB  0x18            CLC                     // CLC                               basicsyscalls.asm:211
0xE2EC  0xA5 0xA3       LDA 0xA3                // LDA ZP.RANDOMSEEDL                basicsyscalls.asm:212
0xE2EE  0x65 0x0E       ADC 0x0E                // ADC ZP.ACCL                       basicsyscalls.asm:213
0xE2F0  0x85 0xA3       STA 0xA3                // STA ZP.RANDOMSEEDL                basicsyscalls.asm:214
0xE2F2  0xA5 0xA4       LDA 0xA4                // LDA ZP.RANDOMSEEDH                basicsyscalls.asm:215
0xE2F4  0x65 0x0F       ADC 0x0F                // ADC ZP.ACCH                       basicsyscalls.asm:216
0xE2F6  0x85 0xA4       STA 0xA4                // STA ZP.RANDOMSEEDH                basicsyscalls.asm:217
0xE2F8  0x46 0x0F       LSR 0x0F                // LSR ZP.ACCH                       basicsyscalls.asm:220
0xE2FA  0x66 0x0E       ROR 0x0E                // ROR ZP.ACCL                       basicsyscalls.asm:221
0xE2FC  0xA5 0xA3       LDA 0xA3                // LDA ZP.RANDOMSEEDL                basicsyscalls.asm:223
0xE2FE  0x45 0x0E       EOR 0x0E                // EOR ZP.ACCL                       basicsyscalls.asm:224
0xE300  0x85 0xA3       STA 0xA3                // STA ZP.RANDOMSEEDL                basicsyscalls.asm:225
0xE302  0xA5 0xA4       LDA 0xA4                // LDA ZP.RANDOMSEEDH                basicsyscalls.asm:226
0xE304  0x45 0x0F       EOR 0x0F                // EOR ZP.ACCH                       basicsyscalls.asm:227
0xE306  0x85 0xA4       STA 0xA4                // STA ZP.RANDOMSEEDH                basicsyscalls.asm:228
0xE308  0xE6 0xA3       INC 0xA3                // INC ZP.RANDOMSEEDL                basicsyscalls.asm:231
0xE30A  0xF0 0x01       BEQ 0xE30D (+1)         // if (Z)                            basicsyscalls.asm:232
0xE30C  0x60            RTS
0xE30D  0xE6 0xA4       INC 0xA4                // INC ZP.RANDOMSEEDH                basicsyscalls.asm:234
0xE30F  0x60            RTS                     // }                                 basicsyscalls.asm:236

// /source/projects/6502sbc/hopperbasic/basicsyscalls.asm:243
// ####  BASICSysCalls.executeRnd()  ####                                       0x0262

0xE310  0x5A            PHY                     // PHY                               basicsyscalls.asm:244
0xE311  0x20 0xAD 0x97  JSR 0x97AD              // Long.ZeroCheckTop();              basicsyscalls.asm:248
0xE314  0xD0 0x03       BNE 0xE319 (+3)         // if (Z)     max == 0               basicsyscalls.asm:249
0xE316  0x18            CLC                     // CLC     Error condition           basicsyscalls.asm:252
0xE317  0x80 0x33       BRA 0xE34C (+51)        // break;                            basicsyscalls.asm:253
0xE319  0x20 0xC9 0xE2  JSR 0xE2C9              // updateRandomSeed();               basicsyscalls.asm:257
0xE31C  0xA5 0xA3       LDA 0xA3                // LDA ZP.RANDOMSEEDL                basicsyscalls.asm:260
0xE31E  0x85 0x16       STA 0x16                // STA ZP.NEXT0                      basicsyscalls.asm:261
0xE320  0xA5 0xA4       LDA 0xA4                // LDA ZP.RANDOMSEEDH                basicsyscalls.asm:262
0xE322  0x85 0x17       STA 0x17                // STA ZP.NEXT1                      basicsyscalls.asm:263
0xE324  0x64 0x18       STZ 0x18                // STZ ZP.NEXT2                      basicsyscalls.asm:264
0xE326  0x64 0x19       STZ 0x19                // STZ ZP.NEXT3                      basicsyscalls.asm:265
0xE328  0xA2 0x01       LDX # 1                 // LDX #1    Mod                     basicsyscalls.asm:268
0xE32A  0x20 0x84 0x9A  JSR 0x9A84              // Long.DivMod();     RESULT = NEXT % TOP
0xE32D  0xE6 0x4F       INC 0x4F                // INC ZP.RESULT0                    basicsyscalls.asm:272
0xE32F  0xD0 0x0A       BNE 0xE33B (+10)        // if (Z)                            basicsyscalls.asm:273
0xE331  0xE6 0x50       INC 0x50                // INC ZP.RESULT1                    basicsyscalls.asm:275
0xE333  0xD0 0x06       BNE 0xE33B (+6)         // if (Z)                            basicsyscalls.asm:276
0xE335  0xE6 0x51       INC 0x51                // INC ZP.RESULT2                    basicsyscalls.asm:278
0xE337  0xD0 0x02       BNE 0xE33B (+2)         // if (Z)                            basicsyscalls.asm:279
0xE339  0xE6 0x52       INC 0x52                // INC ZP.RESULT3                    basicsyscalls.asm:281
0xE33B  0xA5 0x4F       LDA 0x4F                // LDA ZP.RESULT0                    basicsyscalls.asm:287
0xE33D  0x85 0x11       STA 0x11                // STA ZP.TOP0                       basicsyscalls.asm:288
0xE33F  0xA5 0x50       LDA 0x50                // LDA ZP.RESULT1                    basicsyscalls.asm:289
0xE341  0x85 0x12       STA 0x12                // STA ZP.TOP1                       basicsyscalls.asm:290
0xE343  0xA5 0x51       LDA 0x51                // LDA ZP.RESULT2                    basicsyscalls.asm:291
0xE345  0x85 0x13       STA 0x13                // STA ZP.TOP2                       basicsyscalls.asm:292
0xE347  0xA5 0x52       LDA 0x52                // LDA ZP.RESULT3                    basicsyscalls.asm:293
0xE349  0x85 0x14       STA 0x14                // STA ZP.TOP3                       basicsyscalls.asm:294
0xE34B  0x38            SEC                     // SEC    Success                    basicsyscalls.asm:296
0xE34C  0x7A            PLY                     // PLY                               basicsyscalls.asm:299
0xE34D  0x60            RTS                     // }                                 basicsyscalls.asm:300

// /source/projects/6502sbc/hopperbasic/basicsyscalls.asm:304
// ####  BASICSysCalls.validateTopBYTE()  ####                                  0x0263

0xE34E  0xA9 0x03       LDA # 0x03              // LDA # BASICType.BYTE              basicsyscalls.asm:305
0xE350  0x85 0x10       STA 0x10                // STA ZP.ACCT                       basicsyscalls.asm:306
0xE352  0x4C 0x59 0x86  JMP 0x8659              // BASICTypes.Coerce();              basicsyscalls.asm:307

// /source/projects/6502sbc/hopperbasic/basicsyscalls.asm:310
// ####  BASICSysCalls.validatePinNumber()  ####                                0x0264

0xE355  0xA9 0x03       LDA # 0x03              // LDA # BASICType.BYTE              basicsyscalls.asm:311
0xE357  0x85 0x10       STA 0x10                // STA ZP.ACCT                       basicsyscalls.asm:312
0xE359  0x20 0xDB 0x86  JSR 0x86DB              // BASICTypes.CoerceNext();          basicsyscalls.asm:313
0xE35C  0xB0 0x01       BCS 0xE35F (+1)         // if (C)                            basicsyscalls.asm:314
0xE35E  0x60            RTS
0xE35F  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0                      basicsyscalls.asm:316
0xE361  0x29 0xF0       AND # 0xF0              // AND #0xF0                         basicsyscalls.asm:317
0xE363  0xD0 0x01       BNE 0xE366 (+1)         // if (NZ)                           basicsyscalls.asm:318
0xE365  0x60            RTS
0xE366  0x4C 0xD4 0x8B  JMP 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL    -> NC

// /source/projects/6502sbc/hopperbasic/basicsyscalls.asm:326
// ####  BASICSysCalls.pushLongExit()  ####                                     0x0265

0xE369  0x20 0x89 0x97  JSR 0x9789              // PushTopStrictLONG();    LONG -> TOPT
0xE36C  0x4C 0x73 0x8C  JMP 0x8C73              // CheckErrorAndSetFailure();        basicsyscalls.asm:328

// /source/projects/6502sbc/hopperbasic/basicsyscalls.asm:334
// ####  BASICSysCalls.ExecuteSysCall()  ####                                   0x0266

0xE36F  0x20 0x5C 0xE8  JSR 0xE85C              // FetchOperandByte();     A = SYSCALL ID, never fails
0xE372  0x85 0xA5       STA 0xA5                // STA ZP.CURRENTSYSCALL             basicsyscalls.asm:342
0xE374  0x29 0x03       AND # 0x03              // AND #0b00000011      A = argument count
0xE376  0xF0 0x1A       BEQ 0xE392 (+26)        // case 0: { /* No arguments to pop */ }
0xE378  0xC9 0x01       CMP # 1                 // case 1:                           basicsyscalls.asm:347
0xE37A  0xD0 0x05       BNE 0xE381 (+5)
0xE37C  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();                 }  basicsyscalls.asm:349
0xE37F  0x80 0x11       BRA 0xE392 (+17)
0xE381  0xC9 0x02       CMP # 0x02              // case 2:                           basicsyscalls.asm:350
0xE383  0xD0 0x0B       BNE 0xE390 (+11)
0xE385  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();     second arg in ZP.TOP*, munts X
0xE388  0x20 0x0D 0x99  JSR 0x990D              // Long.PopNext();    first arg in ZP.NEXT*, munts X
0xE38B  0xB0 0x05       BCS 0xE392 (+5)         // if (NC) { break; }                basicsyscalls.asm:355
0xE38D  0x4C 0x73 0x8C  JMP 0x8C73
0xE390  0xC9 0x03       CMP # 0x03              // case 3:                           basicsyscalls.asm:357
0xE392  0xA4 0xA5       LDY 0xA5                // LDY ZP.CURRENTSYSCALL             basicsyscalls.asm:367
0xE394  0xC0 0x2C       CPY # 0x2C              // case SysCallType.Millis:           ID = 5
0xE396  0xD0 0x13       BNE 0xE3AB (+19)
0xE398  0xA5 0x25       LDA 0x25                // LDA ZP.TICK3 STA ZP.TOP3     reading TICK3 makes a snapshot of all 4 registers on the emulator
0xE39A  0x85 0x14       STA 0x14
0xE39C  0xA5 0x24       LDA 0x24                // LDA ZP.TICK2 STA ZP.TOP2          basicsyscalls.asm:373
0xE39E  0x85 0x13       STA 0x13
0xE3A0  0xA5 0x23       LDA 0x23                // LDA ZP.TICK1 STA ZP.TOP1          basicsyscalls.asm:374
0xE3A2  0x85 0x12       STA 0x12
0xE3A4  0xA5 0x22       LDA 0x22                // LDA ZP.TICK0 STA ZP.TOP0          basicsyscalls.asm:375
0xE3A6  0x85 0x11       STA 0x11
0xE3A8  0x4C 0x69 0xE3  JMP 0xE369              // pushLongExit();                   basicsyscalls.asm:376
0xE3AB  0xC0 0x34       CPY # 0x34              // case SysCallType.Seconds:          ID = 6
0xE3AD  0xD0 0x34       BNE 0xE3E3 (+52)
0xE3AF  0xA5 0x25       LDA 0x25                // Tools.Seconds();                  basicsyscalls.asm:382
0xE3B1  0x85 0x19       STA 0x19
0xE3B3  0xA5 0x24       LDA 0x24
0xE3B5  0x85 0x18       STA 0x18
0xE3B7  0xA5 0x23       LDA 0x23
0xE3B9  0x85 0x17       STA 0x17
0xE3BB  0xA5 0x22       LDA 0x22
0xE3BD  0x85 0x16       STA 0x16
0xE3BF  0xA9 0xE8       LDA # 0xE8
0xE3C1  0x85 0x11       STA 0x11
0xE3C3  0xA9 0x03       LDA # 0x03
0xE3C5  0x85 0x12       STA 0x12
0xE3C7  0x64 0x13       STZ 0x13
0xE3C9  0x64 0x14       STZ 0x14
0xE3CB  0xA2 0x00       LDX # 0
0xE3CD  0x20 0x84 0x9A  JSR 0x9A84
0xE3D0  0xA5 0x16       LDA 0x16
0xE3D2  0x85 0x11       STA 0x11
0xE3D4  0xA5 0x17       LDA 0x17
0xE3D6  0x85 0x12       STA 0x12
0xE3D8  0xA5 0x18       LDA 0x18
0xE3DA  0x85 0x13       STA 0x13
0xE3DC  0xA5 0x19       LDA 0x19
0xE3DE  0x85 0x14       STA 0x14
0xE3E0  0x4C 0x69 0xE3  JMP 0xE369              // pushLongExit();                   basicsyscalls.asm:383
0xE3E3  0xC0 0x85       CPY # 0x85              // case SysCallType.Rnd:             basicsyscalls.asm:386
0xE3E5  0xD0 0x0E       BNE 0xE3F5 (+14)
0xE3E7  0x20 0x10 0xE3  JSR 0xE310              // executeRnd();                     basicsyscalls.asm:391
0xE3EA  0x90 0x03       BCC 0xE3EF (+3)         // if (NC)                           basicsyscalls.asm:392
0xE3EC  0x4C 0x69 0xE3  JMP 0xE369
0xE3EF  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL    maxvalue cannot be zero
0xE3F2  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:395
0xE3F5  0xC0 0x1D       CPY # 0x1D              // case SysCallType.Abs:              ID = 3
0xE3F7  0xD0 0x16       BNE 0xE40F (+22)
0xE3F9  0xBF 0x15 0x06  BBS3 0x15, 0xE402 (+6)  // if (BBR3, ZP.TOPT)    Bit 3 - Long
0xE3FC  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE3FF  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:409
0xE402  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       basicsyscalls.asm:413
0xE404  0x30 0x03       BMI 0xE409 (+3)         // if (MI)                           basicsyscalls.asm:414
0xE406  0x4C 0x69 0xE3  JMP 0xE369
0xE409  0x20 0x5D 0x9B  JSR 0x9B5D              // Long.NegateLongTOP();             basicsyscalls.asm:417
0xE40C  0x4C 0x69 0xE3  JMP 0xE369              // pushLongExit();                   basicsyscalls.asm:419
0xE40F  0xC0 0x45       CPY # 0x45              // case SysCallType.Peek:             ID = 8
0xE411  0xD0 0x15       BNE 0xE428 (+21)
0xE413  0xA9 0x04       LDA # 0x04              // LDA # BASICType.WORD              basicsyscalls.asm:428
0xE415  0x85 0x10       STA 0x10                // STA ZP.ACCT                       basicsyscalls.asm:429
0xE417  0x20 0x59 0x86  JSR 0x8659              // BASICTypes.Coerce();    WORD      basicsyscalls.asm:430
0xE41A  0xB0 0x03       BCS 0xE41F (+3)         // if (NC) { break; }                basicsyscalls.asm:431
0xE41C  0x4C 0x73 0x8C  JMP 0x8C73
0xE41F  0xB2 0x11       LDA [0x11]              // LDA [ZP.TOP]                      basicsyscalls.asm:434
0xE421  0x85 0x11       STA 0x11                // STA ZP.TOP0                       basicsyscalls.asm:435
0xE423  0x64 0x12       STZ 0x12                // STZ ZP.TOP1                       basicsyscalls.asm:436
0xE425  0x4C 0x69 0xE3  JMP 0xE369              // pushLongExit();                   basicsyscalls.asm:437
0xE428  0xC0 0x75       CPY # 0x75              // case SysCallType.Asc:              ID = 14
0xE42A  0xD0 0x12       BNE 0xE43E (+18)
0xE42C  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       basicsyscalls.asm:447
0xE42E  0xC9 0x01       CMP # 1                 // CMP #BASICType.CHAR               basicsyscalls.asm:448
0xE430  0xF0 0x06       BEQ 0xE438 (+6)         // if (NZ)                           basicsyscalls.asm:449
0xE432  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE435  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:452
0xE438  0x20 0x9A 0x97  JSR 0x979A              // Long.ZeroTop3();                  basicsyscalls.asm:458
0xE43B  0x4C 0x69 0xE3  JMP 0xE369              // pushLongExit();                   basicsyscalls.asm:459
0xE43E  0xC0 0x7D       CPY # 0x7D              // case SysCallType.Len:              ID = 15
0xE440  0xD0 0x46       BNE 0xE488 (+70)
0xE442  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       basicsyscalls.asm:469
0xE444  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          basicsyscalls.asm:470
0xE446  0xC9 0x05       CMP # 0x05              // CMP # BASICType.STRING            basicsyscalls.asm:471
0xE448  0xD0 0x19       BNE 0xE463 (+25)        // if (Z)                            basicsyscalls.asm:472
0xE44A  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       basicsyscalls.asm:475
0xE44C  0x05 0x12       ORA 0x12                // ORA ZP.TOP1                       basicsyscalls.asm:476
0xE44E  0xD0 0x04       BNE 0xE454 (+4)         // if (Z)                            basicsyscalls.asm:477
0xE450  0x64 0x11       STZ 0x11                // STZ ZP.TOP0                       basicsyscalls.asm:480
0xE452  0x80 0x09       BRA 0xE45D (+9)         // }                                 basicsyscalls.asm:481
0xE454  0xA0 0x00       LDY # 0                 // LDY #0                            basicsyscalls.asm:484
0xE456  0xB1 0x11       LDA [0x11],Y            // LDA [ZP.TOP], Y                   basicsyscalls.asm:487
0xE458  0xF0 0x03       BEQ 0xE45D (+3)         // if (Z) { break; }                 basicsyscalls.asm:488
0xE45A  0xC8            INY                     // INY                               basicsyscalls.asm:489
0xE45B  0x80 0xF9       BRA 0xE456 (-7)         // }    loop                         basicsyscalls.asm:496
0xE45D  0x84 0x11       STY 0x11                // STY ZP.TOP0                       basicsyscalls.asm:498
0xE45F  0x64 0x12       STZ 0x12                // STZ ZP.TOP1                       basicsyscalls.asm:499
0xE461  0x80 0x1E       BRA 0xE481 (+30)        // }                                 basicsyscalls.asm:500
0xE463  0x5F 0x15 0x15  BBR5 0x15, 0xE47B (+21) // if (BBS5, ZP.TOPT)    Bit 5 - ARRAY
0xE466  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       basicsyscalls.asm:508
0xE468  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       basicsyscalls.asm:509
0xE46A  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       basicsyscalls.asm:510
0xE46C  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       basicsyscalls.asm:511
0xE46E  0x20 0x55 0xAB  JSR 0xAB55              // BASICArray.GetCount();     Returns in ZP.ACC
0xE471  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       basicsyscalls.asm:514
0xE473  0x85 0x11       STA 0x11                // STA ZP.TOP0                       basicsyscalls.asm:515
0xE475  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       basicsyscalls.asm:516
0xE477  0x85 0x12       STA 0x12                // STA ZP.TOP1                       basicsyscalls.asm:517
0xE479  0x80 0x06       BRA 0xE481 (+6)         // }                                 basicsyscalls.asm:518
0xE47B  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE47E  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:522
0xE481  0x64 0x13       STZ 0x13                // STZ ZP.TOP2                       basicsyscalls.asm:525
0xE483  0x64 0x14       STZ 0x14                // STZ ZP.TOP3    x2                 basicsyscalls.asm:526
0xE485  0x4C 0x69 0xE3  JMP 0xE369              // pushLongExit();                   basicsyscalls.asm:527
0xE488  0xC0 0x09       CPY # 0x09              // case SysCallType.PrintValue:       ID = 1
0xE48A  0xD0 0x07       BNE 0xE493 (+7)
0xE48C  0x18            CLC                     // CLC    no quotes                  basicsyscalls.asm:534
0xE48D  0x20 0x14 0x89  JSR 0x8914              // BASICTypes.PrintValue();     Uses ZP.TOP*, CLC = no quotes
0xE490  0x4C 0x27 0xE6  JMP 0xE627              // }                                 basicsyscalls.asm:536
0xE493  0xC0 0x11       CPY # 0x11              // case SysCallType.PrintChar:        ID = 2
0xE495  0xD0 0x14       BNE 0xE4AB (+20)
0xE497  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       basicsyscalls.asm:540
0xE499  0xC9 0x01       CMP # 1                 // CMP # BASICType.CHAR              basicsyscalls.asm:541
0xE49B  0xF0 0x06       BEQ 0xE4A3 (+6)         // if (NZ)                           basicsyscalls.asm:542
0xE49D  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE4A0  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:545
0xE4A3  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       basicsyscalls.asm:548
0xE4A5  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               basicsyscalls.asm:549
0xE4A8  0x4C 0x27 0xE6  JMP 0xE627              // }                                 basicsyscalls.asm:550
0xE4AB  0xC0 0x4A       CPY # 0x4A              // case SysCallType.Poke:             ID = 9
0xE4AD  0xD0 0x1B       BNE 0xE4CA (+27)
0xE4AF  0xA9 0x04       LDA # 0x04              // LDA # BASICType.WORD              basicsyscalls.asm:557
0xE4B1  0x85 0x10       STA 0x10                // STA ZP.ACCT                       basicsyscalls.asm:558
0xE4B3  0x20 0xDB 0x86  JSR 0x86DB              // BASICTypes.CoerceNext();    WORD  basicsyscalls.asm:559
0xE4B6  0xB0 0x03       BCS 0xE4BB (+3)         // if (NC) { break; }                basicsyscalls.asm:560
0xE4B8  0x4C 0x73 0x8C  JMP 0x8C73
0xE4BB  0x20 0x4E 0xE3  JSR 0xE34E              // validateTopBYTE();                basicsyscalls.asm:562
0xE4BE  0xB0 0x03       BCS 0xE4C3 (+3)         // if (NC) { break; }                basicsyscalls.asm:563
0xE4C0  0x4C 0x73 0x8C  JMP 0x8C73
0xE4C3  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0        Get value to write
0xE4C5  0x92 0x16       STA [0x16]              // STA [ZP.NEXT]      Write to address
0xE4C7  0x4C 0x27 0xE6  JMP 0xE627              // }                                 basicsyscalls.asm:568
0xE4CA  0xC0 0x52       CPY # 0x52              // case SysCallType.PinMode:     ID = 10
0xE4CC  0xD0 0x26       BNE 0xE4F4 (+38)
0xE4CE  0x20 0x55 0xE3  JSR 0xE355              // validatePinNumber();              basicsyscalls.asm:575
0xE4D1  0xB0 0x03       BCS 0xE4D6 (+3)         // if (NC) { break; }                basicsyscalls.asm:576
0xE4D3  0x4C 0x73 0x8C  JMP 0x8C73
0xE4D6  0x20 0x4E 0xE3  JSR 0xE34E              // validateTopBYTE();                basicsyscalls.asm:578
0xE4D9  0xB0 0x03       BCS 0xE4DE (+3)         // if (NC) { break; }                basicsyscalls.asm:579
0xE4DB  0x4C 0x73 0x8C  JMP 0x8C73
0xE4DE  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       basicsyscalls.asm:581
0xE4E0  0x29 0xFE       AND # 0xFE              // AND #0xFE                         basicsyscalls.asm:582
0xE4E2  0xF0 0x06       BEQ 0xE4EA (+6)         // if (NZ)                           basicsyscalls.asm:583
0xE4E4  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0xE4E7  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:586
0xE4EA  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0       Pin number     basicsyscalls.asm:590
0xE4EC  0xA6 0x11       LDX 0x11                // LDX ZP.TOP0        Mode           basicsyscalls.asm:591
0xE4EE  0x20 0xE7 0xE0  JSR 0xE0E7              // GPIO.PinMode();                   basicsyscalls.asm:592
0xE4F1  0x4C 0x27 0xE6  JMP 0xE627              // }                                 basicsyscalls.asm:593
0xE4F4  0xC0 0x5D       CPY # 0x5D              // case SysCallType.Read:     ID = 11
0xE4F6  0xD0 0x22       BNE 0xE51A (+34)
0xE4F8  0x20 0x4E 0xE3  JSR 0xE34E              // validateTopBYTE();                basicsyscalls.asm:601
0xE4FB  0xB0 0x03       BCS 0xE500 (+3)         // if (NC) { break; }                basicsyscalls.asm:602
0xE4FD  0x4C 0x73 0x8C  JMP 0x8C73
0xE500  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       basicsyscalls.asm:604
0xE502  0x29 0xF0       AND # 0xF0              // AND #0xF0                         basicsyscalls.asm:605
0xE504  0xF0 0x06       BEQ 0xE50C (+6)         // if (NZ)                           basicsyscalls.asm:606
0xE506  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0xE509  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:609
0xE50C  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       basicsyscalls.asm:613
0xE50E  0x20 0x41 0xE1  JSR 0xE141              // GPIO.PinRead();     Result in A   basicsyscalls.asm:614
0xE511  0x85 0x11       STA 0x11                // STA ZP.TOP0                       basicsyscalls.asm:615
0xE513  0xA9 0x06       LDA # 0x06              // LDA #BASICType.BIT                basicsyscalls.asm:617
0xE515  0x85 0x15       STA 0x15                // STA ZP.TOPT                       basicsyscalls.asm:618
0xE517  0x4C 0x27 0xE6  JMP 0xE627              // }                                 basicsyscalls.asm:619
0xE51A  0xC0 0x62       CPY # 0x62              // case SysCallType.Write:     ID = 12
0xE51C  0xD0 0x1E       BNE 0xE53C (+30)
0xE51E  0x20 0x55 0xE3  JSR 0xE355              // validatePinNumber();              basicsyscalls.asm:626
0xE521  0xB0 0x03       BCS 0xE526 (+3)         // if (NC) { break; }                basicsyscalls.asm:627
0xE523  0x4C 0x73 0x8C  JMP 0x8C73
0xE526  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       basicsyscalls.asm:630
0xE528  0xC9 0x06       CMP # 0x06              // CMP # BASICType.BIT               basicsyscalls.asm:631
0xE52A  0xF0 0x06       BEQ 0xE532 (+6)         // if (NZ)                           basicsyscalls.asm:632
0xE52C  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE52F  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:635
0xE532  0xA5 0x16       LDA 0x16                // LDA ZP.NEXT0       Pin number     basicsyscalls.asm:639
0xE534  0xA6 0x11       LDX 0x11                // LDX ZP.TOP0        Value          basicsyscalls.asm:640
0xE536  0x20 0x14 0xE1  JSR 0xE114              // GPIO.PinWrite();                  basicsyscalls.asm:641
0xE539  0x4C 0x27 0xE6  JMP 0xE627              // }                                 basicsyscalls.asm:642
0xE53C  0xC0 0x8D       CPY # 0x8D              // case SysCallType.I2CFind:     ID = 17
0xE53E  0xD0 0x23       BNE 0xE563 (+35)
0xE540  0x20 0x4E 0xE3  JSR 0xE34E              // validateTopBYTE();                basicsyscalls.asm:653
0xE543  0xB0 0x03       BCS 0xE548 (+3)         // if (NC) { break; }                basicsyscalls.asm:654
0xE545  0x4C 0x73 0x8C  JMP 0x8C73
0xE548  0x7F 0x11 0x06  BBR7 0x11, 0xE551 (+6)  // if (BBS7, ZP.TOP0)     Bit 7 set = > 127
0xE54B  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0xE54E  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:660
0xE551  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       basicsyscalls.asm:662
0xE553  0x20 0x26 0xAD  JSR 0xAD26              // I2C.Scan();     A = address, returns ZP.LastAck, preserves Y
0xE556  0xA5 0x8A       LDA 0x8A                // LDA ZP.LastAck                    basicsyscalls.asm:664
0xE558  0x49 0x01       EOR # 1                 // EOR #1          Invert: ACK (0) becomes TRUE (1)
0xE55A  0x85 0x11       STA 0x11                // STA ZP.TOP0                       basicsyscalls.asm:666
0xE55C  0xA9 0x06       LDA # 0x06              // LDA #BASICType.BIT                basicsyscalls.asm:667
0xE55E  0x85 0x15       STA 0x15                // STA ZP.TOPT                       basicsyscalls.asm:668
0xE560  0x4C 0x27 0xE6  JMP 0xE627              // }                                 basicsyscalls.asm:669
0xE563  0xC0 0x91       CPY # 0x91              // case SysCallType.I2CBegin:     ID = 18
0xE565  0xD0 0x1C       BNE 0xE583 (+28)
0xE567  0x20 0x4E 0xE3  JSR 0xE34E              // validateTopBYTE();                basicsyscalls.asm:676
0xE56A  0xB0 0x03       BCS 0xE56F (+3)         // if (NC) { break; }                basicsyscalls.asm:677
0xE56C  0x4C 0x73 0x8C  JMP 0x8C73
0xE56F  0x7F 0x11 0x06  BBR7 0x11, 0xE578 (+6)  // if (BBS7, ZP.TOP0)                basicsyscalls.asm:680
0xE572  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0xE575  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:683
0xE578  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       basicsyscalls.asm:686
0xE57A  0x0A            ASL A                   // ASL                               basicsyscalls.asm:687
0xE57B  0x85 0x88       STA 0x88                // STA ZP.OutB                       basicsyscalls.asm:688
0xE57D  0x20 0x32 0xAD  JSR 0xAD32              // I2C.Start();                      basicsyscalls.asm:690
0xE580  0x4C 0x27 0xE6  JMP 0xE627              // }                                 basicsyscalls.asm:691
0xE583  0xC0 0x99       CPY # 0x99              // case SysCallType.I2CPut:     ID = 19
0xE585  0xD0 0x12       BNE 0xE599 (+18)
0xE587  0x20 0x4E 0xE3  JSR 0xE34E              // validateTopBYTE();                basicsyscalls.asm:698
0xE58A  0xB0 0x03       BCS 0xE58F (+3)         // if (NC) { break; }                basicsyscalls.asm:699
0xE58C  0x4C 0x73 0x8C  JMP 0x8C73
0xE58F  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       basicsyscalls.asm:701
0xE591  0x85 0x88       STA 0x88                // STA ZP.OutB                       basicsyscalls.asm:702
0xE593  0x20 0x92 0xAD  JSR 0xAD92              // I2C.ByteOut();                    basicsyscalls.asm:703
0xE596  0x4C 0x27 0xE6  JMP 0xE627              // }                                 basicsyscalls.asm:704
0xE599  0xC0 0xA4       CPY # 0xA4              // case SysCallType.I2CEnd:     ID = 20
0xE59B  0xD0 0x0E       BNE 0xE5AB (+14)
0xE59D  0x20 0x3F 0xAD  JSR 0xAD3F              // I2C.Stop();                       basicsyscalls.asm:709
0xE5A0  0xA5 0x8A       LDA 0x8A                // LDA ZP.LastAck                    basicsyscalls.asm:710
0xE5A2  0x85 0x11       STA 0x11                // STA ZP.TOP0                       basicsyscalls.asm:711
0xE5A4  0xA9 0x06       LDA # 0x06              // LDA #BASICType.BIT                basicsyscalls.asm:712
0xE5A6  0x85 0x15       STA 0x15                // STA ZP.TOPT                       basicsyscalls.asm:713
0xE5A8  0x4C 0x27 0xE6  JMP 0xE627              // }                                 basicsyscalls.asm:714
0xE5AB  0xC0 0xAE       CPY # 0xAE              // case SysCallType.I2CGet:     ID = 21
0xE5AD  0xD0 0x28       BNE 0xE5D7 (+40)
0xE5AF  0xA9 0x03       LDA # 0x03              // LDA #BASICType.BYTE               basicsyscalls.asm:722
0xE5B1  0x85 0x10       STA 0x10                // STA ZP.ACCT                       basicsyscalls.asm:723
0xE5B3  0x20 0xDB 0x86  JSR 0x86DB              // BASICTypes.CoerceNext();    BYTE  basicsyscalls.asm:724
0xE5B6  0xB0 0x03       BCS 0xE5BB (+3)         // if (NC) { break; }                basicsyscalls.asm:725
0xE5B8  0x4C 0x73 0x8C  JMP 0x8C73
0xE5BB  0x7F 0x16 0x06  BBR7 0x16, 0xE5C4 (+6)  // if (BBS7, ZP.NEXT0)     Address > 127
0xE5BE  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0xE5C1  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:730
0xE5C4  0x20 0x4E 0xE3  JSR 0xE34E              // validateTopBYTE();                basicsyscalls.asm:734
0xE5C7  0xB0 0x03       BCS 0xE5CC (+3)         // if (NC) { break; }                basicsyscalls.asm:735
0xE5C9  0x4C 0x73 0x8C  JMP 0x8C73
0xE5CC  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL    I2C address -> A  basicsyscalls.asm:738
0xE5CE  0x20 0x46 0xAD  JSR 0xAD46              // RequestFromTOPA();    A has I2C adddress, TOPL has number of bytes to return, TOPL returns number of bytes read
0xE5D1  0x20 0x9A 0x97  JSR 0x979A              // Long.ZeroTop3();                  basicsyscalls.asm:742
0xE5D4  0x4C 0x69 0xE3  JMP 0xE369              // pushLongExit();                   basicsyscalls.asm:743
0xE5D7  0xC0 0xB4       CPY # 0xB4              // case SysCallType.I2CNext:     ID = 22
0xE5D9  0xD0 0x17       BNE 0xE5F2 (+23)
0xE5DB  0x64 0x11       STZ 0x11                // STZ ZP.TOP0                       basicsyscalls.asm:751
0xE5DD  0xA5 0x78       LDA 0x78                // LDA ZP.I2CInReadPtr               basicsyscalls.asm:753
0xE5DF  0xC5 0x77       CMP 0x77                // CMP ZP.I2CInWritePtr              basicsyscalls.asm:754
0xE5E1  0xF0 0x09       BEQ 0xE5EC (+9)         // if (NZ)    ReadPtr != WritePtr means we have more data available in the I2CInBuffer
0xE5E3  0xA6 0x78       LDX 0x78                // LDX ZP.I2CInReadPtr               basicsyscalls.asm:757
0xE5E5  0xBD 0x00 0x0A  LDA 0x0A00,X            // LDA Address.I2CInBuffer, X        basicsyscalls.asm:758
0xE5E8  0x85 0x11       STA 0x11                // STA ZP.TOPL                       basicsyscalls.asm:759
0xE5EA  0xE6 0x78       INC 0x78                // INC ZP.I2CInReadPtr               basicsyscalls.asm:760
0xE5EC  0x20 0x9A 0x97  JSR 0x979A              // Long.ZeroTop3();                  basicsyscalls.asm:762
0xE5EF  0x4C 0x69 0xE3  JMP 0xE369              // pushLongExit();                   basicsyscalls.asm:763
0xE5F2  0xC0 0x39       CPY # 0x39              // case SysCallType.Delay:            ID = 7
0xE5F4  0xD0 0x0E       BNE 0xE604 (+14)
0xE5F6  0xBF 0x15 0x06  BBS3 0x15, 0xE5FF (+6)  // if (BBR3, ZP.TOPT)    Bit 3 - Long
0xE5F9  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE5FC  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:774
0xE5FF  0x20 0x0C 0x95  JSR 0x950C              // Time.DelayTOP();               Uses ZP.TOP*
0xE602  0x80 0x23       BRA 0xE627 (+35)        // }                                 basicsyscalls.asm:777
0xE604  0xC0 0x6D       CPY # 0x6D              // case SysCallType.Chr:              ID = 13
0xE606  0xD0 0x0B       BNE 0xE613 (+11)
0xE608  0x20 0x4E 0xE3  JSR 0xE34E              // validateTopBYTE();                basicsyscalls.asm:784
0xE60B  0x90 0x2C       BCC 0xE639 (+44)        // if (NC) { break; }                basicsyscalls.asm:785
0xE60D  0xA9 0x01       LDA # 1                 // LDA #BASICType.CHAR               basicsyscalls.asm:790
0xE60F  0x85 0x15       STA 0x15                // STA ZP.TOPT                       basicsyscalls.asm:791
0xE611  0x80 0x14       BRA 0xE627 (+20)        // }                                 basicsyscalls.asm:792
0xE613  0xC0 0xBE       CPY # 0xBE              // case SysCallType.Import:     ID = 23
0xE615  0xD0 0x07       BNE 0xE61E (+7)
0xE617  0x20 0x73 0xE6  JSR 0xE673              // executeImport();                  basicsyscalls.asm:799
0xE61A  0x90 0x1D       BCC 0xE639 (+29)        // if (NC) { break; }                basicsyscalls.asm:800
0xE61C  0x80 0x09       BRA 0xE627 (+9)
0xE61E  0xC0 0xC2       CPY # 0xC2              // case SysCallType.Export:     ID = 24
0xE620  0xD0 0x05       BNE 0xE627 (+5)
0xE622  0x20 0x3C 0xE6  JSR 0xE63C              // executeExport();                  basicsyscalls.asm:812
0xE625  0x90 0x12       BCC 0xE639 (+18)        // if (NC) { break; }                basicsyscalls.asm:813
0xE627  0xA5 0xA5       LDA 0xA5                // LDA ZP.CURRENTSYSCALL             basicsyscalls.asm:831
0xE629  0x29 0x04       AND # 0x04              // AND # 0b00000100    Test return value bit
0xE62B  0xF0 0x05       BEQ 0xE632 (+5)         // if (NZ)                           basicsyscalls.asm:833
0xE62D  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();    Push return value from ZP.TOP0..ZP.TOP3
0xE630  0x90 0x07       BCC 0xE639 (+7)         // if (NC) { break; }                basicsyscalls.asm:837
0xE632  0x38            SEC                     // SEC                               basicsyscalls.asm:839
0xE633  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();              basicsyscalls.asm:840
0xE636  0x4C 0x73 0x8C  JMP 0x8C73              // break;                            basicsyscalls.asm:841
0xE639  0x4C 0x73 0x8C  JMP 0x8C73              // CheckErrorAndSetFailure();        basicsyscalls.asm:843

// /source/projects/6502sbc/hopperbasic/basicsyscalls.asm:856
// ####  BASICSysCalls.executeExport()  ####                                    0x0267

0xE63C  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       basicsyscalls.asm:860
0xE63E  0x29 0x0F       AND # 0x0F              // AND #BASICType.TYPEMASK           basicsyscalls.asm:861
0xE640  0xC9 0x05       CMP # 0x05              // CMP #BASICType.STRING             basicsyscalls.asm:862
0xE642  0xF0 0x03       BEQ 0xE647 (+3)         // if (NZ)                           basicsyscalls.asm:863
0xE644  0x4C 0xED 0x8B  JMP 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE647  0x20 0x5E 0xF6  JSR 0xF65E              // MoveTOPtoSTR();                   basicsyscalls.asm:870
0xE64A  0xDF 0x1A 0x03  BBS5 0x1A, 0xE650 (+3)  // if (BBR5, ZP.NEXTT)    Bit 5 = ARRAY flag
0xE64D  0x4C 0xED 0x8B  JMP 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE650  0x20 0x76 0x96  JSR 0x9676              // Tools.ToUpperSTR();               basicsyscalls.asm:880
0xE653  0xA9 0x02       LDA # 0x02              // LDA # DirWalkAction.FindFile      basicsyscalls.asm:882
0xE655  0x20 0xBB 0xB0  JSR 0xB0BB              // File.Exists();    preserves ZP.STR
0xE658  0x90 0x03       BCC 0xE65D (+3)         // if (C)                            basicsyscalls.asm:884
0xE65A  0x20 0x49 0xB0  JSR 0xB049              // File.Delete();                    basicsyscalls.asm:887
0xE65D  0x20 0x11 0xAF  JSR 0xAF11              // File.StartSave();                 basicsyscalls.asm:893
0xE660  0x90 0x10       BCC 0xE672 (+16)        // if (NC) { break; }                basicsyscalls.asm:894
0xE662  0x20 0xFD 0xAC  JSR 0xACFD              // BASICArray.GetExportPointers();   basicsyscalls.asm:897
0xE665  0x20 0x3D 0xAF  JSR 0xAF3D              // File.AppendStream();              basicsyscalls.asm:900
0xE668  0x90 0x08       BCC 0xE672 (+8)         // if (NC) { break; }                basicsyscalls.asm:901
0xE66A  0xA9 0x00       LDA # 0                 // LDA #0x00     Data file (not executable)
0xE66C  0x20 0x86 0xAF  JSR 0xAF86              // File.EndSave();                   basicsyscalls.asm:905
0xE66F  0x90 0x01       BCC 0xE672 (+1)         // if (NC) { break; }                basicsyscalls.asm:906
0xE671  0x38            SEC                     // SEC    all good                   basicsyscalls.asm:910
0xE672  0x60            RTS                     // }                                 basicsyscalls.asm:913

// /source/projects/6502sbc/hopperbasic/basicsyscalls.asm:920
// ####  BASICSysCalls.executeImport()  ####                                    0x0268

0xE673  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       basicsyscalls.asm:924
0xE675  0x29 0x0F       AND # 0x0F              // AND #BASICType.TYPEMASK           basicsyscalls.asm:925
0xE677  0xC9 0x05       CMP # 0x05              // CMP #BASICType.STRING             basicsyscalls.asm:926
0xE679  0xF0 0x05       BEQ 0xE680 (+5)         // if (NZ)                           basicsyscalls.asm:927
0xE67B  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE67E  0x18            CLC                     // CLC                               basicsyscalls.asm:930
0xE67F  0x60            RTS                     // break;                            basicsyscalls.asm:931
0xE680  0xDF 0x1A 0x05  BBS5 0x1A, 0xE688 (+5)  // if (BBR5, ZP.NEXTT)    Bit 5 = ARRAY flag
0xE683  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xE686  0x18            CLC                     // CLC                               basicsyscalls.asm:938
0xE687  0x60            RTS                     // break;                            basicsyscalls.asm:939
0xE688  0x20 0x5E 0xF6  JSR 0xF65E              // MoveTOPtoSTR();                   basicsyscalls.asm:943
0xE68B  0x20 0x76 0x96  JSR 0x9676              // Tools.ToUpperSTR();               basicsyscalls.asm:946
0xE68E  0xA9 0x02       LDA # 0x02              // LDA # DirWalkAction.FindFile     all files
0xE690  0x20 0xBB 0xB0  JSR 0xB0BB              // File.Exists();    Input: ZP.STR, Output: C if exists
0xE693  0xB0 0x05       BCS 0xE69A (+5)         // if (NC)                           basicsyscalls.asm:950
0xE695  0x20 0xA7 0x8B  JSR 0x8BA7              // Error.FileNotFound(); BIT ZP.EmulatorPCL
0xE698  0x18            CLC                     // CLC                               basicsyscalls.asm:953
0xE699  0x60            RTS                     // break;                            basicsyscalls.asm:954
0xE69A  0x20 0x46 0xB1  JSR 0xB146              // File.GetFileLength();    -> BytesRemainingL/H
0xE69D  0xA0 0x03       LDY # 0x03              // LDY # BASICArray.aiOwner          basicsyscalls.asm:961
0xE69F  0xB1 0x16       LDA [0x16],Y            // LDA [ZP.NEXT], Y                  basicsyscalls.asm:962
0xE6A1  0x85 0x1D       STA 0x1D                // STA ZP.IDYL          Variable node
0xE6A3  0xC8            INY                     // INY                               basicsyscalls.asm:964
0xE6A4  0xB1 0x16       LDA [0x16],Y            // LDA [ZP.NEXT], Y                  basicsyscalls.asm:965
0xE6A6  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       basicsyscalls.asm:966
0xE6A8  0xA0 0x02       LDY # 0x02              // LDY # BASICArray.aiType           basicsyscalls.asm:969
0xE6AA  0xB1 0x16       LDA [0x16],Y            // LDA [ZP.NEXT], Y                  basicsyscalls.asm:970
0xE6AC  0x85 0x10       STA 0x10                // STA ZP.ACCT                       basicsyscalls.asm:971
0xE6AE  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      basicsyscalls.asm:974
0xE6B0  0x85 0x1B       STA 0x1B                // STA ZP.IDXL          Array to free
0xE6B2  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      basicsyscalls.asm:976
0xE6B4  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       basicsyscalls.asm:977
0xE6B6  0x20 0xB8 0x92  JSR 0x92B8              // Memory.Free();       Input: ZP.IDX, Munts: A, ZP.IDX, ZP.M* -> C on success
0xE6B9  0xA5 0x96       LDA 0x96                // LDA File.BytesRemainingL          basicsyscalls.asm:981
0xE6BB  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       basicsyscalls.asm:982
0xE6BD  0xA5 0x97       LDA 0x97                // LDA File.BytesRemainingH          basicsyscalls.asm:983
0xE6BF  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       basicsyscalls.asm:984
0xE6C1  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       basicsyscalls.asm:987
0xE6C3  0xC9 0x06       CMP # 0x06              // case BASICType.BIT:               basicsyscalls.asm:990
0xE6C5  0xD0 0x0E       BNE 0xE6D5 (+14)
0xE6C7  0x06 0x0E       ASL 0x0E                // ASL ZP.ACCL                       basicsyscalls.asm:993
0xE6C9  0x26 0x0F       ROL 0x0F                // ROL ZP.ACCH                       basicsyscalls.asm:994
0xE6CB  0x06 0x0E       ASL 0x0E                // ASL ZP.ACCL                       basicsyscalls.asm:995
0xE6CD  0x26 0x0F       ROL 0x0F                // ROL ZP.ACCH                       basicsyscalls.asm:996
0xE6CF  0x06 0x0E       ASL 0x0E                // ASL ZP.ACCL                       basicsyscalls.asm:997
0xE6D1  0x26 0x0F       ROL 0x0F                // ROL ZP.ACCH                       basicsyscalls.asm:998
0xE6D3  0x80 0x0C       BRA 0xE6E1 (+12)        // }                                 basicsyscalls.asm:999
0xE6D5  0xC9 0x02       CMP # 0x02              // case BASICType.INT:               basicsyscalls.asm:1000
0xE6D7  0xF0 0x04       BEQ 0xE6DD (+4)
0xE6D9  0xC9 0x04       CMP # 0x04              // case BASICType.WORD:              basicsyscalls.asm:1001
0xE6DB  0xD0 0x04       BNE 0xE6E1 (+4)
0xE6DD  0x46 0x0F       LSR 0x0F                // LSR ZP.ACCH                       basicsyscalls.asm:1004
0xE6DF  0x66 0x0E       ROR 0x0E                // ROR ZP.ACCL                       basicsyscalls.asm:1005
0xE6E1  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       basicsyscalls.asm:1010
0xE6E3  0x85 0x11       STA 0x11                // STA ZP.TOP0                       basicsyscalls.asm:1011
0xE6E5  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       basicsyscalls.asm:1012
0xE6E7  0x85 0x12       STA 0x12                // STA ZP.TOP1                       basicsyscalls.asm:1013
0xE6E9  0x64 0x13       STZ 0x13                // STZ ZP.TOP2                       basicsyscalls.asm:1014
0xE6EB  0x64 0x14       STZ 0x14                // STZ ZP.TOP3                       basicsyscalls.asm:1015
0xE6ED  0xA9 0x08       LDA # 0x08              // LDA #BASICType.LONG               basicsyscalls.asm:1016
0xE6EF  0x85 0x15       STA 0x15                // STA ZP.TOPT                       basicsyscalls.asm:1017
0xE6F1  0x20 0xF8 0xAA  JSR 0xAAF8              // BASICArray.New();                 basicsyscalls.asm:1020
0xE6F4  0xB0 0x07       BCS 0xE6FD (+7)         // if (NC)                           basicsyscalls.asm:1021
0xE6F6  0xA9 0x09       LDA # 0x09              // Error.OutOfMemory(); BIT ZP.EmulatorPCL
0xE6F8  0x20 0x5F 0x8B  JSR 0x8B5F
0xE6FB  0x18            CLC                     // CLC                               basicsyscalls.asm:1024
0xE6FC  0x60            RTS                     // break;                            basicsyscalls.asm:1025
0xE6FD  0xA0 0x05       LDY # 0x05              // LDY # Objects.snValue             basicsyscalls.asm:1030
0xE6FF  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL          New array    basicsyscalls.asm:1031
0xE701  0x91 0x1D       STA [0x1D],Y            // STA [ZP.IDY], Y      Variable node (saved in IDY earlier)
0xE703  0xC8            INY                     // INY                               basicsyscalls.asm:1033
0xE704  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       basicsyscalls.asm:1034
0xE706  0x91 0x1D       STA [0x1D],Y            // STA [ZP.IDY], Y                   basicsyscalls.asm:1035
0xE708  0xA0 0x03       LDY # 0x03              // LDY #BASICArray.aiOwner           basicsyscalls.asm:1038
0xE70A  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL          Variable node
0xE70C  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y      New array    basicsyscalls.asm:1040
0xE70E  0xC8            INY                     // INY                               basicsyscalls.asm:1041
0xE70F  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       basicsyscalls.asm:1042
0xE711  0x91 0x1B       STA [0x1B],Y            // STA [ZP.IDX], Y                   basicsyscalls.asm:1043
0xE713  0x18            CLC                     // CLC                               basicsyscalls.asm:1046
0xE714  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       basicsyscalls.asm:1047
0xE716  0x69 0x05       ADC # 0x05              // ADC # BASICArray.aiElements       basicsyscalls.asm:1048
0xE718  0x85 0x63       STA 0x63                // STA ZP.FDESTINATIONADDRESSL       basicsyscalls.asm:1049
0xE71A  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       basicsyscalls.asm:1050
0xE71C  0x69 0x00       ADC # 0                 // ADC # 0                           basicsyscalls.asm:1051
0xE71E  0x85 0x64       STA 0x64                // STA ZP.FDESTINATIONADDRESSH       basicsyscalls.asm:1052
0xE720  0xA9 0x02       LDA # 0x02              // LDA # DirWalkAction.FindFile      basicsyscalls.asm:1055
0xE722  0x20 0xD9 0xB0  JSR 0xB0D9              // File.StartLoad();    Uses ZP.STR  basicsyscalls.asm:1056
0xE725  0x90 0x19       BCC 0xE740 (+25)        // if (NC)                           basicsyscalls.asm:1057
0xE727  0x20 0x03 0xB1  JSR 0xB103              // File.NextStream();                basicsyscalls.asm:1065
0xE72A  0x90 0x13       BCC 0xE73F (+19)        // if (NC)                           basicsyscalls.asm:1066
0xE72C  0x64 0x61       STZ 0x61                // STA ZP.FSOURCEADDRESSL            basicsyscalls.asm:1074
0xE72E  0xA9 0x1A       LDA # 0x1A              // LDA #(File.FileDataBuffer / 256)  basicsyscalls.asm:1075
0xE730  0x85 0x62       STA 0x62                // STA ZP.FSOURCEADDRESSH            basicsyscalls.asm:1076
0xE732  0xA5 0x8E       LDA 0x8E                // LDA File.TransferLengthL          basicsyscalls.asm:1079
0xE734  0x85 0x65       STA 0x65                // STA ZP.FLENGTHL                   basicsyscalls.asm:1080
0xE736  0xA5 0x8F       LDA 0x8F                // LDA File.TransferLengthH          basicsyscalls.asm:1081
0xE738  0x85 0x66       STA 0x66                // STA ZP.FLENGTHH                   basicsyscalls.asm:1082
0xE73A  0x20 0x0B 0x93  JSR 0x930B              // Memory.Copy();                    basicsyscalls.asm:1083
0xE73D  0x80 0xE8       BRA 0xE727 (-24)        // }    loop                         basicsyscalls.asm:1084
0xE73F  0x38            SEC                     // SEC     Success                   basicsyscalls.asm:1086
0xE740  0x60            RTS                     // }                                 basicsyscalls.asm:1089

// /source/projects/6502sbc/hopperbasic/executor.asm:18
// ####  Executor.Reset()  ####                                                 0x0269

0xE741  0x64 0x03       STZ 0x03                // STZ ZP.SP       Reset value/type stack pointer to 0
0xE743  0x64 0x04       STZ 0x04                // STZ ZP.BP       Reset base pointer to 0
0xE745  0x64 0x05       STZ 0x05                // STZ ZP.CSP      Reset call stack pointer to 0
0xE747  0x64 0xA6       STZ 0xA6                // STZ ZP.IDCALLL    No function has been called yet
0xE749  0x64 0xA7       STZ 0xA7                // STZ ZP.IDCALLH                    executor.asm:25
0xE74B  0xA5 0x25       LDA 0x25                // LDA ZP.TICK3    trigger a millis update in the emulator
0xE74D  0xA5 0x22       LDA 0x22                // LDA ZP.TICK0                      executor.asm:29
0xE74F  0x85 0xA3       STA 0xA3                // STA ZP.RANDOMSEEDL                executor.asm:30
0xE751  0xA5 0x23       LDA 0x23                // LDA ZP.TICK1                      executor.asm:31
0xE753  0x85 0xA4       STA 0xA4                // STA ZP.RANDOMSEEDH                executor.asm:32
0xE755  0x20 0x3C 0xA8  JSR 0xA83C              // Functions.IterateFunctions();    Returns first function in ZP.IDX, C if found
0xE758  0x90 0x08       BCC 0xE762 (+8)         // if (NC) { break; }    No more functions
0xE75A  0x20 0x4A 0xA9  JSR 0xA94A              // Functions.RemoveLocals();    IDX = function node
0xE75D  0x20 0x08 0xA0  JSR 0xA008              // Functions.IterateNext();    Get next function
0xE760  0x80 0xF6       BRA 0xE758 (-10)        // }                                 executor.asm:43
0xE762  0x20 0x4C 0x8C  JSR 0x8C4C              // Error.ClearError();               executor.asm:46
0xE765  0x4C 0xBB 0x89  JMP 0x89BB              // States.SetSuccess();              executor.asm:47

// /source/projects/6502sbc/hopperbasic/executor.asm:57
// ####  Executor.LoadGlobals()  ####                                           0x026A

0xE768  0x20 0x6C 0xA3  JSR 0xA36C              // Variables.IterateAll();    Output: ZP.IDX = first symbol, C set if found
0xE76B  0xB0 0x01       BCS 0xE76E (+1)         // if (C)                            executor.asm:64
0xE76D  0x60            RTS
0xE76E  0xB0 0x02       BCS 0xE772 (+2)         // if (NC) { SEC break; }     No more symbols
0xE770  0x38            SEC
0xE771  0x60            RTS
0xE772  0x20 0xEA 0xA1  JSR 0xA1EA              // Variables.GetValue();    Input: ZP.IDX, Output: ZP.TOP = value, ZP.TOPT = dataType (VAR|ARRAY masked away)
0xE775  0x20 0xA9 0xA2  JSR 0xA2A9              // Variables.GetType();    Input: ZP.IDX, Output: ZP.ACCT = symbolType|dataType (packed)
0xE778  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       executor.asm:77
0xE77A  0x29 0x3F       AND # 0x3F              // AND # BASICType.MASK    keep VAR when creating the global slots
0xE77C  0x85 0x15       STA 0x15                // STA ZP.TOPT                       executor.asm:79
0xE77E  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();     LoadGlobals: type is in A
0xE781  0x20 0x08 0xA0  JSR 0xA008              // Variables.IterateNext();    Input: ZP.IDX = current, Output: ZP.IDX = next
0xE784  0x80 0xE8       BRA 0xE76E (-24)        // }                                 executor.asm:84

// /source/projects/6502sbc/hopperbasic/executor.asm:99
// ####  Executor.SaveGlobals()  ####                                           0x026B

0xE786  0x20 0x6C 0xA3  JSR 0xA36C              // Variables.IterateAll();    Output: ZP.IDX = first symbol, C set if found
0xE789  0x90 0x66       BCC 0xE7F1 (+102)       // if (C)                            executor.asm:119
0xE78B  0xA0 0x00       LDY # 0                 // LDY #0     Index counter - tracks position on stack
0xE78D  0xB0 0x03       BCS 0xE792 (+3)         // if (NC) { SEC break; }     No more symbols
0xE78F  0x38            SEC
0xE790  0x80 0x5F       BRA 0xE7F1 (+95)
0xE792  0x20 0xA9 0xA2  JSR 0xA2A9              // Variables.GetType();    Input: ZP.IDX, Output: ZP.ACCT = type
0xE795  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       executor.asm:129
0xE797  0x29 0x80       AND # 0x80              // AND # SymbolType.CONSTANT         executor.asm:130
0xE799  0xF0 0x06       BEQ 0xE7A1 (+6)         // if (NZ)     It's a constant - skip it
0xE79B  0xC8            INY                     // INY     Still increment index to stay in sync with stack position
0xE79C  0x20 0x08 0xA0  JSR 0xA008              // Variables.IterateNext();          executor.asm:134
0xE79F  0x80 0xEC       BRA 0xE78D (-20)        // continue;     Skip to next iteration
0xE7A1  0x5F 0x10 0x06  BBR5 0x10, 0xE7AA (+6)  // if (BBS5, ZP.ACCT)    Bit 5 - ARRAY
0xE7A4  0xC8            INY                     // INY     Still increment index to stay in sync with stack position
0xE7A5  0x20 0x08 0xA0  JSR 0xA008              // Variables.IterateNext();          executor.asm:141
0xE7A8  0x80 0xE3       BRA 0xE78D (-29)        // continue;     Skip to next iteration
0xE7AA  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStackLSB, Y       executor.asm:146
0xE7AD  0x85 0x15       STA 0x15                // STA ZP.TOPT                       executor.asm:147
0xE7AF  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackB0, Y       executor.asm:150
0xE7B2  0x85 0x11       STA 0x11                // STA ZP.TOP0                       executor.asm:151
0xE7B4  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackB1, Y       executor.asm:152
0xE7B7  0x85 0x12       STA 0x12                // STA ZP.TOP1                       executor.asm:153
0xE7B9  0xB9 0x00 0x08  LDA 0x0800,Y            // LDA Address.ValueStackB2, Y       executor.asm:154
0xE7BC  0x85 0x13       STA 0x13                // STA ZP.TOP2                       executor.asm:155
0xE7BE  0xB9 0x00 0x09  LDA 0x0900,Y            // LDA Address.ValueStackB3, Y       executor.asm:156
0xE7C1  0x85 0x14       STA 0x14                // STA ZP.TOP3                       executor.asm:157
0xE7C3  0x4F 0x02 0x12  BBR4 0x02, 0xE7D8 (+18) // if (BBS4, ZP.FLAGS)    Bit 4 - initialization mode: skip current variable GVI?
0xE7C6  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       executor.asm:161
0xE7C8  0xC5 0x82       CMP 0x82                // CMP ZP.GVIL                       executor.asm:162
0xE7CA  0xD0 0x0C       BNE 0xE7D8 (+12)        // if (Z)                            executor.asm:163
0xE7CC  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       executor.asm:165
0xE7CE  0xC5 0x83       CMP 0x83                // CMP ZP.GVIH                       executor.asm:166
0xE7D0  0xD0 0x06       BNE 0xE7D8 (+6)         // if (Z)                            executor.asm:167
0xE7D2  0xC8            INY                     // INY     Increment index for next stack position
0xE7D3  0x20 0x08 0xA0  JSR 0xA008              // Variables.IterateNext();    Input: ZP.IDX = current, Output: ZP.IDX = next
0xE7D6  0x80 0xB5       BRA 0xE78D (-75)        // continue;                         executor.asm:172
0xE7D8  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStackLSB, Y     Get type from stack
0xE7DB  0x29 0x20       AND # 0x20              // AND # BASICType.ARRAY             executor.asm:179
0xE7DD  0xF0 0x06       BEQ 0xE7E5 (+6)         // if (NZ)                           executor.asm:180
0xE7DF  0xC8            INY                     // INY     Increment index for next stack position
0xE7E0  0x20 0x08 0xA0  JSR 0xA008              // Variables.IterateNext();    Input: ZP.IDX = current, Output: ZP.IDX = next
0xE7E3  0x80 0xA8       BRA 0xE78D (-88)        // continue;                         executor.asm:185
0xE7E5  0x20 0xA9 0xA2  JSR 0xA2A9              // Variables.GetType();              executor.asm:189
0xE7E8  0x20 0x0A 0xA2  JSR 0xA20A              // Variables.SetValue();    preserves Y, Input: ZP.IDX = node, ZP.TOP = value, ZP.TOPT = type
0xE7EB  0xC8            INY                     // INY     Increment index for next stack position
0xE7EC  0x20 0x08 0xA0  JSR 0xA008              // Variables.IterateNext();    Input: ZP.IDX = current, Output: ZP.IDX = next
0xE7EF  0x80 0x9C       BRA 0xE78D (-100)       // }    loop                         executor.asm:200
0xE7F1  0x38            SEC                     // SEC                               executor.asm:206
0xE7F2  0x60            RTS                     // }                                 executor.asm:207

// /source/projects/6502sbc/hopperbasic/executor.asm:216
// ####  Executor.ExecuteOpCodes()  ####                                        0x026C

0xE7F3  0x48            PHA                     // PHA                               executor.asm:217
0xE7F4  0xDA            PHX                     // PHX                               executor.asm:218
0xE7F5  0x5A            PHY                     // PHY                               executor.asm:219
0xE7F6  0x20 0x41 0xE7  JSR 0xE741              // Executor.Reset();                 executor.asm:227
0xE7F9  0x20 0x68 0xE7  JSR 0xE768              // Executor.LoadGlobals();           executor.asm:231
0xE7FC  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        executor.asm:232
0xE7FF  0x90 0x3A       BCC 0xE83B (+58)        // if (NC) { break; }                executor.asm:233
0xE801  0x20 0x42 0xE8  JSR 0xE842              // InitExecutor();                   executor.asm:236
0xE804  0x90 0x35       BCC 0xE83B (+53)        // if (NC) { break; }    empty opcode stream -> State.Failure set
0xE806  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:243
0xE808  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:246
0xE80A  0xD0 0x02       BNE 0xE80E (+2)         // if (Z)                            executor.asm:247
0xE80C  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:249
0xE80E  0x20 0x7C 0xE8  JSR 0xE87C              // DispatchOpCode();    expect State.Success to continue
0xE811  0x0F 0x0C 0x0A  BBR0 0x0C, 0xE81E (+10) // if (BBS0, ZP.SerialFlags)         executor.asm:262
0xE814  0x07 0x0C       RMB0 0x0C               // RMB0 ZP.SerialFlags      Clear the BREAK flag
0xE816  0x20 0xDE 0x8B  JSR 0x8BDE              // Error.Break();           "BREAK" error message
0xE819  0x64 0x4E       STZ 0x4E                // States.SetFailure();              executor.asm:266
0xE81B  0x18            CLC                     // CLC                               executor.asm:267
0xE81C  0x80 0x1D       BRA 0xE83B (+29)        // break;                            executor.asm:268
0xE81E  0xA5 0x2D       LDA 0x2D                // LDA ZP.LastError                  executor.asm:272
0xE820  0xD0 0x06       BNE 0xE828 (+6)         // if (Z)                            executor.asm:273
0xE822  0xA5 0x4E       LDA 0x4E                // LDA ZP.SystemState                executor.asm:275
0xE824  0xC9 0x01       CMP # 1                 // CMP # State.Success               executor.asm:276
0xE826  0xF0 0xDE       BEQ 0xE806 (-34)        // if (Z)                            executor.asm:277
0xE828  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        executor.asm:285
0xE82B  0x90 0x0E       BCC 0xE83B (+14)        // if (NC) { break; }                executor.asm:286
0xE82D  0x20 0x96 0x89  JSR 0x8996              // States.CanContinue();     Returns C for Success|Exiting|Return, NC for Failure
0xE830  0xB0 0x03       BCS 0xE835 (+3)         // if (NC)                           executor.asm:288
0xE832  0x18            CLC                     // CLC                               executor.asm:291
0xE833  0x80 0x06       BRA 0xE83B (+6)         // break;     Exit with NC           executor.asm:292
0xE835  0x20 0xAE 0x89  JSR 0x89AE              // States.IsSuccess();               executor.asm:294
0xE838  0xB0 0xCC       BCS 0xE806 (-52)        // if (NC)                           executor.asm:295
0xE83A  0x38            SEC                     // SEC                               executor.asm:298
0xE83B  0x20 0x86 0xE7  JSR 0xE786              // Executor.SaveGlobals();           executor.asm:306
0xE83E  0x7A            PLY                     // PLY                               executor.asm:313
0xE83F  0xFA            PLX                     // PLX                               executor.asm:314
0xE840  0x68            PLA                     // PLA                               executor.asm:315
0xE841  0x60            RTS                     // }                                 executor.asm:316

// /source/projects/6502sbc/hopperbasic/executor.asm:323
// ####  Executor.InitExecutor()  ####                                          0x026D

0xE842  0xA5 0x3A       LDA 0x3A                // LDA ZP.OpCodeBufferL              executor.asm:329
0xE844  0x85 0x00       STA 0x00                // STA ZP.PCL                        executor.asm:330
0xE846  0xA5 0x3B       LDA 0x3B                // LDA ZP.OpCodeBufferH              executor.asm:331
0xE848  0x85 0x01       STA 0x01                // STA ZP.PCH                        executor.asm:332
0xE84A  0xA5 0x32       LDA 0x32                // LDA ZP.OpCodeBufferContentLengthL executor.asm:335
0xE84C  0x05 0x33       ORA 0x33                // ORA ZP.OpCodeBufferContentLengthH executor.asm:336
0xE84E  0xD0 0x07       BNE 0xE857 (+7)         // if (Z)                            executor.asm:337
0xE850  0x20 0xCA 0x8B  JSR 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0xE853  0x64 0x4E       STZ 0x4E                // States.SetFailure();              executor.asm:340
0xE855  0x18            CLC                     // CLC                               executor.asm:341
0xE856  0x60            RTS                     // }                                 executor.asm:342
0xE857  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();              executor.asm:345
0xE85A  0x38            SEC                     // SEC                               executor.asm:346
0xE85B  0x60            RTS                     // }                                 executor.asm:352

// /source/projects/6502sbc/hopperbasic/executor.asm:360
// ####  Executor.FetchOperandByte()  ####                                      0x026E

0xE85C  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:364
0xE85E  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:367
0xE860  0xF0 0x01       BEQ 0xE863 (+1)         // if (Z)                            executor.asm:368
0xE862  0x60            RTS
0xE863  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:370
0xE865  0x60            RTS                     // break;                            executor.asm:382

// /source/projects/6502sbc/hopperbasic/executor.asm:391
// ####  Executor.FetchOperandWord()  ####                                      0x026F

0xE866  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:394
0xE868  0x85 0x0E       STA 0x0E                // STA ZP.ACCL    Save operand       executor.asm:395
0xE86A  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:398
0xE86C  0xD0 0x02       BNE 0xE870 (+2)         // if (Z)                            executor.asm:399
0xE86E  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:401
0xE870  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:404
0xE872  0x85 0x0F       STA 0x0F                // STA ZP.ACCH    Save operand       executor.asm:405
0xE874  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:408
0xE876  0xF0 0x01       BEQ 0xE879 (+1)         // if (Z)                            executor.asm:409
0xE878  0x60            RTS
0xE879  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:411
0xE87B  0x60            RTS                     // break;                            executor.asm:423

// /source/projects/6502sbc/hopperbasic/executor.asm:431
// ####  Executor.DispatchOpCode()  ####                                        0x0270

0xE87C  0xA8            TAY                     // TAY                               executor.asm:432
0xE87D  0xC0 0xC3       CPY # 0xC3              // }                                 executor.asm:813
0xE87F  0x90 0x03       BCC 0xE884 (+3)
0xE881  0x4C 0x19 0xEA  JMP 0xEA19
0xE884  0xB9 0x91 0xE8  LDA 0xE891,Y
0xE887  0x85 0x20       STA 0x20
0xE889  0xB9 0x55 0xE9  LDA 0xE955,Y
0xE88C  0x85 0x21       STA 0x21
0xE88E  0x6C 0x20 0x00  JMP [0x0020]
    0xE891 0x00 0xEA19    // -> Executor.executeNotImplemented()
    0xE892 0x01 0xBF77    // -> Instructions.Addition()
    0xE893 0x02 0xBFA2    // -> Instructions.Subtraction()
    0xE894 0x03 0xC004    // -> Instructions.Multiply()
    0xE895 0x04 0xC016    // -> Instructions.Divide()
    0xE896 0x05 0xC028    // -> Instructions.Modulo()
    0xE897 0x06 0xBFCF    // -> Instructions.UnaryMinus()
    0xE898 0x07 0xC038    // -> Instructions.BitwiseAnd()
    0xE899 0x08 0xC082    // -> Instructions.BitwiseOr()
    0xE89A 0x09 0xC062    // -> Instructions.BitwiseNot()
    0xE89B 0x0A 0xC0AC    // -> Instructions.LogicalAnd()
    0xE89C 0x0B 0xC0D1    // -> Instructions.LogicalOr()
    0xE89D 0x0C 0xC0F6    // -> Instructions.LogicalNot()
    0xE89E 0x0D 0xE164    // -> ComparisonInstructions.Equal()
    0xE89F 0x0E 0xE1A7    // -> ComparisonInstructions.NotEqual()
    0xE8A0 0x0F 0xE1E9    // -> ComparisonInstructions.LessThan()
    0xE8A1 0x10 0xE221    // -> ComparisonInstructions.GreaterThan()
    0xE8A2 0x11 0xE259    // -> ComparisonInstructions.LessEqual()
    0xE8A3 0x12 0xE291    // -> ComparisonInstructions.GreaterEqual()
    0xE8A4 0x13 0xEA96    // -> Executor.executeDup()
    0xE8A5 0x14 0xEA9F    // -> Executor.executeNop()
    0xE8A6 0x15 0xEAA0    // -> Executor.executePush0()
    0xE8A7 0x16 0xEAA6    // -> Executor.executePush1()
    0xE8A8 0x17 0xEAB8    // -> Executor.executePushVoid()
    0xE8A9 0x18 0xEA19    // -> Executor.executeNotImplemented()
    0xE8AA 0x19 0xEA57    // -> Executor.executeHalt()
    0xE8AB 0x1A 0xEA19    // -> Executor.executeNotImplemented()
    0xE8AC 0x1B 0xEAAE    // -> Executor.executePushEmptyVar()
    0xE8AD 0x1C 0xEF7F    // -> Executor.executeGetItem()
    0xE8AE 0x1D 0xEF8A    // -> Executor.executeSetItem()
    0xE8AF 0x1E 0xEA19    // -> Executor.executeNotImplemented()
    0xE8B0 0x1F 0xEA19    // -> Executor.executeNotImplemented()
    0xE8B1 0x20 0xEA19    // -> Executor.executeNotImplemented()
    0xE8B2 0x21 0xEA19    // -> Executor.executeNotImplemented()
    0xE8B3 0x22 0xEA19    // -> Executor.executeNotImplemented()
    0xE8B4 0x23 0xEA19    // -> Executor.executeNotImplemented()
    0xE8B5 0x24 0xEA19    // -> Executor.executeNotImplemented()
    0xE8B6 0x25 0xEA19    // -> Executor.executeNotImplemented()
    0xE8B7 0x26 0xEA19    // -> Executor.executeNotImplemented()
    0xE8B8 0x27 0xEA19    // -> Executor.executeNotImplemented()
    0xE8B9 0x28 0xEA19    // -> Executor.executeNotImplemented()
    0xE8BA 0x29 0xEA19    // -> Executor.executeNotImplemented()
    0xE8BB 0x2A 0xEA19    // -> Executor.executeNotImplemented()
    0xE8BC 0x2B 0xEA19    // -> Executor.executeNotImplemented()
    0xE8BD 0x2C 0xEA19    // -> Executor.executeNotImplemented()
    0xE8BE 0x2D 0xEA19    // -> Executor.executeNotImplemented()
    0xE8BF 0x2E 0xEA19    // -> Executor.executeNotImplemented()
    0xE8C0 0x2F 0xEA19    // -> Executor.executeNotImplemented()
    0xE8C1 0x30 0xEA19    // -> Executor.executeNotImplemented()
    0xE8C2 0x31 0xEA19    // -> Executor.executeNotImplemented()
    0xE8C3 0x32 0xEA19    // -> Executor.executeNotImplemented()
    0xE8C4 0x33 0xEA19    // -> Executor.executeNotImplemented()
    0xE8C5 0x34 0xEA19    // -> Executor.executeNotImplemented()
    0xE8C6 0x35 0xEA19    // -> Executor.executeNotImplemented()
    0xE8C7 0x36 0xEA19    // -> Executor.executeNotImplemented()
    0xE8C8 0x37 0xEA19    // -> Executor.executeNotImplemented()
    0xE8C9 0x38 0xEA19    // -> Executor.executeNotImplemented()
    0xE8CA 0x39 0xEA19    // -> Executor.executeNotImplemented()
    0xE8CB 0x3A 0xEA19    // -> Executor.executeNotImplemented()
    0xE8CC 0x3B 0xEA19    // -> Executor.executeNotImplemented()
    0xE8CD 0x3C 0xEA19    // -> Executor.executeNotImplemented()
    0xE8CE 0x3D 0xEA19    // -> Executor.executeNotImplemented()
    0xE8CF 0x3E 0xEA19    // -> Executor.executeNotImplemented()
    0xE8D0 0x3F 0xEA19    // -> Executor.executeNotImplemented()
    0xE8D1 0x40 0xEAC2    // -> Executor.executePushBit()
    0xE8D2 0x41 0xEADA    // -> Executor.executePushByte()
    0xE8D3 0x42 0xEAE8    // -> Executor.executePushChar()
    0xE8D4 0x43 0xECC5    // -> Executor.executePushLocal()
    0xE8D5 0x44 0xEC71    // -> Executor.executePopLocal()
    0xE8D6 0x45 0xEA19    // -> Executor.executeNotImplemented()
    0xE8D7 0x46 0xEA19    // -> Executor.executeNotImplemented()
    0xE8D8 0x47 0xEA19    // -> Executor.executeNotImplemented()
    0xE8D9 0x48 0xE36F    // -> BASICSysCalls.ExecuteSysCall()
    0xE8DA 0x49 0xEA5A    // -> Executor.executeReturn()
    0xE8DB 0x4A 0xEA65    // -> Executor.executeReturnVal()
    0xE8DC 0x4B 0xEBDC    // -> Executor.executePushGlobal()
    0xE8DD 0x4C 0xEC18    // -> Executor.executePopGlobal()
    0xE8DE 0x4D 0xF05B    // -> Executor.executeIncGlobal()
    0xE8DF 0x4E 0xF045    // -> Executor.executeIncLocal()
    0xE8E0 0x4F 0xEA86    // -> Executor.executeDecSP()
    0xE8E1 0x50 0xEA6B    // -> Executor.executeEnter()
    0xE8E2 0x51 0xECFA    // -> Executor.executePushLocalDup()
    0xE8E3 0x52 0xEA19    // -> Executor.executeNotImplemented()
    0xE8E4 0x53 0xEA19    // -> Executor.executeNotImplemented()
    0xE8E5 0x54 0xEA19    // -> Executor.executeNotImplemented()
    0xE8E6 0x55 0xEA19    // -> Executor.executeNotImplemented()
    0xE8E7 0x56 0xEA19    // -> Executor.executeNotImplemented()
    0xE8E8 0x57 0xEA19    // -> Executor.executeNotImplemented()
    0xE8E9 0x58 0xEA19    // -> Executor.executeNotImplemented()
    0xE8EA 0x59 0xEA19    // -> Executor.executeNotImplemented()
    0xE8EB 0x5A 0xEA19    // -> Executor.executeNotImplemented()
    0xE8EC 0x5B 0xEA19    // -> Executor.executeNotImplemented()
    0xE8ED 0x5C 0xEA19    // -> Executor.executeNotImplemented()
    0xE8EE 0x5D 0xEA19    // -> Executor.executeNotImplemented()
    0xE8EF 0x5E 0xEA19    // -> Executor.executeNotImplemented()
    0xE8F0 0x5F 0xEA19    // -> Executor.executeNotImplemented()
    0xE8F1 0x60 0xEA19    // -> Executor.executeNotImplemented()
    0xE8F2 0x61 0xEA19    // -> Executor.executeNotImplemented()
    0xE8F3 0x62 0xEA19    // -> Executor.executeNotImplemented()
    0xE8F4 0x63 0xEA19    // -> Executor.executeNotImplemented()
    0xE8F5 0x64 0xEA19    // -> Executor.executeNotImplemented()
    0xE8F6 0x65 0xEA19    // -> Executor.executeNotImplemented()
    0xE8F7 0x66 0xEA19    // -> Executor.executeNotImplemented()
    0xE8F8 0x67 0xEA19    // -> Executor.executeNotImplemented()
    0xE8F9 0x68 0xEA19    // -> Executor.executeNotImplemented()
    0xE8FA 0x69 0xEA19    // -> Executor.executeNotImplemented()
    0xE8FB 0x6A 0xEA19    // -> Executor.executeNotImplemented()
    0xE8FC 0x6B 0xEA19    // -> Executor.executeNotImplemented()
    0xE8FD 0x6C 0xEA19    // -> Executor.executeNotImplemented()
    0xE8FE 0x6D 0xEA19    // -> Executor.executeNotImplemented()
    0xE8FF 0x6E 0xEA19    // -> Executor.executeNotImplemented()
    0xE900 0x6F 0xEA19    // -> Executor.executeNotImplemented()
    0xE901 0x70 0xEA19    // -> Executor.executeNotImplemented()
    0xE902 0x71 0xEA19    // -> Executor.executeNotImplemented()
    0xE903 0x72 0xEA19    // -> Executor.executeNotImplemented()
    0xE904 0x73 0xEA19    // -> Executor.executeNotImplemented()
    0xE905 0x74 0xEA19    // -> Executor.executeNotImplemented()
    0xE906 0x75 0xEA19    // -> Executor.executeNotImplemented()
    0xE907 0x76 0xEA19    // -> Executor.executeNotImplemented()
    0xE908 0x77 0xEA19    // -> Executor.executeNotImplemented()
    0xE909 0x78 0xEA19    // -> Executor.executeNotImplemented()
    0xE90A 0x79 0xEA19    // -> Executor.executeNotImplemented()
    0xE90B 0x7A 0xEA19    // -> Executor.executeNotImplemented()
    0xE90C 0x7B 0xEA19    // -> Executor.executeNotImplemented()
    0xE90D 0x7C 0xEA19    // -> Executor.executeNotImplemented()
    0xE90E 0x7D 0xEA19    // -> Executor.executeNotImplemented()
    0xE90F 0x7E 0xEA19    // -> Executor.executeNotImplemented()
    0xE910 0x7F 0xEA19    // -> Executor.executeNotImplemented()
    0xE911 0x80 0xEB61    // -> Executor.executePushInt()
    0xE912 0x81 0xEB7E    // -> Executor.executePushWord()
    0xE913 0x82 0xEB11    // -> Executor.executePushCString()
    0xE914 0x83 0xEB1E    // -> Executor.executeCall()
    0xE915 0x84 0xEB5E    // -> Executor.executeCallF()
    0xE916 0x85 0xEA19    // -> Executor.executeNotImplemented()
    0xE917 0x86 0xEA19    // -> Executor.executeNotImplemented()
    0xE918 0x87 0xEB9E    // -> Executor.executeJumpW()
    0xE919 0x88 0xEBA4    // -> Executor.executeJumpZW()
    0xE91A 0x89 0xEA19    // -> Executor.executeNotImplemented()
    0xE91B 0x8A 0xF06E    // -> Executor.executeAddLocals()
    0xE91C 0x8B 0xF0EA    // -> Executor.executeAddGlobals()
    0xE91D 0x8C 0xEF1F    // -> Executor.executeGetItemGG()
    0xE91E 0x8D 0xEF34    // -> Executor.executeGetItemGL()
    0xE91F 0x8E 0xEF4C    // -> Executor.executeGetItemLG()
    0xE920 0x8F 0xEF64    // -> Executor.executeGetItemLL()
    0xE921 0x90 0xF003    // -> Executor.executeSetItemGG()
    0xE922 0x91 0xEFAF    // -> Executor.executeSetItemGL()
    0xE923 0x92 0xEFCA    // -> Executor.executeSetItemLG()
    0xE924 0x93 0xEFE5    // -> Executor.executeSetItemLL()
    0xE925 0x94 0xF106    // -> Executor.executePushLong()
    0xE926 0x95 0xEA19    // -> Executor.executeNotImplemented()
    0xE927 0x96 0xEA19    // -> Executor.executeNotImplemented()
    0xE928 0x97 0xEA19    // -> Executor.executeNotImplemented()
    0xE929 0x98 0xEA19    // -> Executor.executeNotImplemented()
    0xE92A 0x99 0xEA19    // -> Executor.executeNotImplemented()
    0xE92B 0x9A 0xEA19    // -> Executor.executeNotImplemented()
    0xE92C 0x9B 0xEA19    // -> Executor.executeNotImplemented()
    0xE92D 0x9C 0xEA19    // -> Executor.executeNotImplemented()
    0xE92E 0x9D 0xEA19    // -> Executor.executeNotImplemented()
    0xE92F 0x9E 0xEA19    // -> Executor.executeNotImplemented()
    0xE930 0x9F 0xEA19    // -> Executor.executeNotImplemented()
    0xE931 0xA0 0xEA19    // -> Executor.executeNotImplemented()
    0xE932 0xA1 0xEA19    // -> Executor.executeNotImplemented()
    0xE933 0xA2 0xEA19    // -> Executor.executeNotImplemented()
    0xE934 0xA3 0xEA19    // -> Executor.executeNotImplemented()
    0xE935 0xA4 0xEA19    // -> Executor.executeNotImplemented()
    0xE936 0xA5 0xEA19    // -> Executor.executeNotImplemented()
    0xE937 0xA6 0xEA19    // -> Executor.executeNotImplemented()
    0xE938 0xA7 0xEA19    // -> Executor.executeNotImplemented()
    0xE939 0xA8 0xEA19    // -> Executor.executeNotImplemented()
    0xE93A 0xA9 0xEA19    // -> Executor.executeNotImplemented()
    0xE93B 0xAA 0xEA19    // -> Executor.executeNotImplemented()
    0xE93C 0xAB 0xEA19    // -> Executor.executeNotImplemented()
    0xE93D 0xAC 0xEA19    // -> Executor.executeNotImplemented()
    0xE93E 0xAD 0xEA19    // -> Executor.executeNotImplemented()
    0xE93F 0xAE 0xEA19    // -> Executor.executeNotImplemented()
    0xE940 0xAF 0xEA19    // -> Executor.executeNotImplemented()
    0xE941 0xB0 0xEA19    // -> Executor.executeNotImplemented()
    0xE942 0xB1 0xEA19    // -> Executor.executeNotImplemented()
    0xE943 0xB2 0xEA19    // -> Executor.executeNotImplemented()
    0xE944 0xB3 0xEA19    // -> Executor.executeNotImplemented()
    0xE945 0xB4 0xEA19    // -> Executor.executeNotImplemented()
    0xE946 0xB5 0xEA19    // -> Executor.executeNotImplemented()
    0xE947 0xB6 0xEA19    // -> Executor.executeNotImplemented()
    0xE948 0xB7 0xEA19    // -> Executor.executeNotImplemented()
    0xE949 0xB8 0xEA19    // -> Executor.executeNotImplemented()
    0xE94A 0xB9 0xEA19    // -> Executor.executeNotImplemented()
    0xE94B 0xBA 0xEA19    // -> Executor.executeNotImplemented()
    0xE94C 0xBB 0xEA19    // -> Executor.executeNotImplemented()
    0xE94D 0xBC 0xEA19    // -> Executor.executeNotImplemented()
    0xE94E 0xBD 0xEA19    // -> Executor.executeNotImplemented()
    0xE94F 0xBE 0xEA19    // -> Executor.executeNotImplemented()
    0xE950 0xBF 0xEA19    // -> Executor.executeNotImplemented()
    0xE951 0xC0 0xED40    // -> Executor.executeFORCHK()
    0xE952 0xC1 0xED95    // -> Executor.executeFORIT()
    0xE953 0xC2 0xEE03    // -> Executor.executeFORITF()
    0xE954 0xC3 0xEA19    // -> Executor.executeNotImplemented()

// /source/projects/6502sbc/hopperbasic/executor.asm:820
// ####  Executor.executeNotImplemented()  ####                                 0x0271

0xEA19  0x60            RTS                     // }                                 executor.asm:837

// /source/projects/6502sbc/hopperbasic/executor.asm:852
// ####  Executor.commonReturn()  ####                                          0x0272

0xEA1A  0x20 0x5C 0xE8  JSR 0xE85C              // FetchOperandByte();               executor.asm:857
0xEA1D  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       executor.asm:858
0xEA1F  0x38            SEC                     // SEC                               executor.asm:861
0xEA20  0xA5 0x04       LDA 0x04                // LDA ZP.BP                         executor.asm:862
0xEA22  0xE5 0x0E       SBC 0x0E                // SBC ZP.ACCL            BP - arg_count
0xEA24  0x85 0x03       STA 0x03                // STA ZP.SP                         executor.asm:864
0xEA26  0xAA            TAX                     // TAX                               executor.asm:865
0xEA27  0xCA            DEX                     // DEX                               executor.asm:866
0xEA28  0xDA            PHX                     // PHX                               executor.asm:868
0xEA29  0x20 0xAB 0x93  JSR 0x93AB              // Stacks.PopBP();                   executor.asm:870
0xEA2C  0x20 0xDD 0x93  JSR 0x93DD              // Stacks.PopXID();                  executor.asm:871
0xEA2F  0x20 0xBF 0x93  JSR 0x93BF              // Stacks.PopPC();                   executor.asm:872
0xEA32  0xA5 0x05       LDA 0x05                // LDA ZP.CSP                        executor.asm:874
0xEA34  0xD0 0x06       BNE 0xEA3C (+6)         // if (Z)    CallStack pointer == 0? executor.asm:875
0xEA36  0xFA            PLX                     // PLX    discard                    executor.asm:877
0xEA37  0xA9 0x03       LDA # 0x03              // LDA #State.Return                 executor.asm:880
0xEA39  0x85 0x4E       STA 0x4E                // STA ZP.SystemState                executor.asm:881
0xEA3B  0x60            RTS                     // }                                 executor.asm:882
0xEA3C  0xFA            PLX                     // PLX                               executor.asm:886
0xEA3D  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       executor.asm:887
0xEA3F  0x9D 0x00 0x06  STA 0x0600,X            // STA Address.ValueStackB0, X       executor.asm:888
0xEA42  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       executor.asm:889
0xEA44  0x9D 0x00 0x07  STA 0x0700,X            // STA Address.ValueStackB1, X       executor.asm:890
0xEA47  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       executor.asm:891
0xEA49  0x9D 0x00 0x08  STA 0x0800,X            // STA Address.ValueStackB2, X       executor.asm:892
0xEA4C  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       executor.asm:893
0xEA4E  0x9D 0x00 0x09  STA 0x0900,X            // STA Address.ValueStackB3, X       executor.asm:894
0xEA51  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       executor.asm:895
0xEA53  0x9D 0x00 0x05  STA 0x0500,X            // STA Address.TypeStackLSB, X       executor.asm:896
0xEA56  0x60            RTS                     // break;                            executor.asm:898

// /source/projects/6502sbc/hopperbasic/executor.asm:905
// ####  Executor.executeHalt()  ####                                           0x0273

0xEA57  0x4C 0xC2 0x89  JMP 0x89C2              // States.SetExiting();              executor.asm:909

// /source/projects/6502sbc/hopperbasic/executor.asm:918
// ####  Executor.executeReturn()  ####                                         0x0274

0xEA5A  0xA9 0x00       LDA # 0                 // LDA # BASICType.VOID              executor.asm:922
0xEA5C  0x85 0x15       STA 0x15                // STA ZP.TOPT                       executor.asm:923
0xEA5E  0x64 0x11       STZ 0x11                // STZ ZP.TOPL                       executor.asm:924
0xEA60  0x64 0x12       STZ 0x12                // STZ ZP.TOPH                       executor.asm:925
0xEA62  0x4C 0x1A 0xEA  JMP 0xEA1A              // commonReturn();                   executor.asm:926

// /source/projects/6502sbc/hopperbasic/executor.asm:939
// ####  Executor.executeReturnVal()  ####                                      0x0275

0xEA65  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();    ReturnVal       executor.asm:943
0xEA68  0x4C 0x1A 0xEA  JMP 0xEA1A              // commonReturn();                   executor.asm:944

// /source/projects/6502sbc/hopperbasic/executor.asm:954
// ####  Executor.executeEnter()  ####                                          0x0276

0xEA6B  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:963
0xEA6D  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:966
0xEA6F  0xD0 0x02       BNE 0xEA73 (+2)         // if (Z)                            executor.asm:967
0xEA71  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:969
0xEA73  0xAA            TAX                     // TAX                               executor.asm:972
0xEA74  0x20 0xB5 0x93  JSR 0x93B5              // Stacks.PushBP();    munts Y       executor.asm:974
0xEA77  0xA5 0x03       LDA 0x03                // LDA ZP.SP                         executor.asm:975
0xEA79  0x85 0x04       STA 0x04                // STA ZP.BP                         executor.asm:976
0xEA7B  0xE0 0x00       CPX # 0                 // CPX #0                            executor.asm:978
0xEA7D  0xF0 0x06       BEQ 0xEA85 (+6)         // if (Z) { break; }                 executor.asm:981
0xEA7F  0x20 0xAE 0xEA  JSR 0xEAAE              // executePushEmptyVar();    munts Y executor.asm:982
0xEA82  0xCA            DEX                     // DEX                               executor.asm:983
0xEA83  0x80 0xF8       BRA 0xEA7D (-8)         // }                                 executor.asm:984
0xEA85  0x60            RTS                     // }                                 executor.asm:991

// /source/projects/6502sbc/hopperbasic/executor.asm:996
// ####  Executor.executeDecSP()  ####                                          0x0277

0xEA86  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:1005
0xEA88  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:1008
0xEA8A  0xD0 0x02       BNE 0xEA8E (+2)         // if (Z)                            executor.asm:1009
0xEA8C  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:1011
0xEA8E  0x38            SEC                     // SEC             Set carry for proper subtraction (1 byte, 2 cycles)
0xEA8F  0x49 0xFF       EOR # 0xFF              // EOR #0xFF       One's complement of operand (2 bytes, 2 cycles)
0xEA91  0x65 0x03       ADC 0x03                // ADC ZP.SP       Two's complement subtraction: SP + (~operand + 1) = SP - operand (2 bytes, 3 cycles)
0xEA93  0x85 0x03       STA 0x03                // STA ZP.SP       Store result (2 bytes, 3 cycles)
0xEA95  0x60            RTS                     // }                                 executor.asm:1022

// /source/projects/6502sbc/hopperbasic/executor.asm:1027
// ####  Executor.executeDup()  ####                                            0x0278

0xEA96  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();     Dup: Get top value in ZP.TOP and ZP.TOPT
0xEA99  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();    Dup: push value and type to stack -> always Success
0xEA9C  0x4C 0x6A 0x97  JMP 0x976A              // Long.PushTop();    Dup: push value and type to stack -> always Success

// /source/projects/6502sbc/hopperbasic/executor.asm:1045
// ####  Executor.executeNop()  ####                                            0x0279

0xEA9F  0x60            RTS                     // }                                 executor.asm:1055

// /source/projects/6502sbc/hopperbasic/executor.asm:1062
// ####  Executor.executePush0()  ####                                          0x027A

0xEAA0  0x20 0x95 0x97  JSR 0x9795              // Long.ZeroTop();                   executor.asm:1067
0xEAA3  0x4C 0x89 0x97  JMP 0x9789              // Long.PushTopStrictLONG();    sets TOPT = LONG

// /source/projects/6502sbc/hopperbasic/executor.asm:1078
// ####  Executor.executePush1()  ####                                          0x027B

0xEAA6  0xA9 0x01       LDA # 1                 // LDA #1                            executor.asm:1084
0xEAA8  0x20 0x90 0x97  JSR 0x9790              // Long.LoadTopByte();               executor.asm:1085
0xEAAB  0x4C 0x89 0x97  JMP 0x9789              // Long.PushTopStrictLONG();         executor.asm:1087

// /source/projects/6502sbc/hopperbasic/executor.asm:1099
// ####  Executor.executePushEmptyVar()  ####                                   0x027C

0xEAAE  0x20 0x95 0x97  JSR 0x9795              // Long.ZeroTop();                   executor.asm:1105
0xEAB1  0xA9 0x18       LDA # 0x18              // LDA # (BASICType.VAR|BASICType.LONG)
0xEAB3  0x85 0x15       STA 0x15                // STA ZP.TOPT                       executor.asm:1107
0xEAB5  0x4C 0x6A 0x97  JMP 0x976A              // Long.PushTop();    PushEmptyVar: push value and type to stack -> always Success

// /source/projects/6502sbc/hopperbasic/executor.asm:1118
// ####  Executor.executePushVoid()  ####                                       0x027D

0xEAB8  0x20 0x95 0x97  JSR 0x9795              // Long.ZeroTop();                   executor.asm:1124
0xEABB  0xA9 0x00       LDA # 0                 // LDA #BASICType.VOID               executor.asm:1125
0xEABD  0x85 0x15       STA 0x15                // STA ZP.TOPT                       executor.asm:1126
0xEABF  0x4C 0x6A 0x97  JMP 0x976A              // Long.PushTop();    PushVoid: push value and type to stack -> always Success

// /source/projects/6502sbc/hopperbasic/executor.asm:1137
// ####  Executor.executePushBit()  ####                                        0x027E

0xEAC2  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:1146
0xEAC4  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:1149
0xEAC6  0xD0 0x02       BNE 0xEACA (+2)         // if (Z)                            executor.asm:1150
0xEAC8  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:1152
0xEACA  0xA6 0x03       LDX 0x03                // LDX ZP.SP                         executor.asm:1156
0xEACC  0xE6 0x03       INC 0x03                // INC ZP.SP                         executor.asm:1157
0xEACE  0x9D 0x00 0x06  STA 0x0600,X            // STA Address.ValueStackLSB, X      executor.asm:1159
0xEAD1  0x9E 0x00 0x07  STZ 0x0700,X            // STZ Address.ValueStackMSB, X      executor.asm:1160
0xEAD4  0xA9 0x06       LDA # 0x06              // LDA # BASICType.BIT               executor.asm:1161
0xEAD6  0x9D 0x00 0x05  STA 0x0500,X            // STA Address.TypeStackLSB, X       executor.asm:1162
0xEAD9  0x60            RTS                     // }                                 executor.asm:1167

// /source/projects/6502sbc/hopperbasic/executor.asm:1172
// ####  Executor.executePushByte()  ####                                       0x027F

0xEADA  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:1181
0xEADC  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:1184
0xEADE  0xD0 0x02       BNE 0xEAE2 (+2)         // if (Z)                            executor.asm:1185
0xEAE0  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:1187
0xEAE2  0x20 0x90 0x97  JSR 0x9790              // Long.LoadTopByte();     A = byte value
0xEAE5  0x4C 0x89 0x97  JMP 0x9789              // Long.PushTopStrictLONG();    sets TOPT = LONG

// /source/projects/6502sbc/hopperbasic/executor.asm:1202
// ####  Executor.executePushChar()  ####                                       0x0280

0xEAE8  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:1210
0xEAEA  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:1213
0xEAEC  0xD0 0x02       BNE 0xEAF0 (+2)         // if (Z)                            executor.asm:1214
0xEAEE  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:1216
0xEAF0  0xA6 0x03       LDX 0x03                // LDX ZP.SP                         executor.asm:1221
0xEAF2  0xE6 0x03       INC 0x03                // INC ZP.SP                         executor.asm:1222
0xEAF4  0x9D 0x00 0x06  STA 0x0600,X            // STA Address.ValueStackLSB, X      executor.asm:1224
0xEAF7  0x9E 0x00 0x07  STZ 0x0700,X            // STZ Address.ValueStackMSB, X      executor.asm:1225
0xEAFA  0xA9 0x01       LDA # 1                 // LDA # BASICType.CHAR              executor.asm:1226
0xEAFC  0x9D 0x00 0x05  STA 0x0500,X            // STA Address.TypeStackLSB, X       executor.asm:1227
0xEAFF  0x60            RTS                     // }                                 executor.asm:1232

// /source/projects/6502sbc/hopperbasic/executor.asm:1235
// ####  Executor.fetchOperandAddXID()  ####                                    0x0281

0xEB00  0x20 0x66 0xE8  JSR 0xE866              // FetchOperandWord();    ACC + XID -> TOP0..1
0xEB03  0x18            CLC                     // CLC                               executor.asm:1239
0xEB04  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       executor.asm:1240
0xEB06  0x65 0x80       ADC 0x80                // ADC ZP.XIDL                       executor.asm:1241
0xEB08  0x85 0x11       STA 0x11                // STA ZP.TOP0                       executor.asm:1242
0xEB0A  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       executor.asm:1243
0xEB0C  0x65 0x81       ADC 0x81                // ADC ZP.XIDH                       executor.asm:1244
0xEB0E  0x85 0x12       STA 0x12                // STA ZP.TOP1                       executor.asm:1245
0xEB10  0x60            RTS                     // }                                 executor.asm:1246

// /source/projects/6502sbc/hopperbasic/executor.asm:1254
// ####  Executor.executePushCString()  ####                                    0x0282

0xEB11  0x20 0x00 0xEB  JSR 0xEB00              // fetchOperandAddXID();             executor.asm:1261
0xEB14  0xA9 0x05       LDA # 0x05              // LDA # BASICType.STRING            executor.asm:1263
0xEB16  0x85 0x15       STA 0x15                // STA ZP.TOPT                       executor.asm:1264
0xEB18  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();    PushCString: push value and type to stack -> always Success
0xEB1B  0x4C 0x73 0x8C  JMP 0x8C73              // CheckErrorAndSetFailure();        executor.asm:1268

// /source/projects/6502sbc/hopperbasic/executor.asm:1284
// ####  Executor.executeCall()  ####                                           0x0283

0xEB1E  0x20 0x00 0xEB  JSR 0xEB00              // fetchOperandAddXID();             executor.asm:1291
0xEB21  0x20 0x99 0xA7  JSR 0xA799              // Functions.Find();    Input: ZP.TOP = name
0xEB24  0xB0 0x06       BCS 0xEB2C (+6)         // if (NC)                           executor.asm:1295
0xEB26  0x20 0x8F 0x8B  JSR 0x8B8F              // Error.UndefinedIdentifierTOP(); BIT ZP.EmulatorPCL
0xEB29  0x64 0x4E       STZ 0x4E                // States.SetFailure();              executor.asm:1298
0xEB2B  0x60            RTS                     // break;                            executor.asm:1299
0xEB2C  0x20 0xF7 0xA8  JSR 0xA8F7              // Functions.IsCompiled();           executor.asm:1304
0xEB2F  0xB0 0x08       BCS 0xEB39 (+8)         // if (NC)                           executor.asm:1305
0xEB31  0x20 0x93 0xA9  JSR 0xA993              // Functions.Compile();              executor.asm:1308
0xEB34  0x20 0x96 0x89  JSR 0x8996              // States.CanContinue();             executor.asm:1309
0xEB37  0x90 0x24       BCC 0xEB5D (+36)        // if (NC)                           executor.asm:1310
0xEB39  0xA5 0x00       LDA 0x00                // LDA ZP.PCL                        executor.asm:1322
0xEB3B  0xD0 0x02       BNE 0xEB3F (+2)         // if (Z)                            executor.asm:1323
0xEB3D  0xC6 0x01       DEC 0x01                // DEC ZP.PCH                        executor.asm:1325
0xEB3F  0xC6 0x00       DEC 0x00                // DEC ZP.PCL                        executor.asm:1327
0xEB41  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       executor.asm:1328
0xEB43  0x92 0x00       STA [0x00]              // STA [ZP.PC]                       executor.asm:1329
0xEB45  0xA5 0x00       LDA 0x00                // LDA ZP.PCL                        executor.asm:1333
0xEB47  0xD0 0x02       BNE 0xEB4B (+2)         // if (Z)                            executor.asm:1334
0xEB49  0xC6 0x01       DEC 0x01                // DEC ZP.PCH                        executor.asm:1336
0xEB4B  0xC6 0x00       DEC 0x00                // DEC ZP.PCL                        executor.asm:1338
0xEB4D  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       executor.asm:1339
0xEB4F  0x92 0x00       STA [0x00]              // STA [ZP.PC]                       executor.asm:1340
0xEB51  0xA5 0x00       LDA 0x00                // LDA ZP.PCL                        executor.asm:1344
0xEB53  0xD0 0x02       BNE 0xEB57 (+2)         // if (Z)                            executor.asm:1345
0xEB55  0xC6 0x01       DEC 0x01                // DEC ZP.PCH                        executor.asm:1347
0xEB57  0xC6 0x00       DEC 0x00                // DEC ZP.PCL                        executor.asm:1349
0xEB59  0xA9 0x84       LDA # 0x84              // LDA # OpCode.CALLF                executor.asm:1350
0xEB5B  0x92 0x00       STA [0x00]              // STA [ZP.PC]                       executor.asm:1351
0xEB5D  0x60            RTS                     // }                                 executor.asm:1359

// /source/projects/6502sbc/hopperbasic/executor.asm:1364
// ####  Executor.executeCallF()  ####                                          0x0284

0xEB5E  0x4C 0x21 0xA9  JMP 0xA921              // Functions.JumpToOpCodes();        executor.asm:1373

// /source/projects/6502sbc/hopperbasic/executor.asm:1386
// ####  Executor.executePushInt()  ####                                        0x0285

0xEB61  0x20 0x66 0xE8  JSR 0xE866              // FetchOperandWord();    ACC -> TOP0..1
0xEB64  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       executor.asm:1395
0xEB66  0x85 0x11       STA 0x11                // STA ZP.TOP0                       executor.asm:1396
0xEB68  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       executor.asm:1397
0xEB6A  0x85 0x12       STA 0x12                // STA ZP.TOP1                       executor.asm:1398
0xEB6C  0x10 0x09       BPL 0xEB77 (+9)         // if (MI)                           executor.asm:1400
0xEB6E  0xA9 0xFF       LDA # 0xFF              // LDA #0xFF                         executor.asm:1402
0xEB70  0x85 0x13       STA 0x13                // STA ZP.TOP2                       executor.asm:1403
0xEB72  0x85 0x14       STA 0x14                // STA ZP.TOP3                       executor.asm:1404
0xEB74  0x4C 0x89 0x97  JMP 0x9789              // }                                 executor.asm:1405
0xEB77  0x64 0x13       STZ 0x13                // STZ ZP.TOP2                       executor.asm:1408
0xEB79  0x64 0x14       STZ 0x14                // STZ ZP.TOP3    x2                 executor.asm:1409
0xEB7B  0x4C 0x89 0x97  JMP 0x9789              // Long.PushTopStrictLONG();         executor.asm:1412

// /source/projects/6502sbc/hopperbasic/executor.asm:1422
// ####  Executor.executePushWord()  ####                                       0x0286

0xEB7E  0x20 0x66 0xE8  JSR 0xE866              // FetchOperandWord();    ACC -> TOP0..1
0xEB81  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       executor.asm:1432
0xEB83  0x85 0x11       STA 0x11                // STA ZP.TOP0                       executor.asm:1433
0xEB85  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       executor.asm:1434
0xEB87  0x85 0x12       STA 0x12                // STA ZP.TOP1                       executor.asm:1435
0xEB89  0x64 0x13       STZ 0x13                // STZ ZP.TOP2                       executor.asm:1437
0xEB8B  0x64 0x14       STZ 0x14                // STZ ZP.TOP3    x2                 executor.asm:1438
0xEB8D  0x4C 0x89 0x97  JMP 0x9789              // Long.PushTopStrictLONG();         executor.asm:1440

// /source/projects/6502sbc/hopperbasic/executor.asm:1603
// ####  Executor.applySignedOffsetToPC()  ####                                 0x0288

0xEB90  0x18            CLC                     // CLC                               executor.asm:1605
0xEB91  0xA5 0x00       LDA 0x00                // LDA ZP.PCL                        executor.asm:1606
0xEB93  0x65 0x0E       ADC 0x0E                // ADC ZP.ACCL                       executor.asm:1607
0xEB95  0x85 0x00       STA 0x00                // STA ZP.PCL                        executor.asm:1608
0xEB97  0xA5 0x01       LDA 0x01                // LDA ZP.PCH                        executor.asm:1609
0xEB99  0x65 0x0F       ADC 0x0F                // ADC ZP.ACCH                       executor.asm:1610
0xEB9B  0x85 0x01       STA 0x01                // STA ZP.PCH                        executor.asm:1611
0xEB9D  0x60            RTS                     // }                                 executor.asm:1612

// /source/projects/6502sbc/hopperbasic/executor.asm:1616
// ####  Executor.executeJumpW()  ####                                          0x0289

0xEB9E  0x20 0x66 0xE8  JSR 0xE866              // FetchOperandWord();    NEXT, PC + ACC -> PC
0xEBA1  0x4C 0x90 0xEB  JMP 0xEB90              // applySignedOffsetToPC();    PC + ACC -> PC

// /source/projects/6502sbc/hopperbasic/executor.asm:1634
// ####  Executor.executeJumpZW()  ####                                         0x028A

0xEBA4  0xC6 0x03       DEC 0x03                // DEC ZP.SP                         executor.asm:1642
0xEBA6  0xA6 0x03       LDX 0x03                // LDX ZP.SP                         executor.asm:1643
0xEBA8  0xBD 0x00 0x05  LDA 0x0500,X            // LDA Address.TypeStackLSB, X       executor.asm:1644
0xEBAB  0xC9 0x06       CMP # 0x06              // CMP #BASICType.BIT                executor.asm:1645
0xEBAD  0xF0 0x05       BEQ 0xEBB4 (+5)         // if (NZ)                           executor.asm:1646
0xEBAF  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xEBB2  0x18            CLC                     // CLC     Failure - not BIT type    executor.asm:1649
0xEBB3  0x60            RTS                     // break;                            executor.asm:1650
0xEBB4  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:1658
0xEBB6  0x85 0x0E       STA 0x0E                // STA ZP.ACCL    Save operand       executor.asm:1659
0xEBB8  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:1662
0xEBBA  0xD0 0x02       BNE 0xEBBE (+2)         // if (Z)                            executor.asm:1663
0xEBBC  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:1665
0xEBBE  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:1668
0xEBC0  0x85 0x0F       STA 0x0F                // STA ZP.ACCH    Save operand       executor.asm:1669
0xEBC2  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:1672
0xEBC4  0xD0 0x02       BNE 0xEBC8 (+2)         // if (Z)                            executor.asm:1673
0xEBC6  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:1675
0xEBC8  0xBD 0x00 0x06  LDA 0x0600,X            // LDA Address.ValueStackLSB, X      executor.asm:1680
0xEBCB  0xD0 0x0D       BNE 0xEBDA (+13)        // if (Z)     Value is zero/FALSE - take the jump
0xEBCD  0x18            CLC                     // CLC                               executor.asm:1684
0xEBCE  0xA5 0x00       LDA 0x00                // LDA ZP.PCL                        executor.asm:1685
0xEBD0  0x65 0x0E       ADC 0x0E                // ADC ZP.ACCL                       executor.asm:1686
0xEBD2  0x85 0x00       STA 0x00                // STA ZP.PCL                        executor.asm:1687
0xEBD4  0xA5 0x01       LDA 0x01                // LDA ZP.PCH                        executor.asm:1688
0xEBD6  0x65 0x0F       ADC 0x0F                // ADC ZP.ACCH                       executor.asm:1689
0xEBD8  0x85 0x01       STA 0x01                // STA ZP.PCH                        executor.asm:1690
0xEBDA  0x38            SEC                     // SEC                               executor.asm:1692
0xEBDB  0x60            RTS                     // break;                            executor.asm:1693

// /source/projects/6502sbc/hopperbasic/executor.asm:1740
// ####  Executor.executePushGlobal()  ####                                     0x028C

0xEBDC  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:1751
0xEBDE  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:1754
0xEBE0  0xD0 0x02       BNE 0xEBE4 (+2)         // if (Z)                            executor.asm:1755
0xEBE2  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:1757
0xEBE4  0xA8            TAY                     // TAY     Y = global index          executor.asm:1760
0xEBE5  0xA6 0x03       LDX 0x03                // LDX ZP.SP                         executor.asm:1762
0xEBE7  0xE6 0x03       INC 0x03                // INC ZP.SP                         executor.asm:1763
0xEBE9  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStack, Y          executor.asm:1766
0xEBEC  0x85 0x15       STA 0x15                // STA ZP.TOPT                       executor.asm:1767
0xEBEE  0x4F 0x15 0x07  BBR4 0x15, 0xEBF8 (+7)  // if (BBS4, ZP.TOPT)    Bit 4 - VAR executor.asm:1768
0xEBF1  0x29 0x2F       AND # 0x2F              // AND # (BASICType.TYPEMASK | BASICType.ARRAY)     Strip VAR bit but not ARRAY
0xEBF3  0x9D 0x00 0x05  STA 0x0500,X            // STA Address.TypeStackLSB, X       executor.asm:1772
0xEBF6  0x80 0x03       BRA 0xEBFB (+3)         // }                                 executor.asm:1773
0xEBF8  0x9D 0x00 0x05  STA 0x0500,X            // STA Address.TypeStack, X          executor.asm:1776
0xEBFB  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackB0, Y       executor.asm:1778
0xEBFE  0x9D 0x00 0x06  STA 0x0600,X            // STA Address.ValueStackB0, X       executor.asm:1779
0xEC01  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackB1, Y       executor.asm:1780
0xEC04  0x9D 0x00 0x07  STA 0x0700,X            // STA Address.ValueStackB1, X       executor.asm:1781
0xEC07  0xBF 0x15 0x01  BBS3 0x15, 0xEC0B (+1)  // if (BBS3, ZP.TOPT)    Bit 3 - LONG
0xEC0A  0x60            RTS
0xEC0B  0xB9 0x00 0x08  LDA 0x0800,Y            // LDA Address.ValueStackB2, Y       executor.asm:1784
0xEC0E  0x9D 0x00 0x08  STA 0x0800,X            // STA Address.ValueStackB2, X       executor.asm:1785
0xEC11  0xB9 0x00 0x09  LDA 0x0900,Y            // LDA Address.ValueStackB3, Y       executor.asm:1786
0xEC14  0x9D 0x00 0x09  STA 0x0900,X            // STA Address.ValueStackB3, X       executor.asm:1787
0xEC17  0x60            RTS                     // break;                            executor.asm:1789

// /source/projects/6502sbc/hopperbasic/executor.asm:1803
// ####  Executor.executePopGlobal()  ####                                      0x028D

0xEC18  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:1814
0xEC1A  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:1817
0xEC1C  0xD0 0x02       BNE 0xEC20 (+2)         // if (Z)                            executor.asm:1818
0xEC1E  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:1820
0xEC20  0xA8            TAY                     // TAY            Y = global index   executor.asm:1824
0xEC21  0xC6 0x03       DEC 0x03                // DEC ZP.SP                         executor.asm:1827
0xEC23  0xA6 0x03       LDX 0x03                // LDX ZP.SP      X = stack position executor.asm:1828
0xEC25  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStack, Y          executor.asm:1831
0xEC28  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT                      executor.asm:1832
0xEC2A  0xBD 0x00 0x05  LDA 0x0500,X            // LDA Address.TypeStack, X          executor.asm:1835
0xEC2D  0x85 0x15       STA 0x15                // STA ZP.TOPT                       executor.asm:1836
0xEC2F  0xBD 0x00 0x06  LDA 0x0600,X            // LDA Address.ValueStackB0, X       executor.asm:1839
0xEC32  0x85 0x11       STA 0x11                // STA ZP.TOP0                       executor.asm:1840
0xEC34  0xBD 0x00 0x07  LDA 0x0700,X            // LDA Address.ValueStackB1, X       executor.asm:1841
0xEC37  0x85 0x12       STA 0x12                // STA ZP.TOP1                       executor.asm:1842
0xEC39  0x3F 0x15 0x0A  BBR3 0x15, 0xEC46 (+10) // if (BBS3, ZP.TOPT)    Bit 3 - LONG RHS
0xEC3C  0xBD 0x00 0x08  LDA 0x0800,X            // LDA Address.ValueStackB2, X       executor.asm:1846
0xEC3F  0x85 0x13       STA 0x13                // STA ZP.TOP2                       executor.asm:1847
0xEC41  0xBD 0x00 0x09  LDA 0x0900,X            // LDA Address.ValueStackB3, X       executor.asm:1848
0xEC44  0x85 0x14       STA 0x14                // STA ZP.TOP3                       executor.asm:1849
0xEC46  0x4F 0x1A 0x09  BBR4 0x1A, 0xEC52 (+9)  // if (BBS4, ZP.NEXTT)    Bit 4 - VAR
0xEC49  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       executor.asm:1857
0xEC4B  0x09 0x10       ORA # 0x10              // ORA #BASICType.VAR                executor.asm:1858
0xEC4D  0x99 0x00 0x05  STA 0x0500,Y            // STA Address.TypeStack, Y          executor.asm:1859
0xEC50  0x80 0x06       BRA 0xEC58 (+6)         // }                                 executor.asm:1860
0xEC52  0x20 0xCA 0x8B  JSR 0x8BCA              // Error.InternalError(); BIT ZP.EmulatorPCL
0xEC55  0x64 0x4E       STZ 0x4E                // States.SetFailure();              executor.asm:1865
0xEC57  0x60            RTS                     // break;                            executor.asm:1866
0xEC58  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       executor.asm:1869
0xEC5A  0x99 0x00 0x06  STA 0x0600,Y            // STA Address.ValueStackB0, Y       executor.asm:1870
0xEC5D  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       executor.asm:1871
0xEC5F  0x99 0x00 0x07  STA 0x0700,Y            // STA Address.ValueStackB1, Y       executor.asm:1872
0xEC62  0xBF 0x1A 0x01  BBS3 0x1A, 0xEC66 (+1)  // if (BBS3, ZP.NEXTT)    Bit 3 - LONG LHS
0xEC65  0x60            RTS
0xEC66  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       executor.asm:1875
0xEC68  0x99 0x00 0x08  STA 0x0800,Y            // STA Address.ValueStackB2, Y       executor.asm:1876
0xEC6B  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       executor.asm:1877
0xEC6D  0x99 0x00 0x09  STA 0x0900,Y            // STA Address.ValueStackB3, Y       executor.asm:1878
0xEC70  0x60            RTS                     // break;                            executor.asm:1880

// /source/projects/6502sbc/hopperbasic/executor.asm:1894
// ####  Executor.executePopLocal()  ####                                       0x028E

0xEC71  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:1906
0xEC73  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:1909
0xEC75  0xD0 0x02       BNE 0xEC79 (+2)         // if (Z)                            executor.asm:1910
0xEC77  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:1912
0xEC79  0x18            CLC                     // CLC                               executor.asm:1916
0xEC7A  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:1917
0xEC7C  0xA8            TAY                     // TAY                        Y = local position
0xEC7D  0xC6 0x03       DEC 0x03                // DEC ZP.SP                         executor.asm:1921
0xEC7F  0xA6 0x03       LDX 0x03                // LDX ZP.SP                  X = stack position
0xEC81  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStack, Y          executor.asm:1925
0xEC84  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT                      executor.asm:1926
0xEC86  0xBD 0x00 0x05  LDA 0x0500,X            // LDA Address.TypeStack, X          executor.asm:1929
0xEC89  0x85 0x15       STA 0x15                // STA ZP.TOPT                       executor.asm:1930
0xEC8B  0xBD 0x00 0x06  LDA 0x0600,X            // LDA Address.ValueStackB0, X       executor.asm:1933
0xEC8E  0x85 0x11       STA 0x11                // STA ZP.TOP0                       executor.asm:1934
0xEC90  0xBD 0x00 0x07  LDA 0x0700,X            // LDA Address.ValueStackB1, X       executor.asm:1935
0xEC93  0x85 0x12       STA 0x12                // STA ZP.TOP1                       executor.asm:1936
0xEC95  0x3F 0x15 0x0A  BBR3 0x15, 0xECA2 (+10) // if (BBS3, ZP.TOPT)    Bit 3 - LONG RHS
0xEC98  0xBD 0x00 0x08  LDA 0x0800,X            // LDA Address.ValueStackB2, X       executor.asm:1940
0xEC9B  0x85 0x13       STA 0x13                // STA ZP.TOP2                       executor.asm:1941
0xEC9D  0xBD 0x00 0x09  LDA 0x0900,X            // LDA Address.ValueStackB3, X       executor.asm:1942
0xECA0  0x85 0x14       STA 0x14                // STA ZP.TOP3                       executor.asm:1943
0xECA2  0x4F 0x1A 0x07  BBR4 0x1A, 0xECAC (+7)  // if (BBS4, ZP.NEXTT)    Bit 4 - VAR
0xECA5  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       executor.asm:1949
0xECA7  0x09 0x10       ORA # 0x10              // ORA #BASICType.VAR                executor.asm:1950
0xECA9  0x99 0x00 0x05  STA 0x0500,Y            // STA Address.TypeStack, Y          executor.asm:1951
0xECAC  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       executor.asm:1954
0xECAE  0x99 0x00 0x06  STA 0x0600,Y            // STA Address.ValueStackB0, Y       executor.asm:1955
0xECB1  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       executor.asm:1956
0xECB3  0x99 0x00 0x07  STA 0x0700,Y            // STA Address.ValueStackB1, Y       executor.asm:1957
0xECB6  0xBF 0x1A 0x01  BBS3 0x1A, 0xECBA (+1)  // if (BBS3, ZP.NEXTT)    Bit 3 - LONG LHS
0xECB9  0x60            RTS
0xECBA  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       executor.asm:1960
0xECBC  0x99 0x00 0x08  STA 0x0800,Y            // STA Address.ValueStackB2, Y       executor.asm:1961
0xECBF  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       executor.asm:1962
0xECC1  0x99 0x00 0x09  STA 0x0900,Y            // STA Address.ValueStackB3, Y       executor.asm:1963
0xECC4  0x60            RTS                     // break;                            executor.asm:1965

// /source/projects/6502sbc/hopperbasic/executor.asm:1979
// ####  Executor.executePushLocal()  ####                                      0x028F

0xECC5  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:1989
0xECC7  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:1992
0xECC9  0xD0 0x02       BNE 0xECCD (+2)         // if (Z)                            executor.asm:1993
0xECCB  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:1995
0xECCD  0x18            CLC                     // CLC                               executor.asm:2001
0xECCE  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:2002
0xECD0  0xA8            TAY                     // TAY                               executor.asm:2003
0xECD1  0xA6 0x03       LDX 0x03                // LDX ZP.SP                         executor.asm:2005
0xECD3  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackB0, Y       executor.asm:2007
0xECD6  0x9D 0x00 0x06  STA 0x0600,X            // STA Address.ValueStackB0, X       executor.asm:2008
0xECD9  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackB1, Y       executor.asm:2009
0xECDC  0x9D 0x00 0x07  STA 0x0700,X            // STA Address.ValueStackB1, X       executor.asm:2010
0xECDF  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStack, Y          executor.asm:2011
0xECE2  0x29 0x2F       AND # 0x2F              // AND # (BASICType.TYPEMASK | BASICType.ARRAY)     Strip VAR bit but not ARRAY
0xECE4  0x9D 0x00 0x05  STA 0x0500,X            // STA Address.TypeStack, X          executor.asm:2013
0xECE7  0x29 0x08       AND # 0x08              // AND #BASICType.LONG               executor.asm:2014
0xECE9  0xF0 0x0C       BEQ 0xECF7 (+12)        // if (NZ)                           executor.asm:2015
0xECEB  0xB9 0x00 0x08  LDA 0x0800,Y            // LDA Address.ValueStackB2, Y       executor.asm:2017
0xECEE  0x9D 0x00 0x08  STA 0x0800,X            // STA Address.ValueStackB2, X       executor.asm:2018
0xECF1  0xB9 0x00 0x09  LDA 0x0900,Y            // LDA Address.ValueStackB3, Y       executor.asm:2019
0xECF4  0x9D 0x00 0x09  STA 0x0900,X            // STA Address.ValueStackB3, X       executor.asm:2020
0xECF7  0xE6 0x03       INC 0x03                // INC ZP.SP                         executor.asm:2022
0xECF9  0x60            RTS                     // }                                 executor.asm:2027

// /source/projects/6502sbc/hopperbasic/executor.asm:2035
// ####  Executor.executePushLocalDup()  ####                                   0x0290

0xECFA  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2045
0xECFC  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2048
0xECFE  0xD0 0x02       BNE 0xED02 (+2)         // if (Z)                            executor.asm:2049
0xED00  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2051
0xED02  0x18            CLC                     // CLC                               executor.asm:2057
0xED03  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:2058
0xED05  0xA8            TAY                     // TAY                               executor.asm:2059
0xED06  0xA6 0x03       LDX 0x03                // LDX ZP.SP                         executor.asm:2061
0xED08  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackB0, Y       executor.asm:2063
0xED0B  0x9D 0x00 0x06  STA 0x0600,X            // STA Address.ValueStackB0, X       executor.asm:2064
0xED0E  0x9D 0x01 0x06  STA 0x0601,X            // STA (Address.ValueStackB0+1), X   executor.asm:2065
0xED11  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackB1, Y       executor.asm:2066
0xED14  0x9D 0x00 0x07  STA 0x0700,X            // STA Address.ValueStackB1, X       executor.asm:2067
0xED17  0x9D 0x01 0x07  STA 0x0701,X            // STA (Address.ValueStackB1+1), X   executor.asm:2068
0xED1A  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStack, Y          executor.asm:2069
0xED1D  0x29 0x2F       AND # 0x2F              // AND # (BASICType.TYPEMASK | BASICType.ARRAY)     Strip VAR bit but not ARRAY
0xED1F  0x9D 0x00 0x05  STA 0x0500,X            // STA Address.TypeStack, X          executor.asm:2071
0xED22  0x9D 0x01 0x05  STA 0x0501,X            // STA (Address.TypeStack+1), X      executor.asm:2072
0xED25  0x29 0x08       AND # 0x08              // AND #BASICType.LONG               executor.asm:2073
0xED27  0xF0 0x12       BEQ 0xED3B (+18)        // if (NZ)                           executor.asm:2074
0xED29  0xB9 0x00 0x08  LDA 0x0800,Y            // LDA Address.ValueStackB2, Y       executor.asm:2076
0xED2C  0x9D 0x00 0x08  STA 0x0800,X            // STA Address.ValueStackB2, X       executor.asm:2077
0xED2F  0x9D 0x01 0x08  STA 0x0801,X            // STA (Address.ValueStackB2+1), X   executor.asm:2078
0xED32  0xB9 0x00 0x09  LDA 0x0900,Y            // LDA Address.ValueStackB3, Y       executor.asm:2079
0xED35  0x9D 0x00 0x09  STA 0x0900,X            // STA Address.ValueStackB3, X       executor.asm:2080
0xED38  0x9D 0x01 0x09  STA 0x0901,X            // STA (Address.ValueStackB3+1), X   executor.asm:2081
0xED3B  0xE6 0x03       INC 0x03                // INC ZP.SP                         executor.asm:2083
0xED3D  0xE6 0x03       INC 0x03                // INC ZP.SP                         executor.asm:2084
0xED3F  0x60            RTS                     // }                                 executor.asm:2089

// /source/projects/6502sbc/hopperbasic/executor.asm:2098
// ####  Executor.executeFORCHK()  ####                                         0x0291

0xED40  0x20 0x5C 0xE8  JSR 0xE85C              // FetchOperandByte();    Result in A
0xED43  0x8D 0xCD 0x0B  STA 0x0BCD              // STA Executor.executorOperandBP     Save iterator offset
0xED46  0x20 0x66 0xE8  JSR 0xE866              // FetchOperandWord();    Result in ACC
0xED49  0xA9 0xFF       LDA # 0xFF              // LDA #0xFF                         executor.asm:2113
0xED4B  0x20 0x1B 0x94  JSR 0x941B              // Stacks.GetStackTopSP();     [SP-1] => STEP in ZP.TOP/TOPT, strips BASICTypes.VAR
0xED4E  0xA2 0x00       LDX # 0                 // LDX #0     Assume positive        executor.asm:2117
0xED50  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       executor.asm:2118
0xED52  0x10 0x02       BPL 0xED56 (+2)         // if (MI)                           executor.asm:2119
0xED54  0xA2 0x01       LDX # 1                 // LDX #1     Negative STEP          executor.asm:2121
0xED56  0xAD 0xCD 0x0B  LDA 0x0BCD              // LDA Executor.executorOperandBP    executor.asm:2125
0xED59  0x20 0xFB 0x93  JSR 0x93FB              // Stacks.GetStackTopBP();     Iterator in ZP.TOP/TOPT, preserves X, strips BASICTypes.VAR
0xED5C  0xA9 0xFE       LDA # 0xFE              // LDA #0xFE                         executor.asm:2128
0xED5E  0x20 0x3B 0x94  JSR 0x943B              // Stacks.GetStackNextSP();    [SP-2] => TO in ZP.NEXT/NEXTT, preserves X, strips BASICTypes.VAR
0xED61  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();      FORCHK: Push iterator => NEXT slot
0xED64  0x20 0x58 0x98  JSR 0x9858              // Long.PushNext();     FORCHK: Push TO       => TOP slot
0xED67  0xE0 0x00       CPX # 0                 // CPX #0                            executor.asm:2139
0xED69  0xF0 0x0F       BEQ 0xED7A (+15)        // if (NZ)     Negative STEP         executor.asm:2140
0xED6B  0x20 0x91 0xE2  JSR 0xE291              // ComparisonInstructions.GreaterEqual();     FORCHK   Sets Z if iterator >= TO
0xED6E  0x20 0x96 0x89  JSR 0x8996              // States.CanContinue();             executor.asm:2145
0xED71  0x90 0x21       BCC 0xED94 (+33)        // if (NC) { break; }     Type mismatch
0xED73  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();    FORCHK          executor.asm:2147
0xED76  0xD0 0x1C       BNE 0xED94 (+28)        // if (NZ)    TRUE'                  executor.asm:2148
0xED78  0x80 0x0D       BRA 0xED87 (+13)
0xED7A  0x20 0x59 0xE2  JSR 0xE259              // ComparisonInstructions.LessEqual();    FORCHK
0xED7D  0x20 0x96 0x89  JSR 0x8996              // States.CanContinue();             executor.asm:2160
0xED80  0x90 0x12       BCC 0xED94 (+18)        // if (NC) { break; }     Type mismatch
0xED82  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();      FORCHK        executor.asm:2162
0xED85  0xD0 0x0D       BNE 0xED94 (+13)        // if (NZ)    'TRUE'                 executor.asm:2163
0xED87  0x18            CLC                     // CLC                               executor.asm:2172
0xED88  0xA5 0x00       LDA 0x00                // LDA ZP.PCL                        executor.asm:2173
0xED8A  0x65 0x0E       ADC 0x0E                // ADC ZP.ACCL                       executor.asm:2174
0xED8C  0x85 0x00       STA 0x00                // STA ZP.PCL                        executor.asm:2175
0xED8E  0xA5 0x01       LDA 0x01                // LDA ZP.PCH                        executor.asm:2176
0xED90  0x65 0x0F       ADC 0x0F                // ADC ZP.ACCH                       executor.asm:2177
0xED92  0x85 0x01       STA 0x01                // STA ZP.PCH                        executor.asm:2178
0xED94  0x60            RTS                     // }                                 executor.asm:2187

// /source/projects/6502sbc/hopperbasic/executor.asm:2196
// ####  Executor.executeFORIT()  ####                                          0x0292

0xED95  0x20 0x5C 0xE8  JSR 0xE85C              // FetchOperandByte();    Result in A
0xED98  0x8D 0xCD 0x0B  STA 0x0BCD              // STA Executor.executorOperandBP     Save iterator offset
0xED9B  0x20 0x66 0xE8  JSR 0xE866              // FetchOperandWord();    Result in ACC
0xED9E  0xA9 0xFF       LDA # 0xFF              // LDA #0xFF                         executor.asm:2211
0xEDA0  0x20 0x3B 0x94  JSR 0x943B              // Stacks.GetStackNextSP();     [SP-1] => STEP in ZP.NEXT/NEXTT
0xEDA3  0xA2 0x00       LDX # 0                 // LDX #0     Assume positive        executor.asm:2215
0xEDA5  0xA5 0x17       LDA 0x17                // LDA ZP.NEXTH                      executor.asm:2216
0xEDA7  0x10 0x02       BPL 0xEDAB (+2)         // if (MI)                           executor.asm:2217
0xEDA9  0xA2 0x01       LDX # 1                 // LDX #1     Negative STEP          executor.asm:2219
0xEDAB  0xAD 0xCD 0x0B  LDA 0x0BCD              // LDA Executor.executorOperandBP    executor.asm:2224
0xEDAE  0x20 0xFB 0x93  JSR 0x93FB              // Stacks.GetStackTopBP();     Iterator in ZP.TOP/TOPT, preserves X, strips BASICTypes.VAR
0xEDB1  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();      FORIT: Push iterator => NEXT slot
0xEDB4  0x20 0x58 0x98  JSR 0x9858              // Long.PushNext();     FORIT: Push STEP     => TOP slot
0xEDB7  0x20 0x77 0xBF  JSR 0xBF77              // Instructions.Addition();     Handles signed/unsigned, type checking, preserves X
0xEDBA  0xDA            PHX                     // PHX Long.PopTop(); PLX    FORIT   executor.asm:2232
0xEDBB  0x20 0xEB 0x98  JSR 0x98EB
0xEDBE  0xFA            PLX
0xEDBF  0x20 0x96 0x89  JSR 0x8996              // States.CanContinue();    preserves X
0xEDC2  0x90 0x3E       BCC 0xEE02 (+62)        // if (NC) { break; }     Type mismatch or overflow
0xEDC4  0xAD 0xCD 0x0B  LDA 0x0BCD              // LDA Executor.executorOperandBP    executor.asm:2237
0xEDC7  0x20 0x5B 0x94  JSR 0x945B              // Stacks.SetStackTopBP();     Store ZP.TOP/TOPT to BP+offset, preserves X
0xEDCA  0xA9 0xFE       LDA # 0xFE              // LDA #0xFE                         executor.asm:2241
0xEDCC  0x20 0x3B 0x94  JSR 0x943B              // Stacks.GetStackNextSP();     [SP-2] => TO in ZP.NEXT/NEXTT, preserves X, strips BASICTypes.VAR
0xEDCF  0x20 0x6A 0x97  JSR 0x976A              // Long.PushTop();      FORIT: Push iterator => NEXT slot
0xEDD2  0x20 0x58 0x98  JSR 0x9858              // Long.PushNext();     FORIT: Push       TO => TOP slot
0xEDD5  0xE0 0x00       CPX # 0                 // CPX #0                            executor.asm:2251
0xEDD7  0xF0 0x0F       BEQ 0xEDE8 (+15)        // if (NZ)     Negative STEP         executor.asm:2252
0xEDD9  0x20 0x91 0xE2  JSR 0xE291              // ComparisonInstructions.GreaterEqual();    FORIT
0xEDDC  0x20 0x96 0x89  JSR 0x8996              // States.CanContinue();             executor.asm:2257
0xEDDF  0x90 0x21       BCC 0xEE02 (+33)        // if (NC) { break; }     Type mismatch
0xEDE1  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();      FORIT         executor.asm:2259
0xEDE4  0xF0 0x1C       BEQ 0xEE02 (+28)        // if (Z)    'FALSE'                 executor.asm:2260
0xEDE6  0x80 0x0D       BRA 0xEDF5 (+13)
0xEDE8  0x20 0x59 0xE2  JSR 0xE259              // ComparisonInstructions.LessEqual();    FORIT
0xEDEB  0x20 0x96 0x89  JSR 0x8996              // States.CanContinue();             executor.asm:2272
0xEDEE  0x90 0x12       BCC 0xEE02 (+18)        // if (NC) { break; }     Type mismatch
0xEDF0  0x20 0x04 0x95  JSR 0x9504              // Stacks.PopA();    FORIT           executor.asm:2274
0xEDF3  0xF0 0x0D       BEQ 0xEE02 (+13)        // if (Z)    FALSE                   executor.asm:2275
0xEDF5  0x18            CLC                     // CLC                               executor.asm:2284
0xEDF6  0xA5 0x00       LDA 0x00                // LDA ZP.PCL                        executor.asm:2285
0xEDF8  0x65 0x0E       ADC 0x0E                // ADC ZP.ACCL                       executor.asm:2286
0xEDFA  0x85 0x00       STA 0x00                // STA ZP.PCL                        executor.asm:2287
0xEDFC  0xA5 0x01       LDA 0x01                // LDA ZP.PCH                        executor.asm:2288
0xEDFE  0x65 0x0F       ADC 0x0F                // ADC ZP.ACCH                       executor.asm:2289
0xEE00  0x85 0x01       STA 0x01                // STA ZP.PCH                        executor.asm:2290
0xEE02  0x60            RTS                     // }                                 executor.asm:2299

// /source/projects/6502sbc/hopperbasic/executor.asm:2307
// ####  Executor.executeFORITF()  ####                                         0x0293

0xEE03  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]    -> A               executor.asm:2316
0xEE05  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2317
0xEE07  0xD0 0x02       BNE 0xEE0B (+2)         // if (Z) { INC ZP.PCH }             executor.asm:2318
0xEE09  0xE6 0x01       INC 0x01
0xEE0B  0x18            CLC                     // CLC                               executor.asm:2321
0xEE0C  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:2323
0xEE0E  0xA8            TAY                     // TAY                               executor.asm:2324
0xEE0F  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackLSB, Y      executor.asm:2325
0xEE12  0x85 0x11       STA 0x11                // STA ZP.TOPL                       executor.asm:2326
0xEE14  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackMSB, Y      executor.asm:2327
0xEE17  0x85 0x12       STA 0x12                // STA ZP.TOPH                       executor.asm:2328
0xEE19  0xE6 0x11       INC 0x11                // INC ZP.TOPL                       executor.asm:2331
0xEE1B  0xD0 0x07       BNE 0xEE24 (+7)         // if (Z)                            executor.asm:2332
0xEE1D  0xE6 0x12       INC 0x12                // INC ZP.TOPH                       executor.asm:2334
0xEE1F  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       executor.asm:2335
0xEE21  0x99 0x00 0x07  STA 0x0700,Y            // STA Address.ValueStackMSB, Y      executor.asm:2336
0xEE24  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       executor.asm:2338
0xEE26  0x99 0x00 0x06  STA 0x0600,Y            // STA Address.ValueStackLSB, Y      executor.asm:2339
0xEE29  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2343
0xEE2B  0x85 0x16       STA 0x16                // STA ZP.NEXTL                      executor.asm:2344
0xEE2D  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2345
0xEE2F  0xD0 0x02       BNE 0xEE33 (+2)         // if (Z) { INC ZP.PCH }             executor.asm:2346
0xEE31  0xE6 0x01       INC 0x01
0xEE33  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2348
0xEE35  0x85 0x17       STA 0x17                // STA ZP.NEXTH                      executor.asm:2349
0xEE37  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2350
0xEE39  0xD0 0x02       BNE 0xEE3D (+2)         // if (Z) { INC ZP.PCH }             executor.asm:2351
0xEE3B  0xE6 0x01       INC 0x01
0xEE3D  0xA9 0xFE       LDA # 0xFE              // LDA #0xFE     -2 from SP          executor.asm:2354
0xEE3F  0x18            CLC                     // CLC                               executor.asm:2355
0xEE40  0x65 0x03       ADC 0x03                // ADC ZP.SP                         executor.asm:2356
0xEE42  0xA8            TAY                     // TAY                               executor.asm:2357
0xEE43  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackLSB, Y      executor.asm:2358
0xEE46  0x85 0x0E       STA 0x0E                // STA ZP.ACCL                       executor.asm:2359
0xEE48  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackMSB, Y      executor.asm:2360
0xEE4B  0x85 0x0F       STA 0x0F                // STA ZP.ACCH                       executor.asm:2361
0xEE4D  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH     TO high           executor.asm:2364
0xEE4F  0xC5 0x12       CMP 0x12                // CMP ZP.TOPH      iterator high    executor.asm:2365
0xEE51  0x90 0x23       BCC 0xEE76 (+35)        // if (NC)          TO high < iterator high - definitely exit
0xEE53  0xF0 0x0E       BEQ 0xEE63 (+14)        // if (NZ)          TO high > iterator high - definitely continue
0xEE55  0x18            CLC                     // CLC                               executor.asm:2372
0xEE56  0xA5 0x00       LDA 0x00                // LDA ZP.PCL                        executor.asm:2373
0xEE58  0x65 0x16       ADC 0x16                // ADC ZP.NEXTL                      executor.asm:2374
0xEE5A  0x85 0x00       STA 0x00                // STA ZP.PCL                        executor.asm:2375
0xEE5C  0xA5 0x01       LDA 0x01                // LDA ZP.PCH                        executor.asm:2376
0xEE5E  0x65 0x17       ADC 0x17                // ADC ZP.NEXTH                      executor.asm:2377
0xEE60  0x85 0x01       STA 0x01                // STA ZP.PCH                        executor.asm:2378
0xEE62  0x60            RTS                     // break;                            executor.asm:2379
0xEE63  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL              TO low   executor.asm:2383
0xEE65  0xC5 0x11       CMP 0x11                // CMP ZP.TOPL              Compare with iterator low
0xEE67  0x90 0x0D       BCC 0xEE76 (+13)        // if (NC)                  TO low < iterator low - exit
0xEE69  0x18            CLC                     // CLC                               executor.asm:2390
0xEE6A  0xA5 0x00       LDA 0x00                // LDA ZP.PCL                        executor.asm:2391
0xEE6C  0x65 0x16       ADC 0x16                // ADC ZP.NEXTL                      executor.asm:2392
0xEE6E  0x85 0x00       STA 0x00                // STA ZP.PCL                        executor.asm:2393
0xEE70  0xA5 0x01       LDA 0x01                // LDA ZP.PCH                        executor.asm:2394
0xEE72  0x65 0x17       ADC 0x17                // ADC ZP.NEXTH                      executor.asm:2395
0xEE74  0x85 0x01       STA 0x01                // STA ZP.PCH                        executor.asm:2396
0xEE76  0x60            RTS                     // }                                 executor.asm:2405

// /source/projects/6502sbc/hopperbasic/executor.asm:2411
// ####  Executor.commonGetItem()  ####                                         0x0294

0xEE77  0xBD 0x00 0x06  LDA 0x0600,X            // LDA Address.ValueStackLSB, X      executor.asm:2415
0xEE7A  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       executor.asm:2416
0xEE7C  0xBD 0x00 0x07  LDA 0x0700,X            // LDA Address.ValueStackMSB, X      executor.asm:2417
0xEE7F  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       executor.asm:2418
0xEE81  0xBD 0x00 0x05  LDA 0x0500,X            // LDA Address.TypeStackLSB, X     Array type
0xEE84  0x85 0x10       STA 0x10                // STA ZP.ACCT                       executor.asm:2420
0xEE86  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackB0, Y       executor.asm:2423
0xEE89  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       executor.asm:2424
0xEE8B  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackB1, Y       executor.asm:2425
0xEE8E  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       executor.asm:2426
0xEE90  0xB9 0x00 0x08  LDA 0x0800,Y            // LDA Address.ValueStackB2, Y       executor.asm:2427
0xEE93  0x85 0x18       STA 0x18                // STA ZP.NEXT2                      executor.asm:2428
0xEE95  0xB9 0x00 0x09  LDA 0x0900,Y            // LDA Address.ValueStackB3, Y       executor.asm:2429
0xEE98  0x85 0x19       STA 0x19                // STA ZP.NEXT3                      executor.asm:2430
0xEE9A  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStackLSB, Y       executor.asm:2431
0xEE9D  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT                      executor.asm:2432
0xEE9F  0xA5 0x1A       LDA 0x1A                // LDA ZP.NEXTT                      executor.asm:2440
0xEEA1  0x29 0x0F       AND # 0x0F              // AND #BASICType.TYPEMASK     Remove VAR bit if present
0xEEA3  0xC9 0x08       CMP # 0x08              // CMP #BASICType.LONG               executor.asm:2442
0xEEA5  0xD0 0x0C       BNE 0xEEB3 (+12)        // if (Z)                            executor.asm:2443
0xEEA7  0xA5 0x18       LDA 0x18                // LDA ZP.NEXT2                      executor.asm:2446
0xEEA9  0x05 0x19       ORA 0x19                // ORA ZP.NEXT3                      executor.asm:2447
0xEEAB  0xF0 0x0C       BEQ 0xEEB9 (+12)        // if (NZ)                           executor.asm:2448
0xEEAD  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0xEEB0  0x64 0x4E       STZ 0x4E                // States.SetFailure();              executor.asm:2451
0xEEB2  0x60            RTS                     // break;                            executor.asm:2452
0xEEB3  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xEEB6  0x64 0x4E       STZ 0x4E                // States.SetFailure();              executor.asm:2459
0xEEB8  0x60            RTS                     // break;                            executor.asm:2460
0xEEB9  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       executor.asm:2464
0xEEBB  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          executor.asm:2465
0xEEBD  0xC9 0x05       CMP # 0x05              // CMP # BASICType.STRING            executor.asm:2466
0xEEBF  0xD0 0x2F       BNE 0xEEF0 (+47)        // if (Z)                            executor.asm:2467
0xEEC1  0xA0 0x00       LDY # 0                 // LDY #0                            executor.asm:2470
0xEEC3  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   executor.asm:2473
0xEEC5  0xF0 0x03       BEQ 0xEECA (+3)         // if (Z) { break; }                 executor.asm:2474
0xEEC7  0xC8            INY                     // INY                               executor.asm:2475
0xEEC8  0x80 0xF9       BRA 0xEEC3 (-7)         // }                                 executor.asm:2482
0xEECA  0x84 0x11       STY 0x11                // STY ZP.TOP0                       executor.asm:2483
0xEECC  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       executor.asm:2487
0xEECE  0xF0 0x06       BEQ 0xEED6 (+6)         // if (NZ)     strings are always <= 255
0xEED0  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0xEED3  0x64 0x4E       STZ 0x4E                // States.SetFailure();              executor.asm:2491
0xEED5  0x60            RTS                     // break;                            executor.asm:2492
0xEED6  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       executor.asm:2494
0xEED8  0xC5 0x11       CMP 0x11                // CMP ZP.TOP0                       executor.asm:2495
0xEEDA  0x90 0x06       BCC 0xEEE2 (+6)         // if (C)      IDYL >= TOP0 (index >= length
0xEEDC  0x20 0xD4 0x8B  JSR 0x8BD4              // Error.RangeError(); BIT ZP.EmulatorPCL
0xEEDF  0x64 0x4E       STZ 0x4E                // States.SetFailure();              executor.asm:2499
0xEEE1  0x60            RTS                     // break;                            executor.asm:2500
0xEEE2  0xA4 0x1D       LDY 0x1D                // LDY ZP.IDYL                       executor.asm:2504
0xEEE4  0xB1 0x1B       LDA [0x1B],Y            // LDA [ZP.IDX], Y                   executor.asm:2505
0xEEE6  0x85 0x11       STA 0x11                // STA ZP.TOP0                       executor.asm:2508
0xEEE8  0x64 0x12       STZ 0x12                // STZ ZP.TOP1     Clear high byte   executor.asm:2509
0xEEEA  0xA9 0x01       LDA # 1                 // LDA #BASICType.CHAR               executor.asm:2510
0xEEEC  0x85 0x15       STA 0x15                // STA ZP.TOPT                       executor.asm:2511
0xEEEE  0x80 0x11       BRA 0xEF01 (+17)        // }                                 executor.asm:2512
0xEEF0  0x5F 0x10 0x08  BBR5 0x10, 0xEEFB (+8)  // if (BBS5, ZP.ACCT)    Bit 5 - ARRAY
0xEEF3  0x20 0x9F 0xAB  JSR 0xAB9F              // BASICArray.GetItem();    ZP.IDX = array pointer, ZP.IDY = element index, -> value and type in ZP.TOP
0xEEF6  0xB0 0x09       BCS 0xEF01 (+9)         // if (NC)                           executor.asm:2519
0xEEF8  0x64 0x4E       STZ 0x4E                // States.SetFailure();              executor.asm:2521
0xEEFA  0x60            RTS                     // break;                            executor.asm:2522
0xEEFB  0x20 0xED 0x8B  JSR 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xEEFE  0x64 0x4E       STZ 0x4E                // States.SetFailure();              executor.asm:2528
0xEF00  0x60            RTS                     // break;                            executor.asm:2529
0xEF01  0xA4 0x03       LDY 0x03                // LDY ZP.SP                         executor.asm:2533
0xEF03  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       executor.asm:2534
0xEF05  0x99 0x00 0x05  STA 0x0500,Y            // STA Address.TypeStackLSB, Y       executor.asm:2535
0xEF08  0xA5 0x11       LDA 0x11                // LDA ZP.TOP0                       executor.asm:2536
0xEF0A  0x99 0x00 0x06  STA 0x0600,Y            // STA Address.ValueStackB0, Y       executor.asm:2537
0xEF0D  0xA5 0x12       LDA 0x12                // LDA ZP.TOP1                       executor.asm:2538
0xEF0F  0x99 0x00 0x07  STA 0x0700,Y            // STA Address.ValueStackB1, Y       executor.asm:2539
0xEF12  0xA5 0x13       LDA 0x13                // LDA ZP.TOP2                       executor.asm:2540
0xEF14  0x99 0x00 0x08  STA 0x0800,Y            // STA Address.ValueStackB2, Y       executor.asm:2541
0xEF17  0xA5 0x14       LDA 0x14                // LDA ZP.TOP3                       executor.asm:2542
0xEF19  0x99 0x00 0x09  STA 0x0900,Y            // STA Address.ValueStackB3, Y       executor.asm:2543
0xEF1C  0xE6 0x03       INC 0x03                // INC ZP.SP                         executor.asm:2544
0xEF1E  0x60            RTS                     // break;                            executor.asm:2546

// /source/projects/6502sbc/hopperbasic/executor.asm:2556
// ####  Executor.executeGetItemGG()  ####                                      0x0295

0xEF1F  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2568
0xEF21  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2571
0xEF23  0xD0 0x02       BNE 0xEF27 (+2)         // if (Z)                            executor.asm:2572
0xEF25  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2574
0xEF27  0xAA            TAX                     // TAX     X = array global index    executor.asm:2578
0xEF28  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2583
0xEF2A  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2586
0xEF2C  0xD0 0x02       BNE 0xEF30 (+2)         // if (Z)                            executor.asm:2587
0xEF2E  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2589
0xEF30  0xA8            TAY                     // TAY     Y = index global index    executor.asm:2593
0xEF31  0x4C 0x77 0xEE  JMP 0xEE77              // commonGetItem();                  executor.asm:2596

// /source/projects/6502sbc/hopperbasic/executor.asm:2611
// ####  Executor.executeGetItemGL()  ####                                      0x0296

0xEF34  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2623
0xEF36  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2626
0xEF38  0xD0 0x02       BNE 0xEF3C (+2)         // if (Z)                            executor.asm:2627
0xEF3A  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2629
0xEF3C  0xAA            TAX                     // TAX     X = array global index    executor.asm:2633
0xEF3D  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2638
0xEF3F  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2641
0xEF41  0xD0 0x02       BNE 0xEF45 (+2)         // if (Z)                            executor.asm:2642
0xEF43  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2644
0xEF45  0x18            CLC                     // CLC                               executor.asm:2649
0xEF46  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:2650
0xEF48  0xA8            TAY                     // TAY     Y = index local position  executor.asm:2651
0xEF49  0x4C 0x77 0xEE  JMP 0xEE77              // commonGetItem();                  executor.asm:2654

// /source/projects/6502sbc/hopperbasic/executor.asm:2669
// ####  Executor.executeGetItemLG()  ####                                      0x0297

0xEF4C  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2681
0xEF4E  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2684
0xEF50  0xD0 0x02       BNE 0xEF54 (+2)         // if (Z)                            executor.asm:2685
0xEF52  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2687
0xEF54  0x18            CLC                     // CLC                               executor.asm:2692
0xEF55  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:2693
0xEF57  0xAA            TAX                     // TAX     X = array local position  executor.asm:2694
0xEF58  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2699
0xEF5A  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2702
0xEF5C  0xD0 0x02       BNE 0xEF60 (+2)         // if (Z)                            executor.asm:2703
0xEF5E  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2705
0xEF60  0xA8            TAY                     // TAY     Y = index global index    executor.asm:2709
0xEF61  0x4C 0x77 0xEE  JMP 0xEE77              // commonGetItem();                  executor.asm:2712

// /source/projects/6502sbc/hopperbasic/executor.asm:2727
// ####  Executor.executeGetItemLL()  ####                                      0x0298

0xEF64  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2739
0xEF66  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2742
0xEF68  0xD0 0x02       BNE 0xEF6C (+2)         // if (Z)                            executor.asm:2743
0xEF6A  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2745
0xEF6C  0x18            CLC                     // CLC                               executor.asm:2750
0xEF6D  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:2751
0xEF6F  0xAA            TAX                     // TAX     X = array local position  executor.asm:2752
0xEF70  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2757
0xEF72  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2760
0xEF74  0xD0 0x02       BNE 0xEF78 (+2)         // if (Z)                            executor.asm:2761
0xEF76  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2763
0xEF78  0x18            CLC                     // CLC                               executor.asm:2768
0xEF79  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:2769
0xEF7B  0xA8            TAY                     // TAY     Y = index local position  executor.asm:2770
0xEF7C  0x4C 0x77 0xEE  JMP 0xEE77              // commonGetItem();                  executor.asm:2773

// /source/projects/6502sbc/hopperbasic/executor.asm:2789
// ####  Executor.executeGetItem()  ####                                        0x0299

0xEF7F  0xC6 0x03       DEC 0x03                // DEC ZP.SP                         executor.asm:2801
0xEF81  0xA4 0x03       LDY 0x03                // LDY ZP.SP                         executor.asm:2802
0xEF83  0xC6 0x03       DEC 0x03                // DEC ZP.SP                         executor.asm:2805
0xEF85  0xA6 0x03       LDX 0x03                // LDX ZP.SP                         executor.asm:2806
0xEF87  0x4C 0x77 0xEE  JMP 0xEE77              // commonGetItem();                  executor.asm:2809

// /source/projects/6502sbc/hopperbasic/executor.asm:2826
// ####  Executor.executeSetItem()  ####                                        0x029A

0xEF8A  0xA6 0x03       LDX 0x03                // LDX ZP.SP                         executor.asm:2837
0xEF8C  0xCA            DEX                     // DEX                               executor.asm:2838
0xEF8D  0xBD 0x00 0x06  LDA 0x0600,X            // LDA Address.ValueStackB0, X       executor.asm:2839
0xEF90  0x85 0x11       STA 0x11                // STA ZP.TOP0                       executor.asm:2840
0xEF92  0xBD 0x00 0x07  LDA 0x0700,X            // LDA Address.ValueStackB1, X       executor.asm:2841
0xEF95  0x85 0x12       STA 0x12                // STA ZP.TOP1                       executor.asm:2842
0xEF97  0xBD 0x00 0x08  LDA 0x0800,X            // LDA Address.ValueStackB2, X       executor.asm:2843
0xEF9A  0x85 0x13       STA 0x13                // STA ZP.TOP2                       executor.asm:2844
0xEF9C  0xBD 0x00 0x09  LDA 0x0900,X            // LDA Address.ValueStackB3, X       executor.asm:2845
0xEF9F  0x85 0x14       STA 0x14                // STA ZP.TOP3                       executor.asm:2846
0xEFA1  0xBD 0x00 0x05  LDA 0x0500,X            // LDA Address.TypeStackLSB, X       executor.asm:2847
0xEFA4  0x85 0x15       STA 0x15                // STA ZP.TOPT                       executor.asm:2848
0xEFA6  0xCA            DEX                     // DEX                               executor.asm:2851
0xEFA7  0x8A            TXA                     // TXA                               executor.asm:2852
0xEFA8  0xA8            TAY                     // TAY                               executor.asm:2853
0xEFA9  0xCA            DEX                     // DEX                               executor.asm:2856
0xEFAA  0x86 0x03       STX 0x03                // STX ZP.SP                         executor.asm:2857
0xEFAC  0x4C 0x1B 0xF0  JMP 0xF01B              // commonSetItem();                  executor.asm:2860

// /source/projects/6502sbc/hopperbasic/executor.asm:2877
// ####  Executor.executeSetItemGL()  ####                                      0x029B

0xEFAF  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();                    executor.asm:2888
0xEFB2  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2893
0xEFB4  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2896
0xEFB6  0xD0 0x02       BNE 0xEFBA (+2)         // if (Z)                            executor.asm:2897
0xEFB8  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2899
0xEFBA  0xAA            TAX                     // TAX     global index LSB          executor.asm:2904
0xEFBB  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2910
0xEFBD  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2913
0xEFBF  0xD0 0x02       BNE 0xEFC3 (+2)         // if (Z)                            executor.asm:2914
0xEFC1  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2916
0xEFC3  0x18            CLC                     // CLC                               executor.asm:2921
0xEFC4  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:2922
0xEFC6  0xA8            TAY                     // TAY     Y = stack position        executor.asm:2923
0xEFC7  0x4C 0x1B 0xF0  JMP 0xF01B              // commonSetItem();                  executor.asm:2926

// /source/projects/6502sbc/hopperbasic/executor.asm:2942
// ####  Executor.executeSetItemLG()  ####                                      0x029C

0xEFCA  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();                    executor.asm:2953
0xEFCD  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2958
0xEFCF  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2961
0xEFD1  0xD0 0x02       BNE 0xEFD5 (+2)         // if (Z)                            executor.asm:2962
0xEFD3  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2964
0xEFD5  0x18            CLC                     // CLC                               executor.asm:2969
0xEFD6  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:2970
0xEFD8  0xAA            TAX                     // TAX     X = stack position        executor.asm:2971
0xEFD9  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:2977
0xEFDB  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:2980
0xEFDD  0xD0 0x02       BNE 0xEFE1 (+2)         // if (Z)                            executor.asm:2981
0xEFDF  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:2983
0xEFE1  0xA8            TAY                     // TAY     Y = stack position        executor.asm:2986
0xEFE2  0x4C 0x1B 0xF0  JMP 0xF01B              // commonSetItem();                  executor.asm:2989

// /source/projects/6502sbc/hopperbasic/executor.asm:3005
// ####  Executor.executeSetItemLL()  ####                                      0x029D

0xEFE5  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();                    executor.asm:3017
0xEFE8  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:3022
0xEFEA  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:3025
0xEFEC  0xD0 0x02       BNE 0xEFF0 (+2)         // if (Z)                            executor.asm:3026
0xEFEE  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:3028
0xEFF0  0x18            CLC                     // CLC                               executor.asm:3033
0xEFF1  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:3034
0xEFF3  0xAA            TAX                     // TAX     X = stack position        executor.asm:3035
0xEFF4  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:3040
0xEFF6  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:3043
0xEFF8  0xD0 0x02       BNE 0xEFFC (+2)         // if (Z)                            executor.asm:3044
0xEFFA  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:3046
0xEFFC  0x18            CLC                     // CLC                               executor.asm:3051
0xEFFD  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:3052
0xEFFF  0xA8            TAY                     // TAY     Y = stack position        executor.asm:3053
0xF000  0x4C 0x1B 0xF0  JMP 0xF01B              // commonSetItem();                  executor.asm:3056

// /source/projects/6502sbc/hopperbasic/executor.asm:3072
// ####  Executor.executeSetItemGG()  ####                                      0x029E

0xF003  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();                    executor.asm:3084
0xF006  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:3089
0xF008  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:3092
0xF00A  0xD0 0x02       BNE 0xF00E (+2)         // if (Z)                            executor.asm:3093
0xF00C  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:3095
0xF00E  0xAA            TAX                     // TAX                               executor.asm:3100
0xF00F  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:3106
0xF011  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:3109
0xF013  0xD0 0x02       BNE 0xF017 (+2)         // if (Z)                            executor.asm:3110
0xF015  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:3112
0xF017  0xA8            TAY                     // TAY     Y = stack position        executor.asm:3115
0xF018  0x4C 0x1B 0xF0  JMP 0xF01B              // commonSetItem();                  executor.asm:3118

// /source/projects/6502sbc/hopperbasic/executor.asm:3134
// ####  Executor.commonSetItem()  ####                                         0x029F

0xF01B  0xBD 0x00 0x06  LDA 0x0600,X            // LDA Address.ValueStackLSB, X      executor.asm:3138
0xF01E  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       executor.asm:3139
0xF020  0xBD 0x00 0x07  LDA 0x0700,X            // LDA Address.ValueStackMSB, X      executor.asm:3140
0xF023  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       executor.asm:3141
0xF025  0xBD 0x00 0x05  LDA 0x0500,X            // LDA Address.TypeStackLSB, X    Array type
0xF028  0x29 0x20       AND # 0x20              // AND # BASICType.ARRAY             executor.asm:3144
0xF02A  0xD0 0x03       BNE 0xF02F (+3)         // if (Z)                            executor.asm:3145
0xF02C  0x4C 0xED 0x8B  JMP 0x8BED              // Error.TypeMismatch(); BIT ZP.EmulatorPCL
0xF02F  0x20 0x63 0xAB  JSR 0xAB63              // BASICArray.GetItemType();    Returns type in ZP.ACCT
0xF032  0xB9 0x00 0x06  LDA 0x0600,Y            // LDA Address.ValueStackLSB, Y      executor.asm:3156
0xF035  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       executor.asm:3157
0xF037  0xB9 0x00 0x07  LDA 0x0700,Y            // LDA Address.ValueStackMSB, Y      executor.asm:3158
0xF03A  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       executor.asm:3159
0xF03C  0x20 0x03 0xAC  JSR 0xAC03              // BASICArray.SetItem();             executor.asm:3165
0xF03F  0x90 0x01       BCC 0xF042 (+1)         // if (NC)                           executor.asm:3166
0xF041  0x60            RTS
0xF042  0x64 0x4E       STZ 0x4E                // States.SetFailure();              executor.asm:3169
0xF044  0x60            RTS                     // break;                            executor.asm:3170

// /source/projects/6502sbc/hopperbasic/executor.asm:3183
// ####  Executor.executeIncLocal()  ####                                       0x02A0

0xF045  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:3193
0xF047  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:3196
0xF049  0xD0 0x02       BNE 0xF04D (+2)         // if (Z)                            executor.asm:3197
0xF04B  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:3199
0xF04D  0x18            CLC                     // CLC                               executor.asm:3204
0xF04E  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:3205
0xF050  0xAA            TAX                     // TAX     X = stack position        executor.asm:3206
0xF051  0xFE 0x00 0x06  INC 0x0600,X            // INC Address.ValueStackLSB, X      executor.asm:3209
0xF054  0xF0 0x01       BEQ 0xF057 (+1)         // if (Z)                            executor.asm:3210
0xF056  0x60            RTS
0xF057  0xFE 0x00 0x07  INC 0x0700,X            // INC Address.ValueStackMSB, X      executor.asm:3212
0xF05A  0x60            RTS                     // }                                 executor.asm:3218

// /source/projects/6502sbc/hopperbasic/executor.asm:3226
// ####  Executor.executeIncGlobal()  ####                                      0x02A1

0xF05B  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:3236
0xF05D  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:3239
0xF05F  0xD0 0x02       BNE 0xF063 (+2)         // if (Z)                            executor.asm:3240
0xF061  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:3242
0xF063  0xAA            TAX                     // TAX     X = global index          executor.asm:3245
0xF064  0xFE 0x00 0x06  INC 0x0600,X            // INC Address.ValueStackLSB, X      executor.asm:3248
0xF067  0xF0 0x01       BEQ 0xF06A (+1)         // if (Z)                            executor.asm:3249
0xF069  0x60            RTS
0xF06A  0xFE 0x00 0x07  INC 0x0700,X            // INC Address.ValueStackMSB, X      executor.asm:3251
0xF06D  0x60            RTS                     // }                                 executor.asm:3257

// /source/projects/6502sbc/hopperbasic/executor.asm:3265
// ####  Executor.executeAddLocals()  ####                                      0x02A2

0xF06E  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:3276
0xF070  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:3279
0xF072  0xD0 0x02       BNE 0xF076 (+2)         // if (Z)                            executor.asm:3280
0xF074  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:3282
0xF076  0x18            CLC                     // CLC                               executor.asm:3286
0xF077  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:3287
0xF079  0xAA            TAX                     // TAX                                    X = target stack position (LHS)
0xF07A  0xB2 0x00       LDA [0x00]              // LDA [ZP.PC]                       executor.asm:3293
0xF07C  0xE6 0x00       INC 0x00                // INC ZP.PCL                        executor.asm:3296
0xF07E  0xD0 0x02       BNE 0xF082 (+2)         // if (Z)                            executor.asm:3297
0xF080  0xE6 0x01       INC 0x01                // INC ZP.PCH                        executor.asm:3299
0xF082  0x18            CLC                     // CLC                               executor.asm:3304
0xF083  0x65 0x04       ADC 0x04                // ADC ZP.BP                         executor.asm:3305
0xF085  0xA8            TAY                     // TAY                                   Y = source stack position (RHS)
0xF086  0xB9 0x00 0x05  LDA 0x0500,Y            // LDA Address.TypeStack, Y          executor.asm:3309
0xF089  0x85 0x15       STA 0x15                // STA ZP.TOPT                       executor.asm:3310
0xF08B  0xBD 0x00 0x05  LDA 0x0500,X            // LDA Address.TypeStack, X          executor.asm:3311
0xF08E  0x85 0x1A       STA 0x1A                // STA ZP.NEXTT                      executor.asm:3312
0xF090  0x18            CLC                     // CLC                               executor.asm:3315
0xF091  0xBD 0x00 0x06  LDA 0x0600,X            // LDA Address.ValueStackB0, X       executor.asm:3316
0xF094  0x79 0x00 0x06  ADC 0x0600,Y            // ADC Address.ValueStackB0, Y       executor.asm:3317
0xF097  0x9D 0x00 0x06  STA 0x0600,X            // STA Address.ValueStackB0, X       executor.asm:3318
0xF09A  0xBD 0x00 0x07  LDA 0x0700,X            // LDA Address.ValueStackB1, X       executor.asm:3319
0xF09D  0x79 0x00 0x07  ADC 0x0700,Y            // ADC Address.ValueStackB1, Y       executor.asm:3320
0xF0A0  0x9D 0x00 0x07  STA 0x0700,X            // STA Address.ValueStackB1, X       executor.asm:3321
0xF0A3  0x3F 0x1A 0x27  BBR3 0x1A, 0xF0CD (+39) // if (BBS3, ZP.NEXTT)    LHS is LONG
0xF0A6  0x3F 0x15 0x13  BBR3 0x15, 0xF0BC (+19) // if (BBS3, ZP.TOPT)    RHS is LONG executor.asm:3325
0xF0A9  0xBD 0x00 0x08  LDA 0x0800,X            // LDA Address.ValueStackB2, X       executor.asm:3327
0xF0AC  0x79 0x00 0x08  ADC 0x0800,Y            // ADC Address.ValueStackB2, Y       executor.asm:3328
0xF0AF  0x9D 0x00 0x08  STA 0x0800,X            // STA Address.ValueStackB2, X       executor.asm:3329
0xF0B2  0xBD 0x00 0x09  LDA 0x0900,X            // LDA Address.ValueStackB3, X       executor.asm:3330
0xF0B5  0x79 0x00 0x09  ADC 0x0900,Y            // ADC Address.ValueStackB3, Y       executor.asm:3331
0xF0B8  0x9D 0x00 0x09  STA 0x0900,X            // STA Address.ValueStackB3, X       executor.asm:3332
0xF0BB  0x60            RTS                     // }                                 executor.asm:3333
0xF0BC  0xBD 0x00 0x08  LDA 0x0800,X            // LDA Address.ValueStackB2, X       executor.asm:3337
0xF0BF  0x69 0x00       ADC # 0                 // ADC #0                            executor.asm:3338
0xF0C1  0x9D 0x00 0x08  STA 0x0800,X            // STA Address.ValueStackB2, X       executor.asm:3339
0xF0C4  0xBD 0x00 0x09  LDA 0x0900,X            // LDA Address.ValueStackB3, X       executor.asm:3340
0xF0C7  0x69 0x00       ADC # 0                 // ADC #0                            executor.asm:3341
0xF0C9  0x9D 0x00 0x09  STA 0x0900,X            // STA Address.ValueStackB3, X       executor.asm:3342
0xF0CC  0x60            RTS                     // }                                 executor.asm:3344
0xF0CD  0xBF 0x15 0x01  BBS3 0x15, 0xF0D1 (+1)  // if (BBS3, ZP.TOPT)    RHS is LONG executor.asm:3348
0xF0D0  0x60            RTS
0xF0D1  0xCF 0x1A 0x01  BBS4 0x1A, 0xF0D5 (+1)  // if (BBS4, ZP.NEXTT)    LHS is VAR executor.asm:3350
0xF0D4  0x60            RTS
0xF0D5  0xA9 0x18       LDA # 0x18              // LDA #(BASICType.VAR | BASICType.LONG)
0xF0D7  0x9D 0x00 0x05  STA 0x0500,X            // STA Address.TypeStack, X          executor.asm:3354
0xF0DA  0xA9 0x00       LDA # 0                 // LDA #0                            executor.asm:3358
0xF0DC  0x79 0x00 0x08  ADC 0x0800,Y            // ADC Address.ValueStackB2, Y       executor.asm:3359
0xF0DF  0x9D 0x00 0x08  STA 0x0800,X            // STA Address.ValueStackB2, X       executor.asm:3360
0xF0E2  0xA9 0x00       LDA # 0                 // LDA #0                            executor.asm:3361
0xF0E4  0x79 0x00 0x09  ADC 0x0900,Y            // ADC Address.ValueStackB3, Y       executor.asm:3362
0xF0E7  0x9D 0x00 0x09  STA 0x0900,X            // STA Address.ValueStackB3, X       executor.asm:3363

// /source/projects/6502sbc/hopperbasic/executor.asm:3390
// ####  Executor.executeAddGlobals()  ####                                     0x02A3

0xF0EA  0x20 0x5C 0xE8  JSR 0xE85C              // FetchOperandByte();               executor.asm:3398
0xF0ED  0xAA            TAX                     // TAX     X = target global index   executor.asm:3400
0xF0EE  0x20 0x5C 0xE8  JSR 0xE85C              // FetchOperandByte();               executor.asm:3403
0xF0F1  0xA8            TAY                     // TAY     Y = source global index   executor.asm:3405
0xF0F2  0x18            CLC                     // CLC                               executor.asm:3408
0xF0F3  0xBD 0x00 0x06  LDA 0x0600,X            // LDA Address.ValueStackLSB, X      executor.asm:3409
0xF0F6  0x79 0x00 0x06  ADC 0x0600,Y            // ADC Address.ValueStackLSB, Y      executor.asm:3410
0xF0F9  0x9D 0x00 0x06  STA 0x0600,X            // STA Address.ValueStackLSB, X      executor.asm:3411
0xF0FC  0xBD 0x00 0x07  LDA 0x0700,X            // LDA Address.ValueStackMSB, X      executor.asm:3412
0xF0FF  0x79 0x00 0x07  ADC 0x0700,Y            // ADC Address.ValueStackMSB, Y      executor.asm:3413
0xF102  0x9D 0x00 0x07  STA 0x0700,X            // STA Address.ValueStackMSB, X      executor.asm:3414
0xF105  0x60            RTS                     // break;                            executor.asm:3416

// /source/projects/6502sbc/hopperbasic/executor.asm:3447
// ####  Executor.executePushLong()  ####                                       0x02A5

0xF106  0x20 0x66 0xE8  JSR 0xE866              // FetchOperandWord();               executor.asm:3454
0xF109  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       executor.asm:3456
0xF10B  0x85 0x13       STA 0x13                // STA ZP.TOP2                       executor.asm:3457
0xF10D  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       executor.asm:3458
0xF10F  0x85 0x14       STA 0x14                // STA ZP.TOP3                       executor.asm:3459
0xF111  0x20 0x79 0x94  JSR 0x9479              // Stacks.PopTop();                  executor.asm:3460
0xF114  0x4C 0x89 0x97  JMP 0x9789              // Long.PushTopStrictLONG();         executor.asm:3461

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:14
// ####  TokenIterator.Start()  ####                                            0x02A6

0xF117  0x48            PHA                     // PHA                               tokeniterator.asm:15
0xF118  0x5A            PHY                     // PHY                               tokeniterator.asm:16
0xF119  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       tokeniterator.asm:21
0xF11B  0x85 0x50       STA 0x50                // STA ZP.TOKBASEL                   tokeniterator.asm:22
0xF11D  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       tokeniterator.asm:23
0xF11F  0x85 0x51       STA 0x51                // STA ZP.TOKBASEH                   tokeniterator.asm:24
0xF121  0x64 0x55       STZ 0x55                // STZ ZP.TOKPREV                    tokeniterator.asm:26
0xF123  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       tokeniterator.asm:30
0xF125  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       tokeniterator.asm:31
0xF127  0xD0 0x05       BNE 0xF12E (+5)         // if (Z)                            tokeniterator.asm:32
0xF129  0x64 0x4F       STZ 0x4F                // STZ ZP.TOKCUR                     tokeniterator.asm:35
0xF12B  0x18            CLC                     // CLC     Empty stream              tokeniterator.asm:36
0xF12C  0x80 0x17       BRA 0xF145 (+23)        // break;                            tokeniterator.asm:37
0xF12E  0x64 0x53       STZ 0x53                // STZ ZP.TOKPOSL                    tokeniterator.asm:41
0xF130  0x64 0x54       STZ 0x54                // STZ ZP.TOKPOSH                    tokeniterator.asm:42
0xF132  0xA0 0x00       LDY # 0                 // LDY #0                            tokeniterator.asm:46
0xF134  0xB1 0x1D       LDA [0x1D],Y            // LDA [ZP.IDY], Y                   tokeniterator.asm:47
0xF136  0x85 0x4F       STA 0x4F                // STA ZP.TOKCUR                     tokeniterator.asm:48
0xF138  0xD0 0x03       BNE 0xF13D (+3)         // if (Z)                            tokeniterator.asm:51
0xF13A  0x18            CLC                     // CLC     Empty stream (null terminator)
0xF13B  0x80 0x08       BRA 0xF145 (+8)         // break;                            tokeniterator.asm:54
0xF13D  0xC9 0xDB       CMP # 0xDB              // CMP #Token.EOF                    tokeniterator.asm:56
0xF13F  0xD0 0x03       BNE 0xF144 (+3)         // if (Z)                            tokeniterator.asm:57
0xF141  0x18            CLC                     // CLC     Empty stream (starts with EOF)
0xF142  0x80 0x01       BRA 0xF145 (+1)         // break;                            tokeniterator.asm:60
0xF144  0x38            SEC                     // SEC     Stream has content        tokeniterator.asm:63
0xF145  0x7A            PLY                     // PLY                               tokeniterator.asm:67
0xF146  0x68            PLA                     // PLA                               tokeniterator.asm:68
0xF147  0x60            RTS                     // }                                 tokeniterator.asm:69

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:77
// ####  TokenIterator.Next()  ####                                             0x02A7

0xF148  0x48            PHA                     // PHA                               tokeniterator.asm:78
0xF149  0x5A            PHY                     // PHY                               tokeniterator.asm:79
0xF14A  0xA5 0x4F       LDA 0x4F                // LDA ZP.TOKCUR                     tokeniterator.asm:83
0xF14C  0x85 0x55       STA 0x55                // STA ZP.TOKPREV                    tokeniterator.asm:84
0xF14E  0xC9 0xD7       CMP # 0xD7              // case Token.NUMBER:                tokeniterator.asm:90
0xF150  0xF0 0x10       BEQ 0xF162 (+16)
0xF152  0xC9 0xDA       CMP # 0xDA              // case Token.IDENTIFIER:            tokeniterator.asm:91
0xF154  0xF0 0x0C       BEQ 0xF162 (+12)
0xF156  0xC9 0x94       CMP # 0x94              // case Token.REM:                   tokeniterator.asm:92
0xF158  0xF0 0x08       BEQ 0xF162 (+8)
0xF15A  0xC9 0x95       CMP # 0x95              // case Token.COMMENT:               tokeniterator.asm:93
0xF15C  0xF0 0x04       BEQ 0xF162 (+4)
0xF15E  0xC9 0xD8       CMP # 0xD8              // case Token.STRINGLIT:             tokeniterator.asm:94
0xF160  0xD0 0x07       BNE 0xF169 (+7)
0xF162  0x20 0xA4 0xF1  JSR 0xF1A4              // skipInlineString();               tokeniterator.asm:97
0xF165  0x90 0x3A       BCC 0xF1A1 (+58)        // if (NC) { break; }    Error or end of stream
0xF167  0x80 0x18       BRA 0xF181 (+24)
0xF169  0xC9 0xD9       CMP # 0xD9              // case Token.CHARLIT:               tokeniterator.asm:100
0xF16B  0xD0 0x0E       BNE 0xF17B (+14)
0xF16D  0xE6 0x53       INC 0x53                // INC ZP.TOKPOSL                    tokeniterator.asm:104
0xF16F  0xD0 0x02       BNE 0xF173 (+2)         // if (Z) { INC ZP.TOKPOSH }         tokeniterator.asm:105
0xF171  0xE6 0x54       INC 0x54
0xF173  0xE6 0x53       INC 0x53                // INC ZP.TOKPOSL                    tokeniterator.asm:106
0xF175  0xD0 0x0A       BNE 0xF181 (+10)        // if (Z) { INC ZP.TOKPOSH }         tokeniterator.asm:107
0xF177  0xE6 0x54       INC 0x54
0xF179  0x80 0x06       BRA 0xF181 (+6)         // }                                 tokeniterator.asm:108
0xF17B  0xE6 0x53       INC 0x53                // INC ZP.TOKPOSL                    tokeniterator.asm:112
0xF17D  0xD0 0x02       BNE 0xF181 (+2)         // if (Z)                            tokeniterator.asm:113
0xF17F  0xE6 0x54       INC 0x54                // INC ZP.TOKPOSH                    tokeniterator.asm:115
0xF181  0x18            CLC                     // CLC                               tokeniterator.asm:121
0xF182  0xA5 0x50       LDA 0x50                // LDA ZP.TOKBASEL                   tokeniterator.asm:122
0xF184  0x65 0x53       ADC 0x53                // ADC ZP.TOKPOSL                    tokeniterator.asm:123
0xF186  0x85 0x79       STA 0x79                // STA ZP.STRL                       tokeniterator.asm:124
0xF188  0xA5 0x51       LDA 0x51                // LDA ZP.TOKBASEH                   tokeniterator.asm:125
0xF18A  0x65 0x54       ADC 0x54                // ADC ZP.TOKPOSH                    tokeniterator.asm:126
0xF18C  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       tokeniterator.asm:127
0xF18E  0xA0 0x00       LDY # 0                 // LDY #0                            tokeniterator.asm:130
0xF190  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   tokeniterator.asm:131
0xF192  0x85 0x4F       STA 0x4F                // STA ZP.TOKCUR                     tokeniterator.asm:132
0xF194  0xD0 0x03       BNE 0xF199 (+3)         // if (Z)                            tokeniterator.asm:135
0xF196  0x18            CLC                     // CLC     End of stream             tokeniterator.asm:137
0xF197  0x80 0x08       BRA 0xF1A1 (+8)         // break;                            tokeniterator.asm:138
0xF199  0xC9 0xDB       CMP # 0xDB              // CMP #Token.EOF                    tokeniterator.asm:140
0xF19B  0xD0 0x03       BNE 0xF1A0 (+3)         // if (Z)                            tokeniterator.asm:141
0xF19D  0x18            CLC                     // CLC     End of stream (EOF token) tokeniterator.asm:143
0xF19E  0x80 0x01       BRA 0xF1A1 (+1)         // break;                            tokeniterator.asm:144
0xF1A0  0x38            SEC                     // SEC     Valid token loaded        tokeniterator.asm:147
0xF1A1  0x7A            PLY                     // PLY                               tokeniterator.asm:151
0xF1A2  0x68            PLA                     // PLA                               tokeniterator.asm:152
0xF1A3  0x60            RTS                     // }                                 tokeniterator.asm:153

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:160
// ####  TokenIterator.skipInlineString()  ####                                 0x02A8

0xF1A4  0x48            PHA                     // PHA                               tokeniterator.asm:161
0xF1A5  0x5A            PHY                     // PHY                               tokeniterator.asm:162
0xF1A6  0xE6 0x53       INC 0x53                // INC ZP.TOKPOSL                    tokeniterator.asm:167
0xF1A8  0xD0 0x02       BNE 0xF1AC (+2)         // if (Z)                            tokeniterator.asm:168
0xF1AA  0xE6 0x54       INC 0x54                // INC ZP.TOKPOSH                    tokeniterator.asm:170
0xF1AC  0x18            CLC                     // CLC                               tokeniterator.asm:174
0xF1AD  0xA5 0x50       LDA 0x50                // LDA ZP.TOKBASEL                   tokeniterator.asm:175
0xF1AF  0x65 0x53       ADC 0x53                // ADC ZP.TOKPOSL                    tokeniterator.asm:176
0xF1B1  0x85 0x79       STA 0x79                // STA ZP.STRL                       tokeniterator.asm:177
0xF1B3  0xA5 0x51       LDA 0x51                // LDA ZP.TOKBASEH                   tokeniterator.asm:178
0xF1B5  0x65 0x54       ADC 0x54                // ADC ZP.TOKPOSH                    tokeniterator.asm:179
0xF1B7  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       tokeniterator.asm:180
0xF1B9  0xA0 0x00       LDY # 0                 // LDY #0                            tokeniterator.asm:183
0xF1BB  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y                   tokeniterator.asm:184
0xF1BD  0xD0 0xE7       BNE 0xF1A6 (-25)        // if (Z)                            tokeniterator.asm:185
0xF1BF  0xE6 0x53       INC 0x53                // INC ZP.TOKPOSL                    tokeniterator.asm:188
0xF1C1  0xD0 0x02       BNE 0xF1C5 (+2)         // if (Z)                            tokeniterator.asm:189
0xF1C3  0xE6 0x54       INC 0x54                // INC ZP.TOKPOSH                    tokeniterator.asm:191
0xF1C5  0x38            SEC                     // SEC     Success                   tokeniterator.asm:193
0xF1C6  0x7A            PLY                     // PLY                               tokeniterator.asm:200
0xF1C7  0x68            PLA                     // PLA                               tokeniterator.asm:201
0xF1C8  0x60            RTS                     // }                                 tokeniterator.asm:202

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:219
// ####  TokenIterator.GetCurrentData()  ####                                   0x02AA

0xF1C9  0x48            PHA                     // PHA                               tokeniterator.asm:220
0xF1CA  0x18            CLC                     // CLC                               tokeniterator.asm:223
0xF1CB  0xA5 0x50       LDA 0x50                // LDA ZP.TOKBASEL                   tokeniterator.asm:224
0xF1CD  0x65 0x53       ADC 0x53                // ADC ZP.TOKPOSL                    tokeniterator.asm:225
0xF1CF  0x85 0x79       STA 0x79                // STA ZP.STRL                       tokeniterator.asm:226
0xF1D1  0xA5 0x51       LDA 0x51                // LDA ZP.TOKBASEH                   tokeniterator.asm:227
0xF1D3  0x65 0x54       ADC 0x54                // ADC ZP.TOKPOSH                    tokeniterator.asm:228
0xF1D5  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       tokeniterator.asm:229
0xF1D7  0xE6 0x79       INC 0x79                // INC ZP.STRL                       tokeniterator.asm:232
0xF1D9  0xD0 0x02       BNE 0xF1DD (+2)         // if (Z)                            tokeniterator.asm:233
0xF1DB  0xE6 0x7A       INC 0x7A                // INC ZP.STRH                       tokeniterator.asm:235
0xF1DD  0x68            PLA                     // PLA                               tokeniterator.asm:238
0xF1DE  0x60            RTS                     // }                                 tokeniterator.asm:239

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:248
// ####  TokenIterator.isIndentIncreaseToken()  ####                            0x02AB

0xF1DF  0xC9 0xA5       CMP # 0xA5              // case Token.FUNC:                  tokeniterator.asm:253
0xF1E1  0xF0 0x10       BEQ 0xF1F3 (+16)
0xF1E3  0xC9 0xAA       CMP # 0xAA              // case Token.FOR:                   tokeniterator.asm:254
0xF1E5  0xF0 0x0C       BEQ 0xF1F3 (+12)
0xF1E7  0xC9 0xAE       CMP # 0xAE              // case Token.WHILE:                 tokeniterator.asm:255
0xF1E9  0xF0 0x08       BEQ 0xF1F3 (+8)
0xF1EB  0xC9 0xB0       CMP # 0xB0              // case Token.DO:                    tokeniterator.asm:256
0xF1ED  0xF0 0x04       BEQ 0xF1F3 (+4)
0xF1EF  0xC9 0xA8       CMP # 0xA8              // case Token.BEGIN:                 tokeniterator.asm:257
0xF1F1  0xD0 0x02       BNE 0xF1F5 (+2)
0xF1F3  0x38            SEC                     // SEC                               tokeniterator.asm:259
0xF1F4  0x60            RTS                     // break;                            tokeniterator.asm:260
0xF1F5  0xC9 0xA1       CMP # 0xA1              // case Token.IF:                    tokeniterator.asm:262
0xF1F7  0xD0 0x04       BNE 0xF1FD (+4)
0xF1F9  0x87 0x5A       SMB0 0x5A               // SMB0 ZP.TOKSINGLEIF    entering IF line
0xF1FB  0x38            SEC                     // SEC                               tokeniterator.asm:265
0xF1FC  0x60            RTS                     // break;                            tokeniterator.asm:266
0xF1FD  0xC9 0xA3       CMP # 0xA3              // case Token.ELSE:                  tokeniterator.asm:268
0xF1FF  0xD0 0x05       BNE 0xF206 (+5)
0xF201  0x8F 0x5A 0x02  BBS0 0x5A, 0xF206 (+2)  // if (BBR0, ZP.TOKSINGLEIF)    not in a single line IF
0xF204  0x38            SEC                     // SEC                               tokeniterator.asm:272
0xF205  0x60            RTS                     // break;                            tokeniterator.asm:273
0xF206  0x18            CLC                     // CLC    Not an indent-increasing token
0xF207  0x60            RTS                     // break;                            tokeniterator.asm:278

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:287
// ####  TokenIterator.isIndentDecreaseToken()  ####                            0x02AC

0xF208  0xC9 0xDB       CMP # 0xDB              // case Token.EOF:                   tokeniterator.asm:292
0xF20A  0xF0 0x14       BEQ 0xF220 (+20)
0xF20C  0xC9 0xAD       CMP # 0xAD              // case Token.NEXT:                  tokeniterator.asm:293
0xF20E  0xF0 0x10       BEQ 0xF220 (+16)
0xF210  0xC9 0xAF       CMP # 0xAF              // case Token.WEND:                  tokeniterator.asm:294
0xF212  0xF0 0x0C       BEQ 0xF220 (+12)
0xF214  0xC9 0xB1       CMP # 0xB1              // case Token.UNTIL:                 tokeniterator.asm:295
0xF216  0xF0 0x08       BEQ 0xF220 (+8)
0xF218  0xC9 0xA4       CMP # 0xA4              // case Token.ENDIF:                 tokeniterator.asm:296
0xF21A  0xF0 0x04       BEQ 0xF220 (+4)
0xF21C  0xC9 0xA3       CMP # 0xA3              // case Token.ELSE:                  tokeniterator.asm:297
0xF21E  0xD0 0x02       BNE 0xF222 (+2)
0xF220  0x38            SEC                     // SEC                               tokeniterator.asm:299
0xF221  0x60            RTS                     // break;                            tokeniterator.asm:300
0xF222  0x18            CLC                     // CLC    Not an indent-decreasing token
0xF223  0x60            RTS                     // break;                            tokeniterator.asm:304

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:313
// ####  TokenIterator.printIndentation()  ####                                 0x02AD

0xF224  0x48            PHA                     // PHA                               tokeniterator.asm:314
0xF225  0x5A            PHY                     // PHY                               tokeniterator.asm:315
0xF226  0xA5 0x56       LDA 0x56                // LDA ZP.TOKCOLON                   tokeniterator.asm:320
0xF228  0xF0 0x04       BEQ 0xF22E (+4)         // if (NZ)                           tokeniterator.asm:321
0xF22A  0x64 0x56       STZ 0x56                // STZ ZP.TOKCOLON     Reset flag    tokeniterator.asm:323
0xF22C  0x80 0x0E       BRA 0xF23C (+14)        // break;    Skip indentation        tokeniterator.asm:324
0xF22E  0xA4 0x52       LDY 0x52                // LDY ZP.TOKINDENT                  tokeniterator.asm:326
0xF230  0xC0 0x00       CPY # 0                 // CPY #0                            tokeniterator.asm:329
0xF232  0xF0 0x08       BEQ 0xF23C (+8)         // if (Z) { break; }                 tokeniterator.asm:330
0xF234  0xA2 0x04       LDX # 0x04              // LDX #4 Print.Spaces();            tokeniterator.asm:333
0xF236  0x20 0xC0 0x95  JSR 0x95C0
0xF239  0x88            DEY                     // DEY                               tokeniterator.asm:335
0xF23A  0x80 0xF4       BRA 0xF230 (-12)        // }                                 tokeniterator.asm:336
0xF23C  0x7A            PLY                     // PLY                               tokeniterator.asm:340
0xF23D  0x68            PLA                     // PLA                               tokeniterator.asm:341
0xF23E  0x60            RTS                     // }                                 tokeniterator.asm:342

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:350
// ####  TokenIterator.checkAndPrintErrorMarker()  ####                         0x02AE

0xF23F  0x48            PHA                     // PHA                               tokeniterator.asm:351
0xF240  0xA5 0x59       LDA 0x59                // LDA ZP.TOKERRORFLAG               tokeniterator.asm:356
0xF242  0xD0 0x15       BNE 0xF259 (+21)        // if (NZ)    Set NZ - already printed
0xF244  0xA5 0x57       LDA 0x57                // LDA ZP.TOKERRORL                  tokeniterator.asm:363
0xF246  0x05 0x58       ORA 0x58                // ORA ZP.TOKERRORH                  tokeniterator.asm:364
0xF248  0xF0 0x0F       BEQ 0xF259 (+15)        // if (Z)    Set Z - no error position
0xF24A  0xA5 0x54       LDA 0x54                // LDA ZP.TOKPOSH         TOKPOS MSB tokeniterator.asm:371
0xF24C  0xC5 0x58       CMP 0x58                // CMP ZP.TOKERRORH       TOKERROR MSB
0xF24E  0xD0 0x04       BNE 0xF254 (+4)         // if (Z)                            tokeniterator.asm:373
0xF250  0xA5 0x53       LDA 0x53                // LDA ZP.TOKPOSL      TOKPOS LSB    tokeniterator.asm:375
0xF252  0xC5 0x57       CMP 0x57                // CMP ZP.TOKERRORL    TOKERROR LSB  tokeniterator.asm:376
0xF254  0x90 0x03       BCC 0xF259 (+3)         // if (C)    Set C if TOKPOS >= TOKERROR
0xF256  0x20 0x5B 0xF2  JSR 0xF25B              // printErrorMarker();               tokeniterator.asm:381
0xF259  0x68            PLA                     // PLA                               tokeniterator.asm:387
0xF25A  0x60            RTS                     // }                                 tokeniterator.asm:388

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:396
// ####  TokenIterator.printErrorMarker()  ####                                 0x02AF

0xF25B  0x48            PHA                     // PHA                               tokeniterator.asm:397
0xF25C  0xDA            PHX                     // PHX                               tokeniterator.asm:398
0xF25D  0xA9 0x01       LDA # 1                 // LDA #1                            tokeniterator.asm:401
0xF25F  0x85 0x59       STA 0x59                // STA ZP.TOKERRORFLAG               tokeniterator.asm:402
0xF261  0xA2 0x09       LDX # 0x09              // LDX #9                            tokeniterator.asm:404
0xF263  0x20 0xC0 0x95  JSR 0x95C0              // Print.Spaces();                   tokeniterator.asm:405
0xF266  0xA9 0xA0       LDA # 0xA0              // LDA #( Messages.ErrorMarker % 256)
0xF268  0x85 0x79       STA 0x79                // STA ZP.STRL                       tokeniterator.asm:408
0xF26A  0xA9 0x85       LDA # 0x85              // LDA #( Messages.ErrorMarker / 256)
0xF26C  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       tokeniterator.asm:410
0xF26E  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   tokeniterator.asm:411
0xF271  0xA2 0x03       LDX # 0x03              // LDX #3                            tokeniterator.asm:413
0xF273  0x20 0xC0 0x95  JSR 0x95C0              // Print.Spaces();                   tokeniterator.asm:414
0xF276  0xA5 0x2D       LDA 0x2D                // LDA ZP.LastError                  tokeniterator.asm:417
0xF278  0xA2 0x40       LDX # 0x40              // LDX # MessageExtras.PrefixQuest   tokeniterator.asm:418
0xF27A  0x20 0xE9 0x8A  JSR 0x8AE9              // Error.Message();                  tokeniterator.asm:419
0xF27D  0xFA            PLX                     // PLX                               tokeniterator.asm:421
0xF27E  0x68            PLA                     // PLA                               tokeniterator.asm:422
0xF27F  0x60            RTS                     // }                                 tokeniterator.asm:423

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:432
// ####  TokenIterator.RenderTokenStream()  ####                                0x02B0

0xF280  0x48            PHA                     // PHA                               tokeniterator.asm:433
0xF281  0xDA            PHX                     // PHX                               tokeniterator.asm:434
0xF282  0x5A            PHY                     // PHY                               tokeniterator.asm:435
0xF283  0x20 0x17 0xF1  JSR 0xF117              // Start();    Input: ZP.IDY = token stream base pointer
0xF286  0xB0 0x04       BCS 0xF28C (+4)         // if (NC)                           tokeniterator.asm:439
0xF288  0x7A            PLY                     // PLY                               tokeniterator.asm:442
0xF289  0xFA            PLX                     // PLX                               tokeniterator.asm:443
0xF28A  0x68            PLA                     // PLA                               tokeniterator.asm:444
0xF28B  0x60            RTS                     // return;                           tokeniterator.asm:445
0xF28C  0xA9 0x01       LDA # 1                 // LDA #1                            tokeniterator.asm:449
0xF28E  0x85 0x52       STA 0x52                // STA ZP.TOKINDENT                  tokeniterator.asm:450
0xF290  0x64 0x56       STZ 0x56                // STZ ZP.TOKCOLON    not on a COLON line
0xF292  0x64 0x59       STZ 0x59                // STZ ZP.TOKERRORFLAG    error marker not yet printed
0xF294  0x64 0x5A       STZ 0x5A                // STZ ZP.TOKSINGLEIF                tokeniterator.asm:453
0xF296  0x20 0xAB 0xF2  JSR 0xF2AB              // renderStatementWithIndent();      tokeniterator.asm:459
0xF299  0x90 0x0C       BCC 0xF2A7 (+12)        // if (NC) { break; }    End of stream
0xF29B  0x20 0x3F 0xF2  JSR 0xF23F              // checkAndPrintErrorMarker();       tokeniterator.asm:463
0xF29E  0xA5 0x56       LDA 0x56                // LDA ZP.TOKCOLON                   tokeniterator.asm:466
0xF2A0  0xD0 0xF4       BNE 0xF296 (-12)        // if (Z)                            tokeniterator.asm:467
0xF2A2  0x20 0xB6 0x95  JSR 0x95B6              // Print.NewLine();                  tokeniterator.asm:469
0xF2A5  0x80 0xEF       BRA 0xF296 (-17)        // }                                 tokeniterator.asm:471
0xF2A7  0x7A            PLY                     // PLY                               tokeniterator.asm:473
0xF2A8  0xFA            PLX                     // PLX                               tokeniterator.asm:474
0xF2A9  0x68            PLA                     // PLA                               tokeniterator.asm:475
0xF2AA  0x60            RTS                     // }                                 tokeniterator.asm:476

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:483
// ####  TokenIterator.renderStatementWithIndent()  ####                        0x02B1

0xF2AB  0x48            PHA                     // PHA                               tokeniterator.asm:484
0xF2AC  0xDA            PHX                     // PHX                               tokeniterator.asm:485
0xF2AD  0x5A            PHY                     // PHY                               tokeniterator.asm:486
0xF2AE  0x85 0x55       STA 0x55                // STA ZP.TOKPREV    new statement - no preceding ' '
0xF2B0  0xA5 0x4F       LDA 0x4F                // GetCurrent();    A = current token value
0xF2B2  0x20 0x08 0xF2  JSR 0xF208              // isIndentDecreaseToken();          tokeniterator.asm:492
0xF2B5  0x90 0x06       BCC 0xF2BD (+6)         // if (C)                            tokeniterator.asm:493
0xF2B7  0xA5 0x52       LDA 0x52                // LDA ZP.TOKINDENT                  tokeniterator.asm:496
0xF2B9  0xF0 0x02       BEQ 0xF2BD (+2)         // if (NZ)    Prevent underflow      tokeniterator.asm:497
0xF2BB  0xC6 0x52       DEC 0x52                // DEC ZP.TOKINDENT                  tokeniterator.asm:499
0xF2BD  0x20 0x24 0xF2  JSR 0xF224              // printIndentation();               tokeniterator.asm:504
0xF2C0  0xA5 0x4F       LDA 0x4F                // GetCurrent();    A = current token value
0xF2C2  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    tokeniterator.asm:513
0xF2C4  0xD0 0x08       BNE 0xF2CE (+8)         // if (Z)                            tokeniterator.asm:514
0xF2C6  0x07 0x5A       RMB0 0x5A               // RMB0 ZP.TOKSINGLEIF    no longer in a single like IF (if you were in one)
0xF2C8  0x20 0x48 0xF1  JSR 0xF148              // Next();    Skip EOL and continue  tokeniterator.asm:518
0xF2CB  0x38            SEC                     // SEC    More statements may follow tokeniterator.asm:519
0xF2CC  0x80 0x40       BRA 0xF30E (+64)        // break;                            tokeniterator.asm:520
0xF2CE  0xC9 0xDE       CMP # 0xDE              // CMP #Token.COLON                  tokeniterator.asm:522
0xF2D0  0xD0 0x0D       BNE 0xF2DF (+13)        // if (Z)                            tokeniterator.asm:523
0xF2D2  0x20 0x8C 0xF3  JSR 0xF38C              // renderToken();    Render the colon first
0xF2D5  0x20 0x48 0xF1  JSR 0xF148              // Next();    Skip colon and continue
0xF2D8  0xA9 0x01       LDA # 1                 // LDA #1                            tokeniterator.asm:527
0xF2DA  0x85 0x56       STA 0x56                // STA ZP.TOKCOLON     Set flag for next statement
0xF2DC  0x38            SEC                     // SEC    More statements follow     tokeniterator.asm:529
0xF2DD  0x80 0x2F       BRA 0xF30E (+47)        // break;                            tokeniterator.asm:530
0xF2DF  0xC9 0x00       CMP # 0                 // CMP #0    Null terminator         tokeniterator.asm:532
0xF2E1  0xD0 0x03       BNE 0xF2E6 (+3)         // if (Z)                            tokeniterator.asm:533
0xF2E3  0x18            CLC                     // CLC    End of stream              tokeniterator.asm:535
0xF2E4  0x80 0x28       BRA 0xF30E (+40)        // break;                            tokeniterator.asm:536
0xF2E6  0xC9 0xDB       CMP # 0xDB              // CMP #Token.EOF                    tokeniterator.asm:538
0xF2E8  0xD0 0x03       BNE 0xF2ED (+3)         // if (Z)                            tokeniterator.asm:539
0xF2EA  0x18            CLC                     // CLC    End of stream              tokeniterator.asm:541
0xF2EB  0x80 0x21       BRA 0xF30E (+33)        // break;                            tokeniterator.asm:542
0xF2ED  0x48            PHA                     // PHA    Save token for rendering   tokeniterator.asm:546
0xF2EE  0x20 0xDF 0xF1  JSR 0xF1DF              // isIndentIncreaseToken();          tokeniterator.asm:547
0xF2F1  0x90 0x02       BCC 0xF2F5 (+2)         // if (C)                            tokeniterator.asm:548
0xF2F3  0xE6 0x52       INC 0x52                // INC ZP.TOKINDENT                  tokeniterator.asm:551
0xF2F5  0x68            PLA                     // PLA    Restore token for rendering
0xF2F6  0x20 0x8C 0xF3  JSR 0xF38C              // renderToken();    Input: A = token value
0xF2F9  0x0F 0x5A 0x0C  BBR0 0x5A, 0xF308 (+12) // if (BBS0, ZP.TOKSINGLEIF)    still within IF line?
0xF2FC  0xC9 0xA4       CMP # 0xA4              // CMP #Token.ENDIF                  tokeniterator.asm:560
0xF2FE  0xD0 0x08       BNE 0xF308 (+8)         // if (Z)                            tokeniterator.asm:561
0xF300  0xA5 0x52       LDA 0x52                // LDA ZP.TOKINDENT                  tokeniterator.asm:564
0xF302  0xF0 0x02       BEQ 0xF306 (+2)         // if (NZ)    Prevent underflow      tokeniterator.asm:565
0xF304  0xC6 0x52       DEC 0x52                // DEC ZP.TOKINDENT                  tokeniterator.asm:567
0xF306  0x07 0x5A       RMB0 0x5A               // RMB0 ZP.TOKSINGLEIF               tokeniterator.asm:569
0xF308  0x20 0x48 0xF1  JSR 0xF148              // Next();                           tokeniterator.asm:574
0xF30B  0xB0 0xB3       BCS 0xF2C0 (-77)        // if (NC)                           tokeniterator.asm:575
0xF30D  0x18            CLC                     // CLC    End of stream              tokeniterator.asm:577
0xF30E  0x7A            PLY                     // PLY                               tokeniterator.asm:582
0xF30F  0xFA            PLX                     // PLX                               tokeniterator.asm:583
0xF310  0x68            PLA                     // PLA                               tokeniterator.asm:584
0xF311  0x60            RTS                     // }                                 tokeniterator.asm:585

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:651
// ####  TokenIterator.renderOptionalSpace()  ####                              0x02B3

0xF312  0xA5 0x55       LDA 0x55                // LDA ZP.TOKPREV                    tokeniterator.asm:652
0xF314  0x20 0x6A 0x8A  JSR 0x8A6A              // IsKeyword();                      tokeniterator.asm:653
0xF317  0x90 0x47       BCC 0xF360 (+71)        // if (C)                            tokeniterator.asm:654
0xF319  0xC9 0xC0       CMP # 0xC0              // case Token.ABS:                   tokeniterator.asm:658
0xF31B  0xF0 0x32       BEQ 0xF34F (+50)
0xF31D  0xC9 0xCE       CMP # 0xCE              // case Token.RND:                   tokeniterator.asm:659
0xF31F  0xF0 0x2E       BEQ 0xF34F (+46)
0xF321  0xC9 0xC1       CMP # 0xC1              // case Token.MILLIS:                tokeniterator.asm:660
0xF323  0xF0 0x2A       BEQ 0xF34F (+42)
0xF325  0xC9 0xC2       CMP # 0xC2              // case Token.PEEK:                  tokeniterator.asm:661
0xF327  0xF0 0x26       BEQ 0xF34F (+38)
0xF329  0xC9 0xC3       CMP # 0xC3              // case Token.POKE:                  tokeniterator.asm:662
0xF32B  0xF0 0x32       BEQ 0xF35F (+50)
0xF32D  0xC9 0xC5       CMP # 0xC5              // case Token.SECONDS:               tokeniterator.asm:663
0xF32F  0xF0 0x2E       BEQ 0xF35F (+46)
0xF331  0xC9 0xC6       CMP # 0xC6              // case Token.DELAY:                 tokeniterator.asm:664
0xF333  0xF0 0x2A       BEQ 0xF35F (+42)
0xF335  0xC9 0xC8       CMP # 0xC8              // case Token.ASC:                   tokeniterator.asm:665
0xF337  0xF0 0x26       BEQ 0xF35F (+38)
0xF339  0xC9 0xC9       CMP # 0xC9              // case Token.CHR:                   tokeniterator.asm:666
0xF33B  0xF0 0x22       BEQ 0xF35F (+34)
0xF33D  0xC9 0xCA       CMP # 0xCA              // case Token.LEN:                   tokeniterator.asm:667
0xF33F  0xF0 0x1E       BEQ 0xF35F (+30)
0xF341  0xC9 0xCB       CMP # 0xCB              // case Token.PINMODE:               tokeniterator.asm:668
0xF343  0xF0 0x1A       BEQ 0xF35F (+26)
0xF345  0xC9 0xCC       CMP # 0xCC              // case Token.READ:                  tokeniterator.asm:669
0xF347  0xF0 0x16       BEQ 0xF35F (+22)
0xF349  0xC9 0xCD       CMP # 0xCD              // case Token.WRITE:                 tokeniterator.asm:670
0xF34B  0xF0 0x12       BEQ 0xF35F (+18)
0xF34D  0x80 0x01       BRA 0xF350 (+1)
0xF34F  0x60            RTS                     // }                                 tokeniterator.asm:673
0xF350  0xA5 0x4F       LDA 0x4F                // GetCurrent();    A = current token value
0xF352  0xC9 0xF1       CMP # 0xF1              // case Token.RBRACKET:              tokeniterator.asm:679
0xF354  0xF0 0x09       BEQ 0xF35F (+9)
0xF356  0xC9 0xE5       CMP # 0xE5              // case Token.RPAREN:                tokeniterator.asm:680
0xF358  0xF0 0x05       BEQ 0xF35F (+5)
0xF35A  0xA9 0x20       LDA # 0x20              // LDA # priorSpace Serial.WriteChar();
0xF35C  0x4C 0x2B 0x8D  JMP 0x8D2B
0xF35F  0x60            RTS                     // }                                 tokeniterator.asm:690
0xF360  0xC9 0x00       CMP # 0                 // case 0x00:    first on new line   tokeniterator.asm:696
0xF362  0xF0 0x27       BEQ 0xF38B (+39)
0xF364  0xC9 0xF0       CMP # 0xF0              // case Token.LBRACKET:              tokeniterator.asm:699
0xF366  0xF0 0x06       BEQ 0xF36E (+6)
0xF368  0xC9 0xE4       CMP # 0xE4              // case Token.LPAREN:                tokeniterator.asm:700
0xF36A  0xF0 0x1F       BEQ 0xF38B (+31)
0xF36C  0x80 0x01       BRA 0xF36F (+1)
0xF36E  0x60            RTS                     // }                                 tokeniterator.asm:702
0xF36F  0xC9 0xDA       CMP # 0xDA              // case Token.IDENTIFIER:            tokeniterator.asm:703
0xF371  0xD0 0x13       BNE 0xF386 (+19)
0xF373  0xA5 0x4F       LDA 0x4F                // GetCurrent();    A = current token value
0xF375  0xC9 0xF0       CMP # 0xF0              // case Token.LBRACKET:              tokeniterator.asm:708
0xF377  0xF0 0x06       BEQ 0xF37F (+6)
0xF379  0xC9 0xE4       CMP # 0xE4              // case Token.LPAREN:                tokeniterator.asm:709
0xF37B  0xF0 0x08       BEQ 0xF385 (+8)
0xF37D  0x80 0x01       BRA 0xF380 (+1)
0xF37F  0x60            RTS                     // }                                 tokeniterator.asm:711
0xF380  0xA9 0x20       LDA # 0x20              // LDA # priorSpace Serial.WriteChar();
0xF382  0x4C 0x2B 0x8D  JMP 0x8D2B
0xF385  0x60            RTS                     // }                                 tokeniterator.asm:717
0xF386  0xA9 0x20       LDA # 0x20              // LDA # priorSpace Serial.WriteChar();
0xF388  0x4C 0x2B 0x8D  JMP 0x8D2B
0xF38B  0x60            RTS                     // }                                 tokeniterator.asm:724

// /source/projects/6502sbc/hopperbasic/utilities/tokeniterator.asm:730
// ####  TokenIterator.renderToken()  ####                                      0x02B4

0xF38C  0x48            PHA                     // PHA                               tokeniterator.asm:731
0xF38D  0xDA            PHX                     // PHX                               tokeniterator.asm:732
0xF38E  0x5A            PHY                     // PHY                               tokeniterator.asm:733
0xF38F  0xC9 0xD7       CMP # 0xD7              // case Token.NUMBER:                tokeniterator.asm:737
0xF391  0xD0 0x0C       BNE 0xF39F (+12)
0xF393  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:739
0xF396  0x20 0xC9 0xF1  JSR 0xF1C9              // GetCurrentData();    ZP.TOKADDR* = pointer to number string
0xF399  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   tokeniterator.asm:741
0xF39C  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:742
0xF39F  0xC9 0xDA       CMP # 0xDA              // case Token.IDENTIFIER:            tokeniterator.asm:743
0xF3A1  0xD0 0x0C       BNE 0xF3AF (+12)
0xF3A3  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:745
0xF3A6  0x20 0xC9 0xF1  JSR 0xF1C9              // GetCurrentData();    ZP.TOKADDR* = pointer to identifier string
0xF3A9  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   tokeniterator.asm:747
0xF3AC  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:748
0xF3AF  0xC9 0xD8       CMP # 0xD8              // case Token.STRINGLIT:             tokeniterator.asm:749
0xF3B1  0xD0 0x14       BNE 0xF3C7 (+20)
0xF3B3  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:751
0xF3B6  0x20 0xC9 0xF1  JSR 0xF1C9              // GetCurrentData();    ZP.TOKADDR* = pointer to string content
0xF3B9  0x20 0x55 0xF6  JSR 0xF655              // MoveSTRtoTOP();                   tokeniterator.asm:753
0xF3BC  0xA9 0x05       LDA # 0x05              // LDA # BASICType.STRING            tokeniterator.asm:755
0xF3BE  0x85 0x15       STA 0x15                // STA ZP.TOPT                       tokeniterator.asm:756
0xF3C0  0x38            SEC                     // SEC                               tokeniterator.asm:757
0xF3C1  0x20 0x14 0x89  JSR 0x8914              // BASICTypes.PrintValue();          tokeniterator.asm:758
0xF3C4  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:759
0xF3C7  0xC9 0xD9       CMP # 0xD9              // case Token.CHARLIT:               tokeniterator.asm:760
0xF3C9  0xD0 0x15       BNE 0xF3E0 (+21)
0xF3CB  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:762
0xF3CE  0x20 0xC9 0xF1  JSR 0xF1C9              // GetCurrentData();    ZP.STR* = pointer to character value
0xF3D1  0xB2 0x79       LDA [0x79]              // LDA [ZP.STR]                      tokeniterator.asm:764
0xF3D3  0x85 0x11       STA 0x11                // STA ZP.TOP0                       tokeniterator.asm:765
0xF3D5  0xA9 0x01       LDA # 1                 // LDA # BASICType.CHAR              tokeniterator.asm:766
0xF3D7  0x85 0x15       STA 0x15                // STA ZP.TOPT                       tokeniterator.asm:767
0xF3D9  0x38            SEC                     // SEC                               tokeniterator.asm:768
0xF3DA  0x20 0x14 0x89  JSR 0x8914              // BASICTypes.PrintValue();          tokeniterator.asm:769
0xF3DD  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:770
0xF3E0  0xC9 0x94       CMP # 0x94              // case Token.REM:                   tokeniterator.asm:771
0xF3E2  0xD0 0x14       BNE 0xF3F8 (+20)
0xF3E4  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:773
0xF3E7  0xA9 0x94       LDA # 0x94              // LDA #Token.REM                    tokeniterator.asm:774
0xF3E9  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            tokeniterator.asm:775
0xF3EC  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    tokeniterator.asm:776
0xF3EF  0x20 0xC9 0xF1  JSR 0xF1C9              // GetCurrentData();    ZP.TOKADDR* = pointer to comment text
0xF3F2  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   tokeniterator.asm:778
0xF3F5  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:779
0xF3F8  0xC9 0x95       CMP # 0x95              // case Token.COMMENT:               tokeniterator.asm:780
0xF3FA  0xD0 0x11       BNE 0xF40D (+17)
0xF3FC  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:782
0xF3FF  0xA9 0x21       LDA # 0x21              // LDA #'!'                          tokeniterator.asm:783
0xF401  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:784
0xF404  0x20 0xC9 0xF1  JSR 0xF1C9              // GetCurrentData();    ZP.TOKADDR* = pointer to comment text
0xF407  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   tokeniterator.asm:786
0xF40A  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:787
0xF40D  0xC9 0xBC       CMP # 0xBC              // case Token.TRUE:                  tokeniterator.asm:788
0xF40F  0xD0 0x0B       BNE 0xF41C (+11)
0xF411  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:790
0xF414  0xA9 0xBC       LDA # 0xBC              // LDA #Token.TRUE                   tokeniterator.asm:791
0xF416  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            tokeniterator.asm:792
0xF419  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:793
0xF41C  0xC9 0xBD       CMP # 0xBD              // case Token.FALSE:                 tokeniterator.asm:794
0xF41E  0xD0 0x0B       BNE 0xF42B (+11)
0xF420  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:796
0xF423  0xA9 0xBD       LDA # 0xBD              // LDA #Token.FALSE                  tokeniterator.asm:797
0xF425  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            tokeniterator.asm:798
0xF428  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:799
0xF42B  0xC9 0xE1       CMP # 0xE1              // case Token.EQUALS:                tokeniterator.asm:800
0xF42D  0xD0 0x0B       BNE 0xF43A (+11)
0xF42F  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:802
0xF432  0xA9 0x3D       LDA # 0x3D              // LDA #'='                          tokeniterator.asm:803
0xF434  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:804
0xF437  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:805
0xF43A  0xC9 0xE2       CMP # 0xE2              // case Token.PLUS:                  tokeniterator.asm:806
0xF43C  0xD0 0x0B       BNE 0xF449 (+11)
0xF43E  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:808
0xF441  0xA9 0x2B       LDA # 0x2B              // LDA #'+'                          tokeniterator.asm:809
0xF443  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:810
0xF446  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:811
0xF449  0xC9 0xE3       CMP # 0xE3              // case Token.MINUS:                 tokeniterator.asm:812
0xF44B  0xD0 0x0B       BNE 0xF458 (+11)
0xF44D  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:814
0xF450  0xA9 0x2D       LDA # 0x2D              // LDA #'-'                          tokeniterator.asm:815
0xF452  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:816
0xF455  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:817
0xF458  0xC9 0xEB       CMP # 0xEB              // case Token.MULTIPLY:              tokeniterator.asm:818
0xF45A  0xD0 0x0B       BNE 0xF467 (+11)
0xF45C  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:820
0xF45F  0xA9 0x2A       LDA # 0x2A              // LDA #'*'                          tokeniterator.asm:821
0xF461  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:822
0xF464  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:823
0xF467  0xC9 0xEC       CMP # 0xEC              // case Token.DIVIDE:                tokeniterator.asm:824
0xF469  0xD0 0x0B       BNE 0xF476 (+11)
0xF46B  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:826
0xF46E  0xA9 0x2F       LDA # 0x2F              // LDA #'/'                          tokeniterator.asm:827
0xF470  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:828
0xF473  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:829
0xF476  0xC9 0xE4       CMP # 0xE4              // case Token.LPAREN:                tokeniterator.asm:830
0xF478  0xD0 0x0B       BNE 0xF485 (+11)
0xF47A  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:832
0xF47D  0xA9 0x28       LDA # 0x28              // LDA #'('                          tokeniterator.asm:833
0xF47F  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:834
0xF482  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:835
0xF485  0xC9 0xE5       CMP # 0xE5              // case Token.RPAREN:                tokeniterator.asm:836
0xF487  0xD0 0x08       BNE 0xF491 (+8)
0xF489  0xA9 0x29       LDA # 0x29              // LDA #')'                          tokeniterator.asm:838
0xF48B  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:839
0xF48E  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:840
0xF491  0xC9 0xF0       CMP # 0xF0              // case Token.LBRACKET:              tokeniterator.asm:841
0xF493  0xD0 0x08       BNE 0xF49D (+8)
0xF495  0xA9 0x5B       LDA # 0x5B              // LDA #'['                          tokeniterator.asm:843
0xF497  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:844
0xF49A  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:845
0xF49D  0xC9 0xF1       CMP # 0xF1              // case Token.RBRACKET:              tokeniterator.asm:846
0xF49F  0xD0 0x08       BNE 0xF4A9 (+8)
0xF4A1  0xA9 0x5D       LDA # 0x5D              // LDA #']'                          tokeniterator.asm:848
0xF4A3  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:849
0xF4A6  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:850
0xF4A9  0xC9 0xE7       CMP # 0xE7              // case Token.LT:                    tokeniterator.asm:851
0xF4AB  0xD0 0x0B       BNE 0xF4B8 (+11)
0xF4AD  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:853
0xF4B0  0xA9 0x3C       LDA # 0x3C              // LDA #'<'                          tokeniterator.asm:854
0xF4B2  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:855
0xF4B5  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:856
0xF4B8  0xC9 0xE8       CMP # 0xE8              // case Token.GT:                    tokeniterator.asm:857
0xF4BA  0xD0 0x0B       BNE 0xF4C7 (+11)
0xF4BC  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:859
0xF4BF  0xA9 0x3E       LDA # 0x3E              // LDA #'>'                          tokeniterator.asm:860
0xF4C1  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:861
0xF4C4  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:862
0xF4C7  0xC9 0xE9       CMP # 0xE9              // case Token.LE:                    tokeniterator.asm:863
0xF4C9  0xD0 0x10       BNE 0xF4DB (+16)
0xF4CB  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:865
0xF4CE  0xA9 0x3C       LDA # 0x3C              // LDA #'<'                          tokeniterator.asm:866
0xF4D0  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:867
0xF4D3  0xA9 0x3D       LDA # 0x3D              // LDA #'='                          tokeniterator.asm:868
0xF4D5  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:869
0xF4D8  0x4C 0x59 0xF5  JMP 0xF559              // }                                 tokeniterator.asm:870
0xF4DB  0xC9 0xEA       CMP # 0xEA              // case Token.GE:                    tokeniterator.asm:871
0xF4DD  0xD0 0x0F       BNE 0xF4EE (+15)
0xF4DF  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:873
0xF4E2  0xA9 0x3E       LDA # 0x3E              // LDA #'>'                          tokeniterator.asm:874
0xF4E4  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:875
0xF4E7  0xA9 0x3D       LDA # 0x3D              // LDA #'='                          tokeniterator.asm:876
0xF4E9  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:877
0xF4EC  0x80 0x6B       BRA 0xF559 (+107)       // }                                 tokeniterator.asm:878
0xF4EE  0xC9 0xE6       CMP # 0xE6              // case Token.NOTEQUAL:              tokeniterator.asm:879
0xF4F0  0xD0 0x0F       BNE 0xF501 (+15)
0xF4F2  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:881
0xF4F5  0xA9 0x3C       LDA # 0x3C              // LDA #'<'                          tokeniterator.asm:882
0xF4F7  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:883
0xF4FA  0xA9 0x3E       LDA # 0x3E              // LDA #'>'                          tokeniterator.asm:884
0xF4FC  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:885
0xF4FF  0x80 0x58       BRA 0xF559 (+88)        // }                                 tokeniterator.asm:886
0xF501  0xC9 0xED       CMP # 0xED              // case Token.BITWISE_AND:           tokeniterator.asm:887
0xF503  0xD0 0x0A       BNE 0xF50F (+10)
0xF505  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:889
0xF508  0xA9 0x26       LDA # 0x26              // LDA #'&'                          tokeniterator.asm:890
0xF50A  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:891
0xF50D  0x80 0x4A       BRA 0xF559 (+74)        // }                                 tokeniterator.asm:892
0xF50F  0xC9 0xEE       CMP # 0xEE              // case Token.BITWISE_OR:            tokeniterator.asm:893
0xF511  0xD0 0x0A       BNE 0xF51D (+10)
0xF513  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:895
0xF516  0xA9 0x7C       LDA # 0x7C              // LDA #'|'                          tokeniterator.asm:896
0xF518  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:897
0xF51B  0x80 0x3C       BRA 0xF559 (+60)        // }                                 tokeniterator.asm:898
0xF51D  0xC9 0xDF       CMP # 0xDF              // case Token.COMMA:                 tokeniterator.asm:899
0xF51F  0xD0 0x07       BNE 0xF528 (+7)
0xF521  0xA9 0x2C       LDA # 0x2C              // LDA #','                          tokeniterator.asm:901
0xF523  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:902
0xF526  0x80 0x31       BRA 0xF559 (+49)        // }                                 tokeniterator.asm:903
0xF528  0xC9 0xE0       CMP # 0xE0              // case Token.SEMICOLON:             tokeniterator.asm:904
0xF52A  0xD0 0x07       BNE 0xF533 (+7)
0xF52C  0xA9 0x3B       LDA # 0x3B              // LDA #';'                          tokeniterator.asm:906
0xF52E  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:907
0xF531  0x80 0x26       BRA 0xF559 (+38)        // }                                 tokeniterator.asm:908
0xF533  0xC9 0xDE       CMP # 0xDE              // case Token.COLON:                 tokeniterator.asm:909
0xF535  0xD0 0x0A       BNE 0xF541 (+10)
0xF537  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:911
0xF53A  0xA9 0x3A       LDA # 0x3A              // LDA #':'                          tokeniterator.asm:912
0xF53C  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:913
0xF53F  0x80 0x18       BRA 0xF559 (+24)        // }                                 tokeniterator.asm:914
0xF541  0x48            PHA                     // PHA    Save token value           tokeniterator.asm:918
0xF542  0x20 0x6A 0x8A  JSR 0x8A6A              // Tokens.IsKeyword();               tokeniterator.asm:919
0xF545  0x90 0x09       BCC 0xF550 (+9)         // if (C)                            tokeniterator.asm:920
0xF547  0x20 0x12 0xF3  JSR 0xF312              // renderOptionalSpace();            tokeniterator.asm:922
0xF54A  0x68            PLA                     // PLA                               tokeniterator.asm:924
0xF54B  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            tokeniterator.asm:925
0xF54E  0x80 0x09       BRA 0xF559 (+9)         // }                                 tokeniterator.asm:926
0xF550  0xA9 0x3F       LDA # 0x3F              // LDA #'?'                          tokeniterator.asm:930
0xF552  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               tokeniterator.asm:931
0xF555  0x68            PLA                     // PLA    Get token value for hex output
0xF556  0x20 0xB5 0x8D  JSR 0x8DB5              // Serial.HexOut();                  tokeniterator.asm:933
0xF559  0x7A            PLY                     // PLY                               tokeniterator.asm:938
0xF55A  0xFA            PLX                     // PLX                               tokeniterator.asm:939
0xF55B  0x68            PLA                     // PLA                               tokeniterator.asm:940
0xF55C  0x60            RTS                     // }                                 tokeniterator.asm:941

// /source/projects/6502sbc/hopperbasic/commands.asm:19
// ####  Commands.CmdNew()  ####                                                0x02B6

0xF55D  0x20 0x78 0xA3  JSR 0xA378              // Variables.Clear();                commands.asm:20
0xF560  0x4C 0x4A 0xA8  JMP 0xA84A              // Functions.Clear();                commands.asm:21

// /source/projects/6502sbc/hopperbasic/commands.asm:28
// ####  Commands.CmdClear()  ####                                              0x02B7

0xF563  0x20 0x78 0xA3  JSR 0xA378              // Variables.Clear();                commands.asm:29
0xF566  0x4C 0xA7 0xA8  JMP 0xA8A7              // Functions.FreeAllOpCodes();    compiled FUNCs potentially stale now

// /source/projects/6502sbc/hopperbasic/commands.asm:45
// ####  Commands.CmdMem()  ####                                                0x02B9

0xF569  0xA9 0x41       LDA # 0x41              // LDA # ErrorID.MemoryMessage LDX # (MessageExtras.SuffixColon|MessageExtras.SuffixSpace) Error.Message();
0xF56B  0xA2 0x06       LDX # 0x06
0xF56D  0x20 0xE9 0x8A  JSR 0x8AE9
0xF570  0x20 0xD7 0x92  JSR 0x92D7              // Memory.AvailableACC();    Returns available bytes in ZP.ACC
0xF573  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       commands.asm:51
0xF575  0x85 0x11       STA 0x11                // STA ZP.TOPL                       commands.asm:52
0xF577  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       commands.asm:53
0xF579  0x85 0x12       STA 0x12                // STA ZP.TOPH                       commands.asm:54
0xF57B  0x64 0x15       STZ 0x15                // STZ ZP.TOPT                       commands.asm:55
0xF57D  0x20 0xCF 0x95  JSR 0x95CF              // Print.Decimal();                  commands.asm:56
0xF580  0xA9 0x42       LDA # 0x42              // LDA # ErrorID.BytesMessage LDX # MessageExtras.PrefixSpace Error.MessageNL();
0xF582  0xA2 0x01       LDX # 1
0xF584  0x20 0xE3 0x8A  JSR 0x8AE3
0xF587  0x20 0x4E 0xAE  JSR 0xAE4E              // EEPROM.Detect();                  commands.asm:62
0xF58A  0x90 0x2D       BCC 0xF5B9 (+45)        // if (C)     Set C (detected)       commands.asm:63
0xF58C  0xA9 0x43       LDA # 0x43              // LDA # ErrorID.EEPROMLabel LDX # (MessageExtras.SuffixColon|MessageExtras.SuffixSpace) Error.Message();
0xF58E  0xA2 0x06       LDX # 0x06
0xF590  0x20 0xE9 0x8A  JSR 0x8AE9
0xF593  0x20 0x55 0xAE  JSR 0xAE55              // EEPROM.GetSize();    A -> number of K
0xF596  0x85 0x11       STA 0x11                // STA ZP.TOPL                       commands.asm:68
0xF598  0x64 0x12       STZ 0x12                // STZ ZP.TOPH                       commands.asm:69
0xF59A  0x64 0x15       STZ 0x15                // STZ ZP.TOPT                       commands.asm:70
0xF59C  0x20 0xCF 0x95  JSR 0x95CF              // Print.Decimal();                  commands.asm:71
0xF59F  0xA9 0x4B       LDA # 0x4B              // LDA #'K' Print.Char();            commands.asm:72
0xF5A1  0x20 0xB0 0x95  JSR 0x95B0
0xF5A4  0xA9 0x2C       LDA # 0x2C              // LDA #',' Print.Char();            commands.asm:73
0xF5A6  0x20 0xB0 0x95  JSR 0x95B0
0xF5A9  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:74
0xF5AC  0x20 0xD8 0xAE  JSR 0xAED8              // File.GetAvailable();    TOP -> number of B
0xF5AF  0x20 0xCF 0x95  JSR 0x95CF              // Print.Decimal();                  commands.asm:76
0xF5B2  0xA9 0x42       LDA # 0x42              // LDA # ErrorID.BytesMessage LDX # MessageExtras.PrefixSpace Error.MessageNL();
0xF5B4  0xA2 0x01       LDX # 1
0xF5B6  0x20 0xE3 0x8A  JSR 0x8AE3
0xF5B9  0x38            SEC                     // SEC                               commands.asm:80
0xF5BA  0x60            RTS                     // }                                 commands.asm:81

// /source/projects/6502sbc/hopperbasic/commands.asm:91
// ####  Commands.CmdForget()  ####                                             0x02BA

0xF5BB  0x20 0x55 0xF6  JSR 0xF655              // MoveSTRtoTOP();                   commands.asm:93
0xF5BE  0x20 0xF2 0xA2  JSR 0xA2F2              // Variables.Remove();    Input: ZP.TOP = name pointer
0xF5C1  0x90 0x03       BCC 0xF5C6 (+3)         // if (C)                            commands.asm:96
0xF5C3  0x4C 0xA7 0xA8  JMP 0xA8A7              // Functions.FreeAllOpCodes();    compiled FUNCs potentially stale now
0xF5C6  0x20 0xFE 0xA7  JSR 0xA7FE              // Functions.Remove();    Input: ZP.TOP = name pointer
0xF5C9  0x90 0x01       BCC 0xF5CC (+1)         // if (NC)                           commands.asm:105
0xF5CB  0x60            RTS
0xF5CC  0x4C 0x8F 0x8B  JMP 0x8B8F              // Error.UndefinedIdentifierTOP(); BIT ZP.EmulatorPCL

// /source/projects/6502sbc/hopperbasic/commands.asm:117
// ####  Commands.CmdVars()  ####                                               0x02BB

0xF5CF  0x20 0x50 0xA3  JSR 0xA350              // Variables.IterateVariables();    Output: ZP.IDX = first variable, C set if found
0xF5D2  0xB0 0x05       BCS 0xF5D9 (+5)         // if (NC)                           commands.asm:126
0xF5D4  0x20 0x5E 0xA3  JSR 0xA35E              // Variables.IterateConstants();    Output: ZP.IDX = first constant, C set if found
0xF5D7  0x90 0x1A       BCC 0xF5F3 (+26)        // if (NC)                           commands.asm:129
0xF5D9  0x20 0x5E 0xA3  JSR 0xA35E              // Variables.IterateConstants();     commands.asm:136
0xF5DC  0x90 0x08       BCC 0xF5E6 (+8)         // if (NC) { break; }     No more constants
0xF5DE  0x20 0x5F 0xF7  JSR 0xF75F              // displayConstant();    Input: ZP.IDX = constant node
0xF5E1  0x20 0x08 0xA0  JSR 0xA008              // Variables.IterateNext();    Input: ZP.IDX = current, Output: ZP.IDX = next
0xF5E4  0x80 0xF6       BRA 0xF5DC (-10)        // }                                 commands.asm:142
0xF5E6  0x20 0x50 0xA3  JSR 0xA350              // Variables.IterateVariables();     commands.asm:145
0xF5E9  0x90 0x08       BCC 0xF5F3 (+8)         // if (NC) { break; }     No more variables
0xF5EB  0x20 0x14 0xF7  JSR 0xF714              // displayVariable();    Input: ZP.IDX = variable node
0xF5EE  0x20 0x08 0xA0  JSR 0xA008              // Variables.IterateNext();    Input: ZP.IDX = current, Output: ZP.IDX = next
0xF5F1  0x80 0xF6       BRA 0xF5E9 (-10)        // }                                 commands.asm:152
0xF5F3  0x60            RTS                     // }                                 commands.asm:158

// /source/projects/6502sbc/hopperbasic/commands.asm:164
// ####  Commands.CmdList()  ####                                               0x02BC

0xF5F4  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      commands.asm:167
0xF5F7  0x90 0x06       BCC 0xF5FF (+6)         // if (C)                            commands.asm:168
0xF5F9  0x20 0xE8 0x8B  JSR 0x8BE8              // Error.OnlyAtConsole(); BIT ZP.EmulatorPCL
0xF5FC  0x64 0x4E       STZ 0x4E                // States.SetFailure();              commands.asm:171
0xF5FE  0x60            RTS                     // break;                            commands.asm:172
0xF5FF  0xA5 0x79       LDA 0x79                // LDA ZP.STRL                       commands.asm:176
0xF601  0x05 0x7A       ORA 0x7A                // ORA ZP.STRH                       commands.asm:177
0xF603  0xF0 0x14       BEQ 0xF619 (+20)        // if (NZ)                           commands.asm:178
0xF605  0x20 0x55 0xF6  JSR 0xF655              // MoveSTRtoTOP();                   commands.asm:182
0xF608  0x20 0x99 0xA7  JSR 0xA799              // Functions.Find();    Input: ZP.TOP = name, Output: ZP.IDX = node
0xF60B  0xB0 0x06       BCS 0xF613 (+6)         // if (NC)                           commands.asm:185
0xF60D  0x20 0x8F 0x8B  JSR 0x8B8F              // Error.UndefinedIdentifierTOP(); BIT ZP.EmulatorPCL
0xF610  0x64 0x4E       STZ 0x4E                // States.SetFailure();              commands.asm:188
0xF612  0x60            RTS                     // break;                            commands.asm:189
0xF613  0x20 0x30 0xF8  JSR 0xF830              // displayFunctionWithBody();    Input: ZP.IDX = function node
0xF616  0x4C 0xBB 0x89  JMP 0x89BB              // States.SetSuccess();              commands.asm:193
0xF619  0x8A            TXA                     // TXA                               commands.asm:196
0xF61A  0xD0 0x03       BNE 0xF61F (+3)         // if (Z)    X=0 -> LIST             commands.asm:197
0xF61C  0x20 0xCF 0xF5  JSR 0xF5CF              // CmdVars();    constants and variables
0xF61F  0x20 0xC8 0xF7  JSR 0xF7C8              // displayAllFunctionsWithBodies();  commands.asm:203
0xF622  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        commands.asm:204
0xF625  0x90 0x0C       BCC 0xF633 (+12)        // if (NC) { break; }                commands.asm:205
0xF627  0x20 0x16 0x86  JSR 0x8616              // Messages.Main();    point ZP.TOP -> "$MAIN"
0xF62A  0x20 0x99 0xA7  JSR 0xA799              // Functions.Find();    Input: ZP.TOP = "$MAIN" name, Output: ZP.IDX = node
0xF62D  0xB0 0x01       BCS 0xF630 (+1)         // if (C)                            commands.asm:211
0xF62F  0x60            RTS
0xF630  0x4C 0x30 0xF8  JMP 0xF830              // displayFunctionWithBody();    Input: ZP.IDX = function node
0xF633  0x60            RTS                     // }                                 commands.asm:218

// /source/projects/6502sbc/hopperbasic/commands.asm:224
// ####  Commands.CmdFuncs()  ####                                              0x02BD

0xF634  0xA5 0x79       LDA 0x79                // LDA ZP.STRL                       commands.asm:226
0xF636  0x05 0x7A       ORA 0x7A                // ORA ZP.STRH                       commands.asm:227
0xF638  0xD0 0x03       BNE 0xF63D (+3)         // if (Z)                            commands.asm:228
0xF63A  0x4C 0x96 0xF7  JMP 0xF796              // displayAllFunctions();            commands.asm:231
0xF63D  0x4C 0xAF 0xF7  JMP 0xF7AF              // displaySpecificFunction();        commands.asm:236

// /source/projects/6502sbc/hopperbasic/commands.asm:245
// ####  Commands.NotAvailable()  ####                                          0x02BE

0xF640  0xA9 0x10       LDA # 0x10              // Error.NotInReleaseBuild(); BIT ZP.EmulatorPCL
0xF642  0x20 0x5F 0x8B  JSR 0x8B5F
0xF645  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     commands.asm:253
0xF648  0x97 0x02       SMB1 0x02               // SMB1 ZP.FLAGS                     commands.asm:254
0xF64A  0x60            RTS                     // }                                 commands.asm:255

// /source/projects/6502sbc/hopperbasic/commands.asm:323
// ####  Commands.IsVisibleFunctionSTR()  ####                                  0x02C4

0xF64B  0xB2 0x79       LDA [0x79]              // LDA [ZP.STR]     Get first character
0xF64D  0xC9 0x24       CMP # 0x24              // CMP #'$'                          commands.asm:325
0xF64F  0xD0 0x02       BNE 0xF653 (+2)         // if (Z) { CLC } else { SEC }       commands.asm:326
0xF651  0x18            CLC
0xF652  0x60            RTS
0xF653  0x38            SEC
0xF654  0x60            RTS                     // }                                 commands.asm:327

// /source/projects/6502sbc/hopperbasic/commands.asm:330
// ####  Commands.MoveSTRtoTOP()  ####                                          0x02C5

0xF655  0xA5 0x79       LDA 0x79                // LDA ZP.STRL                       commands.asm:331
0xF657  0x85 0x11       STA 0x11                // STA ZP.TOPL                       commands.asm:332
0xF659  0xA5 0x7A       LDA 0x7A                // LDA ZP.STRH                       commands.asm:333
0xF65B  0x85 0x12       STA 0x12                // STA ZP.TOPH                       commands.asm:334
0xF65D  0x60            RTS                     // }                                 commands.asm:335

// /source/projects/6502sbc/hopperbasic/commands.asm:337
// ####  Commands.MoveTOPtoSTR()  ####                                          0x02C6

0xF65E  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       commands.asm:338
0xF660  0x85 0x79       STA 0x79                // STA ZP.STRL                       commands.asm:339
0xF662  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       commands.asm:340
0xF664  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       commands.asm:341
0xF666  0x60            RTS                     // }                                 commands.asm:342

// /source/projects/6502sbc/hopperbasic/commands.asm:348
// ####  Commands.displayArrayVariable()  ####                                  0x02C7

0xF667  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       commands.asm:354
0xF669  0x48            PHA                     // PHA                               commands.asm:355
0xF66A  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       commands.asm:356
0xF66C  0x48            PHA                     // PHA                               commands.asm:357
0xF66D  0x20 0xEA 0xA1  JSR 0xA1EA              // Variables.GetValue();    ZP.TOP = array pointer, ZP.ACCT = type
0xF670  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       commands.asm:361
0xF672  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK          commands.asm:362
0xF674  0x20 0x4A 0x87  JSR 0x874A              // BASICTypes.PrintType();           commands.asm:363
0xF677  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:365
0xF67A  0x20 0xC9 0xA2  JSR 0xA2C9              // Variables.GetName();    Input: ZP.IDX, Output: ZP.STR = name pointer
0xF67D  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   commands.asm:369
0xF680  0xA5 0x11       LDA 0x11                // LDA ZP.TOPL                       commands.asm:373
0xF682  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       commands.asm:374
0xF684  0xA5 0x12       LDA 0x12                // LDA ZP.TOPH                       commands.asm:375
0xF686  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       commands.asm:376
0xF688  0xA9 0x5B       LDA # 0x5B              // LDA #'[' Serial.WriteChar();      commands.asm:379
0xF68A  0x20 0x2B 0x8D  JSR 0x8D2B
0xF68D  0x20 0x55 0xAB  JSR 0xAB55              // BASICArray.GetCount();    Returns count in ZP.ACC
0xF690  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL                       commands.asm:386
0xF692  0x85 0x11       STA 0x11                // STA ZP.TOPL                       commands.asm:387
0xF694  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       commands.asm:388
0xF696  0x85 0x12       STA 0x12                // STA ZP.TOPH                       commands.asm:389
0xF698  0x64 0x15       STZ 0x15                // STZ ZP.TOPT                       commands.asm:390
0xF69A  0x20 0xCF 0x95  JSR 0x95CF              // Print.Decimal();                  commands.asm:391
0xF69D  0xA9 0x5D       LDA # 0x5D              // LDA #']' Serial.WriteChar();      commands.asm:393
0xF69F  0x20 0x2B 0x8D  JSR 0x8D2B
0xF6A2  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:394
0xF6A5  0xA9 0x3D       LDA # 0x3D              // LDA #'=' Serial.WriteChar();      commands.asm:395
0xF6A7  0x20 0x2B 0x8D  JSR 0x8D2B
0xF6AA  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:396
0xF6AD  0xA9 0x3C       LDA # 0x3C              // LDA #'<' Serial.WriteChar();      commands.asm:399
0xF6AF  0x20 0x2B 0x8D  JSR 0x8D2B
0xF6B2  0x20 0x63 0xAB  JSR 0xAB63              // BASICArray.GetItemType();    Returns ZP.ACCT, preserves ZP.ACCL and ZP.ACCH
0xF6B5  0xA2 0x00       LDX # 0                 // LDX #0     Element counter        commands.asm:405
0xF6B7  0xE0 0x0A       CPX # 0x0A              // CPX # 10                          commands.asm:409
0xF6B9  0xD0 0x28       BNE 0xF6E3 (+40)        // if (Z)                            commands.asm:410
0xF6BB  0xA9 0x00       LDA # 0                 // LDA #0              10 high byte  commands.asm:414
0xF6BD  0xA0 0x01       LDY # 1                 // LDY # BASICArray.aiCount+1        commands.asm:415
0xF6BF  0xD1 0x1B       CMP [0x1B],Y            // CMP [ZP.IDX], Y     Compare with count high byte
0xF6C1  0xD0 0x05       BNE 0xF6C8 (+5)         // if (Z)                            commands.asm:417
0xF6C3  0xA9 0x0A       LDA # 0x0A              // LDA #10         10 low byte       commands.asm:419
0xF6C5  0x88            DEY                     // DEY                               commands.asm:420
0xF6C6  0xD1 0x1B       CMP [0x1B],Y            // CMP [ZP.IDX], Y     Compare with count low byte
0xF6C8  0xB0 0x3B       BCS 0xF705 (+59)        // if (NC)     10 < count means more than 10 elements
0xF6CA  0xA9 0x2C       LDA # 0x2C              // LDA #',' Serial.WriteChar();      commands.asm:426
0xF6CC  0x20 0x2B 0x8D  JSR 0x8D2B
0xF6CF  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:427
0xF6D2  0xA9 0x2E       LDA # 0x2E              // LDA #'.' Serial.WriteChar();      commands.asm:428
0xF6D4  0x20 0x2B 0x8D  JSR 0x8D2B
0xF6D7  0xA9 0x2E       LDA # 0x2E              // LDA #'.' Serial.WriteChar();      commands.asm:429
0xF6D9  0x20 0x2B 0x8D  JSR 0x8D2B
0xF6DC  0xA9 0x2E       LDA # 0x2E              // LDA #'.' Serial.WriteChar();      commands.asm:430
0xF6DE  0x20 0x2B 0x8D  JSR 0x8D2B
0xF6E1  0x80 0x22       BRA 0xF705 (+34)        // break;                            commands.asm:432
0xF6E3  0xE4 0x0E       CPX 0x0E                // CPX ZP.ACCL                       commands.asm:436
0xF6E5  0xD0 0x04       BNE 0xF6EB (+4)         // if (Z)                            commands.asm:437
0xF6E7  0xA5 0x0F       LDA 0x0F                // LDA ZP.ACCH                       commands.asm:439
0xF6E9  0xF0 0x1A       BEQ 0xF705 (+26)        // if (Z) { break; }     No more elements
0xF6EB  0xE0 0x00       CPX # 0                 // CPX #0                            commands.asm:444
0xF6ED  0xF0 0x08       BEQ 0xF6F7 (+8)         // if (NZ)                           commands.asm:445
0xF6EF  0xA9 0x2C       LDA # 0x2C              // LDA #',' Serial.WriteChar();      commands.asm:447
0xF6F1  0x20 0x2B 0x8D  JSR 0x8D2B
0xF6F4  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:448
0xF6F7  0x86 0x1D       STX 0x1D                // STX ZP.IDYL                       commands.asm:452
0xF6F9  0x64 0x1E       STZ 0x1E                // STZ ZP.IDYH                       commands.asm:453
0xF6FB  0x20 0x9F 0xAB  JSR 0xAB9F              // BASICArray.GetItem();    Returns value and type in ZP.TOP
0xF6FE  0x38            SEC                     // SEC     quotes for strings and chars
0xF6FF  0x20 0x14 0x89  JSR 0x8914              // BASICTypes.PrintValue();    preserves X
0xF702  0xE8            INX                     // INX                               commands.asm:460
0xF703  0x80 0xB2       BRA 0xF6B7 (-78)        // }    single exit                  commands.asm:461
0xF705  0xA9 0x3E       LDA # 0x3E              // LDA #'>' Serial.WriteChar();      commands.asm:463
0xF707  0x20 0x2B 0x8D  JSR 0x8D2B
0xF70A  0x20 0xB6 0x95  JSR 0x95B6              // Print.NewLine();                  commands.asm:465
0xF70D  0x68            PLA                     // PLA                               commands.asm:468
0xF70E  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       commands.asm:469
0xF710  0x68            PLA                     // PLA                               commands.asm:470
0xF711  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       commands.asm:471
0xF713  0x60            RTS                     // }                                 commands.asm:476

// /source/projects/6502sbc/hopperbasic/commands.asm:482
// ####  Commands.displayVariable()  ####                                       0x02C8

0xF714  0x20 0xA9 0xA2  JSR 0xA2A9              // Variables.GetType();    Input: ZP.IDX, Output: ZP.ACCT = type
0xF717  0x5F 0x10 0x05  BBR5 0x10, 0xF71F (+5)  // if (BBS5, ZP.ACCT)    Bit 5 - ARRAY
0xF71A  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT     Get full type for helper
0xF71C  0x4C 0x67 0xF6  JMP 0xF667              // displayArrayVariable();     A = full type, ZP.IDX = node
0xF71F  0x4F 0x10 0x18  BBR4 0x10, 0xF73A (+24) // if (BBS4, ZP.ACCT)    Bit 4 - VAR commands.asm:499
0xF722  0xA9 0x9D       LDA # 0x9D              // LDA # Token.VAR                   commands.asm:502
0xF724  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            commands.asm:503
0xF727  0xA9 0x28       LDA # 0x28              // LDA # '(' Serial.WriteChar();     commands.asm:506
0xF729  0x20 0x2B 0x8D  JSR 0x8D2B
0xF72C  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       commands.asm:508
0xF72E  0x29 0x0F       AND # 0x0F              // AND # BASICType.TYPEMASK     Get underlying type without VAR bit
0xF730  0x20 0x4A 0x87  JSR 0x874A              // BASICTypes.PrintType();           commands.asm:510
0xF733  0xA9 0x29       LDA # 0x29              // LDA # ')' Serial.WriteChar();     commands.asm:511
0xF735  0x20 0x2B 0x8D  JSR 0x8D2B
0xF738  0x80 0x07       BRA 0xF741 (+7)         // }                                 commands.asm:512
0xF73A  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       commands.asm:515
0xF73C  0x29 0x3F       AND # 0x3F              // AND # BASICType.MASK              commands.asm:516
0xF73E  0x20 0x4A 0x87  JSR 0x874A              // BASICTypes.PrintType();           commands.asm:517
0xF741  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:520
0xF744  0x20 0xC9 0xA2  JSR 0xA2C9              // Variables.GetName();    Input: ZP.IDX, Output: ZP.STR = name pointer
0xF747  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   commands.asm:524
0xF74A  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:526
0xF74D  0xA9 0x3D       LDA # 0x3D              // LDA #'=' Serial.WriteChar();      commands.asm:527
0xF74F  0x20 0x2B 0x8D  JSR 0x8D2B
0xF752  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:528
0xF755  0x20 0xEA 0xA1  JSR 0xA1EA              // Variables.GetValue();    ZP.TOP = value, ZP.TOPT = dataType
0xF758  0x38            SEC                     // SEC                               commands.asm:534
0xF759  0x20 0x14 0x89  JSR 0x8914              // BASICTypes.PrintValue();          commands.asm:535
0xF75C  0x4C 0xB6 0x95  JMP 0x95B6              // Print.NewLine();                  commands.asm:537

// /source/projects/6502sbc/hopperbasic/commands.asm:548
// ####  Commands.displayConstant()  ####                                       0x02C9

0xF75F  0xA9 0x9E       LDA # 0x9E              // LDA #Token.CONST                  commands.asm:554
0xF761  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            commands.asm:555
0xF764  0xA9 0x28       LDA # 0x28              // LDA #'(' Print.Char();            commands.asm:556
0xF766  0x20 0xB0 0x95  JSR 0x95B0
0xF769  0x20 0xA9 0xA2  JSR 0xA2A9              // Variables.GetType();    Input: ZP.IDX, Output: ACCT = type
0xF76C  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       commands.asm:561
0xF76E  0x29 0x3F       AND # 0x3F              // AND # BASICType.MASK              commands.asm:562
0xF770  0x20 0x4A 0x87  JSR 0x874A              // BASICTypes.PrintType();    Input: A = dataType
0xF773  0xA9 0x29       LDA # 0x29              // LDA #')' Print.Char();            commands.asm:564
0xF775  0x20 0xB0 0x95  JSR 0x95B0
0xF778  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:565
0xF77B  0x20 0xC9 0xA2  JSR 0xA2C9              // Variables.GetName();    Input: ZP.IDX, Output: ZP.STR = name pointer
0xF77E  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   commands.asm:569
0xF781  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:571
0xF784  0xA9 0x3D       LDA # 0x3D              // LDA #'=' Serial.WriteChar();      commands.asm:572
0xF786  0x20 0x2B 0x8D  JSR 0x8D2B
0xF789  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:573
0xF78C  0x20 0xEA 0xA1  JSR 0xA1EA              // Variables.GetValue();    ZP.TOP = value, ZP.TOPT = dataType
0xF78F  0x38            SEC                     // SEC                               commands.asm:579
0xF790  0x20 0x14 0x89  JSR 0x8914              // BASICTypes.PrintValue();          commands.asm:580
0xF793  0x4C 0xB6 0x95  JMP 0x95B6              // Print.NewLine();                  commands.asm:581

// /source/projects/6502sbc/hopperbasic/commands.asm:591
// ####  Commands.displayAllFunctions()  ####                                   0x02CA

0xF796  0x20 0x3C 0xA8  JSR 0xA83C              // Functions.IterateFunctions();    Output: ZP.IDX = first function, C set if found
0xF799  0xB0 0x01       BCS 0xF79C (+1)         // if (C)                            commands.asm:598
0xF79B  0x60            RTS
0xF79C  0x90 0x10       BCC 0xF7AE (+16)        // if (NC) { break; }     No more functions
0xF79E  0x20 0xCB 0xA7  JSR 0xA7CB              // Functions.GetName();    -> ZP.STR = name pointer
0xF7A1  0x20 0x4B 0xF6  JSR 0xF64B              // IsVisibleFunctionSTR();    munts A
0xF7A4  0x90 0x03       BCC 0xF7A9 (+3)         // if (C)                            commands.asm:607
0xF7A6  0x20 0xDE 0xF7  JSR 0xF7DE              // DisplayFunctionSignature();    Input: ZP.IDX = function node
0xF7A9  0x20 0x08 0xA0  JSR 0xA008              // Functions.IterateNext();    Input: ZP.IDX = current, Output: ZP.IDX = next
0xF7AC  0x80 0xEE       BRA 0xF79C (-18)        // }                                 commands.asm:612
0xF7AE  0x60            RTS                     // }                                 commands.asm:618

// /source/projects/6502sbc/hopperbasic/commands.asm:623
// ####  Commands.displaySpecificFunction()  ####                               0x02CB

0xF7AF  0x20 0x55 0xF6  JSR 0xF655              // MoveSTRtoTOP();                   commands.asm:629
0xF7B2  0x20 0x99 0xA7  JSR 0xA799              // Functions.Find();    Input: ZP.TOP = name, Output: ZP.IDX = node
0xF7B5  0xB0 0x03       BCS 0xF7BA (+3)         // if (NC)                           commands.asm:632
0xF7B7  0x4C 0x8F 0x8B  JMP 0x8B8F              // Error.UndefinedIdentifierTOP(); BIT ZP.EmulatorPCL
0xF7BA  0x20 0xCB 0xA7  JSR 0xA7CB              // Functions.GetName();              commands.asm:639
0xF7BD  0x20 0x4B 0xF6  JSR 0xF64B              // IsVisibleFunctionSTR();           commands.asm:640
0xF7C0  0xB0 0x03       BCS 0xF7C5 (+3)         // if (NC)                           commands.asm:641
0xF7C2  0x4C 0x94 0x8B  JMP 0x8B94              // Error.UndefinedFunctionSTR(); BIT ZP.EmulatorPCL
0xF7C5  0x4C 0xDE 0xF7  JMP 0xF7DE              // DisplayFunctionSignature();    Input: ZP.IDX = function node

// /source/projects/6502sbc/hopperbasic/commands.asm:659
// ####  Commands.displayAllFunctionsWithBodies()  ####                         0x02CC

0xF7C8  0x20 0x3C 0xA8  JSR 0xA83C              // Functions.IterateFunctions();    Output: ZP.IDX = first function, C set if found
0xF7CB  0x90 0x10       BCC 0xF7DD (+16)        // if (NC) { break; }     No more functions
0xF7CD  0x20 0xCB 0xA7  JSR 0xA7CB              // Functions.GetName();    -> ZP.STR = name pointer
0xF7D0  0x20 0x4B 0xF6  JSR 0xF64B              // IsVisibleFunctionSTR();           commands.asm:671
0xF7D3  0x90 0x03       BCC 0xF7D8 (+3)         // if (C)                            commands.asm:672
0xF7D5  0x20 0x30 0xF8  JSR 0xF830              // displayFunctionWithBody();    Input: ZP.IDX = function node
0xF7D8  0x20 0x08 0xA0  JSR 0xA008              // Functions.IterateNext();    Input: ZP.IDX = current, Output: ZP.IDX = next
0xF7DB  0x80 0xEE       BRA 0xF7CB (-18)        // }                                 commands.asm:677
0xF7DD  0x60            RTS                     // }                                 commands.asm:682

// /source/projects/6502sbc/hopperbasic/commands.asm:723
// ####  Commands.DisplayFunctionSignature()  ####                              0x02CE

0xF7DE  0xA5 0x1E       LDA 0x1E                // LDA ZP.IDYH                       commands.asm:728
0xF7E0  0x48            PHA                     // PHA                               commands.asm:729
0xF7E1  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       commands.asm:730
0xF7E3  0x48            PHA                     // PHA                               commands.asm:731
0xF7E4  0x20 0xCB 0xA7  JSR 0xA7CB              // Functions.GetName();    Input: ZP.IDX, Output: ZP.STR = name pointer
0xF7E7  0x20 0x87 0xF8  JSR 0xF887              // checkForBeginFunctionSTR();    Input: ZP.STR, Returns C if this is the BEGIN function, munts:  A, Y, ZP.ACCL, ZP.TOP
0xF7EA  0x90 0x07       BCC 0xF7F3 (+7)         // if (C)                            commands.asm:738
0xF7EC  0xA9 0xA8       LDA # 0xA8              // LDA #Token.BEGIN                  commands.asm:741
0xF7EE  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            commands.asm:742
0xF7F1  0x80 0x1B       BRA 0xF80E (+27)        // }                                 commands.asm:743
0xF7F3  0xA9 0xA5       LDA # 0xA5              // LDA #Token.FUNC                   commands.asm:747
0xF7F5  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            commands.asm:748
0xF7F8  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:749
0xF7FB  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   commands.asm:751
0xF7FE  0xA9 0x28       LDA # 0x28              // LDA #'(' Serial.WriteChar();      commands.asm:752
0xF800  0x20 0x2B 0x8D  JSR 0x8D2B
0xF803  0x20 0xDC 0xA7  JSR 0xA7DC              // Functions.GetArguments();    Input: ZP.IDX, Output: ZP.IDY = args list or null
0xF806  0x20 0x55 0xF8  JSR 0xF855              // displayArguments();    Input: ZP.IDY = arguments list
0xF809  0xA9 0x29       LDA # 0x29              // LDA #')' Serial.WriteChar();      commands.asm:758
0xF80B  0x20 0x2B 0x8D  JSR 0x8D2B
0xF80E  0x20 0xB6 0x95  JSR 0x95B6              // Print.NewLine();                  commands.asm:761
0xF811  0x68            PLA                     // PLA                               commands.asm:763
0xF812  0x85 0x1D       STA 0x1D                // STA ZP.IDYL                       commands.asm:764
0xF814  0x68            PLA                     // PLA                               commands.asm:765
0xF815  0x85 0x1E       STA 0x1E                // STA ZP.IDYH                       commands.asm:766
0xF817  0x60            RTS                     // }                                 commands.asm:771

// /source/projects/6502sbc/hopperbasic/commands.asm:774
// ####  Commands.DisplayFunctionSuffix()  ####                                 0x02CF

0xF818  0x20 0xCB 0xA7  JSR 0xA7CB              // Functions.GetName();    Input: ZP.IDX, Output: ZP.STR = name pointer
0xF81B  0x20 0x87 0xF8  JSR 0xF887              // checkForBeginFunctionSTR();    Input: ZP.STR, Returns C if this is the BEGIN function, munts:  A, Y, ZP.ACCL, ZP.TOP
0xF81E  0x90 0x08       BCC 0xF828 (+8)         // if (C)                            commands.asm:778
0xF820  0xA9 0xA9       LDA # 0xA9              // LDA #Token.END                    commands.asm:781
0xF822  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            commands.asm:782
0xF825  0x4C 0xB6 0x95  JMP 0x95B6              // }                                 commands.asm:783
0xF828  0xA9 0xA6       LDA # 0xA6              // LDA #Token.ENDFUNC                commands.asm:787
0xF82A  0x20 0x1D 0x8A  JSR 0x8A1D              // Tokens.PrintKeyword();            commands.asm:788
0xF82D  0x4C 0xB6 0x95  JMP 0x95B6              // Print.NewLine();                  commands.asm:790

// /source/projects/6502sbc/hopperbasic/commands.asm:797
// ####  Commands.displayFunctionWithBody()  ####                               0x02D0

0xF830  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       commands.asm:803
0xF832  0x48            PHA                     // PHA                               commands.asm:804
0xF833  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       commands.asm:805
0xF835  0x48            PHA                     // PHA                               commands.asm:806
0xF836  0x20 0xDE 0xF7  JSR 0xF7DE              // DisplayFunctionSignature();       commands.asm:809
0xF839  0x68            PLA                     // PLA                               commands.asm:812
0xF83A  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       commands.asm:813
0xF83C  0x68            PLA                     // PLA                               commands.asm:814
0xF83D  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       commands.asm:815
0xF83F  0x20 0xC6 0xA7  JSR 0xA7C6              // Functions.GetBody();    Input: ZP.IDX, Output: ZP.IDY = tokens pointer
0xF842  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       commands.asm:840
0xF844  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       commands.asm:841
0xF846  0xF0 0x07       BEQ 0xF84F (+7)         // if (NZ)                           commands.asm:842
0xF848  0x64 0x58       STZ 0x58                // STZ ZP.TOKERRORH                  commands.asm:845
0xF84A  0x64 0x57       STZ 0x57                // STZ ZP.TOKERRORL                  commands.asm:846
0xF84C  0x20 0x80 0xF2  JSR 0xF280              // TokenIterator.RenderTokenStream();    Input: ZP.IDY = tokens pointer
0xF84F  0x20 0x18 0xF8  JSR 0xF818              // DisplayFunctionSuffix();          commands.asm:851
0xF852  0x4C 0xB6 0x95  JMP 0x95B6              // Print.NewLine();    Extra blank line after function

// /source/projects/6502sbc/hopperbasic/commands.asm:862
// ####  Commands.displayArguments()  ####                                      0x02D1

0xF855  0xA2 0x00       LDX # 0                 // LDX #0                            commands.asm:866
0xF857  0xA5 0x1D       LDA 0x1D                // LDA ZP.IDYL                       commands.asm:868
0xF859  0x05 0x1E       ORA 0x1E                // ORA ZP.IDYH                       commands.asm:869
0xF85B  0xD0 0x01       BNE 0xF85E (+1)         // if (NZ)                           commands.asm:870
0xF85D  0x60            RTS
0xF85E  0x20 0x0E 0xA6  JSR 0xA60E              // Locals.IterateStart();    Input: ZP.IDX = function node, Output: ZP.IDY = first argument, munts Y
0xF861  0x90 0x23       BCC 0xF886 (+35)        // if (NC) { break; }    No more arguments (handles empty list case)
0xF863  0x20 0x8D 0xA5  JSR 0xA58D              // Locals.GetType();    Input: ZP.IDY, Output: ZP.ACCT = symbolType|dataType
0xF866  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       commands.asm:879
0xF868  0x29 0xC0       AND # 0xC0              // AND # SymbolType.MASK             commands.asm:880
0xF86A  0xC9 0x40       CMP # 0x40              // CMP # SymbolType.ARGUMENT         commands.asm:881
0xF86C  0xD0 0x13       BNE 0xF881 (+19)        // if (Z)                            commands.asm:882
0xF86E  0xE0 0x00       CPX # 0                 // CPX #0                            commands.asm:884
0xF870  0xF0 0x08       BEQ 0xF87A (+8)         // if (NZ)                           commands.asm:885
0xF872  0xA9 0x2C       LDA # 0x2C              // LDA #','                          commands.asm:888
0xF874  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               commands.asm:889
0xF877  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    commands.asm:890
0xF87A  0x20 0x7D 0xA5  JSR 0xA57D              // Locals.GetName();    Input: ZP.IDY = argument node, Output: ZP.STR = name pointer
0xF87D  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   commands.asm:894
0xF880  0xE8            INX                     // INX                               commands.asm:895
0xF881  0x20 0x24 0xA6  JSR 0xA624              // Locals.IterateNext();    Input: ZP.IDY = current arg, Output: ZP.IDY = next arg
0xF884  0x80 0xDB       BRA 0xF861 (-37)        // }                                 commands.asm:899
0xF886  0x60            RTS                     // }                                 commands.asm:904

// /source/projects/6502sbc/hopperbasic/commands.asm:911
// ####  Commands.checkForBeginFunctionSTR()  ####                              0x02D2

0xF887  0x20 0x16 0x86  JSR 0x8616              // Messages.Main();    point ZP.TOP -> "$MAIN", munts A
0xF88A  0xA0 0x00       LDY # 0                 // LDY #0                            commands.asm:915
0xF88C  0xB1 0x79       LDA [0x79],Y            // LDA [ZP.STR], Y      Get character from name
0xF88E  0x85 0x0E       STA 0x0E                // STA ZP.ACCL          Save it      commands.asm:919
0xF890  0xB1 0x11       LDA [0x11],Y            // LDA [ZP.TOP], Y      Get character from "$MAIN"
0xF892  0xC5 0x0E       CMP 0x0E                // CMP ZP.ACCL          Compare them commands.asm:921
0xF894  0xF0 0x02       BEQ 0xF898 (+2)         // if (NZ)                           commands.asm:922
0xF896  0x18            CLC                     // CLC    Strings don't match        commands.asm:924
0xF897  0x60            RTS                     // break;                            commands.asm:925
0xF898  0xA5 0x0E       LDA 0x0E                // LDA ZP.ACCL          Get the character back
0xF89A  0xD0 0x02       BNE 0xF89E (+2)         // if (Z)     Null terminator - strings match completely
0xF89C  0x38            SEC                     // SEC    Is BEGIN function          commands.asm:931
0xF89D  0x60            RTS                     // break;                            commands.asm:932
0xF89E  0xC8            INY                     // INY                               commands.asm:934
0xF89F  0x80 0xEB       BRA 0xF88C (-21)        // }                                 commands.asm:935

// /source/projects/6502sbc/hopperbasic/commands.asm:966
// ####  Commands.CmdSave()  ####                                               0x02D5

0xF8A1  0xA9 0x02       LDA # 0x02              // LDA # DirWalkAction.FindFile     warn for overwrite of either executable or data
0xF8A3  0x20 0xBB 0xB0  JSR 0xB0BB              // File.Exists();    preserves ZP.STR
0xF8A6  0xB0 0x03       BCS 0xF8AB (+3)         // if (C)                            commands.asm:972
0xF8A8  0x4C 0x05 0xB5  JMP 0xB505
0xF8AB  0xA2 0x02       LDX # 0x02              // LDX #2    Messages.OverwriteWarning
0xF8AD  0x20 0xCC 0xF8  JSR 0xF8CC              // confirmDestructiveAction();    preserves ZP.STR
0xF8B0  0xB0 0x01       BCS 0xF8B3 (+1)         // if (C)                            commands.asm:977
0xF8B2  0x60            RTS
0xF8B3  0x20 0x49 0xB0  JSR 0xB049              // File.Delete();    preserves ZP.STR
0xF8B6  0x4C 0x05 0xB5  JMP 0xB505              // }                                 commands.asm:981

// /source/projects/6502sbc/hopperbasic/commands.asm:1000
// ####  Commands.CmdLoad()  ####                                               0x02D6

0xF8B9  0xA9 0x00       LDA # 0                 // LDA #0    no NEW first            commands.asm:1002
0xF8BB  0x4C 0x8F 0xB4  JMP 0xB48F              // Storage.LoadProgram();    CmdLoad: Input: ZP.STR

// /source/projects/6502sbc/hopperbasic/commands.asm:1013
// ####  Commands.CmdFormat()  ####                                             0x02D7

0xF8BE  0xA2 0x01       LDX # 1                 // LDX #1    Messages.FormatWarning  commands.asm:1015
0xF8C0  0x20 0xCC 0xF8  JSR 0xF8CC              // confirmDestructiveAction();       commands.asm:1016
0xF8C3  0xB0 0x01       BCS 0xF8C6 (+1)         // if (C)                            commands.asm:1017
0xF8C5  0x60            RTS
0xF8C6  0x20 0xF3 0xAE  JSR 0xAEF3              // File.Format();                    commands.asm:1019
0xF8C9  0x4C 0x97 0x8C  JMP 0x8C97              // CheckAndPrint();                  commands.asm:1020

// /source/projects/6502sbc/hopperbasic/commands.asm:1034
// ####  Commands.confirmDestructiveAction()  ####                              0x02D8

0xF8CC  0x48            PHA                     // PHA                               commands.asm:1035
0xF8CD  0xDA            PHX                     // PHX                               commands.asm:1036
0xF8CE  0x5A            PHY                     // PHY                               commands.asm:1037
0xF8CF  0xA5 0x79       LDA 0x79                // LDA ZP.STRL                       commands.asm:1039
0xF8D1  0x48            PHA                     // PHA                               commands.asm:1040
0xF8D2  0xA5 0x7A       LDA 0x7A                // LDA ZP.STRH                       commands.asm:1041
0xF8D4  0x48            PHA                     // PHA                               commands.asm:1042
0xF8D5  0xE0 0x01       CPX # 1                 // case 1:    FORMAT                 commands.asm:1049
0xF8D7  0xD0 0x0D       BNE 0xF8E6 (+13)
0xF8D9  0xA9 0x37       LDA # 0x37              // LDA # ErrorID.FormatWarning LDX # (MessageExtras.None|MessageExtras.SuffixPeriod|MessageExtras.SuffixSpace)
0xF8DB  0xA2 0x22       LDX # 0x22
0xF8DD  0x20 0xE9 0x8A  JSR 0x8AE9              // Error.Message();                  commands.asm:1052
0xF8E0  0xA9 0x39       LDA # 0x39              // LDA # ErrorID.ContinueWarning LDX # (MessageExtras.None|MessageExtras.SuffixSpace)
0xF8E2  0xA2 0x02       LDX # 0x02
0xF8E4  0x80 0x08       BRA 0xF8EE (+8)         // }                                 commands.asm:1054
0xF8E6  0xE0 0x02       CPX # 0x02              // case 2:    SAVE                   commands.asm:1055
0xF8E8  0xD0 0x04       BNE 0xF8EE (+4)
0xF8EA  0xA9 0x38       LDA # 0x38              // LDA # ErrorID.OverwriteWarning LDX # (MessageExtras.None|MessageExtras.SuffixSpace)
0xF8EC  0xA2 0x02       LDX # 0x02
0xF8EE  0x20 0xE9 0x8A  JSR 0x8AE9              // Error.Message();                  commands.asm:1060
0xF8F1  0xA9 0x3A       LDA # 0x3A              // LDA # ErrorID.YesNo LDX # (MessageExtras.InParens|MessageExtras.SuffixQuest|MessageExtras.SuffixSpace)
0xF8F3  0xA2 0x8A       LDX # 0x8A
0xF8F5  0x20 0xE9 0x8A  JSR 0x8AE9              // Error.Message();                  commands.asm:1062
0xF8F8  0x20 0x88 0x8D  JSR 0x8D88              // Serial.WaitForChar();             commands.asm:1067
0xF8FB  0x48            PHA                     // PHA                               commands.asm:1069
0xF8FC  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               commands.asm:1071
0xF8FF  0x20 0xB6 0x95  JSR 0x95B6              // Print.NewLine();       munts A    commands.asm:1072
0xF902  0x68            PLA                     // PLA                               commands.asm:1073
0xF903  0xC9 0x59       CMP # 0x59              // case 'Y':                         commands.asm:1076
0xF905  0xF0 0x04       BEQ 0xF90B (+4)
0xF907  0xC9 0x79       CMP # 0x79              // case 'y':                         commands.asm:1077
0xF909  0xD0 0x03       BNE 0xF90E (+3)
0xF90B  0x38            SEC                     // { SEC break; }                    commands.asm:1078
0xF90C  0x80 0x14       BRA 0xF922 (+20)
0xF90E  0xC9 0x4E       CMP # 0x4E              // case 'N':                         commands.asm:1079
0xF910  0xF0 0x04       BEQ 0xF916 (+4)
0xF912  0xC9 0x6E       CMP # 0x6E              // case 'n':                         commands.asm:1080
0xF914  0xD0 0x03       BNE 0xF919 (+3)
0xF916  0x18            CLC                     // { CLC break; }                    commands.asm:1081
0xF917  0x80 0x09       BRA 0xF922 (+9)
0xF919  0xA9 0x3A       LDA # 0x3A              // LDA # ErrorID.YesNo LDX # (MessageExtras.SuffixQuest|MessageExtras.SuffixSpace)
0xF91B  0xA2 0x0A       LDX # 0x0A
0xF91D  0x20 0xE9 0x8A  JSR 0x8AE9              // Error.Message();                  commands.asm:1086
0xF920  0x80 0xD6       BRA 0xF8F8 (-42)        // }                                 commands.asm:1087
0xF922  0x68            PLA                     // PLA                               commands.asm:1094
0xF923  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       commands.asm:1095
0xF925  0x68            PLA                     // PLA                               commands.asm:1096
0xF926  0x85 0x79       STA 0x79                // STA ZP.STRL                       commands.asm:1097
0xF928  0x7A            PLY                     // PLY                               commands.asm:1099
0xF929  0xFA            PLX                     // PLX                               commands.asm:1100
0xF92A  0x68            PLA                     // PLA                               commands.asm:1101
0xF92B  0x60            RTS                     // }                                 commands.asm:1102

// /source/projects/6502sbc/hopperbasic/console.asm:8
// ####  Console.validateNextToken()  ####                                      0x02D9

0xF92C  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();            console.asm:9
0xF92F  0x20 0x9D 0xFD  JSR 0xFD9D              // validateEndOfCommand();           console.asm:10
0xF932  0x4C 0x59 0x8C  JMP 0x8C59              // CheckError();                     console.asm:11

// /source/projects/6502sbc/hopperbasic/console.asm:16
// ####  Console.Initialize()  ####                                             0x02DA

0xF935  0x20 0x89 0x96  JSR 0x9689              // BufferManager.InitializeForTokenGeneration();
0xF938  0x20 0x00 0x9F  JSR 0x9F00              // Objects.Initialize();             console.asm:20
0xF93B  0xA9 0x00       LDA # 0                 // LDA #CaptureMode.Off              console.asm:22
0xF93D  0x8D 0xB3 0x0B  STA 0x0BB3              // Statement.SetCaptureMode();       console.asm:23
0xF940  0x4C 0xBB 0x89  JMP 0x89BB              // States.SetSuccess();              console.asm:26

// /source/projects/6502sbc/hopperbasic/console.asm:31
// ####  Console.ReadLine()  ####                                               0x02DB

0xF943  0x20 0x9B 0xBE  JSR 0xBE9B              // Tokenizer.ReadLine();       Read into BasicInputBuffer, sets ZP.BasicInputLength
0xF946  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:35
0xF949  0x90 0x09       BCC 0xF954 (+9)         // if (C)                            console.asm:36
0xF94B  0xA9 0x01       LDA # 1                 // LDA #1    Append mode = 1         console.asm:39
0xF94D  0x85 0x37       STA 0x37                // STA ZP.OpCodeTemp                 console.asm:40
0xF94F  0x20 0xD6 0xBA  JSR 0xBAD6              // TokenizeLineWithMode();           console.asm:41
0xF952  0x80 0x05       BRA 0xF959 (+5)         // }                                 console.asm:42
0xF954  0x64 0x37       STZ 0x37                // STZ ZP.OpCodeTemp     Replace mode = 0
0xF956  0x20 0xD6 0xBA  JSR 0xBAD6              // TokenizeLineWithMode();           console.asm:47
0xF959  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:50
0xF95C  0xB0 0x03       BCS 0xF961 (+3)         // if (NC) { States.SetFailure(); }     Return if tokenization failed
0xF95E  0x64 0x4E       STZ 0x4E
0xF960  0x60            RTS
0xF961  0x4C 0xBB 0x89  JMP 0x89BB              // else { States.SetSuccess(); }     console.asm:52

// /source/projects/6502sbc/hopperbasic/console.asm:57
// ####  Console.ProcessLine()  ####                                            0x02DC

0xF964  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:58
0xF967  0x90 0x05       BCC 0xF96E (+5)         // if (C)                            console.asm:59
0xF969  0x20 0x22 0xFA  JSR 0xFA22              // processLineFunctionCapture();     console.asm:62
0xF96C  0x80 0x03       BRA 0xF971 (+3)         // }                                 console.asm:63
0xF96E  0x20 0x7E 0xF9  JSR 0xF97E              // processLineNormal();              console.asm:67
0xF971  0xA5 0x4E       LDA 0x4E                // States.GetState();                console.asm:71
0xF973  0xC9 0x01       CMP # 1                 // case State.Success:   { /* continue */ }
0xF975  0xF0 0x06       BEQ 0xF97D (+6)
0xF977  0xC9 0x00       CMP # 0                 // case State.Failure:   { /* return */ }
0xF979  0xF0 0x02       BEQ 0xF97D (+2)
0xF97B  0xC9 0x02       CMP # 0x02              // case State.Exiting:   { /* return */ }
0xF97D  0x60            RTS                     // }                                 console.asm:78

// /source/projects/6502sbc/hopperbasic/console.asm:83
// ####  Console.processLineNormal()  ####                                      0x02DD

0xF97E  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        console.asm:90
0xF981  0x90 0x25       BCC 0xF9A8 (+37)        // if (NC) { break; }                console.asm:91
0xF983  0xA5 0x29       LDA 0x29                // LDA ZP.TokenBufferContentLengthL  console.asm:94
0xF985  0xC9 0x01       CMP # 1                 // CMP #1                            console.asm:95
0xF987  0xF0 0x03       BEQ 0xF98C (+3)         // if (NZ)                           console.asm:96
0xF989  0x4C 0xA9 0xF9  JMP 0xF9A9              // processTokensAndCheckFunction();  console.asm:99
0xF98C  0xA5 0x2A       LDA 0x2A                // LDA ZP.TokenBufferContentLengthH  console.asm:103
0xF98E  0xF0 0x03       BEQ 0xF993 (+3)         // if (NZ)                           console.asm:104
0xF990  0x4C 0xA9 0xF9  JMP 0xF9A9              // processTokensAndCheckFunction();  console.asm:107
0xF993  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL              console.asm:112
0xF995  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              console.asm:113
0xF997  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no      console.asm:114
0xF99A  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    console.asm:115
0xF99C  0xD0 0x03       BNE 0xF9A1 (+3)         // if (Z)                            console.asm:116
0xF99E  0x4C 0xBB 0x89  JMP 0x89BB              // States.SetSuccess();    Continue (empty line)
0xF9A1  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL              console.asm:123
0xF9A3  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              console.asm:124
0xF9A5  0x4C 0xA9 0xF9  JMP 0xF9A9              // processTokensAndCheckFunction();  console.asm:125
0xF9A8  0x60            RTS                     // }                                 console.asm:132

// /source/projects/6502sbc/hopperbasic/console.asm:136
// ####  Console.processTokensAndCheckFunction()  ####                          0x02DE

0xF9A9  0x20 0x93 0xFA  JSR 0xFA93              // processTokens();                  console.asm:138
0xF9AC  0x20 0xA1 0x89  JSR 0x89A1              // States.IsExiting();               console.asm:139
0xF9AF  0x90 0x01       BCC 0xF9B2 (+1)         // if (NC)                           console.asm:140
0xF9B1  0x60            RTS
0xF9B2  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:143
0xF9B5  0xB0 0x03       BCS 0xF9BA (+3)         // if (NC)                           console.asm:144
0xF9B7  0x64 0x4E       STZ 0x4E                // States.SetFailure();              console.asm:146
0xF9B9  0x60            RTS                     // }                                 console.asm:147
0xF9BA  0x20 0xC0 0xF9  JSR 0xF9C0              // detectIncompleteFunction();       console.asm:151
0xF9BD  0x4C 0xBB 0x89  JMP 0x89BB              // States.SetSuccess();    Continue  console.asm:152

// /source/projects/6502sbc/hopperbasic/console.asm:159
// ####  Console.detectIncompleteFunction()  ####                               0x02DF

0xF9C0  0x48            PHA                     // PHA                               console.asm:160
0xF9C1  0xDA            PHX                     // PHX                               console.asm:161
0xF9C2  0x5A            PHY                     // PHY                               console.asm:162
0xF9C3  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              console.asm:165
0xF9C5  0x48            PHA                     // PHA                               console.asm:166
0xF9C6  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              console.asm:167
0xF9C8  0x48            PHA                     // PHA                               console.asm:168
0xF9C9  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL              console.asm:171
0xF9CB  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              console.asm:172
0xF9CD  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no      console.asm:175
0xF9D0  0xC9 0xA5       CMP # 0xA5              // CMP #Token.FUNC                   console.asm:177
0xF9D2  0xF0 0x2C       BEQ 0xFA00 (+44)        // if (NZ)                           console.asm:178
0xF9D4  0xC9 0xA8       CMP # 0xA8              // CMP #Token.BEGIN                  console.asm:180
0xF9D6  0xF0 0x08       BEQ 0xF9E0 (+8)         // if (NZ)                           console.asm:181
0xF9D8  0x68            PLA                     // PLA                               console.asm:184
0xF9D9  0x85 0x2C       STA 0x2C                // STA ZP.TokenizerPosH              console.asm:185
0xF9DB  0x68            PLA                     // PLA                               console.asm:186
0xF9DC  0x85 0x2B       STA 0x2B                // STA ZP.TokenizerPosL              console.asm:187
0xF9DE  0x80 0x3E       BRA 0xFA1E (+62)        // }                                 console.asm:188
0xF9E0  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no      console.asm:194
0xF9E3  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    console.asm:195
0xF9E5  0xD0 0x0D       BNE 0xF9F4 (+13)        // if (Z)                            console.asm:196
0xF9E7  0x68            PLA                     // PLA                               console.asm:199
0xF9E8  0x85 0x2C       STA 0x2C                // STA ZP.TokenizerPosH              console.asm:200
0xF9EA  0x68            PLA                     // PLA                               console.asm:201
0xF9EB  0x85 0x2B       STA 0x2B                // STA ZP.TokenizerPosL              console.asm:202
0xF9ED  0xA9 0x02       LDA # 0x02              // LDA #CaptureMode.Begin            console.asm:203
0xF9EF  0x8D 0xB3 0x0B  STA 0x0BB3              // Statement.SetCaptureMode();       console.asm:204
0xF9F2  0x80 0x2A       BRA 0xFA1E (+42)        // break;    incomplete BEGIN found  console.asm:205
0xF9F4  0xC9 0xA9       CMP # 0xA9              // CMP #Token.END                    console.asm:208
0xF9F6  0xD0 0xE8       BNE 0xF9E0 (-24)        // if (Z)                            console.asm:209
0xF9F8  0x68            PLA                     // PLA                               console.asm:212
0xF9F9  0x85 0x2C       STA 0x2C                // STA ZP.TokenizerPosH              console.asm:213
0xF9FB  0x68            PLA                     // PLA                               console.asm:214
0xF9FC  0x85 0x2B       STA 0x2B                // STA ZP.TokenizerPosL              console.asm:215
0xF9FE  0x80 0x1E       BRA 0xFA1E (+30)        // break;    Found END - complete BEGIN
0xFA00  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no      console.asm:226
0xFA03  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    console.asm:227
0xFA05  0xD0 0x0D       BNE 0xFA14 (+13)        // if (Z)                            console.asm:228
0xFA07  0x68            PLA                     // PLA                               console.asm:231
0xFA08  0x85 0x2C       STA 0x2C                // STA ZP.TokenizerPosH              console.asm:232
0xFA0A  0x68            PLA                     // PLA                               console.asm:233
0xFA0B  0x85 0x2B       STA 0x2B                // STA ZP.TokenizerPosL              console.asm:234
0xFA0D  0xA9 0x01       LDA # 1                 // LDA #CaptureMode.Func             console.asm:235
0xFA0F  0x8D 0xB3 0x0B  STA 0x0BB3              // Statement.SetCaptureMode();       console.asm:236
0xFA12  0x80 0x0A       BRA 0xFA1E (+10)        // break;    incomplete function found
0xFA14  0xC9 0xA6       CMP # 0xA6              // CMP #Token.ENDFUNC                console.asm:240
0xFA16  0xD0 0xE8       BNE 0xFA00 (-24)        // if (Z)                            console.asm:241
0xFA18  0x68            PLA                     // PLA                               console.asm:244
0xFA19  0x85 0x2C       STA 0x2C                // STA ZP.TokenizerPosH              console.asm:245
0xFA1B  0x68            PLA                     // PLA                               console.asm:246
0xFA1C  0x85 0x2B       STA 0x2B                // STA ZP.TokenizerPosL              console.asm:247
0xFA1E  0x7A            PLY                     // PLY                               console.asm:253
0xFA1F  0xFA            PLX                     // PLX                               console.asm:254
0xFA20  0x68            PLA                     // PLA                               console.asm:255
0xFA21  0x60            RTS                     // }                                 console.asm:256

// /source/projects/6502sbc/hopperbasic/console.asm:261
// ####  Console.processLineFunctionCapture()  ####                             0x02E0

0xFA22  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        console.asm:269
0xFA25  0x90 0x18       BCC 0xFA3F (+24)        // if (NC) { break; }                console.asm:270
0xFA27  0x20 0x40 0xFA  JSR 0xFA40              // checkForCompletionToken();        console.asm:273
0xFA2A  0xB0 0x03       BCS 0xFA2F (+3)         // if (C)                            console.asm:274
0xFA2C  0x4C 0xBB 0x89  JMP 0x89BB
0xFA2F  0xA9 0x00       LDA # 0                 // LDA #CaptureMode.Off              console.asm:277
0xFA31  0x8D 0xB3 0x0B  STA 0x0BB3              // Statement.SetCaptureMode();       console.asm:278
0xFA34  0x20 0x0A 0xC3  JSR 0xC30A              // FunctionDeclaration.CompletePartialFunction();
0xFA37  0x20 0x73 0x8C  JSR 0x8C73              // CheckErrorAndSetFailure();        console.asm:282
0xFA3A  0x90 0x03       BCC 0xFA3F (+3)         // if (NC) { break; }                console.asm:283
0xFA3C  0x4C 0xBB 0x89  JMP 0x89BB
0xFA3F  0x60            RTS                     // }                                 console.asm:296

// /source/projects/6502sbc/hopperbasic/console.asm:300
// ####  Console.checkForCompletionToken()  ####                                0x02E1

0xFA40  0x48            PHA                     // PHA                               console.asm:301
0xFA41  0xDA            PHX                     // PHX                               console.asm:302
0xFA42  0x5A            PHY                     // PHY                               console.asm:303
0xFA43  0xA5 0x2B       LDA 0x2B                // LDA ZP.TokenizerPosL              console.asm:306
0xFA45  0x48            PHA                     // PHA                               console.asm:307
0xFA46  0xA5 0x2C       LDA 0x2C                // LDA ZP.TokenizerPosH              console.asm:308
0xFA48  0x48            PHA                     // PHA                               console.asm:309
0xFA49  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL              console.asm:312
0xFA4B  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              console.asm:313
0xFA4D  0xAD 0xB3 0x0B  LDA 0x0BB3              // Statement.GetCaptureMode();       console.asm:315
0xFA50  0xC9 0x01       CMP # 1                 // CMP #CaptureMode.Func             console.asm:316
0xFA52  0xD0 0x12       BNE 0xFA66 (+18)        // if (Z)                            console.asm:317
0xFA54  0x20 0xDF 0xB9  JSR 0xB9DF              // Tokenizer.CompareTokenizerPosToLength();
0xFA57  0x90 0x03       BCC 0xFA5C (+3)         // if (C) { CLC break; }    Reached end of buffer - not found
0xFA59  0x18            CLC
0xFA5A  0x80 0x1A       BRA 0xFA76 (+26)
0xFA5C  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no      console.asm:325
0xFA5F  0xC9 0xA6       CMP # 0xA6              // CMP #Token.ENDFUNC                console.asm:326
0xFA61  0xD0 0xF1       BNE 0xFA54 (-15)        // if (Z) { SEC break; }    Found completion
0xFA63  0x38            SEC
0xFA64  0x80 0x10       BRA 0xFA76 (+16)
0xFA66  0x20 0xDF 0xB9  JSR 0xB9DF              // Tokenizer.CompareTokenizerPosToLength();
0xFA69  0x90 0x03       BCC 0xFA6E (+3)         // if (C) { CLC break; }    Reached end of buffer - not found
0xFA6B  0x18            CLC
0xFA6C  0x80 0x08       BRA 0xFA76 (+8)
0xFA6E  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no      console.asm:338
0xFA71  0xC9 0xA9       CMP # 0xA9              // CMP #Token.END                    console.asm:339
0xFA73  0xD0 0xF1       BNE 0xFA66 (-15)        // if (Z) { SEC break; }    Found completion
0xFA75  0x38            SEC
0xFA76  0x68            PLA                     // PLA                               console.asm:345
0xFA77  0x85 0x2C       STA 0x2C                // STA ZP.TokenizerPosH              console.asm:346
0xFA79  0x68            PLA                     // PLA                               console.asm:347
0xFA7A  0x85 0x2B       STA 0x2B                // STA ZP.TokenizerPosL              console.asm:348
0xFA7C  0x7A            PLY                     // PLY                               console.asm:350
0xFA7D  0xFA            PLX                     // PLX                               console.asm:351
0xFA7E  0x68            PLA                     // PLA                               console.asm:352
0xFA7F  0x60            RTS                     // }                                 console.asm:353

// /source/projects/6502sbc/hopperbasic/console.asm:358
// ####  Console.ExitFunctionCaptureMode()  ####                                0x02E2

0xFA80  0xA9 0x00       LDA # 0                 // LDA #CaptureMode.Off              console.asm:363
0xFA82  0x8D 0xB3 0x0B  STA 0x0BB3              // Statement.SetCaptureMode();       console.asm:364
0xFA85  0x64 0x29       STZ 0x29                // STZ ZP.TokenBufferContentLengthL  console.asm:368
0xFA87  0x64 0x2A       STZ 0x2A                // STZ ZP.TokenBufferContentLengthH  console.asm:369
0xFA89  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL              console.asm:370
0xFA8B  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              console.asm:371
0xFA8D  0x20 0x4C 0x8C  JSR 0x8C4C              // Error.ClearError();               console.asm:374
0xFA90  0x4C 0xBB 0x89  JMP 0x89BB              // States.SetSuccess();              console.asm:375

// /source/projects/6502sbc/hopperbasic/console.asm:384
// ####  Console.processTokens()  ####                                          0x02E3

0xFA93  0x48            PHA                     // PHA                               console.asm:385
0xFA94  0xDA            PHX                     // PHX                               console.asm:386
0xFA95  0x17 0x02       RMB1 0x02               // RMB1 ZP.FLAGS     Clear bit 1 (exit flag) at start
0xFA97  0x1F 0x02 0x03  BBR1 0x02, 0xFA9D (+3)  // if (BBS1, ZP.FLAGS) { break; }    Exit if bit 1 is set
0xFA9A  0x4C 0x41 0xFC  JMP 0xFC41
0xFA9D  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();     no, Returns token in A, updates ZP.CurrentToken
0xFAA0  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    console.asm:398
0xFAA2  0xD0 0x03       BNE 0xFAA7 (+3)         // if (Z) { break; }     End of all statements
0xFAA4  0x4C 0x41 0xFC  JMP 0xFC41
0xFAA7  0xC9 0xDB       CMP # 0xDB              // CMP #Token.EOF                    console.asm:401
0xFAA9  0xD0 0x03       BNE 0xFAAE (+3)         // if (Z) { break; }     End of all statements
0xFAAB  0x4C 0x41 0xFC  JMP 0xFC41
0xFAAE  0xC9 0x80       CMP # 0x80              // case Token.NEW:                   console.asm:408
0xFAB0  0xD0 0x0D       BNE 0xFABF (+13)
0xFAB2  0x20 0xE4 0xFC  JSR 0xFCE4              // parseNew();                       console.asm:410
0xFAB5  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:411
0xFAB8  0xB0 0x02       BCS 0xFABC (+2)         // if (NC) { SMB1 ZP.FLAGS }    Set exit flag on error
0xFABA  0x97 0x02       SMB1 0x02
0xFABC  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:413
0xFABF  0xC9 0x83       CMP # 0x83              // case Token.CLEAR:                 console.asm:414
0xFAC1  0xD0 0x0D       BNE 0xFAD0 (+13)
0xFAC3  0x20 0xF5 0xFC  JSR 0xFCF5              // parseClear();                     console.asm:416
0xFAC6  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:417
0xFAC9  0xB0 0x02       BCS 0xFACD (+2)         // if (NC) { SMB1 ZP.FLAGS }    Set exit flag on error
0xFACB  0x97 0x02       SMB1 0x02
0xFACD  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:419
0xFAD0  0xC9 0x86       CMP # 0x86              // case Token.FORGET:                console.asm:420
0xFAD2  0xD0 0x0D       BNE 0xFAE1 (+13)
0xFAD4  0x20 0x06 0xFD  JSR 0xFD06              // parseForget();                    console.asm:422
0xFAD7  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:423
0xFADA  0xB0 0x02       BCS 0xFADE (+2)         // if (NC) { SMB1 ZP.FLAGS }    Set exit flag on error
0xFADC  0x97 0x02       SMB1 0x02
0xFADE  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:425
0xFAE1  0xC9 0x84       CMP # 0x84              // case Token.VARS:                  console.asm:426
0xFAE3  0xD0 0x0D       BNE 0xFAF2 (+13)
0xFAE5  0x20 0x29 0xFD  JSR 0xFD29              // parseVars();                      console.asm:428
0xFAE8  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:429
0xFAEB  0xB0 0x02       BCS 0xFAEF (+2)         // if (NC) { SMB1 ZP.FLAGS }    Set exit flag on error
0xFAED  0x97 0x02       SMB1 0x02
0xFAEF  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:431
0xFAF2  0xC9 0x81       CMP # 0x81              // case Token.LIST:                  console.asm:432
0xFAF4  0xD0 0x0F       BNE 0xFB05 (+15)
0xFAF6  0xA2 0x00       LDX # 0                 // LDX #0    LIST                    console.asm:434
0xFAF8  0x20 0x3A 0xFD  JSR 0xFD3A              // parseList();                      console.asm:435
0xFAFB  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:436
0xFAFE  0xB0 0x02       BCS 0xFB02 (+2)         // if (NC) { SMB1 ZP.FLAGS }    Set exit flag on error
0xFB00  0x97 0x02       SMB1 0x02
0xFB02  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:438
0xFB05  0xC9 0x90       CMP # 0x90              // case Token.DASM:                  console.asm:439
0xFB07  0xD0 0x06       BNE 0xFB0F (+6)
0xFB09  0x20 0x40 0xF6  JSR 0xF640              // Commands.NotAvailable();          console.asm:447
0xFB0C  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:450
0xFB0F  0xC9 0x85       CMP # 0x85              // case Token.FUNCS:                 console.asm:451
0xFB11  0xD0 0x0D       BNE 0xFB20 (+13)
0xFB13  0x20 0x54 0xFD  JSR 0xFD54              // parseFuncs();                     console.asm:453
0xFB16  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:454
0xFB19  0xB0 0x02       BCS 0xFB1D (+2)         // if (NC) { SMB1 ZP.FLAGS }    Set exit flag on error
0xFB1B  0x97 0x02       SMB1 0x02
0xFB1D  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:456
0xFB20  0xC9 0x8C       CMP # 0x8C              // case Token.MEM:                   console.asm:457
0xFB22  0xD0 0x0D       BNE 0xFB31 (+13)
0xFB24  0x20 0x6E 0xFD  JSR 0xFD6E              // parseMem();                       console.asm:459
0xFB27  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:460
0xFB2A  0xB0 0x02       BCS 0xFB2E (+2)         // if (NC) { SMB1 ZP.FLAGS }    Set exit flag on error
0xFB2C  0x97 0x02       SMB1 0x02
0xFB2E  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:462
0xFB31  0xC9 0x91       CMP # 0x91              // case Token.BYE:                   console.asm:463
0xFB33  0xD0 0x08       BNE 0xFB3D (+8)
0xFB35  0x20 0x7F 0xFD  JSR 0xFD7F              // parseBye();                       console.asm:465
0xFB38  0x97 0x02       SMB1 0x02               // SMB1 ZP.FLAGS     Always exit after BYE
0xFB3A  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:467
0xFB3D  0xC9 0x8D       CMP # 0x8D              // case Token.HEAP:                  console.asm:469
0xFB3F  0xD0 0x06       BNE 0xFB47 (+6)
0xFB41  0x20 0x40 0xF6  JSR 0xF640              // Commands.NotAvailable();          console.asm:476
0xFB44  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:478
0xFB47  0xC9 0x8E       CMP # 0x8E              // case Token.BUFFERS:               console.asm:479
0xFB49  0xD0 0x06       BNE 0xFB51 (+6)
0xFB4B  0x20 0x40 0xF6  JSR 0xF640              // Commands.NotAvailable();          console.asm:486
0xFB4E  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:488
0xFB51  0xC9 0x8F       CMP # 0x8F              // case Token.DUMP:                  console.asm:489
0xFB53  0xD0 0x06       BNE 0xFB5B (+6)
0xFB55  0x20 0x40 0xF6  JSR 0xF640              // Commands.NotAvailable();          console.asm:496
0xFB58  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:498
0xFB5B  0xC9 0x92       CMP # 0x92              // case Token.TRON:                  console.asm:499
0xFB5D  0xD0 0x06       BNE 0xFB65 (+6)
0xFB5F  0x20 0x40 0xF6  JSR 0xF640              // Commands.NotAvailable();          console.asm:506
0xFB62  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:508
0xFB65  0xC9 0x93       CMP # 0x93              // case Token.TROFF:                 console.asm:509
0xFB67  0xD0 0x06       BNE 0xFB6F (+6)
0xFB69  0x20 0x40 0xF6  JSR 0xF640              // Commands.NotAvailable();          console.asm:516
0xFB6C  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:518
0xFB6F  0xC9 0x87       CMP # 0x87              // case Token.SAVE:                  console.asm:520
0xFB71  0xD0 0x0D       BNE 0xFB80 (+13)
0xFB73  0x20 0x65 0xFC  JSR 0xFC65              // parseSave();                      console.asm:522
0xFB76  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:523
0xFB79  0xB0 0x02       BCS 0xFB7D (+2)         // if (NC) { SMB1 ZP.FLAGS }    Set exit flag on error
0xFB7B  0x97 0x02       SMB1 0x02
0xFB7D  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:525
0xFB80  0xC9 0x88       CMP # 0x88              // case Token.LOAD:                  console.asm:526
0xFB82  0xD0 0x0D       BNE 0xFB91 (+13)
0xFB84  0x20 0x84 0xFC  JSR 0xFC84              // parseLoad();                      console.asm:528
0xFB87  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:529
0xFB8A  0xB0 0x02       BCS 0xFB8E (+2)         // if (NC) { SMB1 ZP.FLAGS }    Set exit flag on error
0xFB8C  0x97 0x02       SMB1 0x02
0xFB8E  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:531
0xFB91  0xC9 0x89       CMP # 0x89              // case Token.DIR:                   console.asm:532
0xFB93  0xD0 0x0D       BNE 0xFBA2 (+13)
0xFB95  0x20 0xA3 0xFC  JSR 0xFCA3              // parseDir();                       console.asm:534
0xFB98  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:535
0xFB9B  0xB0 0x02       BCS 0xFB9F (+2)         // if (NC) { SMB1 ZP.FLAGS }    Set exit flag on error
0xFB9D  0x97 0x02       SMB1 0x02
0xFB9F  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:537
0xFBA2  0xC9 0x8A       CMP # 0x8A              // case Token.DEL:                   console.asm:538
0xFBA4  0xD0 0x0D       BNE 0xFBB3 (+13)
0xFBA6  0x20 0xB4 0xFC  JSR 0xFCB4              // parseDel();                       console.asm:540
0xFBA9  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:541
0xFBAC  0xB0 0x02       BCS 0xFBB0 (+2)         // if (NC) { SMB1 ZP.FLAGS }    Set exit flag on error
0xFBAE  0x97 0x02       SMB1 0x02
0xFBB0  0x4C 0x35 0xFC  JMP 0xFC35              // }                                 console.asm:543
0xFBB3  0xC9 0x8B       CMP # 0x8B              // case Token.FORMAT:                console.asm:544
0xFBB5  0xD0 0x0C       BNE 0xFBC3 (+12)
0xFBB7  0x20 0xD3 0xFC  JSR 0xFCD3              // parseFormat();                    console.asm:546
0xFBBA  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:547
0xFBBD  0xB0 0x76       BCS 0xFC35 (+118)       // if (NC) { SMB1 ZP.FLAGS }    Set exit flag on error
0xFBBF  0x97 0x02       SMB1 0x02
0xFBC1  0x80 0x72       BRA 0xFC35 (+114)       // }                                 console.asm:549
0xFBC3  0xC9 0x82       CMP # 0x82              // case Token.RUN:                   console.asm:552
0xFBC5  0xD0 0x0A       BNE 0xFBD1 (+10)
0xFBC7  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no, consume 'RUN'
0xFBCA  0x20 0xBC 0xFE  JSR 0xFEBC              // CmdRun();                         console.asm:555
0xFBCD  0x97 0x02       SMB1 0x02               // SMB1 ZP.FLAGS     Always exit after RUN
0xFBCF  0x80 0x64       BRA 0xFC35 (+100)       // }                                 console.asm:557
0xFBD1  0xC9 0x94       CMP # 0x94              // case Token.REM:                   console.asm:560
0xFBD3  0xF0 0x04       BEQ 0xFBD9 (+4)
0xFBD5  0xC9 0x95       CMP # 0x95              // case Token.COMMENT:               console.asm:561
0xFBD7  0xD0 0x0D       BNE 0xFBE6 (+13)
0xFBD9  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no      console.asm:567
0xFBDC  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL                    console.asm:568
0xFBDE  0xF0 0x55       BEQ 0xFC35 (+85)        // if (Z) { break; }                 console.asm:569
0xFBE0  0xC9 0xDE       CMP # 0xDE              // CMP #Token.COLON                  console.asm:570
0xFBE2  0xF0 0x51       BEQ 0xFC35 (+81)        // if (Z) { break; }                 console.asm:571
0xFBE4  0x80 0xF3       BRA 0xFBD9 (-13)
0xFBE6  0xAA            TAX                     // TAX                               console.asm:582
0xFBE7  0xC9 0xDA       CMP # 0xDA              // CMP #Token.IDENTIFIER             console.asm:584
0xFBE9  0xD0 0x31       BNE 0xFC1C (+49)        // if (Z)                            console.asm:585
0xFBEB  0xDA            PHX                     // PHX    preserve X for default processing
0xFBEC  0x20 0x3C 0xBF  JSR 0xBF3C              // Tokenizer.GetTokenStringSTR();    console.asm:589
0xFBEF  0xA9 0x03       LDA # 0x03              // LDA # DirWalkAction.FindExecutable     only interested in executables
0xFBF1  0x20 0xBB 0xB0  JSR 0xB0BB              // File.Exists();    Input: ZP.STR, Output: C if exists
0xFBF4  0x90 0x22       BCC 0xFC18 (+34)        // if (C)                            console.asm:592
0xFBF6  0x20 0x25 0xBE  JSR 0xBE25              // Tokenizer.PeekToken();    just the identifier?  HEXDUMP vs HEXDUMP(1) or HEX = 10
0xFBF9  0xC9 0xDC       CMP # 0xDC              // CMP # Token.EOL                   console.asm:595
0xFBFB  0xD0 0x1E       BNE 0xFC1B (+30)        // if (Z)                            console.asm:596
0xFBFD  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();    consume filename - point of no return in terms of default processing below
0xFC00  0x90 0x12       BCC 0xFC14 (+18)        // if (C)                            console.asm:599
0xFC02  0x20 0x9D 0xFD  JSR 0xFD9D              // validateEndOfCommand();           console.asm:601
0xFC05  0x90 0x0D       BCC 0xFC14 (+13)        // if (C)                            console.asm:602
0xFC07  0xA9 0x01       LDA # 1                 // LDA #1    NEW first               console.asm:604
0xFC09  0x20 0x8F 0xB4  JSR 0xB48F              // Storage.LoadProgram();    Execute Identifier: Input: ZP.STR
0xFC0C  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:606
0xFC0F  0x90 0x03       BCC 0xFC14 (+3)         // if (C)                            console.asm:607
0xFC11  0x20 0xBC 0xFE  JSR 0xFEBC              // CmdRun();                         console.asm:609
0xFC14  0x97 0x02       SMB1 0x02               // SMB1 ZP.FLAGS     Always exit after auto load/run
0xFC16  0x80 0x03       BRA 0xFC1B (+3)         // }                                 console.asm:615
0xFC18  0x64 0x2D       STZ 0x2D                // STZ ZP.LastError                  console.asm:619
0xFC1A  0x38            SEC                     // SEC                               console.asm:620
0xFC1B  0xFA            PLX                     // PLX                               console.asm:623
0xFC1C  0x9F 0x02 0x16  BBS1 0x02, 0xFC35 (+22) // if (BBR1, ZP.FLAGS)               console.asm:626
0xFC1F  0x20 0x4C 0xBF  JSR 0xBF4C              // Tokenizer.Rollback();             console.asm:629
0xFC22  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();    preserves X
0xFC25  0xB0 0x04       BCS 0xFC2B (+4)         // if (NC)                           console.asm:633
0xFC27  0x97 0x02       SMB1 0x02               // SMB1 ZP.FLAGS    Set exit flag on error
0xFC29  0x80 0x0A       BRA 0xFC35 (+10)        // }                                 console.asm:636
0xFC2B  0x20 0xC6 0xDD  JSR 0xDDC6              // Statement.Execute();     Handles the current statement
0xFC2E  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:640
0xFC31  0xB0 0x02       BCS 0xFC35 (+2)         // if (NC)                           console.asm:641
0xFC33  0x97 0x02       SMB1 0x02               // SMB1 ZP.FLAGS    Set exit flag on error
0xFC35  0x9F 0x02 0x06  BBS1 0x02, 0xFC3E (+6)  // if (BBR1, ZP.FLAGS)     Only check if bit 1 is clear (continuing)
0xFC38  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               console.asm:653
0xFC3A  0xC9 0xDE       CMP # 0xDE              // CMP #Token.COLON                  console.asm:654
0xFC3C  0xD0 0x03       BNE 0xFC41 (+3)         // if (NZ) { break; }     No more statements on this line
0xFC3E  0x4C 0x97 0xFA  JMP 0xFA97              // }    loop through statements      console.asm:658
0xFC41  0x17 0x02       RMB1 0x02               // RMB1 ZP.FLAGS     Clean up: clear the exit flag before returning
0xFC43  0xFA            PLX                     // PLX                               console.asm:662
0xFC44  0x68            PLA                     // PLA                               console.asm:663
0xFC45  0x60            RTS                     // }                                 console.asm:664

// /source/projects/6502sbc/hopperbasic/console.asm:672
// ####  Console.checkFilename()  ####                                          0x02E4

0xFC46  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               console.asm:675
0xFC48  0xC9 0xDA       CMP # 0xDA              // CMP # Token.IDENTIFIER            console.asm:676
0xFC4A  0xF0 0x17       BEQ 0xFC63 (+23)        // if (NZ)                           console.asm:677
0xFC4C  0x20 0xB6 0x8B  JSR 0x8BB6              // Error.IllegalFilename();    default
0xFC4F  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               console.asm:680
0xFC51  0xC9 0xD8       CMP # 0xD8              // CMP # Token.STRINGLIT             console.asm:681
0xFC53  0xD0 0x05       BNE 0xFC5A (+5)         // if (Z)                            console.asm:682
0xFC55  0x20 0x80 0x8B  JSR 0x8B80              // Error.IdentifierExpected();       console.asm:684
0xFC58  0x80 0x07       BRA 0xFC61 (+7)         // }                                 console.asm:685
0xFC5A  0xC9 0xDC       CMP # 0xDC              // CMP # Token.EOL                   console.asm:688
0xFC5C  0xD0 0x03       BNE 0xFC61 (+3)         // if (Z)                            console.asm:689
0xFC5E  0x20 0xAC 0x8B  JSR 0x8BAC              // Error.FilenameExpected();         console.asm:691
0xFC61  0x18            CLC                     // CLC                               console.asm:694
0xFC62  0x60            RTS                     // break;                            console.asm:695
0xFC63  0x38            SEC                     // SEC                               console.asm:697
0xFC64  0x60            RTS                     // break;                            console.asm:698

// /source/projects/6502sbc/hopperbasic/console.asm:704
// ####  Console.parseSave()  ####                                              0x02E5

0xFC65  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:705
0xFC68  0x90 0x03       BCC 0xFC6D (+3)         // if (C)                            console.asm:706
0xFC6A  0x4C 0xE8 0x8B  JMP 0x8BE8              // Console.FunctionModeError();      console.asm:708
0xFC6D  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();    consume 'SAVE'
0xFC70  0x90 0x11       BCC 0xFC83 (+17)        // if (NC) { break; }                console.asm:715
0xFC72  0x20 0x46 0xFC  JSR 0xFC46              // checkFilename();                  console.asm:718
0xFC75  0x90 0x0C       BCC 0xFC83 (+12)        // if (NC) { BIT ZP.EmulatorPCL break; }
0xFC77  0x20 0x3C 0xBF  JSR 0xBF3C              // Tokenizer.GetTokenStringSTR();    console.asm:721
0xFC7A  0x20 0x2C 0xF9  JSR 0xF92C              // validateNextToken();   consume string
0xFC7D  0xB0 0x01       BCS 0xFC80 (+1)         // if (C) { Commands.CmdSave(); }    Uses ZP.STR
0xFC7F  0x60            RTS
0xFC80  0x4C 0xA1 0xF8  JMP 0xF8A1
0xFC83  0x60            RTS                     // }                                 console.asm:728

// /source/projects/6502sbc/hopperbasic/console.asm:732
// ####  Console.parseLoad()  ####                                              0x02E6

0xFC84  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:733
0xFC87  0x90 0x03       BCC 0xFC8C (+3)         // if (C)                            console.asm:734
0xFC89  0x4C 0xE8 0x8B  JMP 0x8BE8              // Console.FunctionModeError();      console.asm:736
0xFC8C  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();    consume 'LOAD'
0xFC8F  0x90 0x11       BCC 0xFCA2 (+17)        // if (NC) { break; }                console.asm:743
0xFC91  0x20 0x46 0xFC  JSR 0xFC46              // checkFilename();                  console.asm:746
0xFC94  0x90 0x0C       BCC 0xFCA2 (+12)        // if (NC) { BIT ZP.EmulatorPCL break; }
0xFC96  0x20 0x3C 0xBF  JSR 0xBF3C              // Tokenizer.GetTokenStringSTR();    Result in ZP.STR
0xFC99  0x20 0x2C 0xF9  JSR 0xF92C              // validateNextToken();    consume string
0xFC9C  0xB0 0x01       BCS 0xFC9F (+1)         // if (C) { Commands.CmdLoad(); }    Uses ZP.STR
0xFC9E  0x60            RTS
0xFC9F  0x4C 0xB9 0xF8  JMP 0xF8B9
0xFCA2  0x60            RTS                     // }                                 console.asm:756

// /source/projects/6502sbc/hopperbasic/console.asm:760
// ####  Console.parseDir()  ####                                               0x02E7

0xFCA3  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:761
0xFCA6  0x90 0x03       BCC 0xFCAB (+3)         // if (C)                            console.asm:762
0xFCA8  0x4C 0xE8 0x8B  JMP 0x8BE8              // Console.FunctionModeError();      console.asm:764
0xFCAB  0x20 0x2C 0xF9  JSR 0xF92C              // validateNextToken();    consume 'DIR'
0xFCAE  0xB0 0x01       BCS 0xFCB1 (+1)         // if (C) { Commands.CmdDir(); }     console.asm:769
0xFCB0  0x60            RTS
0xFCB1  0x4C 0xB0 0xAF  JMP 0xAFB0

// /source/projects/6502sbc/hopperbasic/console.asm:775
// ####  Console.parseDel()  ####                                               0x02E8

0xFCB4  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:776
0xFCB7  0x90 0x03       BCC 0xFCBC (+3)         // if (C)                            console.asm:777
0xFCB9  0x4C 0xE8 0x8B  JMP 0x8BE8              // Console.FunctionModeError();      console.asm:779
0xFCBC  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();    consume 'DEL'
0xFCBF  0x90 0x11       BCC 0xFCD2 (+17)        // if (NC) { break; }                console.asm:786
0xFCC1  0x20 0x46 0xFC  JSR 0xFC46              // checkFilename();                  console.asm:789
0xFCC4  0x90 0x0C       BCC 0xFCD2 (+12)        // if (NC) { BIT ZP.EmulatorPCL break; }
0xFCC6  0x20 0x3C 0xBF  JSR 0xBF3C              // Tokenizer.GetTokenStringSTR();    console.asm:792
0xFCC9  0x20 0x2C 0xF9  JSR 0xF92C              // validateNextToken();    consume string
0xFCCC  0xB0 0x01       BCS 0xFCCF (+1)         // if (C) { Commands.CmdDel(); }    Uses ZP.STR
0xFCCE  0x60            RTS
0xFCCF  0x4C 0x49 0xB0  JMP 0xB049
0xFCD2  0x60            RTS                     // }                                 console.asm:799

// /source/projects/6502sbc/hopperbasic/console.asm:803
// ####  Console.parseFormat()  ####                                            0x02E9

0xFCD3  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:804
0xFCD6  0x90 0x03       BCC 0xFCDB (+3)         // if (C)                            console.asm:805
0xFCD8  0x4C 0xE8 0x8B  JMP 0x8BE8              // Console.FunctionModeError();      console.asm:807
0xFCDB  0x20 0x2C 0xF9  JSR 0xF92C              // validateNextToken();    consume 'FORMAT'
0xFCDE  0xB0 0x01       BCS 0xFCE1 (+1)         // if (C) { Commands.CmdFormat(); }  console.asm:812
0xFCE0  0x60            RTS
0xFCE1  0x4C 0xBE 0xF8  JMP 0xF8BE

// /source/projects/6502sbc/hopperbasic/console.asm:819
// ####  Console.parseNew()  ####                                               0x02EA

0xFCE4  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:820
0xFCE7  0x90 0x03       BCC 0xFCEC (+3)         // if (C)                            console.asm:821
0xFCE9  0x4C 0xE8 0x8B  JMP 0x8BE8              // Console.FunctionModeError();      console.asm:823
0xFCEC  0x20 0x2C 0xF9  JSR 0xF92C              // validateNextToken();    consume 'NEW'
0xFCEF  0xB0 0x01       BCS 0xFCF2 (+1)         // if (C) { Commands.CmdNew(); }     console.asm:828
0xFCF1  0x60            RTS
0xFCF2  0x4C 0x5D 0xF5  JMP 0xF55D

// /source/projects/6502sbc/hopperbasic/console.asm:834
// ####  Console.parseClear()  ####                                             0x02EB

0xFCF5  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:835
0xFCF8  0x90 0x03       BCC 0xFCFD (+3)         // if (C)                            console.asm:836
0xFCFA  0x4C 0xE8 0x8B  JMP 0x8BE8              // Console.FunctionModeError();      console.asm:838
0xFCFD  0x20 0x2C 0xF9  JSR 0xF92C              // validateNextToken();    consume 'CLEAR'
0xFD00  0xB0 0x01       BCS 0xFD03 (+1)         // if (C) { Commands.CmdClear(); }   console.asm:843
0xFD02  0x60            RTS
0xFD03  0x4C 0x63 0xF5  JMP 0xF563

// /source/projects/6502sbc/hopperbasic/console.asm:849
// ####  Console.parseForget()  ####                                            0x02EC

0xFD06  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:850
0xFD09  0x90 0x03       BCC 0xFD0E (+3)         // if (C)                            console.asm:851
0xFD0B  0x4C 0xE8 0x8B  JMP 0x8BE8              // Console.FunctionModeError();      console.asm:853
0xFD0E  0x20 0xC3 0xBD  JSR 0xBDC3              // Tokenizer.NextTokenCheck();    consume 'FORGET'
0xFD11  0x90 0x15       BCC 0xFD28 (+21)        // if (NC) { break; }                console.asm:860
0xFD13  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               console.asm:863
0xFD15  0xC9 0xDA       CMP # 0xDA              // CMP #Token.IDENTIFIER             console.asm:864
0xFD17  0xF0 0x03       BEQ 0xFD1C (+3)         // if (NZ)                           console.asm:865
0xFD19  0x4C 0x7B 0x8B  JMP 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xFD1C  0x20 0x3C 0xBF  JSR 0xBF3C              // Tokenizer.GetTokenStringSTR();    console.asm:871
0xFD1F  0x20 0x2C 0xF9  JSR 0xF92C              // validateNextToken();    consume identifier
0xFD22  0xB0 0x01       BCS 0xFD25 (+1)         // if (C) { Commands.CmdForget(); }    Uses ZP.STR
0xFD24  0x60            RTS
0xFD25  0x4C 0xBB 0xF5  JMP 0xF5BB
0xFD28  0x60            RTS                     // }                                 console.asm:878

// /source/projects/6502sbc/hopperbasic/console.asm:882
// ####  Console.parseVars()  ####                                              0x02ED

0xFD29  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:883
0xFD2C  0x90 0x03       BCC 0xFD31 (+3)         // if (C)                            console.asm:884
0xFD2E  0x4C 0xE8 0x8B  JMP 0x8BE8              // Console.FunctionModeError();      console.asm:886
0xFD31  0x20 0x2C 0xF9  JSR 0xF92C              // validateNextToken();    consume 'VARS'
0xFD34  0xB0 0x01       BCS 0xFD37 (+1)         // if (C) { Commands.CmdVars(); }    console.asm:891
0xFD36  0x60            RTS
0xFD37  0x4C 0xCF 0xF5  JMP 0xF5CF

// /source/projects/6502sbc/hopperbasic/console.asm:897
// ####  Console.parseList()  ####                                              0x02EE

0xFD3A  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:898
0xFD3D  0x90 0x03       BCC 0xFD42 (+3)         // if (C)                            console.asm:899
0xFD3F  0x4C 0xE8 0x8B  JMP 0x8BE8              // Console.FunctionModeError();      console.asm:901
0xFD42  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no, consume 'LIST'
0xFD45  0x20 0x88 0xFD  JSR 0xFD88              // parseOptionalIdentifier();    Sets ZP.STR or null
0xFD48  0x20 0x9D 0xFD  JSR 0xFD9D              // validateEndOfCommand();           console.asm:907
0xFD4B  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:908
0xFD4E  0xB0 0x01       BCS 0xFD51 (+1)         // if (C) { Commands.CmdList(); }    Uses ZP.STR (null = all)
0xFD50  0x60            RTS
0xFD51  0x4C 0xF4 0xF5  JMP 0xF5F4

// /source/projects/6502sbc/hopperbasic/console.asm:915
// ####  Console.parseFuncs()  ####                                             0x02EF

0xFD54  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:916
0xFD57  0x90 0x03       BCC 0xFD5C (+3)         // if (C)                            console.asm:917
0xFD59  0x4C 0xE8 0x8B  JMP 0x8BE8              // Console.FunctionModeError();      console.asm:919
0xFD5C  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no, consume 'FUNCS'
0xFD5F  0x20 0x88 0xFD  JSR 0xFD88              // parseOptionalIdentifier();    Sets ZP.STR or null
0xFD62  0x20 0x9D 0xFD  JSR 0xFD9D              // validateEndOfCommand();           console.asm:925
0xFD65  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:926
0xFD68  0xB0 0x01       BCS 0xFD6B (+1)         // if (C) { Commands.CmdFuncs(); }    Uses ZP.STR (null = all)
0xFD6A  0x60            RTS
0xFD6B  0x4C 0x34 0xF6  JMP 0xF634

// /source/projects/6502sbc/hopperbasic/console.asm:933
// ####  Console.parseMem()  ####                                               0x02F0

0xFD6E  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:934
0xFD71  0x90 0x03       BCC 0xFD76 (+3)         // if (C)                            console.asm:935
0xFD73  0x4C 0xE8 0x8B  JMP 0x8BE8              // Console.FunctionModeError();      console.asm:937
0xFD76  0x20 0x2C 0xF9  JSR 0xF92C              // validateNextToken();    consume 'MEM'
0xFD79  0xB0 0x01       BCS 0xFD7C (+1)         // if (C) { Commands.CmdMem(); }     console.asm:942
0xFD7B  0x60            RTS
0xFD7C  0x4C 0x69 0xF5  JMP 0xF569

// /source/projects/6502sbc/hopperbasic/console.asm:948
// ####  Console.parseBye()  ####                                               0x02F1

0xFD7F  0x20 0x2C 0xF9  JSR 0xF92C              // validateNextToken();    consume 'BYE'
0xFD82  0xB0 0x01       BCS 0xFD85 (+1)         // if (C) { Commands.CmdBye(); }     console.asm:950
0xFD84  0x60            RTS
0xFD85  0x4C 0xC2 0x89  JMP 0x89C2

// /source/projects/6502sbc/hopperbasic/console.asm:1059
// ####  Console.parseOptionalIdentifier()  ####                                0x02F2

0xFD88  0x48            PHA                     // PHA                               console.asm:1060
0xFD89  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               console.asm:1062
0xFD8B  0xC9 0xDA       CMP # 0xDA              // CMP #Token.IDENTIFIER             console.asm:1063
0xFD8D  0xD0 0x08       BNE 0xFD97 (+8)         // if (Z)                            console.asm:1064
0xFD8F  0x20 0x3C 0xBF  JSR 0xBF3C              // Tokenizer.GetTokenStringSTR();    console.asm:1066
0xFD92  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no, consume identifier
0xFD95  0x80 0x04       BRA 0xFD9B (+4)         // }                                 console.asm:1069
0xFD97  0x64 0x79       STZ 0x79                // STZ ZP.STRL                       console.asm:1073
0xFD99  0x64 0x7A       STZ 0x7A                // STZ ZP.STRH                       console.asm:1074
0xFD9B  0x68            PLA                     // PLA                               console.asm:1077
0xFD9C  0x60            RTS                     // }                                 console.asm:1078

// /source/projects/6502sbc/hopperbasic/console.asm:1082
// ####  Console.validateEndOfCommand()  ####                                   0x02F3

0xFD9D  0x48            PHA                     // PHA                               console.asm:1083
0xFD9E  0xA5 0x2F       LDA 0x2F                // LDA ZP.CurrentToken               console.asm:1085
0xFDA0  0xC9 0xDC       CMP # 0xDC              // case Token.EOL:                   console.asm:1088
0xFDA2  0xF0 0x08       BEQ 0xFDAC (+8)
0xFDA4  0xC9 0xDE       CMP # 0xDE              // case Token.COLON:                 console.asm:1089
0xFDA6  0xF0 0x04       BEQ 0xFDAC (+4)
0xFDA8  0xC9 0x95       CMP # 0x95              // case Token.COMMENT:               console.asm:1090
0xFDAA  0xD0 0x03       BNE 0xFDAF (+3)
0xFDAC  0x38            SEC                     // SEC     Valid end                 console.asm:1092
0xFDAD  0x80 0x04       BRA 0xFDB3 (+4)         // }                                 console.asm:1093
0xFDAF  0x20 0x7B 0x8B  JSR 0x8B7B              // Error.SyntaxError(); BIT ZP.EmulatorPCL
0xFDB2  0x18            CLC                     // CLC                               console.asm:1097
0xFDB3  0x68            PLA                     // PLA                               console.asm:1100
0xFDB4  0x60            RTS                     // }                                 console.asm:1101

// /source/projects/6502sbc/hopperbasic/console.asm:1111
// ####  Console.InitializeGlobals()  ####                                      0x02F4

0xFDB5  0xDA            PHX                     // PHX                               console.asm:1112
0xFDB6  0x5A            PHY                     // PHY                               console.asm:1113
0xFDB7  0x3F 0xA2 0x05  BBR3 0xA2, 0xFDBF (+5)  // if (BBS3, Storage.LoaderFlags)    console.asm:1121
0xFDBA  0x20 0x6C 0xA3  JSR 0xA36C              // Variables.IterateAll();           console.asm:1123
0xFDBD  0x80 0x03       BRA 0xFDC2 (+3)         // }                                 console.asm:1124
0xFDBF  0x20 0x50 0xA3  JSR 0xA350              // Variables.IterateVariables();     console.asm:1127
0xFDC2  0xB0 0x04       BCS 0xFDC8 (+4)         // if (NC)                           console.asm:1136
0xFDC4  0x38            SEC                     // SEC break;    No more variables - success
0xFDC5  0x4C 0xB5 0xFE  JMP 0xFEB5
0xFDC8  0x20 0x89 0x96  JSR 0x9689              // BufferManager.InitializeForTokenGeneration();
0xFDCB  0x20 0xC9 0xA2  JSR 0xA2C9              // Variables.GetName();    -> ZP.STR console.asm:1145
0xFDCE  0x20 0xD9 0xA2  JSR 0xA2D9              // Variables.GetTokens();    Returns tokens pointer in ZP.NEXT
0xFDD1  0x20 0xA9 0xA2  JSR 0xA2A9              // Variables.GetType();    -> ZP.ACCT
0xFDD4  0xA5 0x1B       LDA 0x1B                // LDA ZP.IDXL                       console.asm:1151
0xFDD6  0x85 0x82       STA 0x82                // STA ZP.GVIL                       console.asm:1152
0xFDD8  0xA5 0x1C       LDA 0x1C                // LDA ZP.IDXH                       console.asm:1153
0xFDDA  0x85 0x83       STA 0x83                // STA ZP.GVIH                       console.asm:1154
0xFDDC  0x5F 0x10 0x59  BBR5 0x10, 0xFE38 (+89) // if (BBS5, ZP.ACCT)    Bit 5 - ARRAY
0xFDDF  0x20 0xEA 0xA1  JSR 0xA1EA              // Variables.GetValue();    Variable = IDX: BASICArray -> TOP, Tokens -> NEXT
0xFDE2  0xB2 0x16       LDA [0x16]              // LDA [ZP.NEXT]                     console.asm:1165
0xFDE4  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL    TODO : switch to EOF
0xFDE6  0xD0 0x07       BNE 0xFDEF (+7)         // if (Z)                            console.asm:1167
0xFDE8  0xA9 0xDB       LDA # 0xDB              // LDA #Token.EOF                    console.asm:1169
0xFDEA  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1170
0xFDED  0x80 0x11       BRA 0xFE00 (+17)        // break;    Found EOL terminator    console.asm:1171
0xFDEF  0xC9 0xDB       CMP # 0xDB              // CMP #Token.EOF                    console.asm:1173
0xFDF1  0xD0 0x05       BNE 0xFDF8 (+5)         // if (Z)                            console.asm:1174
0xFDF3  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1176
0xFDF6  0x80 0x08       BRA 0xFE00 (+8)         // break;    Found EOF terminator    console.asm:1177
0xFDF8  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1179
0xFDFB  0x20 0x69 0x93  JSR 0x9369              // IncNEXT();                        console.asm:1180
0xFDFE  0x80 0xE2       BRA 0xFDE2 (-30)        // }                                 console.asm:1181
0xFE00  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL              console.asm:1183
0xFE02  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              console.asm:1184
0xFE04  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no, Get first token
0xFE07  0x47 0x02       RMB4 0x02               // RMB4 ZP.FLAGS    Bit 4 - initialization mode: Load and Save globals to stack (ExecuteOpCodes) - except for ZP.GVI
0xFE09  0xD7 0x02       SMB5 0x02               // SMB5 ZP.FLAGS    Bit 5 - initialization mode: do not create a RETURN slot for REPL calls (in compileFunctionCallOrVariable)
0xFE0B  0x20 0x53 0xDD  JSR 0xDD53              // Statement.EvaluateExpression();    EXECUTION: re-initialize ARRAY (size expression)- GLOBAL LOAD SAVE (except current variable, GVI)
0xFE0E  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:1192
0xFE11  0xB0 0x04       BCS 0xFE17 (+4)         // if (NC)                           console.asm:1193
0xFE13  0x18            CLC                     // CLC                               console.asm:1196
0xFE14  0x4C 0xB5 0xFE  JMP 0xFEB5              // break;                            console.asm:1197
0xFE17  0xA5 0x82       LDA 0x82                // LDA ZP.GVIL                       console.asm:1202
0xFE19  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       console.asm:1203
0xFE1B  0xA5 0x83       LDA 0x83                // LDA ZP.GVIH                       console.asm:1204
0xFE1D  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       console.asm:1205
0xFE1F  0x20 0xEA 0xA1  JSR 0xA1EA              // Variables.GetValue();    Variable = IDX: BASICArray -> TOP, Tokens -> NEXT, Element type -> ZP.TOPT
0xFE22  0x20 0x8D 0x94  JSR 0x948D              // Stacks.PopNext();    newly calculated array dimension
0xFE25  0x20 0x81 0xAC  JSR 0xAC81              // BASICArray.Redimension();         console.asm:1214
0xFE28  0xB0 0x03       BCS 0xFE2D (+3)         // if (NC)                           console.asm:1216
0xFE2A  0x4C 0xB5 0xFE  JMP 0xFEB5              // break;                            console.asm:1218
0xFE2D  0xA5 0x15       LDA 0x15                // LDA ZP.TOPT                       console.asm:1221
0xFE2F  0x09 0x20       ORA # 0x20              // ORA # BASICType.ARRAY             console.asm:1222
0xFE31  0x85 0x15       STA 0x15                // STA ZP.TOPT                       console.asm:1223
0xFE33  0x20 0x0A 0xA2  JSR 0xA20A              // Variables.SetValue();    does not free old ARRAY
0xFE36  0x80 0x77       BRA 0xFEAF (+119)       // }    ARRAY                        console.asm:1225
0xFE38  0xA5 0x16       LDA 0x16                // LDA ZP.NEXTL                      console.asm:1229
0xFE3A  0x05 0x17       ORA 0x17                // ORA ZP.NEXTH                      console.asm:1230
0xFE3C  0xD0 0x38       BNE 0xFE76 (+56)        // if (Z)                            console.asm:1231
0xFE3E  0xA5 0x10       LDA 0x10                // LDA ZP.ACCT                       console.asm:1233
0xFE40  0x29 0x3F       AND # 0x3F              // AND # BASICType.MASK              console.asm:1234
0xFE42  0xC9 0x05       CMP # 0x05              // case BASICType.STRING:            console.asm:1237
0xFE44  0xD0 0x0C       BNE 0xFE52 (+12)
0xFE46  0xA9 0xD8       LDA # 0xD8              // LDA # Token.STRINGLIT             console.asm:1239
0xFE48  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1240
0xFE4B  0xA9 0x00       LDA # 0                 // LDA #0x00                         console.asm:1242
0xFE4D  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1243
0xFE50  0x80 0x1D       BRA 0xFE6F (+29)        // }                                 console.asm:1244
0xFE52  0xC9 0x06       CMP # 0x06              // case BASICType.BIT:               console.asm:1245
0xFE54  0xD0 0x07       BNE 0xFE5D (+7)
0xFE56  0xA9 0xBD       LDA # 0xBD              // LDA #Token.FALSE                  console.asm:1247
0xFE58  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1248
0xFE5B  0x80 0x12       BRA 0xFE6F (+18)        // }                                 console.asm:1249
0xFE5D  0xDF 0x10 0x0F  BBS5 0x10, 0xFE6F (+15) // if (BBR5, ZP.ACCT)    Bit 5 - ARRAY?
0xFE60  0xA9 0xD7       LDA # 0xD7              // LDA #Token.NUMBER                 console.asm:1255
0xFE62  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1256
0xFE65  0xA9 0x30       LDA # 0x30              // LDA #'0'                          console.asm:1259
0xFE67  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1260
0xFE6A  0xA9 0x00       LDA # 0                 // LDA #0x00                         console.asm:1263
0xFE6C  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1264
0xFE6F  0xA9 0xDB       LDA # 0xDB              // LDA #Token.EOF                    console.asm:1278
0xFE71  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1279
0xFE74  0x80 0x15       BRA 0xFE8B (+21)        // }                                 console.asm:1280
0xFE76  0xB2 0x16       LDA [0x16]              // LDA [ZP.NEXT]                     console.asm:1287
0xFE78  0xC9 0xDC       CMP # 0xDC              // CMP #Token.EOL    TODO : switch to EOF
0xFE7A  0xD0 0x07       BNE 0xFE83 (+7)         // if (Z)                            console.asm:1289
0xFE7C  0xA9 0xDB       LDA # 0xDB              // LDA #Token.EOF                    console.asm:1291
0xFE7E  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1292
0xFE81  0x80 0x08       BRA 0xFE8B (+8)         // break;    Found EOL terminator    console.asm:1293
0xFE83  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1295
0xFE86  0x20 0x69 0x93  JSR 0x9369              // IncNEXT();                        console.asm:1296
0xFE89  0x80 0xEB       BRA 0xFE76 (-21)        // }                                 console.asm:1297
0xFE8B  0x64 0x2B       STZ 0x2B                // STZ ZP.TokenizerPosL              console.asm:1299
0xFE8D  0x64 0x2C       STZ 0x2C                // STZ ZP.TokenizerPosH              console.asm:1300
0xFE8F  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    on, Get first token
0xFE92  0xC7 0x02       SMB4 0x02               // SMB4 ZP.FLAGS    Bit 4 - initialization mode: Load and Save globals to stack (ExecuteOpCodes) - except for ZP.GVI
0xFE94  0xD7 0x02       SMB5 0x02               // SMB5 ZP.FLAGS    Bit 5 - initialization mode: do not create a RETURN slot for REPL calls (in compileFunctionCallOrVariable)
0xFE96  0x20 0x53 0xDD  JSR 0xDD53              // Statement.EvaluateExpression();    EXECUTION: re-initialize global variable (RHS expression) - GLOBAL LOAD SAVE (except current variable, GVI)
0xFE99  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:1309
0xFE9C  0xB0 0x03       BCS 0xFEA1 (+3)         // if (NC)                           console.asm:1310
0xFE9E  0x18            CLC                     // CLC                               console.asm:1313
0xFE9F  0x80 0x14       BRA 0xFEB5 (+20)        // break;                            console.asm:1314
0xFEA1  0xA5 0x82       LDA 0x82                // LDA ZP.GVIL                       console.asm:1319
0xFEA3  0x85 0x1B       STA 0x1B                // STA ZP.IDXL                       console.asm:1320
0xFEA5  0xA5 0x83       LDA 0x83                // LDA ZP.GVIH                       console.asm:1321
0xFEA7  0x85 0x1C       STA 0x1C                // STA ZP.IDXH                       console.asm:1322
0xFEA9  0x20 0xEB 0x98  JSR 0x98EB              // Long.PopTop();    includes ZP.TOPT
0xFEAC  0x20 0x0A 0xA2  JSR 0xA20A              // Variables.SetValue();             console.asm:1326
0xFEAF  0x20 0x08 0xA0  JSR 0xA008              // Variables.IterateNext();          console.asm:1330
0xFEB2  0x4C 0xC2 0xFD  JMP 0xFDC2              // }    iterate variables loop       console.asm:1331
0xFEB5  0x64 0x82       STZ 0x82                // STZ ZP.GVIL                       console.asm:1333
0xFEB7  0x64 0x83       STZ 0x83                // STZ ZP.GVIH                       console.asm:1334
0xFEB9  0x7A            PLY                     // PLY                               console.asm:1339
0xFEBA  0xFA            PLX                     // PLX                               console.asm:1340
0xFEBB  0x60            RTS                     // }                                 console.asm:1341

// /source/projects/6502sbc/hopperbasic/console.asm:1350
// ####  Console.CmdRun()  ####                                                 0x02F5

0xFEBC  0x20 0x18 0xDD  JSR 0xDD18              // Statement.IsCaptureModeOn();      console.asm:1355
0xFEBF  0x90 0x05       BCC 0xFEC6 (+5)         // if (C)                            console.asm:1356
0xFEC1  0x20 0xE8 0x8B  JSR 0x8BE8              // Console.FunctionModeError();      console.asm:1358
0xFEC4  0x80 0x4C       BRA 0xFF12 (+76)        // }                                 console.asm:1359
0xFEC6  0x64 0xA2       STZ 0xA2                // STZ Storage.LoaderFlags    clear Bit 3
0xFEC8  0x20 0xB5 0xFD  JSR 0xFDB5              // InitializeGlobals();              console.asm:1365
0xFECB  0x20 0x16 0x86  JSR 0x8616              // Messages.Main();    point ZP.TOP -> "$MAIN"
0xFECE  0x20 0x99 0xA7  JSR 0xA799              // Functions.Find();    Input: ZP.TOP = "$MAIN", Output: ZP.IDX if found
0xFED1  0xB0 0x09       BCS 0xFEDC (+9)         // if (NC)                           console.asm:1373
0xFED3  0xA9 0x36       LDA # 0x36              // LDA # ErrorID.NoProgram LDX # MessageExtras.None Error.MessageNL();
0xFED5  0xA2 0x00       LDX # 0
0xFED7  0x20 0xE3 0x8A  JSR 0x8AE3
0xFEDA  0x80 0x36       BRA 0xFF12 (+54)        // break;                            console.asm:1376
0xFEDC  0x20 0x89 0x96  JSR 0x9689              // BufferManager.InitializeForTokenGeneration();
0xFEDF  0x20 0xCB 0xA7  JSR 0xA7CB              // Functions.GetName();    Input: ZP.IDX, Output: ZP.STR = name pointer
0xFEE2  0xA9 0xDA       LDA # 0xDA              // LDA #Token.IDENTIFIER             console.asm:1386
0xFEE4  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();    munts IDX!
0xFEE7  0xA2 0x00       LDX # 0                 // LDX #0                            console.asm:1390
0xFEE9  0xBD 0xBD 0x83  LDA 0x83BD,X            // LDA Messages.BeginFunctionName, X console.asm:1393
0xFEEC  0xD0 0x05       BNE 0xFEF3 (+5)         // if (Z)                            console.asm:1394
0xFEEE  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1396
0xFEF1  0x80 0x06       BRA 0xFEF9 (+6)         // break;                            console.asm:1397
0xFEF3  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1399
0xFEF6  0xE8            INX                     // INX                               console.asm:1400
0xFEF7  0x80 0xF0       BRA 0xFEE9 (-16)        // }                                 console.asm:1401
0xFEF9  0xA9 0xE4       LDA # 0xE4              // LDA #Token.LPAREN                 console.asm:1403
0xFEFB  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1404
0xFEFE  0xA9 0xE5       LDA # 0xE5              // LDA #Token.RPAREN                 console.asm:1406
0xFF00  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1407
0xFF03  0xA9 0xDB       LDA # 0xDB              // LDA #Token.EOF                    console.asm:1409
0xFF05  0x20 0x02 0xBA  JSR 0xBA02              // Tokenizer.appendToTokenBuffer();  console.asm:1410
0xFF08  0x20 0xD2 0xBD  JSR 0xBDD2              // Tokenizer.NextToken();    no      console.asm:1413
0xFF0B  0xC7 0x02       SMB4 0x02               // SMB4 ZP.FLAGS    Bit 4 - initialization mode: Load and Save globals to stack (ExecuteOpCodes)
0xFF0D  0xD7 0x02       SMB5 0x02               // SMB5 ZP.FLAGS    Bit 5 - initialization mode: do not create a RETURN slot for REPL calls (in compileFunctionCallOrVariable)
0xFF0F  0x20 0x53 0xDD  JSR 0xDD53              // Statement.EvaluateExpression();    executes 'identifier()' as function call- GLOBAL LOAD SAVE
0xFF12  0x20 0x59 0x8C  JSR 0x8C59              // CheckError();                     console.asm:1425
0xFF15  0xB0 0x09       BCS 0xFF20 (+9)         // if (NC)                           console.asm:1428
0xFF17  0x20 0xA1 0x89  JSR 0x89A1              // States.IsExiting();               console.asm:1430
0xFF1A  0xB0 0x01       BCS 0xFF1D (+1)         // if (C)                            console.asm:1431
0xFF1C  0x60            RTS
0xFF1D  0x64 0x4E       STZ 0x4E                // States.SetFailure();    don't "BYE" if we have a failure (probably syntax error from Executor)
0xFF1F  0x60            RTS                     // }                                 console.asm:1435
0xFF20  0x20 0xA1 0x89  JSR 0x89A1              // States.IsExiting();               console.asm:1438
0xFF23  0xB0 0x01       BCS 0xFF26 (+1)         // if (C)                            console.asm:1439
0xFF25  0x60            RTS
0xFF26  0x4C 0xBB 0x89  JMP 0x89BB              // States.SetSuccess();    don't "BYE" if we are just Exiting REPL

// /source/projects/6502sbc/hopperbasic/basic.asm:93
// ####  HopperBASIC.InitializeBASIC()  ####                                    0x02F7

0xFF29  0xA2 0x00       LDX # 0                 // LDX #0                            basic.asm:95
0xFF2B  0xE0 0xED       CPX # 0xED              // CPX # ZP.ACIADATA    don't write to ACIA data register
0xFF2D  0xF0 0x02       BEQ 0xFF31 (+2)         // if (NZ)                           basic.asm:99
0xFF2F  0x74 0x00       STZ 0x00,X              // STZ 0x00, X                       basic.asm:101
0xFF31  0xCA            DEX                     // DEX                               basic.asm:103
0xFF32  0xD0 0xF7       BNE 0xFF2B (-9)         // if (Z) { break; }                 basic.asm:104
0xFF34  0x20 0x4C 0x8C  JSR 0x8C4C              // Error.ClearError();               basic.asm:109
0xFF37  0x20 0xBB 0x89  JSR 0x89BB              // States.SetSuccess();       Initialize state system
0xFF3A  0x20 0x51 0x8D  JSR 0x8D51              // Serial.Initialize();              basic.asm:114
0xFF3D  0x20 0x43 0x95  JSR 0x9543              // Parallel.Initialize();            basic.asm:115
0xFF40  0x20 0x59 0x92  JSR 0x9259              // Memory.InitializeHeapSize();      basic.asm:118
0xFF43  0x20 0x9A 0x93  JSR 0x939A              // Stacks.Initialize();              basic.asm:119
0xFF46  0x64 0x82       STZ 0x82                // STZ ZP.GVIL                       basic.asm:122
0xFF48  0x64 0x83       STZ 0x83                // STZ ZP.GVIH                       basic.asm:123
0xFF4A  0x64 0x02       STZ 0x02                // STZ ZP.FLAGS                      basic.asm:126
0xFF4C  0x27 0x02       RMB2 0x02               // RMB2 ZP.FLAGS     TROFF by default
0xFF4E  0x20 0x38 0xAE  JSR 0xAE38              // EEPROM.Initialize();              basic.asm:135
0xFF51  0x20 0x35 0xF9  JSR 0xF935              // Console.Initialize();     This now initializes the tokenizer too
0xFF54  0xA9 0x0C       LDA # 0x0C              // LDA #(Address.TokenizerBuffer / 256)
0xFF56  0x85 0xAA       STA 0xAA                // STA ZP.TokenizerBuffer            basic.asm:142
0xFF58  0xA9 0x08       LDA # 0x08              // LDA #(Limits.TokenizerBufferSize / 256)
0xFF5A  0x85 0xAB       STA 0xAB                // STA ZP.TokenizerBufferSize        basic.asm:144
0xFF5C  0x60            RTS                     // }                                 basic.asm:146

// /source/projects/6502sbc/hopperbasic/basic.asm:151
// ####  HopperBASIC.printStartupBanner()  ####                                 0x02F8

0xFF5D  0x64 0x79       STZ 0x79                // STA ZP.STRL                       basic.asm:154
0xFF5F  0xA9 0x80       LDA # 0x80              // LDA #(Messages.Welcome / 256)     basic.asm:155
0xFF61  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       basic.asm:156
0xFF63  0x20 0x9D 0x95  JSR 0x959D              // Print.String();                   basic.asm:157
0xFF66  0x4C 0x69 0xF5  JMP 0xF569              // Commands.CmdMem();                basic.asm:159

// /source/projects/6502sbc/hopperbasic/basic.asm:164
// ####  HopperBASIC.interpreterLoop()  ####                                    0x02F9

0xFF69  0xA9 0x14       LDA # 0x14              // LDA #(Messages.AutoexecName % 256)
0xFF6B  0x85 0x79       STA 0x79                // STA ZP.STRL                       basic.asm:168
0xFF6D  0xA9 0x80       LDA # 0x80              // LDA #(Messages.AutoexecName / 256)
0xFF6F  0x85 0x7A       STA 0x7A                // STA ZP.STRH                       basic.asm:170
0xFF71  0xA9 0x03       LDA # 0x03              // LDA # DirWalkAction.FindExecutable
0xFF73  0x20 0xBB 0xB0  JSR 0xB0BB              // File.Exists();                    basic.asm:172
0xFF76  0x90 0x08       BCC 0xFF80 (+8)         // if (C)                            basic.asm:173
0xFF78  0x20 0x8F 0xB4  JSR 0xB48F              // Storage.LoadProgram();            basic.asm:175
0xFF7B  0x90 0x03       BCC 0xFF80 (+3)         // if (C) { Console.CmdRun(); }      basic.asm:176
0xFF7D  0x20 0xBC 0xFE  JSR 0xFEBC
0xFF80  0xA2 0x00       LDX # 0                 // LDX # MessageExtras.None          basic.asm:182
0xFF82  0xA9 0x3F       LDA # 0x3F              // LDA # ErrorID.ReadyPrompt Error.Message();
0xFF84  0x20 0xE9 0x8A  JSR 0x8AE9
0xFF87  0x20 0xE5 0x96  JSR 0x96E5              // BufferManager.ResetInputBuffer(); basic.asm:187
0xFF8A  0x20 0x43 0xF9  JSR 0xF943              // Console.ReadLine();               basic.asm:190
0xFF8D  0x20 0x7C 0x8C  JSR 0x8C7C              // Error.CheckErrorAndStatus();      basic.asm:193
0xFF90  0xB0 0x0A       BCS 0xFF9C (+10)        // if (NC)                           basic.asm:194
0xFF92  0x20 0xA1 0x89  JSR 0x89A1              // States.IsExiting();               basic.asm:196
0xFF95  0xB0 0x52       BCS 0xFFE9 (+82)        // if (C)                            basic.asm:197
0xFF97  0x20 0x97 0x8C  JSR 0x8C97              // Error.CheckAndPrint();            basic.asm:201
0xFF9A  0x80 0xEB       BRA 0xFF87 (-21)        // continue;    Error during input, show prompt again
0xFF9C  0xA5 0x28       LDA 0x28                // LDA ZP.BasicInputLength           basic.asm:206
0xFF9E  0xD0 0x0A       BNE 0xFFAA (+10)        // if (Z)                            basic.asm:207
0xFFA0  0xA9 0x3E       LDA # 0x3E              // LDA #'>'                          basic.asm:210
0xFFA2  0x20 0x2B 0x8D  JSR 0x8D2B              // Serial.WriteChar();               basic.asm:211
0xFFA5  0x20 0xBB 0x95  JSR 0x95BB              // Print.Space();                    basic.asm:212
0xFFA8  0x80 0xDD       BRA 0xFF87 (-35)        // continue;                         basic.asm:213
0xFFAA  0x67 0x02       RMB6 0x02               // RMB6 ZP.FLAGS    Bit 6 - track output was produced by REPL command
0xFFAC  0x64 0xA6       STZ 0xA6                // STZ ZP.IDCALLL    No function has been called
0xFFAE  0x64 0xA7       STZ 0xA7                // STZ ZP.IDCALLH                    basic.asm:220
0xFFB0  0x20 0x64 0xF9  JSR 0xF964              // Console.ProcessLine();            basic.asm:223
0xFFB3  0x20 0xA1 0x89  JSR 0x89A1              // States.IsExiting();               basic.asm:226
0xFFB6  0xB0 0x31       BCS 0xFFE9 (+49)        // if (C) { break; }    BYE command - clean exit
0xFFB8  0x38            SEC                     // SEC    still ok, just not exiting basic.asm:229
0xFFB9  0x20 0x59 0x8C  JSR 0x8C59              // Error.CheckError();    but check for IsFailure or ZP.LastError ..
0xFFBC  0xB0 0x0E       BCS 0xFFCC (+14)        // if (NC)                           basic.asm:231
0xFFBE  0xA5 0xA6       LDA 0xA6                // LDA ZP.IDCALLL                    basic.asm:242
0xFFC0  0x05 0xA7       ORA 0xA7                // ORA ZP.IDCALLH                    basic.asm:243
0xFFC2  0xF0 0x03       BEQ 0xFFC7 (+3)         // if (NZ)                           basic.asm:244
0xFFC4  0x20 0x58 0xA9  JSR 0xA958              // Functions.CompileForError();      basic.asm:250
0xFFC7  0x20 0x97 0x8C  JSR 0x8C97              // Error.CheckAndPrint();            basic.asm:254
0xFFCA  0x80 0x0F       BRA 0xFFDB (+15)        // }                                 basic.asm:255
0xFFCC  0xEF 0x02 0x0C  BBS6 0x02, 0xFFDB (+12) // if (BBR6, ZP.FLAGS)     Bit 6 clear - no output produced by last REPL command
0xFFCF  0x20 0x0F 0xDD  JSR 0xDD0F              // Statement.IsCaptureModeOff();     basic.asm:261
0xFFD2  0x90 0x07       BCC 0xFFDB (+7)         // if (C)                            basic.asm:262
0xFFD4  0xA2 0x00       LDX # 0                 // LDX # MessageExtras.None          basic.asm:264
0xFFD6  0xA9 0x40       LDA # 0x40              // LDA # ErrorID.OKPrompt Error.MessageNL();
0xFFD8  0x20 0xE3 0x8A  JSR 0x8AE3
0xFFDB  0x20 0x0F 0xDD  JSR 0xDD0F              // Statement.IsCaptureModeOff();     basic.asm:271
0xFFDE  0x90 0xA7       BCC 0xFF87 (-89)        // if (C)                            basic.asm:272
0xFFE0  0xA2 0x00       LDX # 0                 // LDX # MessageExtras.None          basic.asm:274
0xFFE2  0xA9 0x3F       LDA # 0x3F              // LDA # ErrorID.ReadyPrompt Error.Message();
0xFFE4  0x20 0xE9 0x8A  JSR 0x8AE9
0xFFE7  0x80 0x9E       BRA 0xFF87 (-98)        // }                                 basic.asm:277
0xFFE9  0x60            RTS                     // }                                 basic.asm:278

// /source/projects/6502sbc/hopperbasic/basic.asm:282
// ####  HopperBASIC.IRQ()  ####                                                0x02FA

0xFFEA  0x20 0x5C 0x8D  JSR 0x8D5C              // Serial.ISR();                     basic.asm:283
0xFFED  0x20 0x56 0x95  JSR 0x9556              // Parallel.ISR();                   basic.asm:284
0xFFF0  0x40            RTI                     // }                                 basic.asm:285

// /source/projects/6502sbc/hopperbasic/basic.asm:288
// ####  HopperBASIC.NMI()  ####                                                0x02FB

0xFFF1  0x87 0x0C       SMB0 0x0C               // SMB0 ZP.SerialFlags               basic.asm:290
0xFFF3  0x40            RTI                     // }                                 basic.asm:291

0xFFFA 0xFFF1 // NMI vector
0xFFFC 0x8606 // Reset vector
0xFFFE 0xFFEA // IRQ vector
