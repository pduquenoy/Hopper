# Analyzing Hopper C Compiler 6502 Output - Debugging Guide

## Overview
This guide provides a systematic approach to analyzing and debugging 6502 assembly code generated by the Hopper C compiler. The compiler generates code that uses a parallel 32-bit stack implementation on top of the 6502's native 8-bit stack.

## Key Concepts to Understand First

### 1. The 6502 Stack Pointer Behavior
**Critical:** The 6502 SP register points to the **next free location**, not the current top of stack.
- After PHA: SP is decremented (SP points to next free slot)
- After PLA: SP is incremented (SP points to the just-freed slot)
- To read the top of stack, you need to use SP+1 or PLA then use SP

### 2. Parallel 32-bit Stack Architecture
The Hopper C compiler implements a 32-bit stack using four parallel pages:
- `ZP.runtimeStack0L/H` - Byte 0 (LSB)
- `ZP.runtimeStack1L/H` - Byte 1
- `ZP.runtimeStack2L/H` - Byte 2  
- `ZP.runtimeStack3L/H` - Byte 3 (MSB)

The native 6502 stack (via PHA/PLA) is used solely for SP management, not for actual data storage.

### 3. VCode Instructions
The compiler generates VCode (Virtual Code) instructions, with NOP instructions marking boundaries between them. This makes the disassembly easier to follow.

## Analysis Process

### Step 1: Identify the Structure

1. **Entry point** - Usually a JMP to initialization code
2. **BIOS dispatcher** - The indirect jump through `[ZP.BIOSDISPATCH]`
3. **Initialization** - Memory allocation and stack setup
4. **Function prologue** - Stack frame setup
5. **Function body** - The actual code
6. **Function epilogue** - Stack frame cleanup

### Step 2: Understand Stack Operations

#### PUSH Operation Pattern:
```
TSX         ; Get current SP
TXA         ; Transfer to A
TAY         ; Transfer to Y (Y = free slot)
LDA #value  ; Load value to push
STA [ZP.runtimeStackXL], Y  ; Store to parallel stack
PHA         ; Increment SP (allocate slot)
```

#### POP Operation Pattern:
```
PLA         ; Decrement SP (now points to value)
TSX         ; Get current SP
TXA         ; Transfer to A
TAY         ; Transfer to Y (Y = slot to pop)
LDA [ZP.runtimeStackXL], Y  ; Load from parallel stack
STA destination             ; Store to destination
```

### Step 3: Trace Stack Frame Management

#### Standard Function Prologue:
```
LDA ZP.runtimeBP    ; Save old base pointer
PHA                 ; Push it on native stack
TSX                 ; Get stack pointer
STX ZP.runtimeBP    ; Save as new base pointer
```

#### Standard Function Epilogue:
```
LDX ZP.runtimeBP    ; Restore saved SP position
TXS                 ; Reset stack pointer (discards locals)
PLA                 ; Pop old base pointer
STA ZP.runtimeBP    ; Restore it
RTS                 ; Return
```

### Step 4: Common Patterns to Recognize

#### Local Variable Declaration
- Look for PHA without preceding value setup - this just allocates stack space
- The prologue/epilogue automatically handle cleanup

#### Expression Evaluation
- Values are pushed onto the stack
- Operations pop operands, compute, push results
- Results may be discarded with a simple PLA

#### Function Calls
- Arguments pushed before call
- Results typically returned in carry flag or zero page registers
- Caller responsible for cleaning up arguments

## Common Bugs to Look For

### 1. Missing Error Checks
**Bug:** No BCS after system calls that return errors in carry flag
```
JSR BIOS_CALL  ; Returns C=1 on error
; Missing: BCS error_handler
LDA ZP.RESULT  ; Using potentially invalid result!
```

### 2. Stack Imbalance
**Bug:** Mismatched PHA/PLA operations
- Count all PHA operations
- Count all PLA operations  
- Verify epilogue properly resets SP

### 3. Wrong Stack Position Access
**Bug:** Not accounting for SP behavior after PLA
```
PLA         ; SP now points to freed location
TSX
TXA
TAY
LDA [ZP], Y ; Wrong! Reading from freed slot
```
**Remember:** After PLA, SP points to the value you want, not beyond it.

### 4. Uninitialized Variables
**Bug:** Using local variables without initialization
- PHA alone just allocates space
- Check if values are stored before being read

## Analysis Checklist

- [ ] **Entry Point**
  - Does initialization check for allocation failures?
  - Are all four stack pages properly initialized?

- [ ] **Each Function**
  - Is the prologue saving/restoring BP correctly?
  - Are all local variables accounted for in epilogue?
  - Is the stack balanced on all exit paths?

- [ ] **Each VCode Block** (between NOPs)
  - What operation is being performed?
  - Are stack operations using correct offsets?
  - Are system call results being checked?

- [ ] **Expression Evaluation**
  - Are intermediate values properly managed?
  - Are unused results properly discarded?
  - Is the comparison flag usage correct?

## Special Considerations

### The C Flag in Comparisons
The 6502 CMP instruction sets carry flag in a non-intuitive way:
- C=1 if A >= operand (no borrow needed)
- C=0 if A < operand (borrow needed)

This is opposite of what you might expect for "less than" comparisons.

### Zero Page Usage
Be careful about zero page variable conflicts:
- Check the call graph
- Ensure functions don't stomp on ZP variables used by functions they call
- System calls may use specific ZP locations

### Debugging Philosophy
**Always suspect the new code first.** The BIOS and runtime are stable and tested. When debugging:
1. First verify your generated code follows conventions correctly
2. Check for the common bugs listed above
3. Only after exhausting these should you suspect the system code

## Example Analysis

Let's analyze a simple expression evaluation `(0 != 1)`:

1. **PUSH 0** - Stores 32-bit zero, allocates with PHA
2. **PUSH 1** - Stores 32-bit one, allocates with PHA  
3. **POP to ZP.TOP** - PLA first (SP--), then reads value
4. **POP to ZP.NEXT** - PLA first (SP--), then reads value
5. **Call Long.NE** - Compares values, returns in carry
6. **PUSH result** - Converts carry to 32-bit value
7. **POP discard** - Simple PLA since result unused

The key insight: PLA happens BEFORE reading in POP operations because after PLA, SP points to the value we want, not beyond it.

## Final Tips

1. **Use comments liberally** in your analysis to track SP position and stack contents
2. **Draw stack diagrams** showing the state after each operation
3. **Verify assumptions** about register contents at each step
4. **Test edge cases** like empty functions before complex ones
5. **Trust the pattern** - once you understand the compiler's patterns, anomalies stand out