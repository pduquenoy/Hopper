program HopperMonitor
{
    //#define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    
    //#define CAPTURESERIAL
    
    uses "/Source/System/System"
    uses "/Source/System/IO"
    
    uses "/Source/Editor/Highlighter"
    
    uses "Source"
    uses "Output"
    uses "6502/Pages"
    uses "6502/Monitor"
    
    uses "Emulator/Shared"
    
    uses "/Source/Compiler/JSON/JSON"
    
    string optionsPath;
    string OptionsPath { get { return string optionsPath; } }
    
    bool NoPackedInstructions { get { return false; } } // to keep peephole code happy (even though it is not used)
    bool IsInteractive { get { return false; } } // for Monitor.Connect(..)
    bool OGMode { get { return false; } }
    
    <Key> keyboardBuffer;
    InjectKey(Key key)
    {
        keyboardBuffer.Append(key);
    }
    InjectText(string keys)
    {
        foreach (var ch in keys)
        {
            ch = ch.ToUpper();
            Key key = Keyboard.FromSerial(ch, char(0));
            keyboardBuffer.Append(key);
        }
    }
    
    Profile(string dataString, string profilePath)
    {
        if (File.Exists(profilePath))
        {
            File.Delete(profilePath);
        }
        file profileFile = File.Create(profilePath);
        
        string ln;
        bool sysCalls = false; // TODO LIBCALL
        foreach (var c in dataString)
        {
            if (c == Char.EOL)
            {
                ln = ln.Trim();
                if (ln.Length != 0)
                {
                    string addressString = "0x" + ln.Substring(0, 4);
                    uint address;
                    ln = ln.Substring(4);
                    if (UInt.TryParse(addressString, ref address))
                    {
                        address = address - 0x0800;
                        address = address / 2;
                        if (address > 255)
                        {
                            address = address - 256; // sysCall
                            sysCalls = true;
                        }
                    }
                    for (uint i = 0; i < 8; i++)
                    {
                        uint index = address + i;
                        string countString = "0x" + ln.Substring(i*4 + 2, 2) + ln.Substring(i*4, 2);
                        uint count;
                        if (UInt.TryParse(countString, ref count)) 
                        {   
                            if (count > 0)
                            {
                                string name;
                                if (sysCalls)
                                {
                                    name = SysCalls.GetSysCallName(byte(index));
                                }
                                else
                                {
                                    name = Instructions.ToString(Instruction(index));
                                }
                                profileFile.Append(name + char(0x09) + count.ToString() + Char.EOL);
                            }
                        }
                    }
                }
                ln = "";
            }
            else if (c == ' ')
            {
                // skip
            }
            else
            {
                String.Build(ref ln, c);
            }
        } // for
        profileFile.Flush();
    }
    
    string GenerateMethodString(uint methodIndex, byte bp)
    {
        <string,variant> methodSymbols = Code.GetMethodSymbols(methodIndex);
        string methodName = methodSymbols["name"];
        string content = methodName + "(";
        if (methodSymbols.Contains("arguments"))
        {
            <string, <string> > argumentInfo = methodSymbols["arguments"];
            bool first = true;
            foreach (var kv in argumentInfo)
            {
                if (!first)
                {
                    content = content + ", ";
                }
                <string> argumentList = kv.value;
                content = content + argumentList[2] + "=";
                int delta;
                if (Int.TryParse(kv.key, ref delta))
                {
                }
                byte voffset = byte(int(bp) +  delta);
                uint value   = GetPageByte(voffset + 0x0600) + GetPageByte(voffset + 0x0700) << 8;
                string vtype = argumentList[1];
                
                bool isReference = (argumentList[0] == "true");
                content = content + char(2) + TypeToString(value, vtype, isReference, 255) + char(3);
                first = false;
            }
        }
        content = content + ")";
        return content;
    }    
    PrintColors(string colourContent)
    {
        string contentBuffer;
        foreach (var ch in colourContent)
        {
            if (ch == char(2))
            {
                Print(contentBuffer);
                contentBuffer = "";   
            }
            else if (ch == char(3))
            {
                Print(contentBuffer, LightestGray, Black);
                contentBuffer = "";
            }
            else
            {
                contentBuffer = contentBuffer + ch;
            }
        }
        Print(contentBuffer);
    }
    OutputMethodLine(uint pc, uint address, uint methodIndex, byte bp, bool sourceLevel, bool symbolsLoaded)
    {
        if (address == pc)
        {
            Print("PC -> ", Colour.MatrixRed, Colour.Black);
        }
        else
        {
            Print("      "); 
        }
        if (address == pc)
        {
            Print("0x" + address.ToHexString(4), LightestGray, Black);
            Print("        0x" + bp.ToHexString(2) + "  ", LightestGray, Black);
        }
        else
        {
            Print("0x" + address.ToHexString(4));
            Print(" 0x" + (address+3).ToHexString(4) + " 0x" + bp.ToHexString(2) + "  ", LightestGray, Black);
        }
        if (!symbolsLoaded)
        {
            PrintLn();
            return;
        }
        
        <string,variant> methodSymbols = Code.GetMethodSymbols(methodIndex);
        string methodName   = methodSymbols["name"];
        string methodSource = methodSymbols["source"];
        string methodLine   = methodSymbols["line"];
        
        string sLine = Code.GetSourceIndex(address, methodIndex);
        uint iColon;
        if ((sLine != "") && sLine.IndexOf(':', ref iColon))
        {
            methodLine = sLine.Substring(iColon+1);
        }
        else
        {
            //Print(address.ToHexString(4) + "?");
        }
        
        string methodString = GenerateMethodString(methodIndex, bp);
        PrintColors(methodString);
        
        Screen.SetCursor(80, Screen.CursorY);
        uint lSlash;
        if (methodSource.LastIndexOf('/', ref lSlash))
        {
            methodSource = methodSource.Substring(lSlash+1);
        }
        Print(" // " + methodSource + ":" + methodLine, Comment, Black);
        PrintLn();
        if (false && methodSymbols.Contains("debug"))
        {
            <string,string> debugInfo = methodSymbols["debug"];
            foreach (var kv in debugInfo)
            {
                Print(kv.key + " ");
            }
            PrintLn();
        }
    }
    
    ShowCallStack(bool sourceLevel, bool symbolsLoaded)
    {
        ClearPageData();
        Pages.LoadZeroPage(false); // for CSP and PC
        Output.Initialize();
        
        if (   ZeroPageContains("PC") && ZeroPageContains("CSP"))
        {
            //DumpMap();
            
            uint csp = GetZeroPage("CSP");
            if (csp > 0)
            {
                byte bp;
                uint address;
                uint methodIndex;
                
                uint pc = GetZeroPage("PC");
                
                PrintLn();     
                PrintLn("             RET    BP");
                uint icsp = 1;
                while (icsp < csp)
                {
                    address = GetPageByte(0x0300+icsp) + GetPageByte(0x0400+icsp) << 8;
                    bp      = GetPageByte(0x0300+icsp+1);

                    methodIndex = LocationToIndex(address);
                    OutputMethodLine(pc, address - 3, methodIndex, bp, sourceLevel, symbolsLoaded);
                    icsp += 2;
                }
                
                // current method
                methodIndex = LocationToIndex(pc);
                bp  = byte(GetZeroPage("BP"));

                OutputMethodLine(pc, pc, methodIndex, bp, sourceLevel, symbolsLoaded);
                if (symbolsLoaded)
                {
                    <uint, <string> > usedGlobals = Source.GetGlobals(methodIndex, 0);
                    //Print(" methodIndex=" +methodIndex.ToHexString(4) + " "  + (usedGlobals.Count).ToString() + " ");
                    foreach (var kv in usedGlobals)
                    {
                        uint goffset = kv.key;
                        <string> globalList = kv.value;
                        uint gvalue  = GetPageByte(goffset + 0x0600) + GetPageByte(goffset + 0x0700) << 8;
                        
                        string gtype = globalList[0];
                        
                        string gcontent = char(2) + Source.TypeToString(gvalue, gtype, false, 255) + char(3);
                        
                        PrintLn();
                        PrintColors("    " + globalList[1] + "=" + gcontent);
                    }
                }
            }
        }
        else
        {
            Print("Failure in ShowCallStack(..)");
        }
    }
    
    ShowZeroPage()
    {
        Pages.LoadZeroPage(true);
        <string,uint> zeroPageEntries = Pages.GetZeroPageEntries();
        foreach (var kv in zeroPageEntries)
        {
            uint value = kv.value;
            string info = kv.key + ": ";
            info = info.Pad(' ', 11);
            byte digits = 2;
            if (value > 255)
            {
                digits = 4;
            }
            info = info + value.ToHexString(digits);
            
            PrintLn();
            Print(info, Colour.LightestGray, Colour.Black);
        }
    }
    ShowValueStack()
    {
        Pages.ClearPageData(); // fresh data
        
        PrintLn();
        Pages.LoadZeroPage(true);
        byte sp = byte(GetZeroPage("SP"));
        byte bp = byte(GetZeroPage("BP"));
        byte spi = sp;
        
        Print("SP -> ", Colour.MatrixRed, Colour.Black);
        PrintLn("0x" + sp.ToHexString(2), Colour.LightestGray, Colour.Black);
        uint entries = 0;
        loop
        {
            if (spi == 0) { break; }
            spi--;
            uint value = Pages.GetPageByte(0x0600 + spi) + (Pages.GetPageByte(0x0700 + spi) << 8);
            byte vtype = byte(Pages.GetPageByte(0x0500 + spi));
            string leftText = "      ";
            if (spi == bp)
            {
                leftText = "BP -> ";
            }
            
            string tstring = Type.ToString(type(vtype));
            
            bool isReference = tstring == "ref";
            string content = TypeToString(value, tstring, isReference, 30);
            
            string referenceCount = "      ";
            if (IsMachineReferenceType(vtype))
            {
                byte count = Pages.GetPageByte(value + 1);
                referenceCount = "[0x" + count.ToHexString(2) + "]";
            }
            
            Print(leftText, Colour.MatrixRed, Colour.Black);
            if (spi == bp)
            {
                Print("0x" + spi.ToHexString(2), Colour.LightestGray, Colour.Black);
            }
            else
            {
                Print("0x" + spi.ToHexString(2));
            }
            Print(" 0x" + value.ToHexString(4) + ":0x" + vtype.ToHexString(2) + referenceCount, Colour.LightestGray, Colour.Black); 
            Print(" (" + tstring + ")" + " " + content);
            PrintLn();
            entries++;
            if (entries == 12) 
            { 
               PrintLn("      ...");
               break; 
            }
        }
    }    
    ShowRegisters()
    {
        Pages.LoadZeroPage(true);
        PrintLn();
        
        uint pc  = GetZeroPage("PC");
        uint csp = GetZeroPage("CSP");
        uint sp  = GetZeroPage("SP");
        uint bp  = GetZeroPage("BP");
        
        uint acc  = GetZeroPage("ACC");
        uint top  = GetZeroPage("TOP");
        uint next = GetZeroPage("NEXT");
        uint idx  = GetZeroPage("IDX");
        uint idy  = GetZeroPage("IDY");
        
        PrintLn("PC   SP  BP  CSP    ACC  TOP  NEXT IDX  IDY");
        
        string registers = // the Hopper registers                   
                   pc.ToHexString(4) + 
             " " + sp.ToHexString(2) + " " +
             " " + bp.ToHexString(2) + " " +
             " " + csp.ToHexString(2) + "    " +
             " " + acc.ToHexString(4) + 
             " " + top.ToHexString(4) + 
             " " + next.ToHexString(4) + 
             " " + idx.ToHexString(4) + 
             " " + idy.ToHexString(4) + " ";
        
        PrintLn(registers, Colour.LightestGray, Colour.Black);
    }    
    
    ShowDisassembly(uint address, uint instructions)
    {
        string content = address.ToHexString(4); // fallback content
        uint entryPoint = Source.GetCode(0x0004) + Source.GetCode(0x0005) << 8;
        
        uint codeLength = Source.GetCodeLength();

        //PrintLn();        
        //PrintLn("address=" + address.ToHexString(4) + 
        //        ", entryPoint=" + entryPoint.ToHexString(4) + 
        //        ", codeLength=" +codeLength.ToHexString(4));
        
        address += entryPoint;
        int entryPointOffset = -int(entryPoint);
        bool first = true;
        loop
        {
            if ((address >= 0) && (address < codeLength))
            {
                uint sourcePC = address - entryPoint;
                string sourceIndex = Code.GetSourceIndex(sourcePC);
                
                if (sourceIndex.Length != 0)
                {
                    string sourceLine = Code.GetSourceLine(sourceIndex);
                    if (sourceLine.Length != 0)
                    {
                        sourceLine = "      " + sourceLine.Trim();
                        sourceLine = sourceLine.Pad(' ', 60);
                        PrintLn();
                        Print(sourceLine);    
                        Print("// " + sourceIndex, Colour.Comment, Colour.Black);
                    }
                }
                Instruction instruction = Instruction(Source.GetCode(address));
                bool wasReturn = Instructions.IsRET(instruction);
                content = Source.Disassemble(ref address, entryPointOffset);
                PrintLn();
                uint colour = Colour.MatrixBlue;
                if (first)
                {
                    Print("PC -> ", Colour.MatrixRed, Colour.Black);
                    
                    string location = content.Substring(0,6);
                    content = content.Substring(6);
                
                    Print(location, Colour.LightestGray, Colour.Black);
                    colour = Colour.Ocean;
                }
                else
                {
                    Print("      ");
                }
                uint iComment;
                string comment;
                if (content.IndexOf("//", ref iComment))
                {
                    comment = content.Substring(iComment);
                    content = content.Substring(0, iComment);        
                    content = content.Pad(' ', 54);
                }
                Print(content, colour, Colour.Black);
                Print(comment, Colour.MatrixGreen, Colour.Black);
                if (wasReturn)
                {
                    break;
                }
            }
            else
            {
                break;
            }
            instructions--;
            if (instructions == 0)
            {
                break;
            }
            address++;
            first = false;
        } //loop
    }
    
    ShowCurrentInstruction(uint instructions)
    {
        Monitor.Command("P", true, true);
        string serialOutput = Monitor.GetSerialOutput();
        serialOutput = "0x" + serialOutput.Substring(1);
        uint pc;
        if (UInt.TryParse(serialOutput, ref pc))
        {
            ShowDisassembly(pc, instructions);
        }
    }
    
    HopperLinePrinter(string ln, uint backColor)
    {
        ln = ln.Pad(' ', Screen.Columns);
        uint blockCommentNesting;
        <uint> colours = Highlighter.HopperSource(ln, "", backColor, false, ref blockCommentNesting);
        uint length = ln.Length;
        for (uint i=0; i < length; i++)
        {
            uint colour = colours[i];
            char c = ln[i];
            Print(c, colour, backColor);
        }
    }
    ShowCurrentSource(uint lines, uint address)
    {
        Screen.Suspend();
        Screen.Clear();
        string sourceIndex = Code.GetSourceIndex(address);
        if (sourceIndex.Length != 0)
        {
            string sourceLine = Code.GetSourceLine(sourceIndex);
            if (sourceLine.Length != 0)
            {
                <string> parts = sourceIndex.Split(':');
                string lNum = parts[1];
                uint iLine;
                if (UInt.TryParse(lNum, ref iLine))
                {
                    Screen.SetCursor(0,1);
                    uint iCurrent = iLine;
                    uint delta = lines / 2;
                    while ((delta > 0) && (iCurrent > 1))
                    {
                        delta--;
                        iCurrent--;
                    }
                    loop
                    {
                        if (lines == 0)
                        {
                            break;
                        }
                        lines--;
                        sourceLine = Code.GetSourceLine(iCurrent);
                        uint backColor = Colour.LightestGray;
                        if (iCurrent == iLine)
                        {
                            backColor = Colour.LightGray;
                        }
                        HopperLinePrinter(sourceLine, backColor);  
                        if (false && (iCurrent == iLine))
                        {
                            Screen.SetCursor(Screen.Columns - 40, Screen.CursorY);
                            uint lSlash;
                            if (sourceIndex.LastIndexOf('/', ref lSlash))
                            {
                                sourceIndex = sourceIndex.Substring(lSlash+1);
                            }
                            Print(" // " + sourceIndex, Comment, backColor);
                        }
                        iCurrent++;
                    }
                }
                
            }
        } 
        Screen.Resume(true);
    }
    
    bool ValidateHexPage(ref string hexpage)
    {
        bool valid = false;
        hexpage = hexpage.ToUpper();
    
        uint returnValue = 0;
        if (UInt.TryParse("0x" + hexpage, ref returnValue))
        {
            if ((returnValue >= 0x00) && (returnValue <= 0xFF))
            {
                valid = true;
                if (hexpage.Length == 1)
                {
                    hexpage = "0" + hexpage;
                }
            }
        }
        
        return valid;
    }
    PrintPad(string ln, uint padding)
    {
        while (padding > 0)
        {
            String.BuildFront(ref ln, ' ');
            padding--;
        }
        PrintLn(ln);
    }
    Welcome()
    {
        PrintLn();
        PrintLn("HopperMon");
        string info = Monitor.GetHopperInfo();
        PrintPad(info, 2);
    }
    
    Help()
    {
        PrintLn();
        PrintPad("Commands:", 2);
        PrintPad("?        - this", 4);
        PrintPad("Q        - exit, also <alt><F4>", 4);
        PrintLn();
        PrintPad("L <name> - load Hopper program (IHex file)", 4);
        PrintPad("D        - debug Hopper program, also <F5>", 4);
        PrintPad("X        - execute Hopper program, also <ctrl><F5>", 4);
        PrintPad("W        - warm restart of loaded Hopper program", 4);
        PrintPad("O        - step over, also <F10>", 4);
        PrintPad("I        - step into, also <F11>", 4);
        PrintPad("B X      - clear all breakpoints", 4);
        PrintPad("B x xxxx - set breakpoint 1..F", 4);
        if (Monitor.IsMCU)
        {
            PrintPad("T        - transfer file to LittleFS on MCU: T <local path> <remote folder>", 4);
            PrintPad("E        - extra functions for microcontrollers:", 4);
            PrintPad("           B - enter Boot Select mode (only for RP2040), and quit Hopper Monitor", 4);
            PrintPad("           W - write the current local Windows date and time to the microcontroller RTC", 4);
            PrintPad("           R - read the date and time from the microcontroller RTC", 4);
        }
        PrintLn();
        PrintPad("C        - emit Hopper call stack", 4);
        PrintPad("V        - emit Hopper value stack", 4);
        PrintPad("R        - emit Hopper registers", 4);
        PrintPad("P        - emit Hopper PC", 4);
        PrintPad("S        - show source listing at Hopper PC", 4);
        PrintPad("H        - emit current Hopper heap objects", 4);
        PrintPad("M <page> - emit a 256 byte page of memory", 4);
    }
    
    Interactive()
    {
        //Screen.Clear();
        
        // if "Debugger.options" exists, see it has a comPort set by Port.hexe:
        uint comPort = 4242; // bogus port value
        string baudRate = "56700";
        optionsPath = Path.MakeOptions("Debugger.options");
        if (File.Exists(optionsPath))
        {
            <string, variant> dict;
            if (JSON.Read(optionsPath, ref dict))
            {
                <string, string> debugOptions = dict["debugoptions"];
                if (debugOptions.Contains("comPort"))
                {
                    string value = debugOptions["comPort"];
                    if (UInt.TryParse(value, ref comPort))
                    {
                        // found a current port
                    }
                }
                if (debugOptions.Contains("baudRate"))
                {
                    baudRate = debugOptions["baudRate"];
                }
                if (comPort != 4242)
                {
                    string currentPort = "COM" + comPort.ToString();
                    <string> ports = Serial.Ports;
                    if (!ports.Contains(currentPort))
                    {
                        // current port no longer exists
                        comPort = 4242;
                        debugOptions["comPort"] = comPort.ToString();
                        File.Delete(optionsPath);
                        dict["debugoptions"] = debugOptions;
                        if (JSON.Write(optionsPath, dict))
                        {
                        }
                    }
                }
            }
        }
        if (!Monitor.Connect(comPort, baudRate))
        {
            return;
        }
        
        // send a <ctrl><C> in case there is a program running
        Monitor.SendBreak();
        
        Welcome();
        
        uint crc = Monitor.GetCurrentCRC();
        PrintLn("CRC:" + crc.ToHexString(4));
        if (crc != 0)
        {
            if (Monitor.FindCurrentHex(crc))
            {
                Source.LoadSymbols(true);
                if (!SymbolsLoaded)
                {
                    PrintLn();
                    PrintLn("Failed to load Symbols", Colour.MatrixRed, Colour.Black);
                }
            }
        }
        
        bool sourceLevel = false; // Hopper source code level debugging
        bool symbolsLoaded = false; // running auto.hexe or was L used?
        
        char currentCommand = ' ';
        string commandLine = "";
        bool refresh = true;
        loop
        {
            if (refresh)
            {
                SetCursor(0, Screen.CursorY);
                string ln = ">" + commandLine;
                uint cursorX = ln.Length;
                ln = ln.Pad(' ', Screen.Columns-1);
                Print(ln);
                SetCursor(cursorX, Screen.CursorY);
                refresh = false;
            }
            
            Key key;
            if (keyboardBuffer.Count != 0)
            {
                key = keyboardBuffer[0];
                keyboardBuffer.Remove(0);
            }
            else
            {
                key  = ReadKey();
            }
            char ch = key.ToChar();
            ch = ch.ToUpper();
            uint clength = commandLine.Length;
            
            // shortcut keys
            bool doShortcut = false;
            if (key == (Key.Alt | Key.F4))
            {
                commandLine = "Q";
                doShortcut = true;
            }
            else if (key == Key.F5)
            {
                commandLine = "D";
                doShortcut = true;
            }
            else if (key == (Key.Control | Key.F5))
            {
                commandLine = "X";
                doShortcut = true;
            }
            else if (key == Key.F11)
            {
                commandLine = "I";
                doShortcut = true;
            }
            else if (key == Key.F10)
            {
                commandLine = "O";
                doShortcut = true;
            }
            if (doShortcut)
            {
                currentCommand = commandLine[0];
                Print(commandLine);
                key = Key.Enter;
            }
            if (key == Key.Enter)
            {
                // execute commandLine
                if (!Pages.IsLoaded && ("BCDIOSUVWX").Contains(currentCommand))
                {
                    // these commands should do be used if there is no program loaded
                    PrintLn();
                    PrintLn("No program loaded");
                    refresh = true;
                }
                else if (currentCommand == 'Q') // exit monitor UI
                {
                    PrintLn();
                    break; 
                }
                else if (currentCommand == '?') // help
                {
                    Welcome();
                    Help();
                    refresh = true;
                }
                else if (currentCommand == 'Z') // zero page variables
                {
                    ShowZeroPage();
                    refresh = true;
                }
                else if (currentCommand == 'C') // show call stack
                {
                    ShowCallStack(sourceLevel, symbolsLoaded);
                    refresh = true;
                }
                else if (currentCommand == 'L') // ihex load
                {
                    string ihexPath = commandLine.Substring(2);
                    if (ValidateHexPath(ref ihexPath))
                    {
                        UploadHex(ihexPath);
                        refresh = true;
                        symbolsLoaded = true;
                    }
                } // case 'L'
                
                else if (Monitor.IsMCU && (currentCommand == 'T')) // transfer file to LittleFS
                {
                    string arguments = commandLine.Substring(2);
                    <string> paths = arguments.Split(' ');
                    if (paths.Count == 2)
                    {
                        string localFile  = paths[0];
                        string remotePath = paths[1]; 
                        localFile = Path.GetFullPath(localFile);
                        if (File.Exists(localFile))
                        {
                            UploadFile(localFile, remotePath);
                            refresh = true;
                        }
                    }
                } // case 'T'
                
                else if (currentCommand == 'M') // memory dump
                {
                    string hexpage = "";
                    if (commandLine.Length > 2)
                    {
                        hexpage = commandLine.Substring(2, commandLine.Length-2);
                        if (hexpage == "X")
                        {
                            // eXport all memory to file
                            Print(" Dumping memory to '" + Monitor.CurrentHexPath + "': ");
                            if (Output.DumpMemory())
                            {
                                PrintLn();
                            }
                            else
                            {
                                PrintLn(" failed");
                            }
                            refresh = true;
                        }
                        else if (ValidateHexPage(ref hexpage))
                        {
                            commandLine = commandLine.Replace('M', 'F');
                            Monitor.Command(commandLine.Substring(0,1) + hexpage, true, true);
                            refresh = true;
                            string output = Monitor.GetSerialOutput();
                            output = output.Replace("" + Char.EOL, "");
                            if (output.Length == 512)
                            {
                                uint iPage;
                                _ = UInt.TryParse("0x" + hexpage, ref iPage);
                                uint address = iPage << 8;
                                PrintLn();
                                Print("      ");
                                for (byte i = 0; i < 16; i++)
                                {
                                   Print("x" + i.ToHex() + " ");  
                                   if (i == 7)
                                   {
                                       Print(' ');
                                   }  
                                }
                                PrintLn();
                                for (uint i = 0; i < 256; i += 16)
                                {
                                    string ln = output.Substring(i<<1, 32);
                                    Print((address + i).ToHexString(4)+ "  ");
                                    for (uint j = 0; j < 32; j++)
                                    {
                                        Print(ln[j], Colour.LightestGray, Colour.Black);
                                        if (j % 2 == 1)
                                        {
                                            Print(' ');
                                        } 
                                        if (j == 15)
                                        {
                                            Print(' ');
                                        }
                                    }
                                    PrintLn();
                                }
                            }
                        }
                    }    
                } // case 'M'
                
                else if (currentCommand == 'F') // memory dump
                {
                    string hexpage = "";
                    if (commandLine.Length > 2)
                    {
                        hexpage = commandLine.Substring(2, commandLine.Length-2);
                        if (ValidateHexPage(ref hexpage))
                        {
                            Monitor.Command(commandLine.Substring(0,1) + hexpage, true, true);
                            refresh = true;
                            
                            string output = Monitor.GetSerialOutput();
                            output = output.Replace("" + Char.EOL, "");
                            if (output.Length == 512)
                            {
                                PrintLn();
                                for (byte i = 0; i < 15; i++)
                                {
                                    PrintLn(output.Substring(0,32), Colour.LightestGray, Colour.Black);
                                    output = output.Substring(32);
                                }
                            }
                        }
                    }
                } // case 'F'
                
                else if (currentCommand == 'B') // breakpoints
                {
                    if (commandLine == "B X")
                    {
                        Monitor.Command("BX", false, false);
                        refresh = true;
                    }
                    else if (commandLine.Length > 4)
                    {
                        string hex = "0x" + commandLine.Substring(2,1);
                        uint breakpoint;
                        if (UInt.TryParse(hex, ref breakpoint) && (breakpoint > 0))
                        {
                            hex = "0x" + commandLine.Substring(4);
                            uint address;
                            if (UInt.TryParse(hex, ref address))
                            {
                                commandLine = "B" + breakpoint.ToHexString(1) + address.ToHexString(4);
                                Monitor.Command(commandLine, false, false);
                                refresh = true;
                            }
                        }
                    }
                } // case 'B'
                
                else if (currentCommand == 'E') // enter Boot Select mode on the RP2040 then quit
                {
                    PrintLn(" Microcontroller functions:");
                    PrintLn("  B     - enter Boot Select mode (only for RP2040), and quit Hopper Monitor");
                    PrintLn("  W - write the current local Windows date and time to the microcontroller RTC");
                    PrintLn("  R - read the date and time from the microcontroller RTC");
                    
                    PrintLn("  <Esc> - cancel");
                    Print  (" >");
                    loop
                    {
                        Key mkey  = ReadKey();
                        if (mkey == Key.Escape)
                        {
                            PrintLn(" * cancelled *", Colour.MatrixRed, Colour.Black);
                        }
                        else
                        {
                            char mch = mkey.ToChar();
                            mch = mch.ToUpper();
                            if (mch == 'B')
                            {
                                if (!Monitor.RunCommand(commandLine))
                                {
                                    PrintLn(mch + " entering BOOTSEL mode..");
                                    break;      
                                }
                                // failed
                            }
                            else if (mch == 'W')
                            {
                                string time = Time.Time;
                                string date = Time.Date;
                                PrintLn(mch + " '" + date + " " + time + "' -> writing date and time ..");
                                // TODO : set the date and time
                            }
                            else if (mch == 'R')
                            {
                                PrintLn(mch + " reading date and time ..");
                                // TODO : set the date and time
                            }
                            else
                            {
                                continue;
                            }
                        }
                        break;
                    }
                    refresh = true;
                }
                else if (currentCommand == 'X') // Execute (run with Warp)
                {
                    if (!Monitor.RunCommand(commandLine))
                    {
                        PrintLn(" serial connection lost", Colour.MatrixRed, Colour.Black);
                    }
                    refresh = true;
                }
                else if (   (currentCommand == 'D') // Debug (run with !Warp)
                         || (currentCommand == 'I') // Step (single / into / F11)
                         || (currentCommand == 'O') // Step (next / over / F10)
                        )
                {
                    Source.LoadSymbols(true);
                    if (!SymbolsLoaded)
                    {
                        PrintLn();
                        PrintLn("Failed to load Symbols", Colour.MatrixRed, Colour.Black);
                    }
                    if (!Monitor.RunCommand(commandLine))
                    {
                        PrintLn(" serial connection lost", Colour.MatrixRed, Colour.Black);
                    }
                    if (sourceLevel)
                    {
                        bool serialConnectionLost;
                        uint pc = Monitor.ReturnToDebugger(currentCommand, ref serialConnectionLost);
                        if (serialConnectionLost)
                        {
                            PrintLn(" serial connection lost", Colour.MatrixRed, Colour.Black);
                        }
                        if (pc != 0)
                        {
                            ShowCurrentSource(Screen.Rows / 2, pc);
                        }
                    }
                    else
                    {
                        ShowCurrentInstruction(3);
                    }
                    refresh = true;
                }
                else if (currentCommand == 'S') // Source
                {
                    Source.LoadSymbols(true);
                    if (!SymbolsLoaded)
                    {
                        PrintLn();
                        PrintLn("Failed to load Symbols", Colour.MatrixRed, Colour.Black);
                    }
                    ShowCurrentInstruction(15);
                    refresh = true;
                }
                else if (currentCommand == 'W') // Warm Restart (keep program, reset data)
                {
                    Monitor.Command(commandLine, false, false);
                    refresh = true;
                }
                else if (currentCommand == 'R') // Registers
                {
                    ShowRegisters();
                    refresh = true;
                }
                else if (currentCommand == 'P') // raw PC (mostly used internally)
                {
                    Monitor.Command(commandLine, false, true);
                    refresh = true;
                }
                else if (currentCommand == 'K') // CRC
                {
                    Monitor.Command(commandLine, false, true);
                    refresh = true;
                }
                else if (currentCommand == 'V') // Value Stack
                {
                    ShowValueStack();
                    refresh = true;
                }
                else if (currentCommand == 'H') // Heap
                {
                    Pages.ClearPageData(); // fresh data
                    GetRAMByteDelegate getRAMByte = Pages.GetPageByte;
                    ShowHopperHeap(getRAMByte);
                    refresh = true;
                }
                if (refresh)
                {
                    commandLine = "";
                    currentCommand = ' ';
                    PrintLn();
                }
            } // if (key == Key.Enter)
            else if (key == Key.Escape)
            {
                // cancel commandline
                commandLine = "";
                refresh = true;
            }
            else if (key == Key.ControlC)
            {
                // cancel commandline
                commandLine = "";
                //Monitor.EmptyCommand();
                PrintLn("<ctrl><C>");
                refresh = true;
            }
            else if (key == Key.Backspace)
            {
                // back up one
                if (commandLine.Length != 0)
                {
                    commandLine = commandLine.Substring(0, commandLine.Length-1);
                    SetCursor(0, Screen.CursorY);
                    refresh = true;
                }
            }
            else
            { 
                // alphanumeric
                if (clength < Screen.Columns-1)
                {
                    if (clength == 0)
                    {
                        // first character must be command key
                        if (String.Contains("?BCDEFHIKLMOPQRSTVWXZ", ch))
                        {
                            currentCommand = ch;
                        }
                        else if (Monitor.IsMCU && String.Contains("ET", ch))
                        {
                            currentCommand = ch; // MCU-only commands
                        }
                        else
                        {
                            continue;
                        }
                    } // clength == 0
                    else if (clength == 1)
                    {
                        if (ch != ' ') // 2nd character must be ' '
                        {
                            continue;
                        }
                        if (currentCommand == 'L')
                        {
                            // has arguments
                        }
                        else if (Monitor.IsMCU && (currentCommand == 'T'))
                        {
                            // has arguments
                        }
                        else if (currentCommand == 'M')
                        {
                            // has arguments
                        }
                        else if (currentCommand == 'F')
                        {
                            // has arguments
                        }
                        else if (currentCommand == 'B')
                        {
                            // has arguments
                        }
                        else
                        {
                            continue; // no arguments
                        }
                    } // clength == 1
                    else
                    {   // clength > 1
                        // arguments
                        if (currentCommand == 'L')
                        {
                            // L <ihex path>
                        }
                        else if (currentCommand == 'T')
                        {
                            // T <local file path> <remote folder>
                        }
                        else if (currentCommand == 'M')
                        {
                            // M n or nn (MSB hex for page)
                            // M X to dump all memory to file
                        }
                        else if (currentCommand == 'F')
                        {
                            // F n or nn (MSB hex for page)
                        }
                        else if (currentCommand == 'B')
                        {
                            // B X or B n nnnn
                        }
                        else
                        {
                            continue; // should never get here
                        }
                    } // clength > 1
                    
                    if (ch != char(0))
                    {
                        commandLine = commandLine + ch;
                        refresh = true;
                    }
                }  // if (commandLine.Length < Screen.Columns-1)
            } // alphanumeric
        } // loop
        Serial.Close();
    }
    
    bool ValidateHexPath(ref string ihexPath)
    {
        bool uploadHex = false; 
        loop
        {
            string extension = Path.GetExtension(ihexPath);
            extension = extension.ToLower();
            if (extension == ".")
            {
                ihexPath = ihexPath + ".ihex";
            }
            else if (extension != ".ihex")
            {
                break;
            }
            if (!File.Exists(ihexPath))
            {
                string fullPath = Path.Combine(System.CurrentDirectory, ihexPath);
                if (!File.Exists(fullPath))
                {
                    fullPath = Path.Combine("/Bin", ihexPath);   
                    if (!File.Exists(fullPath))
                    {
                        break;
                    }
                    else
                    {
                        ihexPath = fullPath;
                    }    
                }
                else
                {
                    ihexPath = fullPath;
                }
            }
            uploadHex = true; 
            break;
        }
        return uploadHex;
    }
    
    {
#ifdef CAPTURESERIAL
        Monitor.InitializeCapture();
#endif        
        Source.ClearSymbols();
        Output.SetPassThrough();
        
        <string> rawArgs = System.Arguments;
        bool invalidArguments = false;
        string ihexPath;  
        string transferPath;
        string remoteFolder;
        bool transferFile = false;
        bool uploadHex = false;
        bool executeAndExit = false;
        bool debugAndExit = false;
        loop // option block
        {
            for (uint i = 0; i < rawArgs.Count; i++)
            {
			             string arg = rawArgs[i];
         			    if ((arg.Length == 2) && arg.StartsWith('-'))
            				{
          				      arg = arg.ToLower();
                    if (arg == "-x")
               					{
                       executeAndExit = true;
                    }
                				else if (arg == "-d")
               					{
                       debugAndExit = true;
                    }
                				else if (arg == "-l")
               					{
					                   i++;
						                  if (i == rawArgs.Count)
						                  {
						                      invalidArguments = true;
                      				  break;
                  						}
                  						ihexPath = rawArgs[i];
                        uploadHex = ValidateHexPath(ref ihexPath);
                        if (!uploadHex)
                        {
                            string extension = Path.GetExtension(ihexPath);
                            if (extension != ".ihex")
                            {
                                PrintLn("IHex file should have .ihex extension.");
                                invalidArguments = true;
                        						  break;
                            }
                        }
					               }
                    else if (arg == "-t")
               					{
					                   i++;
						                  if (i == rawArgs.Count)
						                  {
						                      invalidArguments = true;
                      				  break;
                  						}
                        transferPath = rawArgs[i];
                        if (!File.Exists(transferPath))
                        {
                            PrintLn("'" + transferPath + "' not found");
                            invalidArguments = true;
                        		  break;
                        }
                        i++;
						                  if (i == rawArgs.Count)
						                  {
						                      invalidArguments = true;
                      				  break;
                  						}
                        remoteFolder = rawArgs[i];
                        transferFile = true;
					               }
                				else
                				{
                				    invalidArguments = true;
                						  break;
                				}
                }
            				else
            				{
            				    invalidArguments = true;
                    break;
            				}
			         } // for each argument
         			break;
        } // option block
        if (debugAndExit && executeAndExit)
        {
            invalidArguments = true;
        }
        loop // execution block
        {
            if (invalidArguments)
            {
                 PrintLn("Invalid arguments for HopperMonitor:");
                 PrintLn("  -l <name>           : load IHex image to 6502 machine");
                 PrintLn("  -t <path> <folder>  : transfer file to remote folder");
                 PrintLn("  -x                  : execute without debugging and exit (<ctrl><F5>)");
                 PrintLn("  -d                  : execute with debugging and exit (<F5>)");
                 
                 break;
            }
            if (uploadHex)
            {
                string fileName = Path.GetFileName(ihexPath);
                fileName = fileName.ToUpper();
                fileName = fileName.Replace(".HEX", "");
                Print("'" + fileName + "'");
                InjectText("L " + fileName);
                InjectKey(Key.Enter);
                if (!debugAndExit && !executeAndExit)
                {   
                    // just an upload from the console or a script                 
                    InjectText("Q");
                    InjectKey(Key.Enter);
                }
            }
            if (debugAndExit)
            {
                InjectText("D");
                InjectKey(Key.Enter);
                InjectText("Q");
                InjectKey(Key.Enter);
            }
            if (executeAndExit)
            {
                InjectText("X");
                InjectKey(Key.Enter);
                InjectText("Q");
                InjectKey(Key.Enter);
            }
            if (transferFile)
            {
                transferPath = transferPath.ToUpper();
                remoteFolder = remoteFolder.ToUpper();
                Print("'" + transferPath + "' -> '" + remoteFolder + "'");
                InjectText("T " + transferPath + " " + remoteFolder);
                InjectKey(Key.Enter);
                InjectText("Q");
                InjectKey(Key.Enter);
            }
            Interactive();
            break;
        } // execution block
    }
}
