program DASM
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    #define ASSEMBLER
    
    //#define EXPERIMENTAL
    
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    
    uses "JSON/JSON"
    uses "JSON/Code"
    
    uses "Symbols"
    
    uses "CodeGen/Instructions"
    uses "CODEGEN/AsmZ80"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/SysCalls"
    uses "Tokens/LibCalls"
    uses "Tokens/Parser"
    
    bool extendedCodeSegment;
    
    uint instructionCount = 0;
    
    string pathLoaded;
    <string> sourceLines;
    string getSourceLine(string path, string lnum)
    {
        if (pathLoaded != path)
        {
            file sourceFile = File.Open(path);
            if (sourceFile.IsValid())
            {
                sourceLines.Clear();
                pathLoaded = path;
                loop
                {
                    string ln = sourceFile.ReadLine();
                    if (ln.Length == 0)
                    {
                        if (!sourceFile.IsValid())
                        {
                            break;
                        }
                    }
                    sourceLines.Append(ln);
                }
            }
        }
        string sourceLine;
        uint iline;
        if (UInt.TryParse(lnum, ref iline))
        {
            if (iline > 0)
            {
                iline--;
            }
            if (sourceLines.Count > iline)
            {
                sourceLine = sourceLines[iline];
            }
        }
        return sourceLine;
    }
    
    writeSrc(file srcFile, <byte> output, uint romSize)
    {
        srcFile.Append("#define ROM_START   0x0000" + Char.EOL);
        srcFile.Append("#define ROM_END     0x" + (romSize-1).ToHexString(4) + Char.EOL);
        srcFile.Append("" + Char.EOL);
        
        srcFile.Append("PROGMEM const unsigned char rom_bin[] = {");
        uint length  = output.Count;
        uint index   = 0x0000;
        loop
        {
            byte b = 0;
            if (index < length)
            {
                b = output[index];
            }
            string prefix;
            if (index % 16 == 0)
            {
                prefix = Char.EOL + "    ";
            }
            if (index % 16 == 8)
            {
                prefix = "  ";
            }
            srcFile.Append(prefix + "0x" + b.ToHexString(2) + ", ");    
            index++;
            if (index == romSize) 
            { 
                break; 
            } 
        }
        
        srcFile.Append("};" + Char.EOL);
        srcFile.Flush();
    }
    
    <byte> readIHex(file hexFile, ref uint org)
    {
        bool first = true;
        <byte> code;
        uint byteCount = 0;
        Parser.ProgressTick("i"); // readIHex
        loop
        {
            string ln = hexFile.ReadLine();
            if (!hexFile.IsValid()) { break; }
            string len = ln.Substring(1,2);
            uint length;
            _ = UInt.TryParse("0x" + len, ref length);
            if (length == 0) { continue; }
            if (first)
            {
                string orgString = ln.Substring(3,4);
                _ = UInt.TryParse("0x" + orgString, ref org);
            }
            ln = ln.Substring(9);
            while (length > 0)
            {
                string br = ln.Substring(0, 2);
                ln = ln.Substring(2);
                uint b;
                _ = UInt.TryParse("0x" + br, ref b);
                code.Append(byte(b));
                length--;
            }
            first = false;
            byteCount += 16;
            if (byteCount % 8192 == 0)
            {
                Parser.ProgressTick("i"); // readIHex
            }
        }
        return code;
    }
    
    BadArguments()
    {
        PrintLn("Invalid arguments for Z80DASM:");
        PrintLn("  Z80DASM <hexe file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
        PrintLn("    -b         : 'bare' - no hex, just assembly (for Chat GPT)");
    }
    
    {
        bool success = false;
        bool bare;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length == 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        case "-b":
                        {
                            bare = true;
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                BadArguments();
                break;
            }
            string ext = ".hex";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Bin/"))
            {
                BadArguments();
            }
            bool lastwasNOP = false;
            long startTime = Millis;
            loop
            {
                string extension = Path.GetExtension(codePath);
                string hasmPath  = codePath.Replace(extension, ".lst");
                hasmPath = Path.GetFileName(hasmPath);
                hasmPath = Path.Combine("/Debug/", hasmPath);
                File.Delete(hasmPath);

                file hasmFile = File.Create(hasmPath);
                if (!hasmFile.IsValid())
                {
                    PrintLn("Failed to create '" + hasmPath + "'");
                    break;
                }
                
                SysCalls.New();
                string symbolsPath  = codePath.Replace(extension, ".sym");
                symbolsPath = Path.GetFileName(symbolsPath);
                symbolsPath = Path.Combine("/Debug/Obj", symbolsPath);
                string zcodePath = symbolsPath.Replace(".sym", ".zcode");
                
                if (File.Exists(zcodePath))
                {
                    if (!Code.ParseCode(zcodePath, false, true))
                    {
                        break;
                    }
                }
                uint romSize = 0x8000;
                Symbols.New();
                if (File.Exists(symbolsPath))
                {
                    if (Symbols.Import(symbolsPath, false))
                    {
                        CodeStream.InitializeSymbolShortcuts();
                    }
                    if (DefineExists("ROM_48K"))
                    {
                        romSize = 0xC000;
                    }
                    if (DefineExists("ROM_32K"))
                    {
                        romSize = 0x8000;
                    }
                    if (DefineExists("ROM_16K"))
                    {
                        romSize = 0x4000;
                    }
                    if (DefineExists("ROM_8K"))
                    {
                        romSize = 0x2000;
                    }
                    if (DefineExists("ROM_4K"))
                    {
                        romSize = 0x1000;
                    }
                    if (DefineExists("ROM_1K"))
                    {
                        romSize = 0x0400;
                    }
                }
                uint org;
                
                uint address = 0;
                file hexFile = File.Open(codePath);
                <byte> code = readIHex(hexFile, ref org);
                
                <uint,uint> methodFirstAddresses; // <address,index>
                <uint,uint> methodLastAddresses;  // <index,address>
                uint entryAddress = GetMethodAddresses(code, ref methodFirstAddresses, ref methodLastAddresses);
                
                <string> exportMethods;
                exportMethods.Append("Memory.Available");
                exportMethods.Append("Memory.Maximum");
                exportMethods.Append("Memory.Allocate");
                exportMethods.Append("Memory.Free");
                
                exportMethods.Append("GC.Create");
                exportMethods.Append("GC.Release");
                exportMethods.Append("GC.Clone");
                
                exportMethods.Append("String.New");
                exportMethods.Append("String.NewFromConstant0");
                exportMethods.Append("String.NewFromConstant1");
                exportMethods.Append("String.GetLength");
                exportMethods.Append("String.GetChar");
                exportMethods.Append("String.BuildChar");
                exportMethods.Append("String.BuildString");
                exportMethods.Append("String.BuildClear");
                exportMethods.Append("String.BuildFront");
                
                exportMethods.Append("Array.New");
                exportMethods.Append("Array.NewFromConstant");
                exportMethods.Append("Array.GetCount");
                exportMethods.Append("Array.GetItem");
                exportMethods.Append("Array.SetItem");
                
                exportMethods.Append("Time.Seconds");
                exportMethods.Append("Time.Delay");
                
                
                <uint,string> runtimeMap = Code.GetRuntimeMap();
                
                file codeGen;
                
                uint doffset = 0;
                string src;
                string srcName;
                 
                uint index;
                uint currentMethodIndex = 0;
                uint instructionAddress;
                
                bool isExporting = false;
                bool isExportingCurrent = false;
                <string,uint>   jumpPatches;
                
                uint constantLocation = 0xFFFF;
                uint progressCount;
                <string,string> debugInfo;
                loop
                {
                    if (index == code.Count) { break; }
                    if (index == ConstantAddress)
                    {
                        // location of constants
                        constantLocation = code[index] + (code[index+1] << 8);
                        hasmFile.Append("" + Char.EOL);
                        hasmFile.Append("// constant location" + Char.EOL);
                        hasmFile.Append("0x" + (index).ToHexString(4) + " -> 0x" + constantLocation.ToHexString(4) + Char.EOL);
                        hasmFile.Append("" + Char.EOL);
                        index += 2;
                        continue;
                    }
                    if (index == constantLocation)
                    {
                        uint constantSize  = code[index] + (code[index+1] << 8);
                        
                        hasmFile.Append("" + Char.EOL);
                        hasmFile.Append("// constant data" + Char.EOL);
                        hasmFile.Append("0x" + (index).ToHexString(4) + " 0x" + constantSize.ToHexString(4) + " // " + constantSize.ToString() + " bytes" + Char.EOL);
                        
                        index += 2; // size of constant block
                        
                        uint i;
                        string ascii;
                        for (i = 0; i < constantSize; i++)
                        {
                            byte d = code[index];
                            if ( i % 16 == 0)
                            {
                                hasmFile.Append("0x" + index.ToHexString(4) + "  ");
                            }
                            if ((d < 33) || (d > 127))
                            {
                                ascii += ".";
                            }
                            else
                            {
                                ascii += char(d);
                            }
                            hasmFile.Append(" 0x" + d.ToHexString(2));
                            if ( i % 16 == 7)
                            {
                                hasmFile.Append(" ");
                            }
                            if ( i % 16 == 15)
                            {
                                hasmFile.Append(" //" + ascii + Char.EOL);
                                ascii = "";
                            }
                            index++;
                        }
                        
                        if (ascii != "")
                        {
                            uint rem = i % 16;
                            if (rem <= 7)
                            {
                                hasmFile.Append(" ");
                            }
                            while (rem != 16)
                            {
                                hasmFile.Append("     ");
                                rem++;
                            }
                            hasmFile.Append(" //" + ascii + Char.EOL);
                        }
                        hasmFile.Append("" + Char.EOL);
                        continue;
                    }
                    instructionAddress = index;
                    
                    byte opCodeLength = GetOpCodeLength(code[index]);
                    
                    OpCode instruction;
                    OperandType operandType;
                    byte operandLength;
                    byte tableSize;
                    bool signed;
                    
                    //if (index + opCodeLength > code.Count) { hasmFile.Flush(); break; }
                    
                    if (opCodeLength == 1)
                    {
                         instruction = OpCode(code[index]);
                         index++;
                    }
                    else if (opCodeLength == 2)
                    {
                         instruction = OpCode((code[index] << 8) + code[index+1]);
                         index += 2;
                    }
                    string name = GetOpCodeInfo(instruction, ref operandType, ref operandLength, ref signed, false);
                    uint operand = 0;
                    if (name.Length == 0) { Print(" BadOp: 0x" + instructionAddress.ToHexString(4)); continue; }
                    
                    //if (index + operandLength > code.Count) { hasmFile.Flush(); break; }
                    
                    if (operandLength == 1)
                    {
                         operand = code[index];
                         index++;
                    }
                    else if (operandLength == 2)
                    {
                         operand = code[index] + (code[index+1] << 8);
                         index += 2;
                    }
                    instructionCount++;
                    
                    if (instruction == OpCode.JP_HL)
                    {
                        tableSize = code[index];
                        index += 1;
                    }
                    
                    if (runtimeMap.Contains(instructionAddress))
                    {
                        string runtimeName = runtimeMap[instructionAddress];
                        hasmFile.Append("" + Char.EOL);   
                        hasmFile.Append("// ####  " + runtimeName + "()  ####" + Char.EOL);
                        hasmFile.Append("" + Char.EOL);   
                    }
                    
                    
                    // switch to next methods debugInfo:
                    uint switchAddress = 0;
                    if (entryAddress == instructionAddress)
                    {
                        switchAddress = entryAddress;
                    }
                    else if (instructionAddress-1 == methodLastAddresses[currentMethodIndex])
                    {
                        switchAddress = instructionAddress;
                    }
                    
                    
                    if (methodFirstAddresses.Contains(switchAddress))
                    {
                        uint methodIndex = methodFirstAddresses[switchAddress];
                        <string,variant> methodSymbols = Code.GetMethodSymbols(methodIndex);
                        if (methodSymbols.Count != 0)
                        {
                            src = methodSymbols["source"];
                            srcName = Path.GetFileName(src);
                            string ln = methodSymbols["line"];
                            string nm = methodSymbols["name"];
                            debugInfo = methodSymbols["debug"];
                            doffset = instructionAddress;
                            hasmFile.Append("" + Char.EOL); 
                            hasmFile.Append("// " + src + ":" + ln + Char.EOL);  
                            
                            string mname = "// ####  " + nm + "()  ####";
                            mname = mname.Pad(' ', 80);
                            mname = mname + "0x" + methodIndex.ToHexString(4) + Char.EOL;
                            hasmFile.Append(mname);  
                            hasmFile.Append("" + Char.EOL); 
                            if (progressCount % 64 == 0)
                            {
                                Parser.ProgressTick("d");
                            }
                            progressCount++;
                            
                            if (isExportingCurrent)
                            {
                                codeGen.Append("    }" + Char.EOL);
                                isExportingCurrent = false;
                            }
                            if (exportMethods.Contains(nm))
                            {
                                if (!isExporting)
                                {
                                    codeGen = File.Create("/Source/Compiler/CODEGEN/Z80LibraryGenerated.hs");
                                    isExporting = true;
                                    codeGen.Append("unit Z80LibraryGenerated" + Char.EOL);
                                    codeGen.Append("{" + Char.EOL);
                                }
                                codeGen.Append("    Emit" + nm.Replace(".", "") + "()" + Char.EOL);
                                codeGen.Append("    {" + Char.EOL);
                                    
                                isExportingCurrent = true;
                            }
                        }
                        currentMethodIndex = methodIndex;
                    }
                    string comment;
                    string addressKey = "0x" + instructionAddress.ToHexString(4);
                    if (debugInfo.Contains(addressKey))
                    {
                        string debugLine = debugInfo[addressKey];
                        string sourceLine = getSourceLine(src, debugLine);
                        if (sourceLine.Length != 0)
                        {
                            comment = "// " + sourceLine.Trim();
                            if (comment.Length < 34)
                            {
                                comment = comment.Pad(' ', 34);
                                comment = comment + srcName + ":" + debugLine;
                            }
                        }
                        else
                        {
                            comment = "// " + src + ":" + debugLine;  
                        }
                    }
                    if (comment == "")
                    {
                        if (instruction == OpCode.CALL_nn)
                        {
                            if ((operand >= entryAddress) && methodFirstAddresses.Contains(operand))
                            {
                                uint mi = methodFirstAddresses[operand];
                                comment = "// " + Code.GetMethodName(mi);
                            }
                            else if (runtimeMap.Contains(operand))
                            {
                                comment = "// " + runtimeMap[operand];
                            }
                            else
                            {
                                comment = "// ???";
                                PrintLn();
                                Print("Undefined runtime method: " + instructionAddress.ToHexString(4) + ": CALL 0x" + operand.ToHexString(4), Colour.MatrixRed, Colour.Black);
                            }
                        }
                        else if (instruction == OpCode.JP_nn)
                        {
                            if (runtimeMap.Contains(operand))
                            {
                                comment = "// " + runtimeMap[operand];
                            }
                        }
                    }
                    
                    string disassembly = AsmZ80.Disassemble(instructionAddress, instruction, operand, bare);
                    disassembly = disassembly.Replace("NOP", "    NOP");
                    if (tableSize != 0)
                    {
                        disassembly = disassembly.Replace("JP HL", "JP HL              // " + tableSize.ToString() + " table entries follow:");
                    }
                    
                    if (bare)
                    {
                        disassembly = disassembly.Substring(29);
                        if (disassembly == "NOP")
                        {
                            if (!lastwasNOP)
                            {
                                hasmFile.Append("" +Char.EOL);
                                lastwasNOP = true;
                            }
                        }
                        else
                        {
                            hasmFile.Append(disassembly + Char.EOL);
                            lastwasNOP = false;
                        }
                    }
                    else if (comment == "")
                    {
                        hasmFile.Append(disassembly + Char.EOL);
                    }
                    else
                    {                  
                        hasmFile.Append(disassembly.Pad(' ', 48) + comment + Char.EOL);
                    }
                    if (isExportingCurrent)
                    {
                        foreach (var kvp in jumpPatches)
                        {
                            uint target = kvp.value; 
                            if (target == instructionAddress)
                            {
                                string jumpName = kvp.key;       
                                codeGen.Append("        PatchByte(" + jumpName + "+0, byte(CurrentAddress & 0xFF));" + Char.EOL);    
                                codeGen.Append("        PatchByte(" + jumpName + "+1, byte(CurrentAddress >> 8));" + Char.EOL);    
                            }
                        }
                        string operandStr;
                        switch (instruction)
                        {
                            case OpCode.CALL_nn:
                            {
                                if (methodFirstAddresses.Contains(operand))
                                {
                                    uint callMethodIndex = methodFirstAddresses[operand];
                                    string callname = Code.GetMethodName(callMethodIndex);
                                    if (!exportMethods.Contains(callname))
                                    {
                                        PrintLn();
                                        Print("Bad method call: " + instructionAddress.ToHexString(4) + ": CALL 0x" + operand.ToHexString(4) + " " + callname);
                                    }
                                    operandStr = "GetAddress(\"" + callname.Replace(".", "") + "\")";
                                    comment = "";
                                }
                                else if (runtimeMap.Contains(operand))
                                {
                                    string runtimeName = runtimeMap[operand];
                                    operandStr = "GetAddress(\"" + runtimeName.Replace(".", "") + "\")";
                                    comment = "";
                                }
                                else
                                {
                                    comment = "// -> ???";
                                    PrintLn();
                                    Print("Undefined runtime method: " + instructionAddress.ToHexString(4) + ": CALL 0x" + operand.ToHexString(4), Colour.MatrixRed, Colour.Black);
                                }
                            }
                            case OpCode.JP_nn:
                            case OpCode.JP_Z_nn:
                            case OpCode.JP_NZ_nn:
                            case OpCode.JP_C_nn:
                            case OpCode.JP_NC_nn:
                            case OpCode.JP_P_nn:
                            case OpCode.JP_M_nn:
                            {
                                string jumpName   = "jumpAddress" + instructionAddress.ToHexString(4);
                                if (operand < instructionAddress)
                                {
                                    uint delta = instructionAddress - operand;
                                    string jumpToLine = "        uint " + jumpName + " = CurrentAddress - " + delta.ToString() + ";";
                                    operandStr = jumpName;
                                    codeGen.Append(jumpToLine + Char.EOL);
                                }
                                else
                                {
                                    string jumpToLine = "        uint " + jumpName + " = CurrentAddress + 1;";
                                    codeGen.Append(jumpToLine + Char.EOL);
                                    jumpPatches[jumpName] = operand;
                                }
                                operand = 0xAA55;   
                            }
                        }
                        string codeLine = "        ";
                        string emit = "Emit";
                        
                        string argument;
                        // signed
                        // operand
                        name = name.Replace(" ", "_");
                        name = name.Replace(",", "_");
                        name = name.Replace("+", "_");
                        name = name.Replace("__", "_");
                        name = name.Replace("(", "i");
                        name = name.Replace(")", "");
                        
                        switch (operandType)
                        {
                            case OperandType.Implied:
                            case OperandType.Indexed:            // (ss)
                            {
                            }
                            case OperandType.Immediate8:         //  n
                            {
                                emit = "EmitByte";
                                argument = ", 0x" + operand.ToHexString(2);
                            }
                            case OperandType.Immediate16:        // aa | nn
                            case OperandType.ImmediateIndirect:  // (aa)
                            case OperandType.ImmediateIndexed:   // (nn)
                            {
                                emit = "EmitWord";
                                if (operandStr != "")
                                {
                                    argument = ", " + operandStr;
                                }
                                else
                                {
                                    argument = ", 0x" + operand.ToHexString(4);
                                }
                            }
                            case OperandType.Relative:           // d
                            case OperandType.IndexedRelative:    // (XY+d)
                            {
                                emit = "EmitOffset";
                                int ioperand = int(operand);
                                if (ioperand > 127)
                                {
                                    ioperand = ioperand - 256;
                                }
                                argument = ", int(" + ioperand.ToString() + ")";
                            }
                            case OperandType.RelativeImmediate8: // (XY+d), n
                            {
                                emit = "EmitOffsetByte"; // (OpCode opCode, int offset, byte msb)
                                int ioperand = int(operand & 0xFF);
                                if (ioperand > 127)
                                {
                                    ioperand = ioperand - 256;
                                }
                                operand = operand >> 8;
                                argument = ", int(" + ioperand.ToString() + "), byte(" + operand.ToString() + ")";
                            }
                        }
                        emit = emit.Pad(' ', 10);
                        codeLine = codeLine + emit+"(OpCode." + name + argument + ");";
                        
                        if (comment != "")
                        {
                            codeGen.Append(codeLine.Pad(' ', 60) + " " + comment + Char.EOL);
                        }
                        else
                        {
                            codeGen.Append(codeLine + Char.EOL);
                        }
                    }
                    if (tableSize > 0)
                    {
                        uint count = 0;
                        loop
                        {
                            if (tableSize == 0) { break; }
                            uint entry = code[index] + (code[index+1] << 8);
                            if (count % 8 == 0)
                            {
                                if (count != 0)
                                {
                                    hasmFile.Append("" + Char.EOL);
                                }
                                hasmFile.Append("                               ");
                            }
                            hasmFile.Append("0x" + entry.ToHexString(4) + " ");
                            index += 2;
                            tableSize--;
                            count++;
                        }    
                        hasmFile.Append("" + Char.EOL);
                    }
                } // loop
                if (isExporting)
                {
                    if (isExportingCurrent)
                    {
                        codeGen.Append("    }" + Char.EOL);
                    }
                    codeGen.Append("}" + Char.EOL);
                    codeGen.Flush();
                }
                    
                uint codeSize = code.Count;
                        
                Parser.ProgressTick("d");
                hasmFile.Flush();
                uint kSize = romSize / 1024;
                uint extra = codeSize - romSize;
                success = codeSize <= romSize;
                
                if (success)
                {
                    string srcPath = codePath.Replace(".hex", ".c");
                    file srcFile = File.Create(srcPath);
                    if (!srcFile.IsValid())
                    {
                        PrintLn("Failed to create '" + srcPath + "'");
                        break;
                    }
                    writeSrc(srcFile, code, romSize);
                }
                
                if (!Parser.IsInteractive())
                {
                    PrintLn();
                    Print("Success, " + codeSize.ToString() + " bytes of code", Colour.ProgressText, Colour.ProgressFace);
                    if (codeSize > romSize)
                    {
                        Print(" (" + kSize.ToString() + "K ROM exceeded by " + extra.ToString() + " bytes)", Colour.MatrixRed, Colour.ProgressFace);   
                    }
                    Print(", ", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() +"s", Colour.ProgressHighlight, Colour.ProgressFace);
                    PrintLn("  " + instructionCount.ToString() + " instructions disassembled. ", Colour.ProgressText, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                    if (codeSize > romSize)
                    {
                        InteractiveError(kSize.ToString() + "K ROM exceeded by " + extra.ToString() + " bytes");
                    }
                }
                
                break;
            }
            break;
        }
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}
