program Info
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    
    uses "JSON/JSON"
    uses "JSON/Code"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    
    uses "Symbols"
    
    // Core model structures
    <uint, <byte>> methodCode;           // method index -> bytecode
    <uint, uint> methodSizes;            // method index -> size in bytes
    <string, string> methodNames;        // method index -> method name
    <uint, string> methodSources;        // method index -> source file
    
    // Analysis results
    <string, uint> instructionCounts;    // instruction name -> count
    <string, uint> addressingModeCounts; // addressing mode -> count
    uint totalInstructions;
    uint totalCodeSize;
    
    badArguments()
    {
        PrintLn("Invalid arguments for 65INFO:");
        PrintLn("  65INFO <code file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
    }
    
    bool loadCodeFile(string codePath)
    {
        bool success = false;
        loop
        {
            Symbols.New();
            string jsonPath = codePath.Replace(".code", ".sym");
            
            if (!Symbols.Import(jsonPath))
            {
                PrintLn("Failed to load symbols from '" + jsonPath + "'");
                break;
            }
            
            if (!Code.Load(codePath))
            {
                PrintLn("Failed to load code from '" + codePath + "'");
                break;
            }
            
            // Build our model from the loaded data
            <uint, uint> methodSizesFromCode = Code.GetMethodSizes();
            uint indexMax = 0;
            foreach (var sz in methodSizesFromCode)
            {
                if (sz.key > indexMax)
                {
                    indexMax = sz.key;
                }
            }
            
            // Load all method code and metadata
            for (uint index = 0; index <= indexMax; index++)
            {
                if (!methodSizesFromCode.Contains(index)) { continue; }
                
                <byte> code = Code.GetMethodCode(index);
                methodCode[index] = code;
                methodSizes[index] = code.Count;
                totalCodeSize += code.Count;
                
                // Get method name and source info
                <string,variant> methodSymbols = Code.GetMethodSymbols(index);
                if (methodSymbols.Count != 0)
                {
                    string methodName = methodSymbols["name"];
                    string sourcePath = methodSymbols["source"];
                    methodNames[index] = methodName;
                    methodSources[index] = sourcePath;
                }
            }
            
            success = true;
            break;
        }
        return success;
    }
    
    bool analyzeInstructions()
    {
        bool success = false;
        loop
        {
            instructionCounts.Clear();
            addressingModeCounts.Clear();
            totalInstructions = 0;
            
            foreach (var kv in methodCode)
            {
                uint methodIndex = kv.key;
                <byte> code = kv.value;
                
                uint index = 0;
                while (index < code.Count)
                {
                    OpCode instruction = OpCode(code[index]);
                    uint instructionLength = Asm6502.GetInstructionLength(instruction);
                    
                    // Get instruction name and addressing mode
                    string instructionName = Asm6502.GetInstructionName(instruction);
                    AddressingModes mode = Asm6502.GetAddressingMode(instruction);
                    string modeName = Asm6502.GetAddressingModeName(mode);
                    
                    // Count instructions
                    if (instructionCounts.Contains(instructionName))
                    {
                        instructionCounts[instructionName] = instructionCounts[instructionName] + 1;
                    }
                    else
                    {
                        instructionCounts[instructionName] = 1;
                    }
                    
                    // Count addressing modes
                    if (addressingModeCounts.Contains(modeName))
                    {
                        addressingModeCounts[modeName] = addressingModeCounts[modeName] + 1;
                    }
                    else
                    {
                        addressingModeCounts[modeName] = 1;
                    }
                    
                    totalInstructions++;
                    index += instructionLength;
                }
            }
            
            success = true;
            break;
        }
        return success;
    }
    
    bool generateReport(string outputPath)
    {
        bool success = false;
        loop
        {
            file reportFile = File.Create(outputPath);
            if (!reportFile.IsValid())
            {
                PrintLn("Failed to create report file '" + outputPath + "'");
                break;
            }
            
            // Report header
            reportFile.Append("# 6502 Code Analysis Report" + Char.EOL + Char.EOL);
            
            // Summary section
            reportFile.Append("## Summary" + Char.EOL + Char.EOL);
            reportFile.Append("- **Total Methods**: " + methodCode.Count.ToString() + Char.EOL);
            reportFile.Append("- **Total Code Size**: " + totalCodeSize.ToString() + " bytes" + Char.EOL);
            reportFile.Append("- **Total Instructions**: " + totalInstructions.ToString() + Char.EOL);
            reportFile.Append("- **Average Method Size**: " + (totalCodeSize / methodCode.Count).ToString() + " bytes" + Char.EOL);
            reportFile.Append(Char.EOL);
            
            // Method sizes section
            reportFile.Append("## Method Sizes" + Char.EOL + Char.EOL);
            reportFile.Append("| Method | Size (bytes) | Source |" + Char.EOL);
            reportFile.Append("|--------|--------------|--------|" + Char.EOL);
            
            foreach (var kv in methodSizes)
            {
                uint methodIndex = kv.key;
                uint size = kv.value;
                string name = "Method_" + methodIndex.ToString();
                string source = "";
                
                if (methodNames.Contains(methodIndex))
                {
                    name = methodNames[methodIndex];
                }
                if (methodSources.Contains(methodIndex))
                {
                    source = Path.GetFileName(methodSources[methodIndex]);
                }
                
                reportFile.Append("| " + name + " | " + size.ToString() + " | " + source + " |" + Char.EOL);
            }
            reportFile.Append(Char.EOL);
            
            // Instruction frequency section
            reportFile.Append("## Instruction Frequency" + Char.EOL + Char.EOL);
            reportFile.Append("| Instruction | Count | Percentage |" + Char.EOL);
            reportFile.Append("|-------------|-------|------------|" + Char.EOL);
            
            foreach (var kv in instructionCounts)
            {
                string instruction = kv.key;
                uint count = kv.value;
                float percentage = (count * 100.0) / totalInstructions;
                reportFile.Append("| " + instruction + " | " + count.ToString() + " | " + 
                                 percentage.ToString() + "% |" + Char.EOL);
            }
            reportFile.Append(Char.EOL);
            
            // Addressing mode frequency section
            reportFile.Append("## Addressing Mode Usage" + Char.EOL + Char.EOL);
            reportFile.Append("| Addressing Mode | Count | Percentage |" + Char.EOL);
            reportFile.Append("|-----------------|-------|------------|" + Char.EOL);
            
            foreach (var kv in addressingModeCounts)
            {
                string mode = kv.key;
                uint count = kv.value;
                float percentage = (count * 100.0) / totalInstructions;
                reportFile.Append("| " + mode + " | " + count.ToString() + " | " + 
                                 percentage.ToString() + "% |" + Char.EOL);
            }
            
            reportFile.Flush();
            success = true;
            break;
        }
        return success;
    }
    
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            
            // Parse command line arguments (similar to 65GEN)
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length >= 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
            
            if (args.Count != 1)
            {
                badArguments();
                break;
            }
            
            string ext = ".code";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Debug/Obj/"))
            {
                badArguments();
                break;
            }
            
            long startTime = Millis;
            
            // Load the code file into our model
            if (!loadCodeFile(codePath))
            {
                break;
            }
            
            // Run instruction frequency analysis
            if (!analyzeInstructions())
            {
                PrintLn("Analysis failed");
                break;
            }
            
            // Generate report
            string extension = Path.GetExtension(codePath);
            string reportPath = codePath.Replace(extension, ".md");
            reportPath = Path.GetFileName(reportPath);
            reportPath = Path.Combine("/Bin/", reportPath);
            
            if (!generateReport(reportPath))
            {
                break;
            }
            
            if (!Parser.IsInteractive())
            {
                PrintLn();
                Print("Analysis complete, report generated: " + reportPath, Colour.ProgressText, Colour.ProgressFace);
                long elapsedTime = Millis - startTime;
                float seconds = elapsedTime / 1000.0;
                PrintLn("  " + seconds.ToString() + "s", Colour.ProgressHighlight, Colour.ProgressFace);
            }
            else
            {
                Parser.ProgressDone();
            }
            
            success = true;
            break;
        }
        
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}